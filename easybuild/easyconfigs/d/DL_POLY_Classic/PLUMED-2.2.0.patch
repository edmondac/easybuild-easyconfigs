# This patch allows to use Plumed 2.2 with DL_POLY. It is autogenerated with the help
# of Plumed and https://groups.google.com/forum/#!topic/plumed-users/cWaIDU5F6Bw
# Follow the instructions on that forum and you can generate the patch below
# The makefile is also adjust to use the EB set values for building
# Ward Poelmans <ward.poelmans@ugent.be>
diff -urN dl_class_1.9.orig/Plumed.cmake dl_class_1.9/Plumed.cmake
--- dl_class_1.9.orig/Plumed.cmake	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/Plumed.cmake	2015-11-09 14:26:25.657769545 +0100
@@ -0,0 +1,3 @@
+# PLUMED: runtime installation
+set(PLUMED_LOAD  -L$ENV{EBROOTPLUMED}/lib -lplumed -ldl  )
+set(PLUMED_DEPENDENCIES )
diff -urN dl_class_1.9.orig/Plumed.h dl_class_1.9/Plumed.h
--- dl_class_1.9.orig/Plumed.h	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/Plumed.h	2015-11-09 14:26:31.797805893 +0100
@@ -0,0 +1,500 @@
+/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+   Copyright (c) 2011-2015 The plumed team
+   (see the PEOPLE file at the root of the distribution for a list of names)
+
+   See http://www.plumed-code.org for more information.
+
+   This file is part of plumed, version 2.
+
+   plumed is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   plumed is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
+#ifndef __PLUMED_wrapper_Plumed_h
+#define __PLUMED_wrapper_Plumed_h
+
+/**
+\page ReferencePlumedH Reference for interfacing MD codes with PLUMED
+
+  Plumed.h and Plumed.c contain the external plumed interface, which is used to
+  integrate it with MD engines. This interface is very general, and is expected
+  not to change across plumed versions. Plumed.c also implements a dummy version
+  of the interface, so as to allow a code to be fully linked even if the plumed
+  library is not available yet. These files could be directly included in the official
+  host MD distribution. In this manner, it will be sufficient to link the plumed
+  library at link time (on all systems) or directly at runtime (on system where
+  dynamic loading is enabled) to include plumed features.
+
+  Why is Plumed.c written in C and not C++? The reason is that the resulting Plumed.o
+  needs to be linked with the host MD code immediately (whereas the rest of plumed
+  could be linked a posteriori). Imagine the MD code is written in FORTRAN: when we
+  link the Plumed.o file we would like not to need any C++ library linked. In this
+  manner, we do not need to know which C++ compiler will be used to compile plumed.
+  The C++ library is only linked to the "rest" of plumed, which actually use it.
+  Anyway, Plumed.c is written in such a manner to allow its compilation also in C++
+  (C++ is a bit stricter than C; compatibility is checked when PlumedStatic.cpp,
+  which basically includes Plumed.c, is compiled with the C++ compiler). This will
+  allow e.g. MD codes written in C++ to just incorporate Plumed.c (maybe renamed into
+  Plumed.cpp), without the need of configuring a plain C compiler.
+
+  Plumed interface can be used from C, C++ and FORTRAN. Everything concerning plumed
+  is hidden inside a single object type, which is described in C by a structure
+  (struct \ref plumed), in C++ by a class (PLMD::Plumed) and in FORTRAN by a
+  fixed-length string (CHARACTER(LEN=32)). Obviously C++ can use both struct
+  and class interfaces, but the first should be preferred. The reference interface
+  is the C one, whereas FORTRAN and C++ interfaces are implemented as wrappers
+  around it.
+
+  In the C++ interface, all the routines are implemented as methods of PLMD::Plumed.
+  In the C and FORTRAN interfaces, all the routines are named plumed_*, to
+  avoid potential name clashes. Notice that the entire plumed library
+  is implemented in C++, and it is hidden inside the PLMD namespace.
+
+  Handlers to the plumed object can be converted among different representations,
+  to allow inter-operability among languages. In C, there are tools to convert
+  to/from FORTRAN, whereas in C++ there are tools to convert to/from FORTRAN and C.
+
+  These handlers only contain a pointer to the real structure, so that
+  when a plumed object is brought from one language to another,
+  it brings a reference to the same environment.
+
+  Moreover, to simplify life in all cases where a single Plumed object is
+  required for the entire simulation (which covers most of the practical
+  applications with conventional MD codes) it is possible to take advantage
+  of a global interface, which is implicitly referring to a unique global instance.
+  The global object should still be initialized and finalized properly.
+
+  The basic method to send a message to plumed is
+\verbatim
+  (C) plumed_cmd
+  (C++) PLMD::Plumed::cmd
+  (FORTRAN)  PLUMED_F_CMD
+\endverbatim
+
+  To initialize a plumed object, use:
+\verbatim
+  (C)        plumed_create
+  (C++)      (constructor of PLMD::Plumed)
+  (FORTRAN)  PLUMED_F_CREATE
+\endverbatim
+
+  To finalize it, use
+\verbatim
+  (C)        plumed_finalize
+  (C++)      (destructor of PLMD::Plumed)
+  (FORTRAN)  PLUMED_F_FINALIZE
+\endverbatim
+
+  To access to the global-object, use
+\verbatim
+  (C)        plumed_gcreate, plumed_gfinalize, plumed_gcmd
+  (C++)      PLMD::Plumed::gcreate, PLMD::Plumed::gfinalize, PLMD::Plumed::gcmd
+  (FORTRAN)  PLUMED_F_GCREATE, PLUMED_F_GFINALIZE, PLUMED_F_GCMD
+\endverbatim
+
+  To check if the global object has been initialized, use
+\verbatim
+  (C)        plumed_ginitialized
+  (C++)      PLMD::Plumed::ginitialized
+  (FORTRAN)  PLUMED_F_GINITIALIZED
+\endverbatim
+
+  To check if plumed library is available (this is useful for runtime linking), use
+\verbatim
+  (C)        plumed_installed 
+  (C++)      PLMD::Plumed::installed
+  (FORTRAN)  PLUMED_F_INSTALLED
+\endverbatim
+
+  To convert handlers use
+\verbatim
+  (C)        plumed_c2f                 (C to FORTRAN)
+  (C)        plumed_f2c                 (FORTRAN to C)
+  (C++)      Plumed(plumed) constructor (C to C++)
+  (C++)      operator plumed() cast     (C++ to C)
+  (C++)      Plumed(char*)  constructor (FORTRAN to C++)
+  (C++)      toFortran(char*)           (C++ to FORTRAN)
+\endverbatim
+
+\verbatim
+  FORTRAN interface
+    SUBROUTINE PLUMED_F_INSTALLED(i)
+      INTEGER,           INTENT(OUT)   :: i
+    SUBROUTINE PLUMED_F_GINITIALIZED(i)
+      INTEGER,           INTENT(OUT)   :: i
+    SUBROUTINE PLUMED_F_GCREATE()
+    SUBROUTINE PLUMED_F_GCMD(key,val)
+      CHARACTER(LEN=*), INTENT(IN)     :: key
+      UNSPECIFIED_TYPE, INTENT(INOUT)  :: val(*)
+    SUBROUTINE PLUMED_F_GFINALIZE()
+    SUBROUTINE PLUMED_F_GLOBAL(p)
+      CHARACTER(LEN=32), INTENT(OUT)   :: p
+    SUBROUTINE PLUMED_F_CREATE(p)
+      CHARACTER(LEN=32), INTENT(OUT)   :: p
+    SUBROUTINE PLUMED_F_CMD(p,key,val)
+      CHARACTER(LEN=32), INTENT(IN)    :: p
+      CHARACTER(LEN=*),  INTENT(IN)    :: key
+      UNSPECIFIED_TYPE,  INTENT(INOUT) :: val(*)
+    SUBROUTINE PLUMED_F_FINALIZE(p)
+      CHARACTER(LEN=32), INTENT(IN)    :: p
+\endverbatim
+
+  The main routine is "cmd", which accepts two arguments:
+  key is a string containing the name of the command
+  val is the argument. it is declared const so as to use allow passing const objects, but in practice plumed
+      is going to modify val in several cases (using a const_cast).
+  In some cases val can be omitted: just pass a NULL pointer (in C++, val is optional and can be omitted).
+  The set of possible keys is the real API of the plumed library, and will be expanded with time.
+  New commands will be added, but backward compatibility will be retained as long as possible.
+
+  To pass plumed a callback function use the following syntax (not available in FORTRAN yet)
+\verbatim
+    plumed_function_holder ff;
+    ff.p=your_function;
+    plumed_cmd(plumed,"xxxx",&ff);
+\endverbatim
+  (this is passing the your_function() function to the "xxxx" command)
+*/
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Generic function pointer */
+typedef void (*plumed_function_pointer)(void);
+
+/**
+  \brief Holder for function pointer.
+
+  To pass plumed a callback function use the following syntax:
+\verbatim
+    plumed_function_holder ff;
+    ff.p=your_function;
+    plumed_cmd(plumed,"xxxx",&ff);
+\endverbatim
+  (this is going to pass the your_function() function to the "xxxx" command)
+*/
+
+typedef struct {
+  plumed_function_pointer p;
+} plumed_function_holder;
+
+/**
+  \brief Main plumed object
+
+  This is an object containing a Plumed instance, which should be used in
+  the MD engine. It should first be initialized with plumed_create(),
+  then it communicates with the MD engine using plumed_cmd(). Finally,
+  before the termination, it should be deallocated with plumed_finalize().
+  Its interface is very simple and general, and is expected
+  not to change across plumed versions. See \ref ReferencePlumedH.
+*/
+typedef struct {
+/**
+  \private
+  \brief Void pointer holding the real PlumedMain structure
+*/
+  void*p;
+} plumed;
+
+/** \relates plumed
+    \brief Constructor
+
+    \return The constructed plumed object
+*/
+plumed plumed_create(void);
+
+/** \relates plumed
+    \brief Tells p to execute a command
+
+    \param p The plumed object on which command is acting
+    \param key The name of the command to be executed
+    \param val The argument. It is declared as const to allow calls like plumed_cmd(p,"A","B"),
+               but for some choice of key it can change the content
+*/
+void plumed_cmd(plumed p,const char*key,const void*val);
+
+/** \relates plumed
+    \brief Destructor
+
+    \param p The plumed object to be deallocated
+*/
+void plumed_finalize(plumed p);
+
+/** \relates plumed
+    \brief Check if plumed is installed (for runtime binding)
+
+    \return 1 if plumed is installed, to 0 otherwise
+*/
+int plumed_installed(void);
+
+/** \relates plumed
+    \brief Retrieves an handler to the global structure.
+*/
+plumed plumed_global(void);
+
+/** \relates plumed
+    \brief Check if the global interface has been initialized
+
+    \return 1 if plumed has been initialized, 0 otherwise
+*/
+int plumed_ginitialized(void);
+
+/* global C interface, working on a global object */
+
+/** \relates plumed
+    \brief Constructor for the global interface.
+
+    \note Equivalent to plumed_create(), but initialize a static global plumed object
+*/
+void plumed_gcreate(void);
+
+/** \relates plumed
+    \brief Tells to the global interface to execute a command.
+
+    \param key The name of the command to be executed
+    \param val The argument. It is declared as const to allow calls like plumed_gcmd("A","B"),
+               but for some choice of key it can change the content
+
+    \note Equivalent to plumed_cmd(), but skipping the plumed argument
+*/
+void plumed_gcmd(const char* key,const void* val);
+
+/** \relates plumed
+    \brief Destructor for the global interface.
+
+    \note Equivalent to plumed_finalize(), but skipping the plumed argument
+*/
+void plumed_gfinalize(void);
+
+/* routines to convert char handler from/to plumed objects */
+
+/** \related plumed
+    \brief Converts a C handler to a FORTRAN handler
+
+    \param p The C handler
+    \param c The FORTRAN handler (a char[32])
+*/
+void   plumed_c2f(plumed p,char* c);
+
+/** \related plumed
+    \brief Converts a FORTRAN handler to a C handler
+    \param c The FORTRAN handler (a char[32])
+    \return The C handler
+*/
+plumed plumed_f2c(const char* c);
+
+#ifdef __cplusplus
+ }
+#endif
+
+#ifdef __cplusplus
+
+/* this is to include the NULL pointer */
+#include <cstdlib>
+
+/* C++ interface is hidden in PLMD namespace (same as plumed library) */
+namespace PLMD {
+
+/**
+  C++ wrapper for \ref plumed.
+
+  This class provides a C++ interface to PLUMED.
+*/
+
+class Plumed{
+  plumed main;
+/**
+   keeps track if the object was created from scratch using 
+   the defaults destructor (reference=false) or if it was imported
+   from C or FORTRAN (reference=true). In the latter case, the
+   plumed_finalize() method is not called when destructing the object,
+   since it is expected to be finalized in the C/FORTRAN code
+*/
+  bool reference;
+public:
+/**
+   Check if plumed is installed (for runtime binding)
+   \return true if plumed is installed, false otherwise
+*/
+  static bool installed();
+/**
+   Check if global-plumed has been initialized
+   \return true if global plumed object (see global()) is initialized (i.e. if gcreate() has been
+           called), false otherwise.
+*/
+  static bool ginitialized();
+/**
+   Initialize global-plumed
+*/
+  static void gcreate();
+/**
+   Send a command to global-plumed
+    \param key The name of the command to be executed
+    \param val The argument. It is declared as const to allow calls like gcmd("A","B"),
+               but for some choice of key it can change the content
+*/
+  static void gcmd(const char* key,const void* val);
+/**
+   Finalize global-plumed
+*/
+  static void gfinalize();
+/**
+   Returns the Plumed global object
+   \return The Plumed global object
+*/
+  static Plumed global();
+/**
+   Constructor
+*/
+  Plumed();
+/**
+   Clone a Plumed object from a FORTRAN char* handler
+   \param c The FORTRAN handler (a char[32]).
+
+ \attention The Plumed object created in this manner
+            will not finalize the corresponding plumed structure.
+            It is expected that the FORTRAN code calls plumed_c_finalize for it
+*/
+// to have maximum portability of this file I do not use the explicit keyword here
+// I thus add a suppress command for cppcheck
+// cppcheck-suppress noExplicitConstructor
+  Plumed(const char*c);
+/**
+   Clone a Plumed object from a C plumed structure
+   \param p The C plumed structure.
+
+ \attention The Plumed object created in this manner
+            will not finalize the corresponding plumed structure.
+            It is expected that the C code calls plumed_finalize for it
+*/ 
+// to have maximum portability of this file I do not use the explicit keyword here
+// I thus add a suppress command for cppcheck
+// cppcheck-suppress noExplicitConstructor
+  Plumed(plumed p);
+private:
+/** Copy constructor is disabled (private and unimplemented)
+  The problem here is that after copying it will not be clear who is
+  going to finalize the corresponding plumed structure.
+*/
+  Plumed(const Plumed&);
+/** Assignment operator is disabled (private and unimplemented)
+  The problem here is that after copying it will not be clear who is
+  going to finalize the corresponding plumed structure.
+*/
+  Plumed&operator=(const Plumed&);
+public:
+/**
+   Retrieve the C plumed structure for this object
+*/
+  operator plumed()const;
+/**
+   Retrieve a FORTRAN handler for this object
+    \param c The FORTRAN handler (a char[32]).
+*/
+  void toFortran(char*c)const;
+/**
+   Send a command to this plumed object
+    \param key The name of the command to be executed
+    \param val The argument. It is declared as const to allow calls like p.cmd("A","B"),
+               but for some choice of key it can change the content
+*/
+  void cmd(const char*key,const void*val=NULL);
+/**
+   Destructor
+
+   Destructor is virtual so as to allow correct inheritance from Plumed object.
+   To avoid linking problems with g++, I specify "inline" also here (in principle
+   it should be enough to specify it down in the definition of the function, but
+   for some reason that I do not understand g++ does not inline it properly in that
+   case and complains when Plumed.h is included but Plumed.o is not linked. Anyway, the
+   way it is done here seems to work properly).
+*/
+  inline virtual ~Plumed();
+};
+
+/* All methods are inlined so as to avoid the compilation of an extra c++ file */
+
+inline
+bool Plumed::installed(){
+  return plumed_installed();
+}
+
+inline
+Plumed::Plumed():
+  main(plumed_create()),
+  reference(false)
+{}
+
+inline
+Plumed::Plumed(const char*c):
+  main(plumed_f2c(c)),
+  reference(true)
+{}
+
+inline
+Plumed::Plumed(plumed p):
+  main(p),
+  reference(true)
+{}
+
+inline
+Plumed::operator plumed()const{
+  return main;
+}
+
+inline
+void Plumed::toFortran(char*c)const{
+  plumed_c2f(main,c);
+}
+
+inline
+void Plumed::cmd(const char*key,const void*val){
+  plumed_cmd(main,key,val);
+}
+
+inline
+Plumed::~Plumed(){
+  if(!reference)plumed_finalize(main);
+}
+
+inline
+bool Plumed::ginitialized(){
+  return plumed_ginitialized();
+}
+
+inline
+void Plumed::gcreate(){
+  plumed_gcreate();
+}
+
+inline
+void Plumed::gcmd(const char* key,const void* val){
+  plumed_gcmd(key,val);
+}
+
+inline
+void Plumed::gfinalize(){
+  plumed_gfinalize();
+}
+
+inline
+Plumed Plumed::global(){
+  return plumed_global();
+}
+
+}
+
+#endif
+
+
+#endif
diff -urN dl_class_1.9.orig/Plumed.inc dl_class_1.9/Plumed.inc
--- dl_class_1.9.orig/Plumed.inc	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/Plumed.inc	2015-11-09 14:26:16.827714651 +0100
@@ -0,0 +1,3 @@
+# PLUMED: runtime installation
+PLUMED_LOAD= -L$(EBROOTPLUMED)/lib -lplumed -ldl  
+PLUMED_DEPENDENCIES=
diff -urN dl_class_1.9.orig/srcmod/angles_module.f dl_class_1.9/srcmod/angles_module.f
--- dl_class_1.9.orig/srcmod/angles_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/angles_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,741 @@
+      module angles_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining valence angle potentials
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     modified  - p.-a.cazade      oct 2007 : solvation etc.
+c     modified  - d. quigley           2010 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      real(8), allocatable :: prmang(:,:)
+      integer, allocatable :: listang(:,:)
+      integer, allocatable :: numang(:),keyang(:),lstang(:,:)
+
+      save prmang,listang,numang,keyang,lstang
+
+      contains
+      
+      subroutine alloc_ang_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining valence angle potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(5)
+
+      do i=1,5
+        fail(i)=0
+      enddo
+
+      allocate (prmang(mxtang,mxpang),stat=fail(1))
+      allocate (numang(mxtmls),stat=fail(2))
+      allocate (keyang(mxtang),stat=fail(3))
+      allocate (lstang(mxtang,3),stat=fail(4))
+      allocate (listang(mxangl,4),stat=fail(5))
+
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1010)
+      enddo
+
+      do i=1,mxtmls
+         numang(i)=0
+      enddo
+
+      end subroutine alloc_ang_arrays
+
+      subroutine define_angles
+     x  (safe,idnode,itmols,nangle,nsite,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining bond angles
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,nangle,nsite,ntmp,i,iang,iang1
+      integer idum,iatm1,iatm2,iatm3,isite1,isite2,isite3,ia,ja
+      real(8) engunit
+
+      ntmp=intstr(record,lenrec,idum)
+      numang(itmols)=numang(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of bond angles',
+     x    10x,i10)")ntmp
+        write(nrite,"(/,/,1x,'bond angle details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',5x,
+     x    'index',5x,'f-const',7x,'angle',/)")
+      endif
+      
+      iang1=numang(itmols)
+      do iang=1,iang1
+
+c     read bond angle potential parameters
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        iatm3=intstr(record,lenrec,idum)
+
+c     test for frozen atom pairs
+
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        isite3=nsite-numsit(itmols)+iatm3
+
+        if(lfzsit(isite1)*lfzsit(isite2)*
+     x    lfzsit(isite3).ne.0)then
+          
+          numang(itmols)=numang(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+
+        else
+
+          nangle=nangle+1
+          
+          if(nangle.gt.mxtang)call error(idnode,50)
+          
+          if(keyword(1:4).eq.'harm')then
+            keyang(nangle)=1
+          elseif(keyword(1:4).eq.'-hrm')then
+            keyang(nangle)=-1
+          elseif(keyword(1:4).eq.'quar')then
+            keyang(nangle)=2
+          elseif(keyword(1:4).eq.'-qur')then
+            keyang(nangle)=-2
+          elseif(keyword(1:4).eq.'thrm')then
+            keyang(nangle)=3
+          elseif(keyword(1:4).eq.'-thm')then
+            keyang(nangle)=-3
+          elseif(keyword(1:4).eq.'shrm')then
+            keyang(nangle)=4
+          elseif(keyword(1:4).eq.'-shm')then
+            keyang(nangle)=-4
+          elseif(keyword(1:4).eq.'bvs1')then
+            keyang(nangle)=5
+          elseif(keyword(1:4).eq.'-bv1')then
+            keyang(nangle)=-5
+          elseif(keyword(1:4).eq.'bvs2')then
+            keyang(nangle)=6
+          elseif(keyword(1:4).eq.'-bv2')then
+            keyang(nangle)=-6
+          elseif(keyword(1:4).eq.'hcos')then
+            keyang(nangle)=7
+          elseif(keyword(1:4).eq.'-hcs')then
+            keyang(nangle)=-7
+          elseif(keyword(1:4).eq.'cos ')then
+            keyang(nangle)=8
+          elseif(keyword(1:4).eq.'-cos')then
+            keyang(nangle)=-8
+          elseif(keyword(1:4).eq.'mmsb')then
+            keyang(nangle)=9
+          elseif(keyword(1:4).eq.'-msb')then
+            keyang(nangle)=-9
+          elseif(keyword(1:4).eq.'stst') then
+            keyang(nangle)=10
+          elseif(keyword(1:4).eq.'-sts') then
+            keyang(nangle)=-10
+          elseif(keyword(1:4).eq.'stbe') then
+            keyang(nangle)=11
+          elseif(keyword(1:4).eq.'-stb') then
+            keyang(nangle)=-11
+          elseif(keyword(1:4).eq.'cmps') then
+            keyang(nangle)=12
+          elseif(keyword(1:4).eq.'-cmp') then
+            keyang(nangle)=-12
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,440)
+          endif
+
+          lstang(nangle,1)=iatm1
+          lstang(nangle,2)=iatm2
+          lstang(nangle,3)=iatm3
+          prmang(nangle,1)=dblstr(record,lenrec,idum)
+          prmang(nangle,2)=dblstr(record,lenrec,idum)
+          prmang(nangle,3)=dblstr(record,lenrec,idum)
+          prmang(nangle,4)=dblstr(record,lenrec,idum)
+          prmang(nangle,5)=dblstr(record,lenrec,idum)
+          prmang(nangle,6)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0) 
+     x      write(nrite,"(27x,a4,3i10,1p,e12.4,0p,9f12.6)")
+     x      keyword(1:4),(lstang(nangle,ia),ia=1,3),
+     x      (prmang(nangle,ja),ja=1,mxpang)
+
+c     convert energies to internal units
+          
+          prmang(nangle,1)=prmang(nangle,1)*engunit
+          if(abs(keyang(nangle)).eq.2)then
+            prmang(nangle,3)=prmang(nangle,3)*engunit
+            prmang(nangle,4)=prmang(nangle,4)*engunit
+          elseif(abs(keyang(nangle)).eq.12)then
+            prmang(nangle,2)=prmang(nangle,2)*engunit            
+            prmang(nangle,3)=prmang(nangle,3)*engunit
+          endif
+
+c     convert angles to radians
+          
+          if(abs(keyang(nangle)).eq.12)then
+            prmang(nangle,4)=prmang(nangle,4)*(pi/180.d0)
+          elseif(abs(keyang(nangle)).ne.10)then
+            prmang(nangle,2)=prmang(nangle,2)*(pi/180.d0) 
+          endif
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine define_angles
+
+      subroutine angfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntangl,engang,virang)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating bond angle energy and 
+c     force terms in molecular dynamics.
+c     
+c     replicated data - blocked version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith         may 1992
+c     modified  - t. forester      feb 1993
+c     modified  - t. forester      nov 1994 : block data
+c     modified  - t. forester      may 1995 : stress tensor 
+c     modified  - p.-a.cazade      oct 2007 : solvation etc.
+c     modified  - d. quigley       nov 2010 : metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect
+      logical idrive,jdrive,kdrive
+      integer idnode,mxnode,imcon,ntangl,fail1,fail2
+      integer ii,iang1,iang2,i,ia,ib,ic,kk,keya
+      real(8) engang,virang,theta,fxc,fyc,fzc,rab,xab
+      real(8) yab,zab,rbc,xbc,ybc,zbc,sint,cost,pterm,vterm
+      real(8) gamma,gamsa,gamsc,rrbc,rrab,fxa,fya,fza
+      real(8) strs(6),strs_loc(6)
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      real(8), allocatable :: xdbc(:),ydbc(:),zdbc(:)
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail1)
+      allocate (xdbc(msbad),ydbc(msbad),zdbc(msbad),stat=fail2)
+      if(fail1.ne.fail2)call error(idnode,1020)
+
+c     flag for undefined potentials
+
+      safe=.true.
+
+c     check size of work arrays
+
+      if((ntangl-mxnode+1)/mxnode.gt.msbad)call error(idnode,419)
+
+c     block indices
+      
+      iang1=(idnode*ntangl)/mxnode+1
+      iang2=((idnode+1)*ntangl)/mxnode
+
+c     zero accumulators
+      
+      engang=0.d0
+      virang=0.d0
+      ang_fre=0.d0
+      ang_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+      if(lsolva)then
+        
+        lcomp(2)=.true.
+        ang_sol(:)=0.d0
+        if(lexcite)ang_exc(:)=0.d0
+        
+      endif
+      
+c     calculate atom separation vectors
+      
+      ii=0
+      do i=iang1,iang2
+        
+        ii=ii+1
+
+c     indices of bonded atoms
+        
+        ia=listang(ii,2)
+        ib=listang(ii,3)
+        ic=listang(ii,4)
+
+c     components of first bond vector
+        
+        xdab(ii)=xxx(ia)-xxx(ib)
+        ydab(ii)=yyy(ia)-yyy(ib)
+        zdab(ii)=zzz(ia)-zzz(ib)
+
+c     components of second bond vector
+        
+        xdbc(ii)=xxx(ic)-xxx(ib)
+        ydbc(ii)=yyy(ic)-yyy(ib)
+        zdbc(ii)=zzz(ic)-zzz(ib)
+        
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      call images(imcon,0,1,ii,cell,xdbc,ydbc,zdbc)
+
+c     loop over all specified angle potentials
+      
+      ii=0
+      do i=iang1,iang2
+        
+        ii=ii+1
+
+c     define components of first bond vector
+        
+        rab=sqrt(xdab(ii)**2+ydab(ii)**2+zdab(ii)**2)
+        rrab=1.d0/rab
+        
+        xab=xdab(ii)*rrab
+        yab=ydab(ii)*rrab
+        zab=zdab(ii)*rrab
+
+c     define components of second bond vector
+        
+        rbc=sqrt(xdbc(ii)**2+ydbc(ii)**2+zdbc(ii)**2)
+        rrbc=1.d0/rbc
+        
+        xbc=xdbc(ii)*rrbc
+        ybc=ydbc(ii)*rrbc
+        zbc=zdbc(ii)*rrbc
+
+c     index of potential function parameters
+        
+        kk=listang(ii,1)
+
+c     determine bond angle and calculate potential energy
+        
+        cost=(xab*xbc+yab*ybc+zab*zbc)
+        theta=acos(cost)
+        sint=max(1.d-8,sqrt(1.d0-cost**2))
+        
+        keya=abs(keyang(kk))
+        
+        if(keya.eq.1)then
+          
+c     harmonic potential
+          
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2
+          gamma=prmang(kk,1)*(theta-prmang(kk,2))/sint
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.2)then
+
+c     quartic potential
+          
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2+
+     x      1.d0/3.d0*prmang(kk,3)*(theta-prmang(kk,2))**3+
+     x      0.25d0*prmang(kk,4)*(theta-prmang(kk,2))**4
+          gamma=(prmang(kk,1)*(theta-prmang(kk,2))+
+     x      prmang(kk,3)*(theta-prmang(kk,2))**2+
+     x      prmang(kk,4)*(theta-prmang(kk,2))**3)/sint
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.3)then
+
+c     truncated harmonic potential
+      
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2*
+     x      exp(-(rab**8+rbc**8)/prmang(kk,3)**8)
+          gamma=prmang(kk,1)*(theta-prmang(kk,2))*
+     x      exp(-(rab**8+rbc**8)/prmang(kk,3)**8)/sint
+          vterm=-8.d0*pterm*(rab**8+rbc**8)/prmang(kk,3)**8
+          gamsa=(8.d0*pterm/prmang(kk,3)**8)*rab**7
+          gamsc=(8.d0*pterm/prmang(kk,3)**8)*rbc**7
+          
+        elseif(keya.eq.4)then
+
+c     screened harmonic potential
+          
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))
+          gamma=prmang(kk,1)*(theta-prmang(kk,2))*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))/sint
+          vterm=-pterm*(rab/prmang(kk,3)+rbc/prmang(kk,4))
+          gamsa=(pterm/prmang(kk,3))
+          gamsc=(pterm/prmang(kk,4))
+          
+        elseif(keya.eq.5)then
+
+c     screened vessal potential (type 1)
+      
+          pterm=(prmang(kk,1)/(8.d0*(prmang(kk,2)-pi)**2)*
+     x      (((prmang(kk,2)-pi)**2-(theta-pi)**2)**2))*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))
+          gamma=(prmang(kk,1)/(2.d0*(prmang(kk,2)-pi)**2)*
+     x      ((prmang(kk,2)-pi)**2-(theta-pi)**2)*(theta-pi))*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))/sint
+          vterm=-pterm*(rab/prmang(kk,3)+rbc/prmang(kk,4))
+          gamsa=(pterm/prmang(kk,3))
+          gamsc=(pterm/prmang(kk,4))
+          
+        elseif(keya.eq.6)then
+
+c     truncated vessal potential (type 2)
+          
+          pterm=prmang(kk,1)*(theta**prmang(kk,3)*(theta-prmang(kk,2))
+     x      **2*(theta+prmang(kk,2)-2.d0*pi)**2-0.5d0*prmang(kk,3)*pi
+     x      **(prmang(kk,3)-1.d0)*(theta-prmang(kk,2))**2*(pi-prmang(kk,
+     x      2))**3)*exp(-(rab**8+rbc**8)/prmang(kk,4)**8)
+          gamma=prmang(kk,1)*(theta**(prmang(kk,3)-1.d0)*(theta-prmang
+     x      (kk,2))*(theta+prmang(kk,2)-2.d0*pi)*((prmang(kk,3)+4.d0)*
+     x      theta**2-2.d0*pi*(prmang(kk,3)+2.d0)*theta+prmang(kk,3)*
+     x      prmang(kk,2)*(2.d0*pi-prmang(kk,2)))-prmang(kk,3)*pi**
+     x      (prmang(kk,3)-1.d0)*(theta-prmang(kk,2))*(pi-prmang(kk,2))
+     x      **3)*exp(-(rab**8+rbc**8)/prmang(kk,4)**8)/sint
+          vterm=-8.d0*pterm*(rab**8+rbc**8)/prmang(kk,4)**8
+          gamsa=(8.d0*pterm/prmang(kk,4)**8)*rab**7
+          gamsc=(8.d0*pterm/prmang(kk,4)**8)*rbc**7
+
+        elseif(keya.eq.7)then
+          
+c     harmonic cosine potential
+          
+          pterm=0.5d0*prmang(kk,1)*(cos(theta)-cos(prmang(kk,2)))**2
+          gamma=-prmang(kk,1)*(cos(theta)-cos(prmang(kk,2)))
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.8)then
+          
+c     ordinary cosine potential
+          
+          pterm=prmang(kk,1)*(1+cos(prmang(kk,3)*theta-prmang(kk,2)))
+          gamma=-prmang(kk,1)*prmang(kk,3)*sin(prmang(kk,3)*theta-
+     x      prmang(kk,2))/sint
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.9)then
+
+c     mm3 stretch-bend potential
+
+          pterm=prmang(kk,1)*(theta-prmang(kk,2))*
+     x      (rab-prmang(kk,3))*(rbc-prmang(kk,4))
+          gamma=prmang(kk,1)*(rab-prmang(kk,3))*(rbc-
+     x      prmang(kk,4))/sint
+          gamsa=-prmang(kk,1)*(theta-prmang(kk,2))*(rbc-prmang(kk,4))
+          gamsc=-prmang(kk,1)*(theta-prmang(kk,2))*(rab-prmang(kk,3))
+          vterm=-(gamsa*rab+gamsc*rbc)
+
+        elseif(keya.eq.10)then
+
+c     compass stretch-stretch potential
+
+          pterm=prmang(kk,1)*(rab-prmang(kk,2))*(rbc-prmang(kk,3))
+          gamma=0.d0
+          gamsa=-prmang(kk,1)*(rbc-prmang(kk,3))
+          gamsc=-prmang(kk,1)*(rab-prmang(kk,2))
+          vterm=-(gamsa*rab+gamsc*rbc)
+
+        elseif(keya.eq.11)then
+
+c     compass stretch-bend potential
+
+          pterm=prmang(kk,1)*(theta-prmang(kk,2))*(rab-prmang(kk,3))
+          gamma=prmang(kk,1)*(rab-prmang(kk,3))/sint
+          gamsa=-prmang(kk,1)*(theta-prmang(kk,2))
+          gamsc=0.d0
+          vterm=-gamsa*rab
+
+        elseif(keya.eq.12)then
+
+c     combined compass angle potential with 3 coupling terms
+
+          pterm=prmang(kk,1)*(rab-prmang(kk,5))*(rbc-prmang(kk,6))+
+     x          (theta-prmang(kk,4))*(prmang(kk,2)*(rab-prmang(kk,5))+
+     x          prmang(kk,3)*(rbc-prmang(kk,6)))
+          gamma=(prmang(kk,2)*(rab-prmang(kk,5))+
+     x           prmang(kk,3)*(rbc-prmang(kk,6)))/sint
+          gamsa=-prmang(kk,2)*(theta-prmang(kk,4))-
+     x           prmang(kk,1)*(rbc-prmang(kk,6))
+          gamsc=-prmang(kk,3)*(theta-prmang(kk,4))-
+     x           prmang(kk,1)*(rab-prmang(kk,5))
+          vterm=-(gamsa*rab+gamsc*rbc)
+
+        else
+
+c     undefined potential
+
+          safe=.false.
+          pterm=0.d0
+          vterm=0.d0
+          gamma=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listang(ii,2)
+        ib=listang(ii,3)
+        ic=listang(ii,4)
+
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          kdrive=driven(ltype(ic))
+          
+        endif
+
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+        
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x      (atm_fre(ic).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic).eq.0)
+            
+            if(lsolva)then
+              ang_exc(atmolt(ia))=ang_exc(atmolt(ia))+pterm
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x        (atm_fre(ic).eq.1))then
+            
+c     set hamiltonian mixing parameter
+
+            ang_fre=ang_fre-pterm
+            ang_vir=ang_vir-vterm
+            pterm=lambda1*pterm
+            vterm=lambda1*vterm
+            gamma=lambda1*gamma
+            gamsa=lambda1*gamsa
+            gamsc=lambda1*gamsc
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x        (atm_fre(ic).eq.2))then
+            
+c     set hamiltonian mixing parameter
+
+            ang_fre=ang_fre+pterm
+            ang_vir=ang_vir+vterm
+            pterm=lambda2*pterm
+            vterm=lambda2*vterm
+            gamma=lambda2*gamma
+            gamsa=lambda2*gamsa
+            gamsc=lambda2*gamsc
+                        
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     sum potential energy and virial
+          
+          engang=engang+pterm
+          virang=virang+vterm
+          
+c     calculate solvation energy
+        
+          if(lsolva)then
+            ang_sol(atmolt(ia))=ang_sol(atmolt(ia))+pterm
+          endif
+          
+c     calculate atomic forces
+        
+          fxa=gamma*(xbc-xab*cost)*rrab+gamsa*xab
+          fya=gamma*(ybc-yab*cost)*rrab+gamsa*yab
+          fza=gamma*(zbc-zab*cost)*rrab+gamsa*zab
+          
+          fxc=gamma*(xab-xbc*cost)*rrbc+gamsc*xbc
+          fyc=gamma*(yab-ybc*cost)*rrbc+gamsc*ybc
+          fzc=gamma*(zab-zbc*cost)*rrbc+gamsc*zbc
+          
+c     sum atomic forces
+
+          fxx(ia)=fxx(ia)+fxa
+          fyy(ia)=fyy(ia)+fya
+          fzz(ia)=fzz(ia)+fza
+          
+          fxx(ib)=fxx(ib)-fxa-fxc
+          fyy(ib)=fyy(ib)-fya-fyc
+          fzz(ib)=fzz(ib)-fza-fzc
+          
+          fxx(ic)=fxx(ic)+fxc
+          fyy(ic)=fyy(ic)+fyc
+          fzz(ic)=fzz(ic)+fzc
+          
+c     calculate stress tensor
+          
+          strs(1)=strs(1)+rab*xab*fxa+rbc*xbc*fxc
+          strs(2)=strs(2)+rab*xab*fya+rbc*xbc*fyc
+          strs(3)=strs(3)+rab*xab*fza+rbc*xbc*fzc
+          strs(4)=strs(4)+rab*yab*fya+rbc*ybc*fyc
+          strs(5)=strs(5)+rab*yab*fza+rbc*ybc*fzc
+          strs(6)=strs(6)+rab*zab*fza+rbc*zbc*fzc
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive.or.kdrive))then
+          
+c     local energy and virial
+          
+          eng_loc=eng_loc+pterm
+          vir_loc=vir_loc+vterm
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fxa
+          fyy_loc(ia)=fyy_loc(ia)+fya
+          fzz_loc(ia)=fzz_loc(ia)+fza
+          
+          fxx_loc(ib)=fxx_loc(ib)-fxa-fxc
+          fyy_loc(ib)=fyy_loc(ib)-fya-fyc
+          fzz_loc(ib)=fzz_loc(ib)-fza-fzc
+          
+          fxx_loc(ic)=fxx_loc(ic)+fxc
+          fyy_loc(ic)=fyy_loc(ic)+fyc
+          fzz_loc(ic)=fzz_loc(ic)+fzc
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+rab*xab*fxa+rbc*xbc*fxc
+          strs_loc(2)=strs_loc(2)+rab*xab*fya+rbc*xbc*fyc
+          strs_loc(3)=strs_loc(3)+rab*xab*fza+rbc*xbc*fzc
+          strs_loc(4)=strs_loc(4)+rab*yab*fya+rbc*ybc*fyc
+          strs_loc(5)=strs_loc(5)+rab*yab*fza+rbc*ybc*fzc
+          strs_loc(6)=strs_loc(6)+rab*zab*fza+rbc*zbc*fzc
+
+        endif
+        
+      enddo
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,440)
+
+c     complete stress tensor
+        
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     sum up contributions to potential and virial
+      
+      if(mxnode.gt.1)then
+
+        buffer(1)=engang
+        buffer(2)=virang
+        buffer(3)=ang_fre
+        buffer(4)=ang_vir
+        call gdsum(buffer(1),4,buffer(5))
+        engang=buffer(1)
+        virang=buffer(2)
+        ang_fre=buffer(3)
+        ang_vir=buffer(4)
+
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(ang_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(ang_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      deallocate (xdab,ydab,zdab,stat=fail1)
+      deallocate (xdbc,ydbc,zdbc,stat=fail2)
+      
+      return
+      end subroutine angfrc
+      
+      end module angles_module
diff -urN dl_class_1.9.orig/srcmod/basic_comms.f dl_class_1.9/srcmod/basic_comms.f
--- dl_class_1.9.orig/srcmod/basic_comms.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/basic_comms.f	2015-11-09 14:52:08.086294333 +0100
@@ -0,0 +1,389 @@
+      subroutine initcomms()
+      
+c*********************************************************************
+c     
+c     communication harness initialisation
+c     
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      include "comms.inc"
+      
+      integer ierr
+
+CMPIU      define MPI_init MPI_init_
+
+      call MPI_init(ierr)
+
+      return
+      end
+
+c PLUMED
+      integer*8 function get_comms()
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for obtaining the communicator
+c     this is used by plumed
+c     
+c     author - G. Tribello 
+c
+c*********************************************************************
+
+      get_comms=MPI_COMM_WORLD
+      end
+
+      subroutine machine(idnode,mxnode)
+c PLUMED
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for obtaining charcteristics of
+c     the computer on which the program is being run
+c     
+c     copyright daresbury laboratory 1992
+c     author - w.smith july 1992
+c     
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,mynode,numnodes
+
+      idnode=mynode()
+      mxnode=numnodes()
+
+      return
+      end
+
+      integer function mynode()
+
+c*********************************************************************
+c
+c     routine to determine identity of processing node 
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+
+CMPIU define MPI_COMM_RANK MPI_COMM_RANK_
+
+      call MPI_COMM_RANK(MPI_COMM_WORLD, mynode ,ierr)
+
+      return
+      end
+
+      integer function nodedim()
+
+c*********************************************************************
+c
+c     calculate dimension of hypercube
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer i,n,ierr,mxnode
+
+CMPIU      define MPI_COMM_SIZE MPI_COMM_SIZE_
+
+      call MPI_COMM_SIZE(MPI_COMM_WORLD, mxnode ,ierr)
+      n=1
+      nodedim = -1
+      do i=0,16
+
+         if(n.eq.mxnode)nodedim=i
+         n=2*n
+
+      enddo
+
+      return
+      end
+
+      integer function numnodes()
+
+c*********************************************************************
+c
+c     calculate number of nodes
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+
+CMPIU      define MPI_COMM_SIZE MPI_COMM_SIZE_
+
+      call MPI_COMM_SIZE(MPI_COMM_WORLD, numnodes, ierr)
+
+      return
+      end
+
+      subroutine csend(tagmsg,buf,length,pe,idum)
+
+c*********************************************************************
+c
+c     Intel-like  csend (double precision)
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer tagmsg,length,pe,idum
+
+      integer ierr
+      real(8) buf(*)
+
+CMPIU      define MPI_send MPI_send_
+
+      call MPI_send(buf,length,MPI_DOUBLE_PRECISION,pe,tagmsg,
+     x     MPI_COMM_WORLD,ierr)
+
+      return
+      end
+
+      subroutine crecv(tagmsg,buf,length)
+
+c*********************************************************************
+c
+c     Intel-like  crecv (double precision)
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer tagmsg,length
+
+      integer ierr
+      integer status(MPI_STATUS_SIZE)
+      real(8) buf(*)
+
+CMPIU      define MPI_RECV MPI_RECV_
+
+      call MPI_RECV(buf,length,MPI_DOUBLE_PRECISION,MPI_ANY_SOURCE,
+     x     tagmsg,MPI_COMM_WORLD,status,ierr)
+
+      return 
+      end
+
+      subroutine gisum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global summation subroutine for hypercube - MPI version
+c     integer version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      integer nnn,i,ierror,iii,kk,k,k0,k1,k2,msg1,msg2
+      integer aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+
+CMPIU      define MPI_allreduce MPI_allreduce_
+
+      call MPI_allreduce(aaa,bbb,nnn,MPI_INTEGER,
+     x  MPI_SUM,MPI_COMM_WORLD,ierror)
+
+      do i = 1,nnn
+        aaa(i) = bbb(i)
+      enddo
+
+      return
+      end
+
+      subroutine gdsum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global summation subroutine for MPI - hypercube assumed
+c     double precision version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nnn,i,iii,kk,k1,k2,ierror
+      real(8) aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+
+CMPIU      define MPI_allreduce MPI_allreduce_
+
+      call MPI_allreduce(aaa,bbb,nnn,MPI_DOUBLE_PRECISION,
+     x  MPI_SUM,MPI_COMM_WORLD,ierror)
+
+        do i = 1,nnn
+          aaa(i) = bbb(i)
+        enddo
+
+      return
+      end
+
+      subroutine gimax(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global maximum subroutine for hypercube - MPI version
+c     integer version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      integer nnn,i,iii,kk,k1,k2,k,k0msg1,msg2,ierror
+      integer aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+CMPIU      define MPI_allreduce MPI_allreduce_
+      
+      call MPI_allreduce(aaa,bbb,nnn,MPI_INTEGER,
+     x   MPI_MAX,MPI_COMM_WORLD,ierror)
+      
+      do i = 1,nnn
+        aaa(i) = bbb(i)
+      enddo
+
+      return
+      end
+
+      subroutine gstate(check)
+
+c***********************************************************************
+c     
+c     dl_poly global status subroutine : gisum version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     MPI version -  t. forester may 1995
+c     
+c***********************************************************************
+
+
+      implicit none
+
+      logical check
+      integer i,idum
+
+      i = 0
+      if(.not.check) i = 1
+
+      call gisum(i,1,idum)
+      
+      check = (i.eq.0)
+
+      return
+      end
+
+      subroutine gsync()
+
+c*********************************************************************
+c     
+c     barrier / synchronization routine
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ierr
+
+      include "comms.inc"
+
+CMPIU      define MPI_BARRIER MPI_BARRIER_
+
+      call  MPI_BARRIER(MPI_COMM_WORLD,ierr)
+
+      return
+      end
+
+      subroutine exitcomms()
+
+c*********************************************************************
+c
+c     exitcomms: exit from communication harness
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+CMPIU      define MPI_FINALIZE MPI_FINALIZE_
+
+      call MPI_FINALIZE(ierr)
+      call exit(0)
+
+      return
+      end
diff -urN dl_class_1.9.orig/srcmod/basic_comms.f.preplumed dl_class_1.9/srcmod/basic_comms.f.preplumed
--- dl_class_1.9.orig/srcmod/basic_comms.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/basic_comms.f.preplumed	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,373 @@
+      subroutine initcomms()
+      
+c*********************************************************************
+c     
+c     communication harness initialisation
+c     
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      include "comms.inc"
+      
+      integer ierr
+
+CMPIU      define MPI_init MPI_init_
+
+      call MPI_init(ierr)
+
+      return
+      end
+
+      subroutine machine(idnode,mxnode)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for obtaining charcteristics of
+c     the computer on which the program is being run
+c     
+c     copyright daresbury laboratory 1992
+c     author - w.smith july 1992
+c     
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,mynode,numnodes
+
+      idnode=mynode()
+      mxnode=numnodes()
+
+      return
+      end
+
+      integer function mynode()
+
+c*********************************************************************
+c
+c     routine to determine identity of processing node 
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+
+CMPIU define MPI_COMM_RANK MPI_COMM_RANK_
+
+      call MPI_COMM_RANK(MPI_COMM_WORLD, mynode ,ierr)
+
+      return
+      end
+
+      integer function nodedim()
+
+c*********************************************************************
+c
+c     calculate dimension of hypercube
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer i,n,ierr,mxnode
+
+CMPIU      define MPI_COMM_SIZE MPI_COMM_SIZE_
+
+      call MPI_COMM_SIZE(MPI_COMM_WORLD, mxnode ,ierr)
+      n=1
+      nodedim = -1
+      do i=0,16
+
+         if(n.eq.mxnode)nodedim=i
+         n=2*n
+
+      enddo
+
+      return
+      end
+
+      integer function numnodes()
+
+c*********************************************************************
+c
+c     calculate number of nodes
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+
+CMPIU      define MPI_COMM_SIZE MPI_COMM_SIZE_
+
+      call MPI_COMM_SIZE(MPI_COMM_WORLD, numnodes, ierr)
+
+      return
+      end
+
+      subroutine csend(tagmsg,buf,length,pe,idum)
+
+c*********************************************************************
+c
+c     Intel-like  csend (double precision)
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer tagmsg,length,pe,idum
+
+      integer ierr
+      real(8) buf(*)
+
+CMPIU      define MPI_send MPI_send_
+
+      call MPI_send(buf,length,MPI_DOUBLE_PRECISION,pe,tagmsg,
+     x     MPI_COMM_WORLD,ierr)
+
+      return
+      end
+
+      subroutine crecv(tagmsg,buf,length)
+
+c*********************************************************************
+c
+c     Intel-like  crecv (double precision)
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer tagmsg,length
+
+      integer ierr
+      integer status(MPI_STATUS_SIZE)
+      real(8) buf(*)
+
+CMPIU      define MPI_RECV MPI_RECV_
+
+      call MPI_RECV(buf,length,MPI_DOUBLE_PRECISION,MPI_ANY_SOURCE,
+     x     tagmsg,MPI_COMM_WORLD,status,ierr)
+
+      return 
+      end
+
+      subroutine gisum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global summation subroutine for hypercube - MPI version
+c     integer version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      integer nnn,i,ierror,iii,kk,k,k0,k1,k2,msg1,msg2
+      integer aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+
+CMPIU      define MPI_allreduce MPI_allreduce_
+
+      call MPI_allreduce(aaa,bbb,nnn,MPI_INTEGER,
+     x  MPI_SUM,MPI_COMM_WORLD,ierror)
+
+      do i = 1,nnn
+        aaa(i) = bbb(i)
+      enddo
+
+      return
+      end
+
+      subroutine gdsum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global summation subroutine for MPI - hypercube assumed
+c     double precision version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nnn,i,iii,kk,k1,k2,ierror
+      real(8) aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+
+CMPIU      define MPI_allreduce MPI_allreduce_
+
+      call MPI_allreduce(aaa,bbb,nnn,MPI_DOUBLE_PRECISION,
+     x  MPI_SUM,MPI_COMM_WORLD,ierror)
+
+        do i = 1,nnn
+          aaa(i) = bbb(i)
+        enddo
+
+      return
+      end
+
+      subroutine gimax(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global maximum subroutine for hypercube - MPI version
+c     integer version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      integer nnn,i,iii,kk,k1,k2,k,k0msg1,msg2,ierror
+      integer aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+CMPIU      define MPI_allreduce MPI_allreduce_
+      
+      call MPI_allreduce(aaa,bbb,nnn,MPI_INTEGER,
+     x   MPI_MAX,MPI_COMM_WORLD,ierror)
+      
+      do i = 1,nnn
+        aaa(i) = bbb(i)
+      enddo
+
+      return
+      end
+
+      subroutine gstate(check)
+
+c***********************************************************************
+c     
+c     dl_poly global status subroutine : gisum version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     MPI version -  t. forester may 1995
+c     
+c***********************************************************************
+
+
+      implicit none
+
+      logical check
+      integer i,idum
+
+      i = 0
+      if(.not.check) i = 1
+
+      call gisum(i,1,idum)
+      
+      check = (i.eq.0)
+
+      return
+      end
+
+      subroutine gsync()
+
+c*********************************************************************
+c     
+c     barrier / synchronization routine
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ierr
+
+      include "comms.inc"
+
+CMPIU      define MPI_BARRIER MPI_BARRIER_
+
+      call  MPI_BARRIER(MPI_COMM_WORLD,ierr)
+
+      return
+      end
+
+      subroutine exitcomms()
+
+c*********************************************************************
+c
+c     exitcomms: exit from communication harness
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+CMPIU      define MPI_FINALIZE MPI_FINALIZE_
+
+      call MPI_FINALIZE(ierr)
+      call exit(0)
+
+      return
+      end
diff -urN dl_class_1.9.orig/srcmod/bonds_module.f dl_class_1.9/srcmod/bonds_module.f
--- dl_class_1.9.orig/srcmod/bonds_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/bonds_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,579 @@
+      module bonds_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining bond potential arrays
+c     copyright - daresbury laboratory
+c     
+c     author    - w. smith    sep 2003
+c     adapted for solvation, free energy and excitation
+c               - p.-a. cazade oct 2007
+c     adapted for metadynamics
+c               - d. quigley 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmbnd(:,:)
+      integer, allocatable :: listbnd(:,:)
+      integer, allocatable :: numbonds(:),keybnd(:),lstbnd(:,:)
+      
+      save prmbnd,listbnd,numbonds,keybnd,lstbnd
+      
+      contains
+      
+      subroutine alloc_bnd_arrays(idnode)
+      
+      implicit none
+      
+      integer i,fail,idnode
+      dimension fail(5)
+      
+      do i=1,5
+        fail(i)=0
+      enddo
+      
+      allocate (prmbnd(mxtbnd,mxpbnd),stat=fail(1))
+      allocate (numbonds(mxtmls),stat=fail(2))
+      allocate (keybnd(mxtbnd),stat=fail(3))
+      allocate (lstbnd(mxtbnd,3),stat=fail(4))
+      allocate (listbnd(mxbond,4),stat=fail(5))
+      
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+      do i=1,mxtmls
+        numbonds(i)=0
+      enddo
+      
+      end subroutine alloc_bnd_arrays
+      
+      subroutine define_bonds
+     x  (safe,idnode,itmols,nbonds,nsite,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining bonds
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,nbonds,nsite,ntmp,ibond,ibond1
+      integer iatm1,iatm2,isite1,isite2,idum,i,j
+      real(8) engunit
+      
+      ntmp=intstr(record,lenrec,idum)
+      numbonds(itmols)=numbonds(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of chemical bonds',
+     x    7x,i10)")ntmp
+        write(nrite,"(/,/,1x,'chemical bond details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',28x,
+     x    'parameters', /)")
+      endif
+      
+      ibond1=numbonds(itmols)
+      do ibond=1,ibond1
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        
+c     test for frozen atom pairs
+        
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        
+        if(lfzsit(isite1)*lfzsit(isite2).ne.0)then
+          
+          numbonds(itmols)=numbonds(itmols)-1
+          if(idnode.eq.0)write(nrite,'(12x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+          
+        else
+          
+          nbonds=nbonds+1
+          if(nbonds.gt.mxtbnd)call error(idnode,30)
+          
+          if(keyword(1:4).eq.'harm')then
+            keybnd(nbonds)=1
+          elseif(keyword(1:4).eq.'-hrm')then
+            keybnd(nbonds)=-1
+          elseif(keyword(1:4).eq.'mors')then
+            keybnd(nbonds)=2
+          elseif(keyword(1:4).eq.'-mrs')then
+            keybnd(nbonds)=-2
+          elseif(keyword(1:4).eq.'12-6')then
+            keybnd(nbonds)=3
+          elseif(keyword(1:4).eq.'-126')then
+            keybnd(nbonds)=-3
+          elseif(keyword(1:4).eq.'rhrm')then
+            keybnd(nbonds)=4
+          elseif(keyword(1:4).eq.'-rhm')then
+            keybnd(nbonds)=-4
+          elseif(keyword(1:4).eq.'quar')then
+            keybnd(nbonds)=5
+          elseif(keyword(1:4).eq.'-qur')then
+            keybnd(nbonds)=-5
+          elseif(keyword(1:4).eq.'buck')then
+            keybnd(nbonds)=6
+          elseif(keyword(1:4).eq.'-bck')then
+            keybnd(nbonds)=-6
+          elseif(keyword(1:4).eq.'fene')then
+            keybnd(nbonds)=7
+          elseif(keyword(1:4).eq.'-fen')then
+            keybnd(nbonds)=-7
+          elseif(keyword(1:4).eq.'coul')then
+            keybnd(nbonds)=8
+          elseif(keyword(1:4).eq.'-cou')then
+            keybnd(nbonds)=-8
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,444)
+          endif
+          
+          lstbnd(nbonds,1)=iatm1
+          lstbnd(nbonds,2)=iatm2
+          prmbnd(nbonds,1)=dblstr(record,lenrec,idum)
+          prmbnd(nbonds,2)=dblstr(record,lenrec,idum)
+          prmbnd(nbonds,3)=dblstr(record,lenrec,idum)
+          prmbnd(nbonds,4)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,2i10,2x,1p,10e15.6)")
+     x      keyword(1:4),lstbnd(nbonds,1),
+     x      lstbnd(nbonds,2),(prmbnd(nbonds,j),j=1,mxpbnd)
+c     
+c     convert energy units to internal units
+          
+          if(abs(keybnd(nbonds)).eq.3)then
+            prmbnd(nbonds,2)=prmbnd(nbonds,2)*engunit
+          endif
+          if(abs(keybnd(nbonds)).eq.5)then
+            prmbnd(nbonds,3)=prmbnd(nbonds,3)*engunit
+            prmbnd(nbonds,4)=prmbnd(nbonds,4)*engunit
+          endif
+          if(abs(keybnd(nbonds)).eq.6)then
+            prmbnd(nbonds,3)=prmbnd(nbonds,3)*engunit
+          endif
+          
+          if(abs(keybnd(nbonds)).ne.8)
+     x      prmbnd(nbonds,1)=prmbnd(nbonds,1)*engunit
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_bonds
+      
+      subroutine bndfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntbond,epsq,
+     x  engbnd,virbnd)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating chemical bond energy and 
+c     force terms in molecular dynamics.
+c     
+c     replicated data - blocked  data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        july 1992
+c     modified  - t. forester    march 1993 
+c     modified  - t. forester    march 1994 
+c     modified  - t. forester    may   1994 
+c     modified  - t. forester    nov   1994 
+c     modified  - w. smith       nov   2006
+c     modified  - p.-a. cazade   oct   2007, solvation etc.
+c     modified  - d. quigley           2007, metdynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect
+      logical idrive,jdrive
+      integer i,fail,ibnd1,ibnd2,idnode,mxnode,ii,ia,ib,imcon
+      integer keyb,kk,ntbond
+      real(8) strs(6),strs_loc(6)
+      real(8) rab,rrab,omega,gamma,fx,fy,fz,engbnd,virbnd,epsq
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail)
+      if(fail.ne.0)call error(idnode,1040)
+      
+c     flag for undefined potential
+      
+      safe=.true.
+      
+c     check size of work arrays
+      
+      if((ntbond-mxnode+1)/mxnode.gt.msbad)call error(idnode,418)
+      
+c     block indices
+      
+      ibnd1=(idnode*ntbond)/mxnode+1
+      ibnd2=((idnode+1)*ntbond)/mxnode
+      
+c     initialise accumulators
+      
+      engbnd=0.d0
+      virbnd=0.d0
+      bnd_fre=0.d0
+      bnd_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+      if(lsolva)then
+        
+        lcomp(1)=.true.
+        bnd_sol(:)=0.d0
+        if(lexcite)bnd_exc(:)=0.d0
+        
+      endif
+      
+c     calculate atom separation vectors
+      
+      ii=0
+      do i=ibnd1,ibnd2
+        
+        ii=ii+1
+        
+c     indices of bonded atoms
+        
+        ia=listbnd(ii,2)
+        ib=listbnd(ii,3)
+        
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          
+        endif
+
+c     components of bond vector
+        
+        xdab(ii)=xxx(ia)-xxx(ib)
+        ydab(ii)=yyy(ia)-yyy(ib)
+        zdab(ii)=zzz(ia)-zzz(ib)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      
+c     loop over all specified chemical bond potentials
+      
+      ii=0
+      do i=ibnd1,ibnd2
+        
+        ii=ii+1
+        
+c     define components of bond vector
+        
+        rrab=0.d0
+        rab=sqrt(xdab(ii)**2+ydab(ii)**2+zdab(ii)**2)
+        if(rab.gt.1.d-6)rrab=1.d0/rab
+        
+c     index of potential function parameters
+        
+        kk=listbnd(ii,1)
+        keyb=abs(keybnd(kk))
+        
+c     calculate scalar constant terms
+        
+        if(keyb.eq.0)then
+          
+c     null interaction
+          
+          omega=0.d0
+          gamma=0.d0
+          
+        elseif(keyb.eq.1)then
+          
+c     harmonic potential
+          
+          omega=0.5d0*prmbnd(kk,1)*(rab-prmbnd(kk,2))**2
+          gamma=prmbnd(kk,1)*(rab-prmbnd(kk,2))*rrab
+          
+        else if(keyb.eq.2)then
+          
+c     morse potential
+          
+          omega=prmbnd(kk,1)*((1.d0-exp(-prmbnd(kk,3)*
+     x      (rab-prmbnd(kk,2))))**2-1.d0)
+          gamma=2.d0*prmbnd(kk,1)*prmbnd(kk,3)*(1.d0-
+     x      exp(-prmbnd(kk,3)*(rab-prmbnd(kk,2))))*
+     x      exp(-prmbnd(kk,3)*(rab-prmbnd(kk,2)))*rrab
+          
+        else if(keyb.eq.3)then
+          
+c     12-6 potential
+          
+          omega=(prmbnd(kk,1)*rrab**6-prmbnd(kk,2))*rrab**6
+          gamma=(6.d0*prmbnd(kk,2)-12.d0*prmbnd(kk,1)*rrab**6)*
+     x      rrab**8
+          
+        elseif(keyb.eq.4)then
+          
+c     restrained harmonic
+          
+          rab=rab-prmbnd(kk,2)
+          omega=0.5d0*prmbnd(kk,1)*(min(abs(rab),prmbnd(kk,3)))**2
+     x      +prmbnd(kk,1)*prmbnd(kk,3)*max(abs(rab)-prmbnd(kk,3),0.d0)
+          gamma=rrab*prmbnd(kk,1)*(sign(min(abs(rab),prmbnd(kk,3)),rab))
+          
+        elseif(keyb.eq.5)then
+          
+c     quartic potential
+          
+          omega=0.5d0*prmbnd(kk,1)*(rab-prmbnd(kk,2))**2+
+     x      1.d0/3.d0*prmbnd(kk,3)*(rab-prmbnd(kk,2))**3+
+     x      0.25d0*prmbnd(kk,4)*(rab-prmbnd(kk,2))**4
+          gamma=rrab*(prmbnd(kk,1)*(rab-prmbnd(kk,2))+
+     x      prmbnd(kk,3)*(rab-prmbnd(kk,2))**2+
+     x      prmbnd(kk,4)*(rab-prmbnd(kk,2))**3)
+          
+        else if(keyb.eq.6)then
+          
+c     buckingham exp-6 potential
+          
+          omega=prmbnd(kk,1)*exp(-rab/prmbnd(kk,2))-prmbnd(kk,3)*
+     x      rrab**6
+          gamma=-rrab*prmbnd(kk,1)*exp(-rab/prmbnd(kk,2))/prmbnd(kk,2)+
+     x      6.d0*prmbnd(kk,3)*rrab**8
+          
+        else if(keyb.eq.7)then
+          
+c     FENE bond potential
+          
+          omega=-0.5d0*prmbnd(kk,1)*prmbnd(kk,2)**2*log(1.d0-
+     x      ((rab-prmbnd(kk,3))/prmbnd(kk,2))**2)
+          gamma=rrab*prmbnd(kk,1)*(rab-prmbnd(kk,3))/
+     x      (1.d0-((rab-prmbnd(kk,3))/prmbnd(kk,2))**2)
+          
+        else if(keyb.eq.8)then
+          
+c     coulomb bond potential
+          
+          omega=prmbnd(kk,1)*prmbnd(kk,2)*rrab*r4pie0/epsq
+          gamma=-omega*rrab*rrab
+          
+        else
+          
+c     undefined potential
+          
+          omega=0.d0
+          gamma=0.d0
+          safe=.false.
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listbnd(ii,2)
+        ib=listbnd(ii,3)
+        
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+          
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib).eq.0)
+            
+            if(lsolva)then
+              bnd_exc(atmolt(ia))=bnd_exc(atmolt(ia))+omega
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1))then
+            
+c     set hamiltonian mixing parameter
+            
+            bnd_fre=bnd_fre-omega
+            bnd_vir=bnd_vir-gamma*rab*rab
+            omega=lambda1*omega
+            gamma=lambda1*gamma
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2))then
+            
+c     set hamiltonian mixing parameter
+            
+            bnd_fre=bnd_fre+omega
+            bnd_vir=bnd_vir+gamma*rab*rab
+            omega=lambda2*omega
+            gamma=lambda2*gamma
+            
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate bond energy and virial
+        
+          engbnd=engbnd+omega
+          virbnd=virbnd+gamma*rab*rab
+          
+c     calculate solvation energy
+        
+          if(lsolva)then
+            bnd_sol(atmolt(ia))=bnd_sol(atmolt(ia))+omega
+          endif
+          
+c     calculate forces
+          
+          fx=-gamma*xdab(ii)
+          fy=-gamma*ydab(ii)
+          fz=-gamma*zdab(ii)
+          
+          fxx(ia)=fxx(ia)+fx
+          fyy(ia)=fyy(ia)+fy
+          fzz(ia)=fzz(ia)+fz
+          
+          fxx(ib)=fxx(ib)-fx
+          fyy(ib)=fyy(ib)-fy
+          fzz(ib)=fzz(ib)-fz
+          
+c     calculate stress tensor
+        
+          strs(1)=strs(1)+xdab(ii)*fx
+          strs(2)=strs(2)+xdab(ii)*fy
+          strs(3)=strs(3)+xdab(ii)*fz
+          strs(4)=strs(4)+ydab(ii)*fy
+          strs(5)=strs(5)+ydab(ii)*fz
+          strs(6)=strs(6)+zdab(ii)*fz
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive))then
+          
+c     local energy and virial
+          
+          eng_loc=eng_loc+omega
+          vir_loc=vir_loc+gamma*rab*rab
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fx
+          fyy_loc(ia)=fyy_loc(ia)+fy
+          fzz_loc(ia)=fzz_loc(ia)+fz
+          
+          fxx_loc(ib)=fxx_loc(ib)-fx
+          fyy_loc(ib)=fyy_loc(ib)-fy
+          fzz_loc(ib)=fzz_loc(ib)-fz
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xdab(ii)*fx
+          strs_loc(2)=strs_loc(2)+xdab(ii)*fy
+          strs_loc(3)=strs_loc(3)+xdab(ii)*fz
+          strs_loc(4)=strs_loc(4)+ydab(ii)*fy
+          strs_loc(5)=strs_loc(5)+ydab(ii)*fz
+          strs_loc(6)=strs_loc(6)+zdab(ii)*fz
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+      
+      endif
+      
+c     check for undefined potentials
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,444)
+      
+c     sum contributions to potential and virial
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engbnd
+        buffer(2)=virbnd
+        buffer(3)=bnd_fre
+        buffer(4)=bnd_vir
+        call gdsum(buffer(1),4,buffer(5))        
+        engbnd=buffer(1)
+        virbnd=buffer(2)
+        bnd_fre=buffer(3)
+        bnd_vir=buffer(4)
+        
+        if(lsolva)then
+          
+          call gdsum(bnd_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(bnd_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      deallocate (xdab,ydab,zdab,stat=fail)
+      
+      return
+      end subroutine bndfrc
+      
+      end module bonds_module
diff -urN dl_class_1.9.orig/srcmod/comms.inc dl_class_1.9/srcmod/comms.inc
--- dl_class_1.9.orig/srcmod/comms.inc	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/comms.inc	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,42 @@
+c*********************************************************************
+c
+c     dl_poly include file for MPI, PVM and SHMEM
+c     copyright - daresbury laboratory
+c
+c*********************************************************************
+
+CMPIU define mpipriv mpipriv_
+
+      include "mpif.h"
+
+c     parameters for message tags
+
+      integer Xgcopy_tag, Merge1_tag
+      integer Dgsum_tag1, Dgsum_tag2
+      integer Igmax_tag1, Igmax_tag2
+      integer Igsum_tag1, Igsum_tag2
+      integer Shmove_tag, Merge_tag
+      integer Merge4_tag, Shell_tag
+      integer Gstate_tag1, Gstate_tag2
+      integer Passcon_tag, Msgtag
+
+c     MPI tagsizes
+
+      parameter(
+     $     Xgcopy_tag = 105,
+     $     Dgsum_tag1  = 6001,
+     $     Dgsum_tag2  = 9001,
+     $     Igsum_tag1  = 12001,
+     $     Igsum_tag2  = 15001,
+     $     Shmove_tag  = 18001,
+     $     Merge_tag   = 6001,
+     $     Merge1_tag  = 9001,
+     $     Merge4_tag  = 12001,
+     $     Gstate_tag1 = 15001,
+     $     Gstate_tag2 = 18001,
+     $     Shell_tag   = 21001,
+     $     Passcon_tag =  3001,
+     $     Igmax_tag1  = 24001,
+     $     Igmax_tag2  = 27001,
+     $     Msgtag      = 30000)
+
diff -urN dl_class_1.9.orig/srcmod/config_module.f dl_class_1.9/srcmod/config_module.f
--- dl_class_1.9.orig/srcmod/config_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/config_module.f	2015-11-09 14:15:45.054258793 +0100
@@ -0,0 +1,103 @@
+      module config_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation configuration data
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+      
+      implicit none
+
+      character*1 cfgname(80)
+      character*1 sysname(80)
+      real(8) cell(9),rcell(9),celprp(10)
+      real(8) eta(9),stress(9),stresl(9),strcns(9),strbod(9)
+      
+      character*8, allocatable :: atmnam(:)
+      real(8), allocatable :: xxx(:),yyy(:),zzz(:)
+      real(8), allocatable :: vxx(:),vyy(:),vzz(:)
+      real(8), allocatable :: fxx(:),fyy(:),fzz(:)
+      real(8), allocatable :: flx(:),fly(:),flz(:)
+      real(8), allocatable :: chge(:),weight(:),rmass(:)
+      integer, allocatable :: ltype(:),lstfrz(:)
+      integer, allocatable :: neulst(:),lstneu(:)
+      integer, allocatable :: lentry(:),list(:,:)
+      integer, allocatable :: lstout(:),link(:)
+      integer, allocatable :: lct(:),lst(:)
+
+      real(8), allocatable :: buffer(:)
+
+c PLUMED variables
+      logical, save :: lplumed
+c PLUMED variables
+
+      save atmnam,neulst,lstneu,cfgname,sysname
+      save cell,xxx,yyy,zzz,vxx,vyy,vzz,fxx,fyy,fzz
+      save buffer,weight,chge,ltype,lstfrz,flx,fly,flz
+      save lentry,list,lstout,link,lct,lst,celprp,rmass
+      save eta,stress,stresl,strcns,rcell
+      
+      contains
+      
+      subroutine alloc_config_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining simulation configuration arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      integer, parameter :: nnn=27
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (xxx(mxatms),stat=fail(1))
+      allocate (yyy(mxatms),stat=fail(2))
+      allocate (zzz(mxatms),stat=fail(3))
+      allocate (vxx(mxatms),stat=fail(4))
+      allocate (vyy(mxatms),stat=fail(5))
+      allocate (vzz(mxatms),stat=fail(6))
+      allocate (fxx(mxatms),stat=fail(7))
+      allocate (fyy(mxatms),stat=fail(8))
+      allocate (fzz(mxatms),stat=fail(9))
+      allocate (weight(mxatms),stat=fail(11))
+      allocate (chge(mxatms),stat=fail(12))
+      allocate (ltype(mxatms),stat=fail(13))
+      allocate (lstfrz(mxatms),stat=fail(14))
+      allocate (flx(mxatms),stat=fail(15))
+      allocate (fly(mxatms),stat=fail(16))
+      allocate (flz(mxatms),stat=fail(17))
+      allocate (atmnam(mxatms),stat=fail(18))
+      allocate (neulst(mxneut),stat=fail(19))
+      allocate (lstneu(mxatms),stat=fail(20))
+      allocate (lstout(mxatms),stat=fail(21))
+      allocate (lentry(msatms),stat=fail(22))
+      allocate (list(msatms,mxlist),stat=fail(23))
+      allocate (link(mxatms),stat=fail(24))
+      allocate (lct(mxcell),stat=fail(25))
+      allocate (lst(mxcell),stat=fail(26))
+      allocate (rmass(mxatms),stat=fail(27))
+      allocate (buffer(mxbuff),stat=fail(10))
+
+      do i=1,nnn
+        if(fail(i).gt.0)then
+          if(idnode.eq.0)write(nrite,'(10i5)')fail
+          call error(idnode,1000)
+        endif
+      enddo
+
+      end subroutine alloc_config_arrays
+
+      end module config_module
diff -urN dl_class_1.9.orig/srcmod/config_module.f.preplumed dl_class_1.9/srcmod/config_module.f.preplumed
--- dl_class_1.9.orig/srcmod/config_module.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/config_module.f.preplumed	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,99 @@
+      module config_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation configuration data
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+      
+      implicit none
+
+      character*1 cfgname(80)
+      character*1 sysname(80)
+      real(8) cell(9),rcell(9),celprp(10)
+      real(8) eta(9),stress(9),stresl(9),strcns(9),strbod(9)
+      
+      character*8, allocatable :: atmnam(:)
+      real(8), allocatable :: xxx(:),yyy(:),zzz(:)
+      real(8), allocatable :: vxx(:),vyy(:),vzz(:)
+      real(8), allocatable :: fxx(:),fyy(:),fzz(:)
+      real(8), allocatable :: flx(:),fly(:),flz(:)
+      real(8), allocatable :: chge(:),weight(:),rmass(:)
+      integer, allocatable :: ltype(:),lstfrz(:)
+      integer, allocatable :: neulst(:),lstneu(:)
+      integer, allocatable :: lentry(:),list(:,:)
+      integer, allocatable :: lstout(:),link(:)
+      integer, allocatable :: lct(:),lst(:)
+
+      real(8), allocatable :: buffer(:)
+
+      save atmnam,neulst,lstneu,cfgname,sysname
+      save cell,xxx,yyy,zzz,vxx,vyy,vzz,fxx,fyy,fzz
+      save buffer,weight,chge,ltype,lstfrz,flx,fly,flz
+      save lentry,list,lstout,link,lct,lst,celprp,rmass
+      save eta,stress,stresl,strcns,rcell
+      
+      contains
+      
+      subroutine alloc_config_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining simulation configuration arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      integer, parameter :: nnn=27
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (xxx(mxatms),stat=fail(1))
+      allocate (yyy(mxatms),stat=fail(2))
+      allocate (zzz(mxatms),stat=fail(3))
+      allocate (vxx(mxatms),stat=fail(4))
+      allocate (vyy(mxatms),stat=fail(5))
+      allocate (vzz(mxatms),stat=fail(6))
+      allocate (fxx(mxatms),stat=fail(7))
+      allocate (fyy(mxatms),stat=fail(8))
+      allocate (fzz(mxatms),stat=fail(9))
+      allocate (weight(mxatms),stat=fail(11))
+      allocate (chge(mxatms),stat=fail(12))
+      allocate (ltype(mxatms),stat=fail(13))
+      allocate (lstfrz(mxatms),stat=fail(14))
+      allocate (flx(mxatms),stat=fail(15))
+      allocate (fly(mxatms),stat=fail(16))
+      allocate (flz(mxatms),stat=fail(17))
+      allocate (atmnam(mxatms),stat=fail(18))
+      allocate (neulst(mxneut),stat=fail(19))
+      allocate (lstneu(mxatms),stat=fail(20))
+      allocate (lstout(mxatms),stat=fail(21))
+      allocate (lentry(msatms),stat=fail(22))
+      allocate (list(msatms,mxlist),stat=fail(23))
+      allocate (link(mxatms),stat=fail(24))
+      allocate (lct(mxcell),stat=fail(25))
+      allocate (lst(mxcell),stat=fail(26))
+      allocate (rmass(mxatms),stat=fail(27))
+      allocate (buffer(mxbuff),stat=fail(10))
+
+      do i=1,nnn
+        if(fail(i).gt.0)then
+          if(idnode.eq.0)write(nrite,'(10i5)')fail
+          call error(idnode,1000)
+        endif
+      enddo
+
+      end subroutine alloc_config_arrays
+
+      end module config_module
diff -urN dl_class_1.9.orig/srcmod/core_shell_module.f dl_class_1.9/srcmod/core_shell_module.f
--- dl_class_1.9.orig/srcmod/core_shell_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/core_shell_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,826 @@
+      module core_shell_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining core_shell arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use pair_module
+      use parse_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use site_module
+      use solvation_module
+
+      implicit none
+
+      real(8), allocatable :: prmshl(:,:)
+      integer, allocatable :: listshl(:,:)
+      integer, allocatable :: numshl(:),lstshl(:,:)
+
+      save prmshl,listshl,numshl,lstshl
+
+      contains
+      
+      subroutine alloc_csh_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining core_shell arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(4)
+
+      do i=1,4
+        fail(i)=0
+      enddo
+
+      allocate (prmshl(mxtshl,2),stat=fail(1))
+      allocate (numshl(mxtmls),stat=fail(2))
+      allocate (lstshl(mxtshl,2),stat=fail(3))
+      allocate (listshl(mxshl,3),stat=fail(4))
+
+      do i=1,4
+        if(fail(i).gt.0)call error(idnode,1100)
+      enddo
+
+      do i=1,mxtmls
+         numshl(i)=0
+      enddo
+
+      end subroutine alloc_csh_arrays
+
+      subroutine define_core_shell
+     x  (safe,idnode,itmols,nshels,nsite,keyshl,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining core-shell units
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      logical safe
+      integer idnode,itmols,nshels,nsite,ntmp,ishls
+      integer iatm1,iatm2,isite1,isite2,keyshl,kshl,idum
+      real(8) engunit
+
+      ntmp=intstr(record,lenrec,idum)
+      numshl(itmols)=numshl(itmols)+ntmp
+      kshl=intstr(record,lenrec,idum)
+      if(keyshl.eq.0)then
+        keyshl=kshl
+      elseif(kshl.ne.keyshl)then
+        call error(idnode,1960)
+      endif
+      if(idnode.eq.0) then
+        
+        write(nrite,
+     x    "(/,1x,'number of core-shell units',5x,i10)")
+     x    ntmp
+        if(keyshl.eq.1)then
+
+          write(nrite,
+     x       "(/,/,1x,'core-shell details:',/,/,21x,
+     x       5x,'index',5x,'index',6x,'parameter')")
+
+        else
+
+          write(nrite,
+     x       "(/,/,1x,'core-shell details:',/,/,21x,
+     x       6x,'core',5x,'shell',6x,'parameter')")
+        
+        endif
+
+      endif
+      
+      do ishls=1,numshl(itmols)
+        
+        nshels=nshels+1
+        if(nshels.gt.mxtshl) call error(idnode,57)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        lstshl(nshels,1)=iatm1
+        lstshl(nshels,2)=iatm2
+        prmshl(nshels,1)=dblstr(record,lenrec,idum)
+        prmshl(nshels,2)=dblstr(record,lenrec,idum)
+        if(idnode.eq.0) write(nrite,
+     x    "(21x,2i10,2f15.4)")
+     x    lstshl(nshels,1),lstshl(nshels,2),
+     x    prmshl(nshels,1),prmshl(nshels,2)
+
+c     test for frozen cores or shells
+        
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        if(lfzsit(isite1)*lfzsit(isite2).ne.0)
+     x    call error(idnode,49)
+        
+c     convert energy units to internal units
+        
+        prmshl(nshels,1)=prmshl(nshels,1)*engunit
+        prmshl(nshels,2)=prmshl(nshels,2)*engunit
+        
+      enddo
+
+      return
+      end subroutine define_core_shell
+
+      subroutine corshl(idnode,mxnode,ntshl,shlke)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating the internal kinetic
+c     energy of core-shell units in the shell polarisation model
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith july 1994
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer  idnode,mxnode,ntshl,ishl1,ishl2,i,j,k,m
+      real(8) shlke,ppp,ccc,sss
+      
+      shlke=0.d0
+
+c     block indices
+
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+
+c     loop over all specified core-shell pairs
+      
+      m=0
+
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+c     indices of atoms involved
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+
+c     calculate atom translational kinetic energy
+        
+        ppp=((weight(i)*vxx(i)+weight(j)*vxx(j))**2
+     x      +(weight(i)*vyy(i)+weight(j)*vyy(j))**2
+     x      +(weight(i)*vzz(i)+weight(j)*vzz(j))**2)
+     x      /(weight(i)+weight(j))
+
+c     calculate individual core and shell kinetic energies
+        
+        ccc=weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+        sss=weight(j)*(vxx(j)**2+vyy(j)**2+vzz(j)**2)
+        
+c     calculate core-shell internal kinetic energy
+        
+        shlke=shlke+0.5d0*(ccc+sss-ppp)
+        
+      enddo
+
+c     global average of core-shell internal kinetic energy
+        
+      if(mxnode.gt.1)then
+        buffer(1)=shlke
+        call gdsum(buffer(1),1,buffer(2))
+        shlke=buffer(1)
+      endif
+      
+      return
+      end subroutine corshl
+
+      subroutine put_shells_on_cores(idnode,mxnode,ntshl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for placing shells on top of cores in the
+c     shell model at the start of a simulation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith feb 2006
+c     
+c***********************************************************************
+            
+      implicit none
+      
+      integer, allocatable :: ltop(:)
+      integer  idnode,mxnode,ntshl,ishl1,ishl2,i,j,k,m,fail
+      
+c     allocate ltop array
+
+      allocate(ltop(ntshl),stat=fail)
+
+c     block indices
+      
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+      
+c     zero ltop array
+      
+      do i=1,ntshl
+        ltop(i)=0
+      enddo
+
+c     loop over all specified core-shell pairs
+      
+      m=0
+      
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+c     indices of atoms involved
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        
+c     set shell and core positions equal
+        
+        ltop(m)=j
+        xxx(j)=xxx(i)
+        yyy(j)=yyy(i)
+        zzz(j)=zzz(i)
+        
+      enddo
+      
+c     merge data on different processors
+      
+      if(mxnode.gt.1)call merge1
+     x  (idnode,mxnode,ntshl,ltop,xxx,yyy,zzz,buffer)
+      
+c     deallocate ltop array
+      
+      deallocate(ltop,stat=fail)
+      
+      return
+      end subroutine put_shells_on_cores
+
+      subroutine shlfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntshl,engshl,virshl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating shell model spring energy and 
+c     force terms in molecular dynamics.
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith        july 1994
+c
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lexcite,lselect
+      integer idnode,imcon,mxnode,ntshl,ishl1,ishl2,i,j,k,m,kk
+      real(8) engshl,virshl,rij2,omega,gamma,ffx,ffy,ffz,strs
+
+      dimension strs(6)
+      
+c     check adequate workspace is available
+
+      if(mxxdf.lt.mxshl)call error(idnode,423)
+
+c     block indices
+
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+
+c     initialise accumulators
+      
+      engshl=0.d0
+      virshl=0.d0
+      shl_fre=0.d0
+      shl_vir=0.d0
+      
+      do i=1,6
+        strs(i)=0.d0
+      enddo
+
+      if(lsolva)then
+        
+        lcomp(5)=.true.
+        shl_sol(:)=0.d0
+        if(lexcite)shl_exc(:)=0.d0
+        
+      endif
+      
+c     calculate core-shell separation vectors
+      
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+
+c     indices of core and shell
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        
+c     components of bond vector
+        
+        xdf(m)=xxx(i)-xxx(j)
+        ydf(m)=yyy(i)-yyy(j)
+        zdf(m)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,m,cell,xdf,ydf,zdf)
+
+c     loop over all specified core-shell units
+      
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+
+c     index of potential parameters
+
+        kk=listshl(m,1)
+
+c     core-shell separation
+        
+        rij2=xdf(m)**2+ydf(m)**2+zdf(m)**2
+        
+c     calculate scalar constant terms
+        
+        omega=(0.5d0*prmshl(kk,1)+0.25d0*prmshl(kk,2)*rij2)*rij2
+        gamma=prmshl(kk,1)+prmshl(kk,2)*rij2
+
+c     indices of core and shell
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+        
+          if((atm_fre(i).ne.1).and.(atm_fre(j).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(i)+atm_fre(i).eq.0)
+            
+            if(lsolva)then
+              shl_exc(atmolt(i))=shl_exc(atmolt(i))+omega
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(i).eq.1).or.(atm_fre(j).eq.1))then
+            
+c     set hamiltonian mixing parameter
+
+            shl_fre=shl_fre-omega
+            shl_vir=shl_vir-gamma*rij2
+            omega=lambda1*omega
+            gamma=lambda1*gamma
+            
+          elseif((atm_fre(i).eq.2).or.(atm_fre(j).eq.2))then
+            
+c     set hamiltonian mixing parameter
+
+            shl_fre=shl_fre+omega
+            shl_vir=shl_vir+gamma*rij2
+            omega=lambda2*omega
+            gamma=lambda2*gamma
+                        
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate spring energy and virial
+          
+          engshl=engshl+omega
+          virshl=virshl+gamma*rij2
+          
+          if(lsolva)then
+            shl_sol(atmolt(i))=shl_sol(atmolt(i))+omega
+          endif
+          
+c     calculate spring forces
+          
+          ffx=-gamma*xdf(m)
+          ffy=-gamma*ydf(m) 
+          ffz=-gamma*zdf(m)
+          
+          fxx(i)=fxx(i)+ffx
+          fyy(i)=fyy(i)+ffy
+          fzz(i)=fzz(i)+ffz
+          
+          fxx(j)=fxx(j)-ffx
+          fyy(j)=fyy(j)-ffy
+          fzz(j)=fzz(j)-ffz
+          
+c     calculate stress tensor
+          
+          strs(1)=strs(1)+xdf(m)*ffx
+          strs(2)=strs(2)+xdf(m)*ffy
+          strs(3)=strs(3)+xdf(m)*ffz
+          strs(4)=strs(4)+ydf(m)*ffy
+          strs(5)=strs(5)+ydf(m)*ffz
+          strs(6)=strs(6)+zdf(m)*ffz
+          
+        endif
+        
+      enddo
+        
+c     complete stress tensor
+
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+c     sum contributions to potential and virial
+      
+      if(mxnode.gt.1) then
+        
+        buffer(1)=engshl
+        buffer(2)=virshl
+        buffer(3)=shl_fre
+        buffer(4)=shl_vir
+        call gdsum(buffer(1),4,buffer(5))
+        engshl=buffer(1)
+        virshl=buffer(2)
+        shl_fre=buffer(3)
+        shl_vir=buffer(4)
+        
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(shl_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(shl_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine shlfrc
+
+      subroutine check_shells(idnode,itmols,nshels,ngrp)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to check no core-shell units are in 
+c     rigid bodies
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,itmols,nshels,ngrp,k1,ia,ib,kk
+      integer id,jj,ia1,jk,ib1
+
+      nshels=nshels-numshl(itmols)
+      do k1=1,numshl(itmols)
+
+        nshels=nshels+1
+        ia=lstshl(nshels,1)
+        ib=lstshl(nshels,2)
+
+        ngrp=ngrp-numgrp(itmols)
+
+        do kk=1,numgrp(itmols)
+          
+          ngrp=ngrp+1
+          id=listyp(ngrp)
+          
+          do jj=1,numgsit(id)-1
+            
+            ia1=lstgst(ngrp,jj)
+            if(ia1.eq.ia) then
+
+              do jk=jj,numgsit(id)
+                
+                ib1=lstgst(ngrp,jk)
+                if(ib1.eq.ib) then 
+                  
+                  if(idnode.eq.0)write(nrite,'(/,13x,a,2i10)')
+     x              'error: sites ',ia,ib
+                  call error(idnode,456)
+
+                endif
+
+              enddo
+
+            elseif(ia1.eq.ib) then
+
+              do jk=jj,numgsit(id)
+                
+                ib1=lstgst(ngrp,jk)
+                if(ib1.eq.ia) then 
+                  
+                  if(idnode.eq.0)write(nrite,'(/,13x,a,2i10)')
+     x              'error: sites ',ia,ib
+                  call error(idnode,456)
+
+                endif
+
+              enddo
+
+            endif
+
+          enddo
+        enddo
+      enddo
+
+      return
+      end subroutine check_shells
+
+      subroutine relax_shells
+     x   (relaxed,keyrlx,idnode,mxnode,natms,ntpmls,tstep,rlxtol)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for relaxing shells to zero force
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical relaxed,newjob
+      integer keyrlx,idnode,mxnode,natms,i,j,itmols,imols
+      integer iatm1,iatm2,fail,numopt,isite,ishls,jshls,lshls,ntpmls
+      integer nbuff
+      real(8) hnorm,grad0,grad1,grad2,stride,tstep,step
+      real(8) ggg,gam2,sgn,rlxtol
+
+      dimension fail(4)
+
+      integer, allocatable :: lstopt(:)
+      real(8), allocatable :: ggx(:),ggy(:),ggz(:)
+      real(8), allocatable :: hhx(:),hhy(:),hhz(:)
+      real(8), allocatable :: oxx(:),oyy(:),ozz(:)
+
+      save hnorm,grad0,grad1,grad2,stride,lstopt
+      save ggx,ggy,ggz,hhx,hhy,hhz,oxx,oyy,ozz,numopt,nbuff,sgn
+
+      data newjob/.true./,fail/0,0,0,0/
+
+c     define initial data
+
+      if(newjob)then
+
+        newjob=.false.
+        allocate(lstopt(mxatms),stat=fail(1))
+        allocate(ggx(mxatms),ggy(mxatms),ggz(mxatms),stat=fail(2))
+        allocate(hhx(mxatms),hhy(mxatms),hhz(mxatms),stat=fail(3))
+        allocate(oxx(mxatms),oyy(mxatms),ozz(mxatms),stat=fail(4))
+        do i=1,4
+          if(fail(i).ne.0)call error(idnode,1970)
+        enddo
+
+c     identify the shells
+
+        isite=0
+        ishls=0
+        jshls=0
+        do i=1,natms
+
+          lstopt(i)=0
+
+        enddo
+        do itmols=1,ntpmls
+
+          do imols=1,nummols(itmols)
+
+            do lshls=1,numshl(itmols)
+              
+              ishls=ishls+1
+              lstopt(lstshl(lshls+jshls,2)+isite)=1
+              
+            enddo
+            
+            isite=isite+numsit(itmols)
+
+          enddo
+
+          jshls=jshls+numshl(itmols)
+
+        enddo
+
+        numopt=ishls
+
+      endif
+
+c     load coordinates of shells
+
+      j=0
+      do i=1,natms
+
+        if(lstopt(i).gt.0)then
+
+          j=j+1
+          oxx(j)=xxx(i)
+          oyy(j)=yyy(i)
+          ozz(j)=zzz(i)
+          ggx(j)=fxx(i)
+          ggy(j)=fyy(i)
+          ggz(j)=fzz(i)
+
+        endif
+
+      enddo
+
+c     step length for relaxation
+
+      step=tstep**2
+
+c     define atoms for this nodes
+
+      iatm1=(idnode*numopt)/mxnode+1
+      iatm2=((idnode+1)*numopt)/mxnode
+
+      ggg=0.d0
+      do i=iatm1,iatm2
+        ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+      enddo
+      if(mxnode.gt.1)then
+        buffer(1)=ggg
+        call gdsum(buffer(1),1,buffer(2))
+        ggg=buffer(1)
+      endif
+      ggg=sqrt(ggg)
+
+c     check convergence
+
+      if(abs(ggg)/dble(numopt).lt.rlxtol)then
+
+        relaxed=.true.
+        return
+        
+      endif
+
+      if(keyrlx.eq.0) then
+
+c     set original search direction
+
+        hnorm=ggg
+        grad0=ggg
+        grad2=ggg
+        do i=iatm1,iatm2
+
+          hhx(i)=ggx(i)
+          hhy(i)=ggy(i)
+          hhz(i)=ggz(i)
+          oxx(i)=oxx(i)+step*hhx(i)
+          oyy(i)=oyy(i)+step*hhy(i)
+          ozz(i)=ozz(i)+step*hhz(i)
+
+        enddo
+        keyrlx=1
+        sgn=1.d0
+
+      elseif(keyrlx.eq.1)then
+
+c     line search along chosen direction
+
+        grad1=grad2
+        grad2=0.d0
+        do i=iatm1,iatm2
+          grad2=grad2+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+        enddo
+        if(mxnode.gt.1)then
+          buffer(1)=grad2
+          call gdsum(buffer(1),1,buffer(2))
+          grad2=buffer(1)
+        endif
+        grad2=sgn*grad2/hnorm
+
+c     linear extrapolation to minimum
+
+        stride=sgn*step
+        if(grad2.lt.0.d0)then
+
+          keyrlx=2
+          stride=sgn*step*grad2/(grad1-grad2)
+
+        endif
+        
+        do i=iatm1,iatm2
+          
+          oxx(i)=oxx(i)+stride*hhx(i)
+          oyy(i)=oyy(i)+stride*hhy(i)
+          ozz(i)=ozz(i)+stride*hhz(i)
+          
+        enddo
+
+      elseif(keyrlx.eq.2)then
+
+c     construct conjugate search vector
+
+        gam2=(ggg/grad0)**2
+        hnorm=0.d0
+        grad0=ggg
+        grad2=0.d0
+        do i=iatm1,iatm2
+          
+          hhx(i)=ggx(i)+gam2*hhx(i)
+          hhy(i)=ggy(i)+gam2*hhy(i)
+          hhz(i)=ggz(i)+gam2*hhz(i)
+          hnorm=hnorm+hhx(i)**2+hhy(i)**2+hhz(i)**2
+          grad2=grad2+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+          
+        enddo
+        if(mxnode.gt.1)then
+          
+          buffer(1)=hnorm
+          buffer(2)=grad2
+          call gdsum(buffer(1),2,buffer(3))
+          hnorm=buffer(1)
+          grad2=buffer(2)
+          
+        endif
+        hnorm=sqrt(hnorm)
+        grad2=grad2/hnorm
+        sgn=sign(1.d0,grad2)
+        grad2=sgn*grad2
+
+        do i=iatm1,iatm2
+          
+          oxx(i)=oxx(i)+sgn*step*hhx(i)
+          oyy(i)=oyy(i)+sgn*step*hhy(i)
+          ozz(i)=ozz(i)+sgn*step*hhz(i)
+          
+        enddo
+        
+        keyrlx=1
+
+      endif 
+      
+c     merge coordinate arrays
+      
+      if(mxnode.gt.1)then
+        
+        nbuff=6*(numopt+mxnode-1)/mxnode
+        call merge(idnode,mxnode,numopt,nbuff,oxx,oyy,ozz,buffer)
+        
+      endif
+
+c     unload coordinates of shells
+
+      j=0
+      do i=1,natms
+
+        if(lstopt(i).gt.0)then
+
+          j=j+1
+          xxx(i)=oxx(j)
+          yyy(i)=oyy(j)
+          zzz(i)=ozz(j)
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine relax_shells
+      
+      end module core_shell_module
diff -urN dl_class_1.9.orig/srcmod/coulomb_module.f dl_class_1.9/srcmod/coulomb_module.f
--- dl_class_1.9.orig/srcmod/coulomb_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/coulomb_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1542 @@
+      module coulomb_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining coulomb terms
+c     copyright - daresbury laboratory
+c     
+c     author    - w. smith    sep 2003
+c     adapted for solvation, free energy and excitation
+c               - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+
+      use config_module
+      use ewald_module
+      use metafreeze_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+
+      implicit none
+
+      contains
+      
+      subroutine coul0
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     1/r potential, no truncation or damping
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester february 1993
+c     stress tensor - t.forester may 1994
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,kkk
+      real(8) rcsq,chgea,rsq,chgprd,rrr,coul,fcoul,fi,fx,fy,fz
+      real(8) engcpe,vircpe,rcut,epsq,strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0     
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+              
+c     coulomb potential and force
+              
+              coul=chgprd/rrr
+              fcoul=coul/rsq
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+coul
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-coul
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-coul
+                
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+                
+c     calculate forces
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+c     metadynamics local parameters
+              
+              if(lmetadyn.and.(idrive.or.jdrive))then
+                
+c     local energy and virial
+          
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-coul
+                
+c     local forces          
+                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine coul0
+      
+      subroutine coul1
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a standard coulomb potential truncated at rcut
+c     and shifted to zero at rcut.
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith december 1992.
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c     stress tensor t.forester may 1994
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,kkk
+      real(8) engcpe,vircpe,rcut,epsq,rcsq,chgea,rsq
+      real(8) fi,chgprd,omega,egamma,fx,fy,fz,rrr
+      real(8) strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      chgea=chge(iatm)*r4pie0/epsq
+
+      if(abs(chgea).gt.1.d-10)then
+
+c     start of primary loop for forces evaluation
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10) then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+
+c     calculate potential energy and virial
+
+              omega=chgprd*(rcut-rrr)/(rrr*rcut)
+              egamma=chgprd/(rrr*rsq)
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+omega
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-omega
+                  cou_vir=cou_vir+egamma*rsq
+                  omega=lambda1*omega
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+omega
+                  cou_vir=cou_vir-egamma*rsq
+                  omega=lambda2*omega
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate potential energy and virial
+              
+                engcpe=engcpe+omega
+                vircpe=vircpe-egamma*rsq
+                
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+omega
+              
+c     calculate forces
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+
+                eng_loc=eng_loc+omega
+                vir_loc=vir_loc-egamma*rsq                
+              
+c     local forces
+          
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local  stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+
+            endif
+            
+          endif
+
+        enddo
+
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+
+      endif
+      
+      return
+      end subroutine coul1
+
+      subroutine coul2
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a distance dependant dielectric `constant'.
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester    april 1993
+c     stress tensor added - t.forester may 1994
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,kkk
+      real(8) engcpe,vircpe,rcut,epsq
+      real(8) fi,rcsq,chgea,chgprd,rsq,rrsq,coul,egamma,fx,fy,fz
+      real(8) strs(6),strs_loc(6)
+      
+      dimension fi(3)
+      
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+c     start of primary loop for forces evaluation
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+c     calculate potential energy and Virial
+              
+              rrsq=1.d0/rsq
+              coul=chgprd*rrsq
+              egamma=2.d0*coul*rrsq
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+2.d0*coul
+                  coul=lambda1*coul
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-2.d0*coul
+                  coul=lambda2*coul
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate potential energy and Virial
+                
+                engcpe=engcpe+coul
+                vircpe=vircpe-2.d0*coul
+                
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+              
+c     calculate forces
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+              
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+        
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-2.d0*coul
+              
+c     local forces
+          
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+
+            endif
+            
+          endif
+          
+        enddo
+        
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine coul2
+
+      subroutine coul3
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     reaction field  potential
+c     Ref: M Neumann, J Chem Phys, 82, 5633, (1985)
+c     adapted for fennell-gezelter coulombic model
+c     by w.smith june 2007
+c     Ref: CJ Fennell and JD Gezelter, J Chem Phys, 
+c     124, 234104, (2006)
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester february 1995
+c     stress tensor - t.forester   feb 1995
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,l,kkk
+      real(8) engcpe,vircpe,rcut,epsq,vcon,fcon,rdr,ppp,fi,rcsq
+      real(8) b0,rfld0,rfld1,rfld2,chgea,chgprd,rsq,coul,omega
+      real(8) fx,fy,fz,fcoul,rrr,vk0,vk1,vk2,gk0,gk1,gk2,t1,t2
+      real(8) strs(6),strs_loc(6)
+      dimension fi(3)
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+        
+c     reaction field terms
+      
+      b0=2.d0*(epsq-1.d0)/(2.d0*epsq+1.d0)
+      rfld0=b0/rcut**3
+      rfld1=(1.d0+b0*0.5d0)/rcut
+      rfld2=rfld0*0.5d0
+      
+c     screened coulomb terms
+        
+      vcon=erc(mxegrd-4)+rfld2*rcut**2-rfld1
+      fcon=rcut*fer(mxegrd-4)-rfld0*rcut
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      rdr=dble(mxegrd-4)/rcut
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+              l=int(rrr*rdr)
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate potential energy using 3-point interpolation
+              
+              vk0=erc(l)
+              vk1=erc(l+1)
+              vk2=erc(l+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              omega=t1+(t2-t1)*ppp*0.5d0-vcon+fcon*(rrr-rcut)
+              coul=chgprd*(omega+rfld2*rsq-rfld1)
+
+c     calculate forces using 3-point interpolation
+              
+              gk0=fer(l)
+              gk1=fer(l+1)
+              gk2=fer(l+2)
+              t1=gk0+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+              fcoul=chgprd*((t1+(t2-t1)*ppp*0.5d0)-fcon/rrr-rfld0)
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+fcoul*rsq
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-fcoul*rsq
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate coulombic energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-fcoul*rsq
+              
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+                
+c     calculate coulombic force
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+              
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-fcoul*rsq
+              
+c     local forces
+                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+
+          endif
+          
+        enddo
+        
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+
+      endif
+
+      endif
+      
+      return
+      end subroutine coul3
+
+      subroutine coul4
+     X  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a force shifted coulomb potential.
+c     adapted for fennell-gezelter coulombic model
+c     by w.smith may 2007
+c     Ref: CJ Fennell and JD Gezelter, J Chem Phys, 
+c     124, 234104, (2006)
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    -  t.forester october  1995
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,l,kkk
+      real(8) engcpe,vircpe,rcut,epsq,vcon,fcon,rdr,ppp,fi,rcsq,coul
+      real(8) strs9,chgea,chgprd,rsq,rrr,omega,fcoul,fx,fy,fz
+      real(8) vk0,vk1,vk2,gk0,gk1,gk2,t1,t2
+      real(8) strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+
+c     screened coulomb terms
+        
+      vcon=erc(mxegrd-4)
+      fcon=rcut*fer(mxegrd-4)
+      rdr=dble(mxegrd-4)/rcut
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      chgea=chge(iatm)*r4pie0/epsq
+
+      if(abs(chgea).gt.1.d-10)then
+
+c     start of primary loop for forces evaluation
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+              l=int(rrr*rdr)
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate potential energy using 3-point interpolation
+              
+              vk0=erc(l)
+              vk1=erc(l+1)
+              vk2=erc(l+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              omega=t1+(t2-t1)*ppp*0.5d0
+              coul=chgprd*(omega-vcon+fcon*(rrr-rcut))
+              
+c     calculate forces using 3-point interpolation
+              
+              gk0=fer(l)
+              gk1=fer(l+1)
+              gk2=fer(l+2)
+              t1=gk0+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+              fcoul=chgprd*((t1+(t2-t1)*ppp*0.5d0)-fcon/rrr)
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+fcoul*rsq
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-fcoul*rsq
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate the coulombic energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-fcoul*rsq
+                
+c     calculate solvation energy
+                
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+                
+c     calculate coulombic forces
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+          
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-fcoul*rsq
+                
+c     local forces
+                                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+                
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+
+        enddo
+
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+      
+      endif
+      
+      return
+      end subroutine coul4
+      
+      subroutine coul_nsq
+     x  (lsolva,lfree,lghost,idnode,mxnode,natms,imcon,epsq,rcut,
+     x  engcpe,vircpe)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic potential and forces
+c     for the all-pairs algorithm beyond the range of the normal cutoff
+c     i.e. the 'tertiary' forces.  frozen atom option included
+c     
+c     to be used with multiple_nsq
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith  august 2008
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip
+      integer natms,idnode,mxnode,imcon,ibig,i,last,mpm2
+      integer npm2,m,ii,j,idum,kkk
+      real(8) engcpe,epsq,rcut,vircpe,rsq,rrr,chgprd,fcoul,coul,rct2
+
+      lskip=(lfree.or.lghost)
+      
+c     zero energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     zero force arrays
+      
+      do i=1,natms
+        
+        flx(i)=0.d0
+        fly(i)=0.d0
+        flz(i)=0.d0
+        
+      enddo
+      
+c     zero stress tensor
+      
+      do i=1,9
+        stresl(i)=0.d0
+      enddo
+      
+c     zero solvation and excitation accumulators
+      
+      if(lsolva)then
+        
+        cou_sol_lng(:)=0.d0
+        
+        if(lghost)then
+          
+          cou_exc_lng(:)=0.d0
+          
+        endif
+        
+      endif
+      
+c     set control variables
+      
+      last=natms
+      mpm2=natms/2
+      npm2=(natms-1)/2
+      
+c     set cutoff radius
+      
+      rct2=rcut**2
+      
+c     outer loop over atoms
+      
+      do m=1,mpm2
+        
+        if(m.gt.npm2)last=mpm2
+        
+c     inner loop over atoms
+        
+        ii=0
+        do i=idnode+1,last,mxnode
+          
+c     calculate atom indices
+          
+          j=i+m
+          if(j.gt.natms)j=j-natms
+          
+          if(lskip)then
+            if(atm_fre(i)*atm_fre(j).eq.2)cycle
+          endif
+          
+c     calculate interatomic displacements
+          
+          ii=ii+1
+          xdf(ii)=xxx(i)-xxx(j)
+          ydf(ii)=yyy(i)-yyy(j)
+          zdf(ii)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     apply minimum image convention
+        
+        call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+
+c     calculate coulomb terms
+        
+        ii=0
+        
+        do i=idnode+1,last,mxnode
+          
+c     calculate atom indices
+          
+          j=i+m
+          if(j.gt.natms)j=j-natms
+          
+          if(lskip)then
+            if(atm_fre(i)*atm_fre(j).eq.2)cycle
+          endif
+          
+          ii=ii+1
+          if(lstfrz(i).eq.0.or.lstfrz(j).eq.0)then
+            
+c     reject frozen atoms and calculate interatomic distance
+            
+            rsq=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+            
+c     running check of neighbour list array capacity
+            
+            if(rsq.ge.rct2)then
+              
+              chgprd=chge(i)*chge(j)*r4pie0/epsq
+              rrr=sqrt(rsq)
+              
+c     calculate potential energy and force
+              
+              coul=chgprd/rrr
+              fcoul=coul/rsq
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(i),atmolt(j))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(i).ne.1).and.(atm_fre(j).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(i)+atm_fre(j).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc_lng(kkk)=cou_exc_lng(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(i).eq.1).or.(atm_fre(j).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+coul
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(i).eq.2).or.(atm_fre(j).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-coul
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-coul
+
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol_lng(kkk)=cou_sol_lng(kkk)+coul
+                
+c     calculate forces
+                
+                flx(i)=flx(i)+fcoul*xdf(ii)
+                fly(i)=fly(i)+fcoul*ydf(ii)
+                flz(i)=flz(i)+fcoul*zdf(ii)             
+                
+                flx(j)=flx(j)-fcoul*xdf(ii)
+                fly(j)=fly(j)-fcoul*ydf(ii)
+                flz(j)=flz(j)-fcoul*zdf(ii)  
+                
+c     stress tensor
+                
+                stresl(1)=stresl(1)+xdf(ii)*fcoul*xdf(ii)
+                stresl(2)=stresl(2)+xdf(ii)*fcoul*ydf(ii)
+                stresl(3)=stresl(3)+xdf(ii)*fcoul*zdf(ii)
+                stresl(5)=stresl(5)+ydf(ii)*fcoul*ydf(ii)
+                stresl(6)=stresl(6)+ydf(ii)*fcoul*zdf(ii)
+                stresl(9)=stresl(9)+zdf(ii)*fcoul*zdf(ii)
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+          
+      enddo
+
+c     complete stress tensor
+
+      stresl(4)=stresl(2)
+      stresl(7)=stresl(3)
+      stresl(8)=stresl(6)
+      
+      return
+      end subroutine coul_nsq
+      
+      end module coulomb_module
diff -urN dl_class_1.9.orig/srcmod/define_system_module.f dl_class_1.9/srcmod/define_system_module.f
--- dl_class_1.9.orig/srcmod/define_system_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/define_system_module.f	2015-11-09 14:15:45.054258793 +0100
@@ -0,0 +1,6004 @@
+      module define_system_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for utility subroutines and functions
+c     copyright - daresbury laboratory
+c     author    - w. smith     aug 2006
+c     adapted   - p.-a. cazade oct 2007, solvation, free energy
+c     and excitation
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use dihedral_module
+      use ensemble_tools_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use inversion_module
+      use metafreeze_module
+      use metal_module
+      use parse_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use vdw_module
+      
+      contains
+      
+      subroutine simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the simulation control 
+c     parameters
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith july 1992.
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c     modified
+c     author   - t.forester       may  1993
+c     amended  - t.forester       sept 1994 - dl_poly_1.1
+c     amended  - t.forester       nov  1994 - macro version
+c     amended  - w.smith          dec  1994 - t3d adaptation
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 hms
+      character*1 directive(lenrec)
+      logical lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,lpsoc
+      logical ltscal,lzeql,loptim,ltraj,lfcap,lgofr,lpgr,lpres,safe
+      logical lstep,ltemp,lcut,ldelr,lprim,lforc,lens,lvdw,lrvdw,kill
+      logical lnsq,lzden,lewald,lspme,lhke,loop,lzero,nolink,newgau
+      logical lminim,lminopt,ltad,lneb,lhit,lbpd,prechk,tadall,nebgo
+      integer idnode,intsta,istraj,keyens,keyfce,keyres,nstbpo,nsbzdn
+      integer keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,khit,nhit
+      integer nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,ntrack
+      integer idum,imcon,keyver,keytol,nblock,blkout,numgau
+      integer minstp,numneb,i,keybpd,mode,nsolva,isolva,nofic
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,rlxtol,opttol
+      real(8) eps,tol,fm,densvar,delrdf,delzdn,zlen,ehit,hyp_units
+      real(8) catchrad,sprneb,deltad,tlow,xhit,yhit,zhit,ebias,vmin
+      real(8) prntim
+      
+CSGIC      real(8) dummy
+CCRAY      real(8) dummy
+CFFTWc     FFTW instruction codes
+CFFTW
+CFFTW      integer FFTW_FORWARD,FFTW_BACKWARD
+CFFTW      parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)
+CFFTW
+CFFTW      integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
+CFFTW      parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)
+CFFTW
+CFFTW      integer FFTW_ESTIMATE,FFTW_MEASURE
+CFFTW      parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)
+CFFTW
+CFFTW      integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
+CFFTW      parameter (FFTW_OUT_OF_PLACE=0)
+CFFTW      parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)
+CFFTW
+CFFTW      integer FFTW_THREADSAFE
+CFFTW      parameter (FFTW_THREADSAFE=128)
+CFFTW
+      
+c     intitialize system variables: temperature,pressure,ensemble key
+c     force key, cutoff, primary cutoff, verlet shell width, relative
+c     dielectric constant,timestep,temperature scaling flag, 
+c     temp scaling interval
+      
+      mode=0
+      nhko=0
+      nlatt=0
+      nsteql=0
+      nstrun=0
+      minstp=0
+      keybpd=0
+      keyres=0
+      keyens=0
+      keyver=0
+      taut=0.d0
+      nstbts=0
+      nstbgr=0
+      nsbzdn=0
+      nstbpo=100
+      nstack=mxstak
+      intsta=0
+      nstraj=0
+      istraj=1
+      keytrj=0
+      numgau=1
+      alpha=0.d0
+      kmax1=0
+      kmax2=0
+      kmax3=0
+      nospl=min(8,mxspl)
+      isolva=1
+      nsolva=0
+      niswitch=0
+      nswitch=0
+      nofic=1000
+      
+      fmax=1000.d0
+      keyfce=0
+      multt=1
+      keytol=0
+      tstep=0.d0
+      temp=0.d0
+      press=0.d0
+      rcut=0.d0
+      rprim=0.d0
+      rvdw=0.d0
+      delr=0.d0
+      epsq=1.d0
+      rlxtol=1.d0
+      opttol=1.d0
+      tolnce=1.d-8
+      quattol=1.d-8
+      timjob=0.d0
+      timcls=0.d0
+      delrdf=0.d0
+      delzdn=0.d0
+      zlen=0.d0
+      ehit=0.d0
+      xhit=0.d0
+      yhit=0.d0
+      zhit=0.d0
+      vmin=0.d0
+      ebias=0.d0
+      catchrad=0.d0
+      pfree=0.d0
+      
+      lhit=.false.
+      lbpd=.false.
+      ltad=.false.
+      lneb=.false.
+      loop=.true.
+      lnfic=.false.
+      lpsoc=.false.
+      lzero=.false.
+      ltscal=.false.
+      lewald=.false.
+      lspme=.false.
+      lhke=.false.
+      lgofr=.false.
+      lpgr=.false.
+      lzeql=.true.
+      loptim=.false.
+      lminim=.false.
+      lminopt=.false.
+      ltraj=.false.
+      lfcap=.false.
+      ltemp=.false.
+      lstep=.false.
+      lcut=.false.
+      ldelr=.false.
+      lprim=.false.
+      lforc=.false.
+      lens=.false.
+      lvdw=.false.
+      lrvdw=.false.
+      lpres=.false.
+      kill=.false.
+      lnsq=.false.
+      lzden=.false.
+      nolink=.false.
+      newgau=.false.
+      prechk=.false.
+      tadall=.false.
+      lsolva=.false.
+      lfree=.false.
+      lfrmas=.false.
+      lexcite=.false.
+      lswitch=.false.
+      lghost=.false.
+      nebgo=.true.
+      seek='all     '
+      
+c     open the simulation input file
+      
+      if(idnode.eq.0)open(nread,file='CONTROL',status='old')
+      
+
+c PlUMED defaults
+      lplumed=.false.
+c PLUMED defaults
+c     read job title
+      
+      call getrec(safe,idnode,nread)
+      if(.not.safe)call abort_control_read(1,idnode,nread)
+      
+      call copystring(record,sysname,80)
+      if(idnode.eq.0)then 
+        
+        write(nrite,"(3(1x,120('*'),/),1x,15('*'),5x,80a1,5x,15('*'),/,
+     x    3(1x,120('*'),/),/,/,1x,'SIMULATION CONTROL PARAMETERS',/)")
+     x    sysname
+        
+      endif
+      
+c     read and process directives from CONTROL file
+      
+      do while(loop)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        
+c     convert to lowercase and strip out leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('redirect',directive,idum))then
+          
+c     ignore this option in this context
+
+c PLUMED modifications
+        elseif(findstring('plumed',directive,idum))then
+             if(findstring('on',directive,idum)) lplumed=.true.
+             if(findstring('off',directive,idum)) lplumed=.false.
+c PLUMED modifications
+          cycle
+          
+        elseif(findstring('steps',directive,idum))then
+          
+c     number of timesteps
+          
+          nstrun=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'selected number of timesteps',3x,i10)")nstrun
+          
+        elseif(findstring('integ',directive,idum))then
+          
+c     choice of integration algorithm
+          
+          if(findstring('leapfrog',directive,idum))then
+            
+            keyver=0
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'leapfrog verlet integration selected')")
+            
+          elseif(findstring('velocity',directive,idum))then
+            
+            keyver=1
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'velocity verlet integration selected')")
+            
+          endif
+          
+        elseif(findstring('no fic',directive,idum))then
+          
+c     cancel possible "flying ice cube" in Berendsen thermostats
+          
+          lnfic=.true.
+          nofic=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('shells',directive,idum).and.
+     x      findstring('on',directive,idum).and.
+     x      findstring('cores',directive,idum))then
+          
+c     put shells on cores at start - shell model only (else null)
+          
+          lpsoc=.true.
+          
+        elseif(findstring('densvar',directive,idum))then
+          
+c     specify allowed density variation
+          
+          densvar=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'allowed density variation   ',3x,1p,e12.4)")
+     x      densvar
+          
+        elseif(findstring('no link',directive,idum))then
+          
+c     switch off link cell option
+          
+          nolink=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'link cells option deactivated')")
+          
+        elseif(findstring('equil',directive,idum))then
+          
+c     number of equilibration timesteps
+          
+          nsteql=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration period        ',3x,i10)")nsteql
+          
+        elseif(findstring('restart',directive,idum))then
+          
+c     restart control
+          
+          if(findstring('noscale',directive,idum))then
+            
+            keyres=3
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'noscale restart requested')")
+            
+          elseif(findstring('scale',directive,idum))then
+            
+            keyres=2
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'scaled restart requested')")
+            
+          else
+            
+            keyres=1
+            if(idnode.eq.0)write(nrite,"(/,1x,'restart requested')")
+            
+          endif
+          
+        elseif(findstring('ensemble',directive,idum))then
+          
+c     ensemble selection
+          
+          call ensemble_selection(directive,lens,kill,idnode,keyens,
+     x      mode,taut,taup)
+          
+        elseif(findstring('regauss',directive,idum))then
+          
+c     re-initialise velocities option (regaussing)
+          
+          newgau=.true.
+          numgau=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'regaussing option activated',
+     x      /,1x,'regaussing interval set to  ',3x,i10)")
+     x      numgau
+          
+        elseif(findstring('scale',directive,idum))then
+          
+          nstbts=intstr(directive,lenrec,idum)
+          if(nstbts.gt.0)then
+            ltscal=.true.
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'temperature scaling on' 
+     x        /,1x,'temperature scaling interval',3x,i10)")
+     x        nstbts
+            
+          endif
+          
+        elseif(findstring('rdf',directive,idum))then
+          
+          if(findstring('print',directive,idum))then
+            
+            lpgr=.true.
+            lpgr=(lgofr.and.lpgr)
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'g(r) printing option on      ')")
+          
+          else
+            
+            lgofr=.true.
+            nstbgr=intstr(directive,lenrec,idum)
+            delrdf=dblstr(directive,lenrec,idum)
+            if(nstbgr.eq.0)nstbgr=10
+            if(delrdf.lt.1.d-8)delrdf=0.05d0
+            
+            if(idnode.eq.0)then
+              
+              write(nrite,
+     x          "(/,/,1x,'radial distribution functions on ',
+     x          /,1x,'g(r) collection interval    ',3x,i10)")nstbgr
+              write(nrite,
+     x          "(1x,'g(r) bin width              ',3x,1p,e12.4)")
+     x          delrdf
+              
+            endif
+            
+          endif
+          
+        elseif(findstring('zden',directive,idum))then
+          
+          lzden=.true.
+          nsbzdn=intstr(directive,lenrec,idum)
+          delzdn=dblstr(directive,lenrec,idum)
+          zlen=dblstr(directive,lenrec,idum)
+          if(nsbzdn.eq.0)nsbzdn=10
+          if(delzdn.lt.1.d-8)then
+            zlen=0.1d0*dble(mxzdn)
+            delzdn=0.1d0
+          elseif(zlen.lt.1.d-8)then
+            zlen=delzdn*dble(mxzdn)
+          endif
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,/,1x,'Z density profile requested',
+     x        /,1x,'zdensity collection interval',3x,i10)")nsbzdn
+            write(nrite,
+     x        "(1x,'zdensity bin width          ',3x,1p,e12.4)")
+     x        delzdn
+            write(nrite,
+     x        "(1x,'zdensity range              ',3x,1p,e12.4)")
+     x        zlen
+            
+          endif
+          
+        elseif(findstring('collect',directive,idum))then
+          
+          lzeql=.false.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration included in overall averages')")
+          
+        elseif(findstring('neb',directive,idum))then
+          
+c     activate nudged elastic band option
+          
+          call neb_option(directive,lneb,lminopt,idnode,
+     x      numneb,keytol,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('impact',directive,idum))then
+          
+c     activate the impact option
+          
+          if(lhit)call error(idnode,516)
+          lhit=.true.
+          khit=intstr(directive,lenrec,idum)
+          nhit=intstr(directive,lenrec,idum)
+          ehit=dblstr(directive,lenrec,idum)
+          xhit=dblstr(directive,lenrec,idum)
+          yhit=dblstr(directive,lenrec,idum)
+          zhit=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)then
+            
+            write(nrite,"(/,1x,'impact option selected')")
+            write(nrite,"(
+     x        /,1x,'identity of impact atom        ',i10,
+     x        /,1x,'time step of impact            ',i10,
+     x        /,1x,'impact recoil energy (keV)     ',1p,e12.4,
+     x        /,1x,'impact direction (x component) ',1p,e12.4,
+     x        /,1x,'impact direction (y component) ',1p,e12.4,
+     x        /,1x,'impact direction (z component) ',1p,e12.4)")
+     x        khit,nhit,ehit,xhit,yhit,zhit
+            
+          endif
+          
+c     convert impact energy from keV to internal units
+          
+          ehit=ehit*9648530.821d0
+          
+        elseif(findstring('bpd',directive,idum))then
+          
+c     activate the BPD option
+          
+          call bpd_option(directive,seek,lbpd,ltad,lminopt,prechk,
+     x      nebgo,keybpd,idnode,nblock,ntrack,keytol,ebias,vmin,
+     x      catchrad,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('tad',directive,idum))then
+          
+c     activate temperature accelerated dynamics option
+          
+          call tad_option(directive,ltad,lbpd,lminopt,prechk,tadall,
+     x      idnode,nblock,ntrack,blkout,keytol,catchrad,sprneb,tlow,
+     x      deltad,opttol,hyp_units)
+          
+        elseif(findstring('minim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          minstp=intstr(directive,lenrec,idum)
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          lminim=.true.
+          loptim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'minimisation programme requested')")
+            write(nrite,
+     x        "(1x,'structure minimisation interval ',
+     x        3x,i10)")minstp
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'structure minimisation tolerance',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('optim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          loptim=.true.
+          lminim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'structure optimisation requested')")
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'tolerance for structure optimisation ',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('zero',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          temp=1.d0
+          lzero=.true.
+          loptim=.false.
+          lminim=.false.
+          ltemp=.true.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'zero K optimisation requested')")
+            write(nrite,
+     x        "(' temperature reset to',1p,e12.4)")1.d0
+            
+          endif
+          
+        else if(findstring('solva',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        else if(findstring('decomp',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        elseif(findstring('metafreeze',directive,idum).or.
+     x      findstring('metadyn',directive,idum))then
+          
+c     activate metadynamics option - d. quigley
+          
+          call metadyn_option
+     x      (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x      ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x      locpe_scale,ref_W_aug,h_aug,wt_Dt)
+          
+        else if(findstring('free',directive,idum))then
+          
+          call free_energy_option(directive,lfree,lfrmas,idnode)
+          
+        else if(findstring('excite',directive,idum))then
+          
+          call excitation_option
+     x      (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+          
+        else if(findstring('switch',directive,idum))then
+          
+          call switching_option
+     x      (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+          
+        elseif(findstring('print',directive,idum))then
+          
+          nstbpo=intstr(directive,lenrec,idum)
+          nstbpo=max(nstbpo,1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data printing interval      ',3x,i10)")nstbpo
+          
+        elseif(findstring('stack',directive,idum))then
+          
+          nstack=intstr(directive,lenrec,idum)
+          
+c     reset stack limit if too large
+          
+          nstack=min(nstack,mxstak)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data stacking interval      ',3x,i10)")nstack
+          
+        elseif(findstring('stats',directive,idum))then
+          
+          intsta=intstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'statistics file interval    ',3x,i10)")intsta
+          
+        elseif(findstring('traj',directive,idum))then
+          
+          ltraj=.true.
+          nstraj=intstr(directive,lenrec,idum)
+          istraj=max(intstr(directive,lenrec,idum),1)
+          keytrj=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'trajectory file option on  ',
+     x      /,1x,'trajectory file start       ',3x,i10,
+     x      /,1x,'trajectory file interval    ',3x,i10
+     x      /,1x,'trajectory file info key    ',3x,i10)")
+     x      nstraj,istraj,keytrj
+          
+        elseif(findstring('ewald',directive,idum).or.
+     x      findstring('spme',directive,idum).or.
+     x      findstring('hke',directive,idum))then
+          
+c     read Ewald or HK-Ewald or SPM-Ewald sum parameters
+          
+          call ewald_selection(directive,lhke,lspme,lewald,lcut,
+     x      lforc,kill,idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,
+     x      kmax3,alpha,rcut)
+          
+        elseif(findstring('distan',directive,idum))then
+          
+          keyfce=4
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Distance dependent dielectric')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('coul',directive,idum))then
+          
+          keyfce=6
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Coulombic potential')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('shift',directive,idum))then
+          
+          keyfce=8
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Shifted Coulombic potential')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('reaction',directive,idum))then
+          
+          keyfce=10
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : reaction field')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('cap',directive,idum))then
+          
+          lfcap=.true.
+          fm=dblstr(directive,lenrec,idum)
+          if(fm.gt.0.d0)fmax=fm
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'force capping :',16x,1p,e12.4,' kT/A')")fmax
+          
+        elseif(findstring('no vdw',directive,idum))then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'short-range potential terms off')")
+          lvdw=.true.
+          
+        elseif(findstring('no elec',directive,idum))then
+          
+          keyfce=0
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'electrostatic potential terms off')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('mult',directive,idum))then
+          
+          multt=max(intstr(directive,lenrec,idum),1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'multiple timestep interval  ',3x,i10)")multt
+          
+        elseif(findstring('timestep',directive,idum))then
+          
+          lstep=.true.
+          tstep=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation timestep         ',3x,1p,e12.4)")tstep
+          
+        elseif(findstring('temp',directive,idum))then
+          
+          ltemp=.true.
+          temp=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation temperature      ',3x,1p,e12.4)")temp
+          
+        elseif(findstring('pres',directive,idum))then
+          
+          press=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation pressure (katm)  ',3x,1p,e12.4)")press
+          
+c     convert from katm to internal units of pressure
+          
+          press=press/prsunt
+          lpres=.true.
+          
+        elseif(findstring('prim',directive,idum))then
+          
+c     primary cutoff
+          
+          lprim=.true.
+          rprim=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'primary neighbour cut off   ',3x,1p,e12.4)")rprim
+          
+        elseif(findstring('rvdw',directive,idum))then
+          
+c     cutoff for short range potentials
+          
+          rvdw=dblstr(directive,lenrec,idum)
+          lrvdw=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off (vdw)    ',3x,1p,e12.4)")rvdw
+          
+        elseif(findstring('delr',directive,idum))then
+          
+c     Verlet shell width
+          
+          ldelr=.true.
+          delr=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'border width of Verlet shell',3x,1p,e12.4)")delr
+          
+        elseif(findstring('cut',directive,idum))then
+          
+c     cutoff
+          
+          lcut=.true.
+          rcut=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off          ',3x,1p,e12.4)")rcut
+          
+        elseif(findstring('eps',directive,idum))then
+          
+c     relative dielectric constant
+          
+          epsq=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'relative dielectric constant',3x,1p,e12.4)")epsq
+          
+        elseif(findstring('rlxtol',directive,idum))then
+          
+c     force tolerance for shell relaxation
+          
+          rlxtol=max(rlxtol,dblstr(directive,lenrec,idum))
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for shell relaxn. ',3x,1p,e12.4)")rlxtol
+          
+        elseif(findstring('shake',directive,idum))then
+          
+c     tolerance for shake
+          
+          tolnce=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for SHAKE         ',3x,1p,e12.4)")tolnce
+          
+        elseif(findstring('quaternion',directive,idum))then
+          
+c     tolerance for quaternion integration
+          
+          quattol=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for Quaternions   ',3x,1p,e12.4)")quattol
+          
+        elseif(findstring('job time',directive,idum))then
+          
+c     time for simulation (in seconds/minutes/hours/days or indefinite)
+          
+          if(findstring('indef',directive,idum))then
+             timjob=1.0d6*365.25d0*24.d0*60.d0*60.d0
+          else
+             timjob=dblstr(directive,lenrec,idum)
+             if(findstring('m',directive,idum))then
+               timjob=6.0d1*timjob
+             elseif(findstring('h',directive,idum))then
+               timjob=3.6d3*timjob
+             elseif(findstring('d',directive,idum))then
+               timjob=8.64d4*timjob
+             endif
+          endif
+          
+          call get_prntime(hms,timjob,prntim)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'user allocated job time (',a1,') ',3x,f8.4)")
+     x      hms,prntim
+          
+        elseif(findstring('close time',directive,idum))then
+          
+c     time for winding up a job (in seconds)
+          
+          timcls=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'job closure time        (s) ',3x,f8.3)")timcls
+          
+        elseif(findstring('all pairs',directive,idum))then
+          
+c     full minimum image - N^2 interactions each timestep
+          
+          lnsq=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'All-pairs requested for electrostatics')")
+          
+        elseif(findstring('nospl',directive,idum))then
+          
+c     set ewald_spme interpolation order
+          
+          nospl=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('finish',directive,idum))then
+          
+c     safe termination of reading CONTROL file
+          
+          loop=.false.
+          
+        else
+          
+c     unrecognised directive in control file
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      enddo
+      
+c     check on steps before temperature scaling
+      
+      if(nstbts.eq.0)nstbts=nstrun+1
+      
+c     conduct consistency checks on directives
+      
+      if(lminim)then
+        
+c     ensure final configuration follows minimisation
+        
+        if(minstp.eq.0)minstp=nstrun
+        nstrun=minstp*(nstrun/minstp)
+        
+      endif
+      
+c     check force activation options
+      
+      if(.not.lforc)then
+        
+c     check if any forces are in operation
+        
+        if(.not.lvdw)then
+          
+          kill=.true.
+          call error(idnode,-383)
+          
+        endif
+        
+      else
+        
+c     turn on short range forces
+        
+        if(lvdw)then
+          
+          if(keyfce.eq.0)then
+            
+            lcut=.true.
+            ldelr=.true.
+            
+          endif
+          
+        else
+          
+          keyfce=keyfce+1
+          
+        endif
+        
+      endif
+      
+c     if tad selected use only leap frog
+      
+      if(ltad.and.keyver.eq.1)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to leapfrog for TAD dynamics')")
+        keyver=0
+        
+      endif
+      
+c     error checking 
+      
+      if(lmetadyn.and.keyens.ne.3.and.keyens.ne.5.and.keyens.ne.7)then
+        
+        kill=.true.
+        call error(idnode,-2360)
+        
+      endif
+      
+      if(lsolva.or.lfree.or.lexcite.or.lswitch)then
+        
+        if(lspme)then
+          
+          kill=.true.
+          call error(idnode,-601)
+          
+        endif
+        
+        if(lhke)then
+          
+          kill=.true.
+          call error(idnode,-602)
+          
+        endif
+        
+      endif
+      
+      if(lghost.and.nstbgr.ne.isolva)then
+        
+        call warning(idnode,130,dble(isolva),0.d0,0.d0)
+        nstbgr=isolva
+        
+      endif
+      if(lfree.and.lgofr)then
+        
+        call warning(idnode,140,0.d0,0.d0,0.d0)
+        lgofr=.false.
+        lpgr=.false.
+        
+      endif
+      if(loptim)then
+        
+        temp=0.d0
+        
+      elseif(.not.ltemp)then
+        
+        kill=.true.
+        call error(idnode,-380)
+        
+      endif
+      
+      if(.not.lstep)then
+        
+        kill=.true.
+        call error(idnode,-381)
+        
+      endif
+      
+      if(.not.lcut)then
+        
+        kill=.true.
+        call error(idnode,-382)
+        
+      endif
+      
+c     check if van der Waals cutoff set
+      
+      if(.not.lrvdw.and.mod(keyfce,2).eq.1)then
+        
+        if(rcut.gt.0.d0)then
+          
+          rvdw=rcut
+          
+        else
+          
+          kill=.true.
+          call error(idnode,-402)
+          
+        endif      
+        
+      endif
+      
+      if(.not.ldelr)then
+        
+        kill=.true.
+        call error(idnode,-384)
+        
+      endif
+      
+      if(multt.gt.1)then
+        
+        if(.not.lprim)then
+          
+          kill=.true.
+          call error(idnode,-385)
+          
+        elseif(rprim.gt.rcut)then
+          
+          kill=.true.
+          call error(idnode,-386)
+          
+        endif
+        
+      endif
+      
+c     check settings in nvt ensemble
+      
+      if(keyens.ge.2.and.keyens.le.3)then
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        
+      endif
+      
+c     check settings in npt ensemble
+      
+      if(keyens.ge.4.and.keyens.le.7)then
+        
+        if(.not.lpres)then
+          
+          kill=.true.
+          call error(idnode,-387)
+          
+        endif
+        
+c     check barostat and thermostat rates non zero
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        if(taup.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-466)
+          
+        endif
+        
+      endif
+      
+c     check multiple timestep cutoffs are sensible
+      
+      if(multt.gt.1)then
+        if(rcut-rprim.lt.delr)then
+          
+          kill=.true.
+          call error(idnode,-398)
+          
+        endif
+      endif
+      
+c     check rcut > rvdw (for verlet list constructor)
+      
+      if(rcut.lt.rvdw)then 
+        
+        kill=.true.
+        call error(idnode,-400)
+        
+      endif
+      
+c     check spme is not being used with incorrect pbc
+      
+      if(lspme)then
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+          kill=.true.
+          call error(idnode,-513)
+          
+        endif
+        
+      endif
+      
+c     check on all-pairs calculation request
+      
+      if(lnsq)then
+        
+        if(multt.eq.1)then
+          
+          kill=.true.
+          call error(idnode,-422)
+          
+        endif
+        
+        if(keyfce/2.lt.2.or.keyfce/2.gt.3)then
+          
+          kill=.true.
+          call error(idnode,-424)
+          
+        endif
+        
+      endif
+      
+c     cancel rdf option if no vdw or coulombic forces
+      
+      if(lgofr.and.keyfce.eq.0)then
+        
+        lgofr=.false.
+        call warning(idnode,120,0.d0,0.d0,0.d0)
+        
+      endif
+      
+      if(kill)call abort_control_read(2,idnode,nread)
+      
+c     close CONTROL file
+      
+      if(idnode.eq.0)close(nread)
+      
+      return
+      end subroutine simdef
+      
+      subroutine sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the molecular specifications
+c     of the system to be simulated
+c     version for rigid unit data and neutral groups
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith may 1992.
+c     amended   - w.smith march 1994 
+c     amended   - t.forester april 1994
+c     amended   - w.smith  dec 1994 - getrec etc
+c     amended   - a.smondyrev may 2000 - keydih=5 for 
+c     ryckaert-bellemans potential in dihedrals
+c     amended   - a.smondyrev may 2000 - keydih=6 for 
+c     fluorinated ryckaert-bellemans potential in dihedrals
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lunits,lmols,lneut,ltable,lnsq,lshl,safe,lpmf
+      logical loop1,loop2,lsolva,lfree,lexcite,lswitch,lghost
+      
+      integer idnode,keyfce,keyfld,natms,ngrp,ntpatm,ntpmls
+      integer ntpvdw,ntptbp,ntpmet,ntpfbp,nshels,ksite
+      integer nsite,nconst,nangle,ndihed,ninver,nbonds
+      integer nteth,nspmf,itmols,i,idum,keyver
+      integer ntpter,keyshl,iatm,natmsr,ntghost
+      
+      real(8) dlrpot,engunit,rvdw,rcuttb,rctter,rcutfb
+      real(8) sumchg
+      
+      data loop1/.true./,loop2/.true./
+      
+c     initialise system counters: atomic site index, number of 
+c     constraints, bond angles, dihedrals, inversions, chemical bonds,
+c     unique atom types, total number of atoms,
+c     total number of rigid groups, number of tethered atoms,
+c     number of three body potentials
+      
+      nsite=0
+      nconst=0
+      nangle=0
+      ndihed=0
+      ninver=0
+      nbonds=0
+      ntpatm=0
+      natms=0
+      ngrp=0
+      nteth=0
+      ntptbp=0
+      ntpter=0
+      ntpmet=0
+      ntpvdw=0
+      ntpfbp=0
+      nshels=0
+      nspmf=0
+      keyfld=0
+      keyshl=0
+      ntghost=0
+      natmsr=0
+      ntcons_ghost=0
+      
+      lunits=.false.
+      lmols=.false.
+      lneut=.false.
+      ltable=.false.
+      lmetab=.false.
+      lshl=.false.
+      lpmf=.false.
+      engunit=1.d0
+      
+      numbonds(:)=0
+      numpmf(:)=0
+      numcon(:)=0
+      numdih(:)=0
+      numinv(:)=0
+      numgrp(:)=0
+      numsit(:)=0
+      numteth(:)=0
+      numshl(:)=0
+      npmf(:)=0
+      indpmf(:)=0
+      
+c     open force field data file
+      
+      if(idnode.eq.0)open (nfield,file='FIELD',status='old')
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,'SYSTEM SPECIFICATION')")
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)call abort_field_read(1,idnode,nfield)
+      
+c     read and process directives from field file
+      
+      do while(loop1)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)call abort_field_read(1,idnode,nfield)
+        
+c     convert to lowercase and remove leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('units',record,idum))then
+          
+c     identify energy unit for input/output
+          
+          lunits=.true.
+          call define_units(idnode,engunit)
+          
+c     neutral group control option
+          
+        elseif(findstring('neut',record,idum))then
+          
+          lneut=.true.
+          if(idnode.eq.0)
+     x      write(nrite,"(/,' neutral group implementation in use')")
+          
+c     can't have neutral groups with all-pairs
+          
+          if(lnsq)call error(idnode,426)
+          
+c     specify molecular species
+          
+        elseif(findstring('molecu',record,idum))then
+          
+c     number of molecular types
+          
+          if(lmols)call error(idnode,11)
+          lmols=.true.
+          ntpmls=intstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(/,/,1x,'number of molecular types',6x,i10)")
+     x      ntpmls
+          
+          if(ntpmls.gt.mxtmls)call error(idnode,10)
+          
+c     initialise total system charge
+          
+          sumchg=0.d0
+          
+c     read in molecular characteristics
+          
+          do itmols=1,ntpmls
+            
+            if(idnode.eq.0)
+     x        write(nrite,"(/,1x,'molecular species type',9x,i10)")
+     x        itmols
+            
+c     name of molecular species
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abort_field_read(1,idnode,nfield)
+            
+            call copystring(record,molnam(1,itmols),40)
+            if(idnode.eq.0)
+     x        write(nrite,"(/,/,1x,'name of species:',13x,40a1)")
+     x        (molnam(i,itmols),i=1,40)
+            
+c     stop processing if energy unit has not been specified
+            
+            if(.not.lunits)call error(idnode,6)
+            
+c     read molecular data
+            
+            loop2=.true.
+            
+            do while(loop2)
+              
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abort_field_read(1,idnode,nfield)
+              
+              call lowcase(record,lenrec)
+              call strip(record,lenrec)
+              
+              ksite=0
+              
+              if(findstring('nummol',record,idum))then
+                
+                nummols(itmols)=intstr(record,lenrec,idum)
+                if(idnode.eq.0)
+     x            write(nrite,"(/,1x,'number of molecules  ',
+     x            10x,i10)")nummols(itmols)
+                
+              elseif(findstring('atoms',record,idum))then
+                
+c     read in atomic details
+                
+                call define_atoms
+     x            (safe,lneut,idnode,itmols,nsite,ksite,ntpatm)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read core - shell spring parameters
+                
+              elseif(findstring('shell',record,idum))then
+                
+                lshl=.true.
+                call define_core_shell
+     x            (safe,idnode,itmols,nshels,nsite,keyshl,
+     x            engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read chemical bond force constant and bondlength
+                
+              elseif(findstring('bonds',record,idum))then
+                
+                call define_bonds
+     x            (safe,idnode,itmols,nbonds,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read bond atom indices and constraint bondlength
+                
+              elseif(findstring('constr',record,idum))then
+                
+                call define_constraints
+     x            (safe,lghost,idnode,itmols,nconst,nsite,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read pmf bond atom indices, weights and constraint bondlength
+                
+              elseif(findstring('pmf',record,idum))then
+                
+                if(lpmf)call error(idnode,484)
+                lpmf=.true.
+                call define_pmf(safe,idnode,itmols,nspmf)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular angular potential parameters
+                
+              elseif(findstring('angles',record,idum))then
+                
+                call define_angles
+     x            (safe,idnode,itmols,nangle,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular dihedral potential parameters
+                
+              elseif(findstring('dihedr',record,idum))then
+                
+                call define_dihedrals
+     x            (safe,idnode,itmols,ndihed,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular inversion potential parameters
+                
+              elseif(findstring('invers',record,idum))then
+                
+                call define_inversions
+     x            (safe,idnode,itmols,ninver,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read rigid body data
+                
+              elseif(findstring('rigid',record,idum))then
+                
+                call define_rigid_body
+     x            (safe,lghost,idnode,itmols,ngrp,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read tethered atom indices and tethering parameters
+                
+              elseif(findstring('teth',record,idum))then
+                
+                call define_tethers
+     x            (safe,idnode,itmols,nteth,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     finish of data for one molecular type
+                
+              elseif(findstring('finish',record,idum))then
+                
+c     running total of number of atoms in system
+                
+                natms=natms+nummols(itmols)*numsit(itmols)
+                if(natms.gt.mxatms)call error(idnode,75)
+                
+c     check core-shell units are not both in same rigid body unit
+                
+                call check_shells(idnode,itmols,nshels,ngrp)
+                
+                loop2=.false.
+                
+              else
+                
+c     error exit for unidentified directive in molecular data
+                
+                if(idnode.eq.0)write(nrite,'(12x,a)')record
+                call error(idnode,12)
+                
+              endif
+              
+            enddo
+            
+c     construction of atmolt table for solvation calculation
+            
+            if(lsolva)then
+              
+              do iatm=natmsr+1,natms
+                atmolt(iatm)=itmols
+              enddo
+              natmsr=natms
+              
+            endif
+            
+          enddo
+          
+c     construction of atm_fre table for free energy or excitation
+          
+          if(lfree.or.lexcite.or.lswitch)then
+            
+            atm_fre(:)=0
+            if((ind_fre(1).ne.0).and.(ind_fre(2).ne.0))then
+              
+              do iatm=ind_fre(1),ind_fre(2)
+                atm_fre(iatm)=1
+              enddo
+              
+            endif
+            
+            if((ind_fre(3).ne.0).and.(ind_fre(4).ne.0))then
+              
+              do iatm=ind_fre(3),ind_fre(4)
+                
+                atm_fre(iatm)=2
+                if(lghost)ntghost=ntghost+1
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+c     calculate system charge
+          
+          call check_syschg(idnode,ntpmls,sumchg)
+          
+c     read in the nonbonded potential energy parameters
+          
+        elseif(findstring('vdw',record,idum))then
+          
+          call define_van_der_waals
+     x      (safe,ltable,lunits,lmols,idnode,ntpvdw,
+     x      ntpatm,keyfce,dlrpot,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the metal potential energy parameters
+          
+        elseif(findstring('met',record,idum))then
+          
+          call define_metals
+     x      (safe,lunits,lmols,idnode,ntpmet,ntpatm,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the three body potential energy parameters
+          
+        elseif(findstring('tbp',record,idum))then
+          
+          call define_three_body
+     x      (safe,lunits,lmols,idnode,ntptbp,ntpatm,rcuttb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the tersoff potential energy parameters
+          
+        elseif(findstring('tersoff',record,idum))then
+          
+          call define_tersoff
+     x      (safe,lunits,lmols,idnode,ntpter,ntpatm,rctter,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the four body potential energy parameters
+          
+        elseif(findstring('fbp',record,idum))then
+          
+          call define_four_body
+     x      (safe,lunits,lmols,idnode,ntpfbp,ntpatm,
+     x      rcutfb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read external field data
+          
+        elseif(findstring('extern',record,idum))then
+          
+          call define_external_field
+     x      (safe,lunits,idnode,keyfld,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     normal end of FIELD file
+          
+        elseif(findstring('close',record,idum))then
+          
+          loop1=.false.
+          if(ntpvdw.eq.0.and.ntpmet.eq.0.and.
+     x      mod(keyfce,2).eq.1)call error(idnode,145)
+          
+c     error exit for unidentified directive
+          
+        else
+          
+          if(idnode.eq.0)write(nrite,'(100a)')record
+          call abort_field_read(2,idnode,nfield)
+          
+        endif
+        
+      enddo
+      
+c     close force field file
+      
+      if(idnode.eq.0)close (nfield)
+      
+      
+      if(lshl.and.idnode.eq.0)then
+        
+        if(keyshl.eq.1)write(nrite,
+     x    "(/,/,'adiabatic shell model in operation')")
+        
+        if(keyshl.eq.2)write(nrite,
+     x    "(/,/,'relaxed shell model in operation')")
+        
+      endif
+      
+      if(lshl.and.keyshl.eq.0)call error(idnode,1951)
+      
+c     if metadynamics and shell selected use only velocity verlet
+      
+      if(lshl.and.lmetadyn.and.keyver.eq.0)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to velocity verlet for metadynamics')")
+        keyver=1
+        
+      endif
+
+      return
+      end subroutine sysdef
+      
+      subroutine sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the configuration data file
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 atname(8)
+      
+      logical loglnk,safe,lneut,nolink,lfree,lfrmas
+      integer idnode,imcon,keyens,keyfce,keyres,levcfg,multt
+      integer ntpmls,i,indatm,indnam,indneu,k,ilx,ily,ilz
+      integer m,l,ncells,idum,mxnode
+      real(8) delr,rcut,volm,xcoord,ycoord,zcoord,totmas,xveloc
+      real(8) yveloc,zveloc,xforce,yforce,zforce,axx,rt3,xhi,yhi,zhi
+      real(8) width,dum1,dum2,test,com(3)
+      
+c     open the system input file
+      
+      if(idnode.eq.0)open (nconf,file='CONFIG')
+      
+c     read the CONFIG file header
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      call copystring(record,cfgname,80)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,1x,'configuration file name: ',/,/,10x,80a1)")cfgname
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      levcfg=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'selected image convention',6x,i10)")imcon
+      
+c     check config file contents for consistent data
+      
+      if((imcon.eq.0.or.imcon.eq.6).and.
+     x  (keyfce/2.eq.1.or.keyfce/2.eq.6))
+     x  call error(idnode,180)
+      
+      if(imcon.eq.0.and.(.not.lneut).and.(keyfce.gt.1)
+     x  .and.(multt.eq.1))call warning(idnode,30,0.d0,0.d0,0.d0)
+      
+      if(imcon.eq.0.and.(keyens.ge.4.and.keyens.le.7))
+     x  call error(idnode,390)
+      if(imcon.le.2.and.(keyens.eq.6.or.keyens.eq.7))imcon=3
+      if(keyres.gt.0.and.levcfg.lt.1)call error(idnode,85)
+      
+c     specify molecular dynamics simulation cell
+      
+      if(imcon.eq.0)then
+        
+c     if no periodic boundaries - set zero values for cell 
+c     vectors and cell volume
+        
+        cell(:)=0.d0
+        volm=0.d0
+        
+      else
+        
+c     read cell vectors
+        
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(1)=dblstr(record,lenrec,idum)
+        cell(2)=dblstr(record,lenrec,idum)
+        cell(3)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(4)=dblstr(record,lenrec,idum)
+        cell(5)=dblstr(record,lenrec,idum)
+        cell(6)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(7)=dblstr(record,lenrec,idum)
+        cell(8)=dblstr(record,lenrec,idum)
+        cell(9)=dblstr(record,lenrec,idum)
+        
+      endif
+      
+c     read the atomic coordinates
+      
+      indatm=0
+      indnam=0
+      indneu=0
+      safe=.true.
+      
+      do k=1,ntpmls
+        
+        do l=1,nummols(k)
+          
+          do m=1,numsit(k)
+            
+            indatm=indatm+1
+            
+            if(indatm.gt.mxatms)call error(idnode,45)
+            
+            xxx(indatm)=0.d0
+            yyy(indatm)=0.d0
+            zzz(indatm)=0.d0
+            vxx(indatm)=0.d0
+            vyy(indatm)=0.d0
+            vzz(indatm)=0.d0
+            fxx(indatm)=0.d0
+            fyy(indatm)=0.d0
+            fzz(indatm)=0.d0
+            
+            if(idnode.eq.0)then
+              
+              if(levcfg.eq.0)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                
+              elseif(levcfg.eq.1)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                
+              else
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                read(nconf,'(3f20.0)',end=100)xforce,yforce,zforce
+                
+              endif
+              
+c     strip blanks off atom name
+              
+              call strip(atname,8)
+              
+              if(sitnam(indnam+m).eq.mkwd8(atname))then
+                
+                xxx(indatm)=xcoord
+                yyy(indatm)=ycoord
+                zzz(indatm)=zcoord
+                
+                if(levcfg.gt.0)then
+                  
+                  vxx(indatm)=xveloc
+                  vyy(indatm)=yveloc
+                  vzz(indatm)=zveloc
+                  
+                endif
+                
+                if(levcfg.gt.1)then
+                  
+                  fxx(indatm)=xforce
+                  fyy(indatm)=yforce
+                  fzz(indatm)=zforce
+                  
+                endif
+                
+              else
+                
+                write(nrite,"(/,/,'unidentified atom label :',8a1,
+     x            ': atom number ',i5)")atname,indatm
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+            call gstate(safe)
+            if(.not.safe)call error(idnode,25)
+            
+            ltype(indatm)=ltpsit(indnam+m)
+            weight(indatm)=wgtsit(indnam+m)
+            chge(indatm)=chgsit(indnam+m)
+            atmnam(indatm)=sitnam(indnam+m)
+            lstfrz(indatm)=lfzsit(indnam+m)
+            if(lneut)lstneu(indatm)=nugrp(indnam+m)+indneu
+            
+c     reset atomic masses according to free energy definitions
+            
+            if(lfree)then
+
+              weight_sav(indatm)=weight(indatm)
+              
+              if(lfrmas)then
+                
+                if(indatm.ge.ind_fre(1).and.indatm.le.ind_fre(2))then
+                  weight(indatm)=lambda1*weight(indatm)
+                elseif(indatm.ge.ind_fre(3).and.indatm.le.ind_fre(4))
+     x              then
+                  weight(indatm)=lambda2*weight(indatm)
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          indneu=indneu+nugrp(indnam+numsit(k))
+          
+        enddo
+        
+        indnam=indnam+numsit(k)
+        
+      enddo
+      
+      if(mxnode.gt.1)then
+        
+        call gdsum(xxx,indatm,buffer)
+        call gdsum(yyy,indatm,buffer)
+        call gdsum(zzz,indatm,buffer)
+        
+        if(levcfg.gt.0)then
+          
+          call gdsum(vxx,indatm,buffer)
+          call gdsum(vyy,indatm,buffer)
+          call gdsum(vzz,indatm,buffer)
+          
+        endif
+        
+        if(levcfg.gt.1)then
+          
+          call gdsum(fxx,indatm,buffer)
+          call gdsum(fyy,indatm,buffer)
+          call gdsum(fzz,indatm,buffer)
+          
+        endif
+        
+      endif
+      
+c     check integrity of cell vectors : for cubic, TO and RD cases
+c     ie. cell(1)=cell(5)=cell(9) (or cell(9)/sqrt(2) for RD)
+      
+      if((imcon.eq.1).or.(imcon.eq.4).or.(imcon.eq.5))then
+        
+        axx=(abs(cell(1))+abs(cell(5)))/2.d0
+        test=1.d-8*axx
+        if(abs(cell(1)-axx).gt.test)call error(idnode,410)
+        if(abs(cell(5)-axx).gt.test)call error(idnode,410)
+        if(imcon.eq.5)then
+          if(abs(cell(9)-axx*sqrt(2.d0)).gt.test)
+     x      call error(idnode,410)
+        else
+          if(abs(cell(9)-axx).gt.test)call error(idnode,410)
+        endif
+        
+      endif
+      
+c     check integrity of hexagonal prism cell vectors
+      
+      if(imcon.eq.7)then
+        
+        rt3=sqrt(3.d0)
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,410)
+        
+      endif
+      
+c     check 2D PBC for imcon=6
+      
+      if(imcon.eq.6)then
+        
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     check for diagonal cell matrix if appropriate
+      
+      if((imcon.eq.1).or.(imcon.eq.2).or.(imcon.eq.4).or.
+     x  (imcon.eq.5).or.(imcon.eq.7))then
+        
+        if(abs(cell(2)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(4)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     put centre of mass at centre of coordinates if imcon=0
+      
+      if(imcon.eq.0)then
+        
+        totmas=getmass(indatm,idnode,mxnode)
+        call getcom(indatm,idnode,mxnode,totmas,com)
+        
+        do i=1,indatm
+          
+          xxx(i)=xxx(i)-com(1)
+          yyy(i)=yyy(i)-com(2)
+          zzz(i)=zzz(i)-com(3)
+          
+        enddo
+        
+      endif
+      
+c     set widths if unset - needed for check on link cells below
+      
+      if(imcon.eq.0.or.imcon.eq.6)then
+        
+        xhi=abs(xxx(1))
+        yhi=abs(yyy(1))
+        zhi=abs(zzz(1))
+        do i=2,indatm
+          
+          xhi=max(xhi,abs(xxx(i)))
+          yhi=max(yhi,abs(yyy(i)))
+          zhi=max(zhi,abs(zzz(i)))
+          
+        enddo
+        if(imcon.eq.0)then
+          
+          cell(1)=max(2.d0*xhi+rcut+delr,3.d0*(rcut+delr))
+          cell(5)=max(2.d0*yhi+rcut+delr,3.d0*(rcut+delr))
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+        if(imcon.eq.6.and.cell(9).lt.1.d-6)then
+          
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+      endif
+      
+c     calculate dimensional properties of simulation cell
+      
+      call dcell(cell,celprp)
+      
+      if(imcon.eq.0)then
+        
+        volm=0.d0
+        
+      elseif(imcon.eq.4)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.5)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.7)then
+        
+        volm=0.5d0*celprp(10)
+        
+      else
+        
+        volm=celprp(10)
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,/,1x,'simulation cell vectors'/,/)")
+        write(nrite,"(21x,3f12.6)")cell
+        
+        write(nrite,
+     x    "(/,/,1x,'system volume     ',2x,1p,g22.12)")volm
+        
+      endif
+      
+c     check value of cutoff and reset if necessary
+      
+      if(imcon.gt.0)then
+        
+        width=min(celprp(7),celprp(8),celprp(9))/2.d0
+        if(imcon.eq.4)width=sqrt(3.d0)*cell(1)/4.d0
+        if(imcon.eq.5)width=cell(1)/2.d0
+        if(imcon.eq.6)width=min(celprp(7),celprp(8))/2.d0
+        
+c     halt program if potential cutoff exceeds cell width
+        
+        if(rcut.gt.width)call error(idnode,95)
+        
+      endif
+      
+c     decide on whether to use link cells for verlet list constructor
+      
+      if(nolink)then
+        
+        loglnk=.false.
+        
+      else
+        
+        loglnk=.true.
+        
+        ilx=int(celprp(7)/(rcut+delr))
+        ily=int(celprp(8)/(rcut+delr))
+        ilz=int(celprp(9)/(rcut+delr))
+        if(ilx.lt.3.or.ily.lt.3.or.ilz.lt.3)loglnk=.false.
+        ncells=ilx*ily*ilz
+        if(lneut.and.ncells.le.36)loglnk=.false.
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)loglnk=.false.
+        if(loglnk.and.ncells.gt.mxcell)then
+          
+          dum1=dble(ncells)
+          dum2=dble(mxcell)
+          call warning(idnode,90,dum1,dum2,dum2)
+          loglnk=.false.
+          
+        endif
+        
+      endif
+      
+      if(loglnk.and.idnode.eq.0)
+     x  write(nrite,"(/,/,' link cell algorithm in use')")
+      
+      if(idnode.eq.0)close (nconf)
+      
+c     ensure PBC compliance of starting structure
+      
+      if(keyres.eq.0.and.imcon.gt.0)then
+        
+        call images(imcon,idnode,mxnode,indatm,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,indatm,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+      return
+      
+c     error exit for config file read
+      
+  100 call abort_config_read(2,idnode,nconf)
+      
+      end subroutine sysgen
+      
+      subroutine sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the REVIVE file data and 
+c     defining the initial thermodynamic and structural accumulators.
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzden,lfree,lsolva,lghost,lpsoc
+      integer idnode,imcon,keyfce,keyres,mxnode,natms,nstep,numacc
+      integer numrdf,ntpatm,nzden,i,j,k,ntpmet,ntshl,ntpvdw
+      real(8) chip,chit,conint,elrc,engunit,virlrc,rvdw,volm
+      real(8) dnumrd,dnstep,dnumac,dnzden,virtot,vircom,tboost
+      real(8) chit_shl
+      
+c     read or initialise accumulator arrays
+      
+      if(keyres.eq.1.and.idnode.eq.0)then
+        
+c     read accumulator data from dump file
+        
+        open(nrest,file='REVOLD',form='unformatted')
+        
+        read(nrest) dnstep,dnumac,dnumrd,chit,chip,conint,dnzden,
+     x    tboost,chit_shl
+        read(nrest) virtot,vircom,eta,strcns,strbod
+        read(nrest) stpval
+        read(nrest) sumval
+        read(nrest) ssqval
+        read(nrest) zumval
+        read(nrest) ravval
+        read(nrest) stkval
+        read(nrest) xx0,yy0,zz0
+        read(nrest) xxs,yys,zzs
+        
+        if(lgofr) read(nrest)rdf
+        if(lzden) read(nrest)zdens
+        
+        nstep=nint(dnstep)
+        numacc=nint(dnumac)
+        numrdf=nint(dnumrd)
+        nzden=nint(dnzden)
+        close (nrest)
+        
+      else
+         
+c     initialise step counters
+        
+        nstep=0
+        numacc=0
+        numrdf=0
+        nzden=0
+        
+c     initialise temperature and pressure coupling parameters
+c     and integral for conserved quantity
+        
+        chit=0.d0
+        chip=0.d0
+        conint=0.d0
+        virtot=0.d0
+        vircom=0.d0
+        chit_shl=0.d0
+        do i=1,9
+          
+          eta(i)=0.d0
+          strcns(i)=0.d0
+          strbod(i)=0.d0
+          
+        enddo
+        
+c     initialise accumulator arrays
+        
+        do i=1,mxnstk
+          
+          stpval(i)=0.d0
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          zumval(i)=0.d0
+          ravval(i)=0.d0
+          
+        enddo
+        
+        do i=1,mxatms
+          
+          xx0(i)=0.d0
+          yy0(i)=0.d0
+          zz0(i)=0.d0
+          xxs(i)=0.d0
+          yys(i)=0.d0
+          zzs(i)=0.d0
+          
+        enddo
+        
+        do j=1,mxnstk
+          
+          do i=1,mxstak
+            
+            stkval(i,j)=0.d0
+            
+          enddo
+          
+        enddo
+        
+        if(lgofr)then
+          
+          do i=1,mxxtyp
+            
+            do j=1,mxrdf
+              
+              rdf(j,i)=0.d0
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do i=1,mxatyp
+            
+            do j=1,mxzdn
+              zdens(j,i)=0.d0
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     put shells on cores at start
+      
+      if(lpsoc.and.keyres.ne.1.and.ntshl.gt.0)
+     x  call put_shells_on_cores(idnode,mxnode,ntshl)
+      
+c     if restart then broadcast stored variables via a global sum
+      
+      if(keyres.eq.1.and.mxnode.gt.1)then
+        
+        if(mxbuff.lt.natms.or.mxbuff.lt.mxnstk*mxstak)
+     x    call error(idnode,186)
+        
+        buffer(1)=chit
+        buffer(2)=chip
+        buffer(3)=conint
+        buffer(4)=dble(nstep)
+        buffer(5)=dble(numacc)
+        buffer(6)=dble(numrdf)
+        buffer(7)=dble(nzden)
+        buffer(8)=tboost
+        buffer(9)=virtot
+        buffer(10)=vircom
+        buffer(11)=chit_shl
+        call gdsum(buffer(1),11,buffer(12))
+        chit=buffer(1)
+        chip=buffer(2)
+        conint=buffer(3)
+        nstep=nint(buffer(4))
+        numacc=nint(buffer(5))
+        numrdf=nint(buffer(6))
+        nzden=nint(buffer(7))
+        tboost=buffer(8)
+        virtot=buffer(9)
+        vircom=buffer(10)
+        chit_shl=buffer(11)
+        
+        call gdsum(eta,9,buffer)
+        call gdsum(strcns,9,buffer)
+        call gdsum(strbod,9,buffer)
+        call gdsum(stpval,mxnstk,buffer)
+        call gdsum(sumval,mxnstk,buffer)
+        call gdsum(ssqval,mxnstk,buffer)
+        call gdsum(zumval,mxnstk,buffer)
+        call gdsum(ravval,mxnstk,buffer)    
+        call gdsum(stkval,mxnstk*mxstak,buffer)
+        call gdsum(xx0,natms,buffer)
+        call gdsum(yy0,natms,buffer)
+        call gdsum(zz0,natms,buffer)
+        call gdsum(xxs,natms,buffer)
+        call gdsum(yys,natms,buffer)
+        call gdsum(zzs,natms,buffer)
+        
+c     for rdf table - broadcast and normalise
+        
+        if(lgofr)then
+          
+          do k=1,mxxtyp
+            
+            call gdsum(rdf(1,k),mxrdf,buffer)
+            
+            do j=1,mxrdf
+              rdf(j,k)=rdf(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do k=1,mxatyp
+            
+            call gdsum(zdens(1,k),mxzdn,buffer)
+            
+            do j=1,mxzdn
+              zdens(j,k)=zdens(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     number densities and long-range corrections
+      
+      elrc=0.d0       
+      virlrc=0.d0
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=4.d0*pi/3.d0*rvdw**3
+      
+      call lrcorrect
+     x  (lsolva,lfree,lghost,idnode,imcon,keyfce,natms,
+     x  ntpatm,ntpvdw,elrc,engunit,virlrc,rvdw,volm)
+      
+      if(lmetab.or.ntpmet.eq.0)then
+        
+        elrcm(0)=0.d0
+        vlrcm(0)=0.d0
+        
+      else 
+        
+        call lrcmetal
+     x    (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+        
+      endif
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=0.d0
+      
+      return
+      end subroutine sysinit
+      
+      subroutine systemp
+     x  (idnode,imcon,keyres,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for setting the initial system temperature
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,imcon,keyres,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,ntshl,levcfg,i,io,k,keyshl
+      real(8) degfre,degshl,degrot,temp,tolnce,sigma,rsq
+      
+c     number of degrees of freedom 
+c     3 for com translation
+c     3 for angular momentum about origin (non-periodic systems only)
+      
+      degfre=dble(3*(ntfree-ntshl)-3-ntcons)+degfre
+      if(imcon.eq.0.or.imcon.eq.6)degfre=degfre-3.0d0
+      if(imcon.eq.0.or.imcon.eq.6)degrot=max(0.d0,degrot-3.0d0)
+      degshl=dble(3*ntshl)
+      
+c     lose one degree of freedom if temperature constrained
+c     gaussian constraints
+      
+c     if(keyens.eq.1)degfre=degfre-1.d0
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,' total degrees of freedom       ',f20.0,/,
+     x  ' rotational degrees of freedom  ',f20.0,/,
+     x  ' shell pseudo degrees of freedom',f20.0)")
+     x  degfre,degrot,degshl
+      if(degfre.lt.1.d0)call error(idnode,350)
+      
+c     define reciprocal masses of atoms
+      
+      do i=1,natms
+        
+        if(lstfrz(i).ne.0.or.weight(i).lt.1.d-6)then
+          
+          rmass(i)=0.d0
+          weight(i)=0.d0
+          
+        else
+          
+          rmass(i)=1.d0/weight(i)
+          
+        endif
+        
+      enddo
+      
+c     generate starting velocities
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+      if(keyres.eq.0)then
+        
+        call gauss(natms,vxx,vyy,vzz)
+        
+        do i=1,natms
+          
+          rsq=sqrt(rmass(i))
+          vxx(i)=vxx(i)*rsq
+          vyy(i)=vyy(i)*rsq
+          vzz(i)=vzz(i)*rsq
+          
+        enddo
+        
+        if(ntcons.gt.0)call quench
+     x    (imcon,idnode,mxnode,natms,nscons,tolnce)
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+        if(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      elseif(keyres.eq.1.or.keyres.eq.3)then 
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+      elseif(keyres.eq.2)then
+        
+        if(ngrp.gt.0)then 
+          
+          call vscaleg
+     x      (idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        elseif(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+c     print out sample of initial configuration 
+      
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'sample of starting configuration',/)")
+      
+      io=(natms+19)/20
+      if((levcfg.le.1).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',/,/)")
+      if((levcfg.eq.2).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',
+     x  7x,'fx(i)',7x,'fy(i)',7x,'fz(i)',/,/)")
+      
+      do i=1,natms,io
+        
+        if(levcfg.le.1)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),vxx(i),vyy(i),vzz(i)
+          
+        elseif(levcfg.eq.2)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),
+     x      vxx(i),vyy(i),vzz(i),fxx(i),fyy(i),fzz(i)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine systemp
+      
+      subroutine sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine  defining global bookkeeping
+c     arrays
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical loglnk,lneut,lshmov,lcnb,lsolva,lghost
+      integer idnode,imcon,mxnode,natms,nneut,ngrp,nscons,ntangl,i
+      integer ntbond,ntcons,ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,ii,isol,itmols,igsol,iggsol,natmsf,natmsl
+      integer ntghost,natms2
+      real(8) degfre,degrot
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     neutral group bookkeeping
+      
+      call neutbook(lneut,idnode,natms,nneut)
+      
+c     rigid body bookkeeping 
+      
+      call quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms2,ngrp,ntpmls,
+     x  ntfree,degfre,degrot)
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)+ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)+ngrp_ghost
+        
+      endif
+      
+c     construct list of excluded pair interactions
+      
+      if(lneut)then
+ 
+        call exclude(idnode,mxnode,natms,ntpmls)
+        call excludeneu(idnode,mxnode,nneut)
+        
+      elseif(.not.lneut)then
+        
+        call exclude(idnode,mxnode,natms,ntpmls)
+        
+        if(loglnk)then
+          
+          call exclude_link(idnode,mxnode,ntpmls)
+          
+        else
+          
+          call exclude_atom(idnode,mxnode,natms,ntpmls)
+          
+        endif
+        
+      endif
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)-ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)-ngrp_ghost
+        
+      endif
+      
+c     construct interaction lists for bonded forces
+      
+      call intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms2,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c     adaptations for solvation and excitation simulations
+      
+      if(lsolva.or.lghost)then
+                
+        natmsf=0
+        natmsl=0
+        natm_sol(:)=0
+        const_sol(:)=numcon(:)*nummols(:)
+        rigid_sol(:)=numgrp(:)*nummols(:)
+        
+        if(ngrp.eq.0)then
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstfrz(isol).eq.0)then
+                natm_sol(itmols)=natm_sol(itmols)+1
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+
+        else
+          
+          ii=1
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstgot_sol(ii).eq.isol)then
+                ii=ii+1
+              else
+                
+                if(lstfrz(isol).eq.0)then
+                  natm_sol(itmols)=natm_sol(itmols)+1
+                endif
+                
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+          
+          degrot_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          degfre_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          
+        endif
+        
+        if(lghost)natm_sol(mxtmls)=natm_sol(mxtmls)-ntghost
+        degfre_sol(:)=dble(3*(natm_sol(:))-const_sol(:))+degfre_sol(:)
+        
+      endif
+      
+      return
+      end subroutine sysbook
+      
+      subroutine define_units(idnode,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting energy units
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith august 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,idum,i
+      real(8) engunit
+      logical blank
+      
+      blank=.true.
+      
+      do i=6,lenrec
+        if(record(i).ne.' ')blank=.false.
+      enddo
+      
+      if(blank)then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal ',
+     x    'units ')")
+        
+      elseif(findstring('ev',record,idum))then
+        
+        engunit=9648.530821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=electron volts ')")
+        
+      elseif(findstring('kev',record,idum))then
+        
+        engunit=9648530.821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kilo electron volts ')")
+        
+      elseif(findstring('kcal',record,idum))then
+        
+        engunit=418.4d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kcal/ mol ')")
+        
+      elseif(findstring('kj',record,idum))then
+        
+        engunit=1.d2
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kjoule/mol ')")
+        
+      elseif(findstring('k',record,idum))then
+        
+        engunit=boltz
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kelvin ')")
+        
+      elseif(findstring('internal',record,idum))then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal',
+     x    ' units ')")
+        
+      else
+        
+        if(idnode.eq.0)write(nrite,'(a)')record
+        call error(idnode,5)
+        
+      endif
+      
+      return
+      end subroutine define_units
+      
+      subroutine quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree,
+     x  degfre,degrot)
+      
+c**************************************************************************
+c     
+c     dl_poly subroutine for setting up bookkeeping for rigid bodies
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c*************************************************************************
+      
+      implicit none
+      
+      logical safe,pass1,pass2,linear,lsolva
+      integer fail,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree
+      integer i,igrp,jgrp,kgrp,jr,jt,igrp1,igrp2,itmols,imols,lgrp,id
+      integer ii,jj,isite,k,kk,ill,i1,i2,i3,j,ngp,ifre1,ifre2,ig,ij
+      integer fngrp,lngrp
+      real(8) degfre,degrot,dnorm,a1,rtall,rotall,rot,aa,rotinr,bb,rot1
+      real(8) rsq,det,dettest,aq,bq,cq,dq,eq,fq,gq,hq,rnorm,tol,rotxyz
+      real(8) rotlim,rrr
+      
+      integer, allocatable :: ind(:,:),lstgot(:)
+      real(8), allocatable :: gaxs(:,:),rotmin(:),accum(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      dimension rot(9),aa(9),rotinr(3,3),bb(9),rot1(3,3),fail(5)
+      
+      data fail/0,0,0,0,0/
+      
+c     allocate working arrays
+      
+      allocate (ind(mxgrp,3),lstgot(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+      allocate (gaxs(mxungp,9),rotmin(mxungp),stat=fail(4))
+      allocate (accum(mxungp),stat=fail(5))
+      do i=1,5
+        if(fail(i).ne.0)call error(idnode,1790)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      igrp=0
+      jgrp=0
+      kgrp=0
+      isite=0
+      jr=0
+      jt=0
+      safe=.true.
+      degfre=0.d0
+      degrot=0.d0
+      
+c     rigid body identifier
+      
+      do i=1,natms
+        lstbod(i)=0
+      enddo
+      
+c     number of rigid groups in system
+      
+      ngrp=0
+      do itmols=1,ntpmls
+        ngrp=ngrp+nummols(itmols)*numgrp(itmols)
+      enddo
+      
+c     block indices for groups
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if(igrp.le.mxgrp)then
+              
+              lstgtp(igrp)=listyp(lgrp+kgrp)
+              id=listyp(lgrp+kgrp)
+              
+              if((igrp.ge.igrp1).and.(igrp.le.igrp2))then
+                
+                jgrp=jgrp+1
+                
+                do jj=1,numgsit(id)
+                  
+                  jr=jr+1
+                  jt=jt+1
+                  
+                  if(jr.le.mxatms.and.jt.le.mxatms)then
+                    
+                    lstrgd(jr)=lstgst(id,jj)+isite
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              else
+                
+                do jj=1,numgsit(id)
+                  
+                  jt=jt+1
+                  if(jt.le.mxatms)then
+                    
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            else
+              
+              safe=.false.
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,304)
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kgrp=kgrp+numgrp(itmols)
+        
+      enddo
+      
+      if(ngrp.eq.0)then
+        
+        j=0
+        do i=1,natms
+          
+          if(lstfrz(i).eq.0)then
+            
+            j=j+1
+            lstfre(j)=i
+            
+          endif
+          
+        enddo
+        ntfree=j
+        
+      else
+        
+c     centre of mass of groups
+c     assumes group dimensions are smaller than half box width
+        
+        do i=1,natms
+          lstme(i)=0
+        enddo
+        
+        do id=1,mxungp
+          gmass(id)=0.d0
+        enddo
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     working com is first site in group
+          
+          i=lstrgd(jr+1)
+          txx(ig)=xxx(i)
+          tyy(ig)=yyy(i)
+          tzz(ig)=zzz(i)
+          
+          id=lstgtp(ig)
+          safe=.false.
+          if(abs(gmass(id)).lt.1.d-10)safe=.true.
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            xxt(jr)=xxx(i)-txx(ig)
+            yyt(jr)=yyy(i)-tyy(ig)
+            zzt(jr)=zzz(i)-tzz(ig)
+            if(safe)gmass(id)=gmass(id)+weight(i)
+            
+          enddo
+          
+        enddo
+        
+c     minimum image from working com
+        
+        call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          gcmx(ig)=0.d0
+          gcmy(ig)=0.d0
+          gcmz(ig)=0.d0
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            gcmx(ig)=gcmx(ig)+weight(i)*xxt(jr)
+            gcmy(ig)=gcmy(ig)+weight(i)*yyt(jr)
+            gcmz(ig)=gcmz(ig)+weight(i)*zzt(jr)
+            
+          enddo
+          
+          gcmx(ig)=gcmx(ig)/gmass(id)+txx(ig)
+          gcmy(ig)=gcmy(ig)/gmass(id)+tyy(ig)
+          gcmz(ig)=gcmz(ig)/gmass(id)+tzz(ig)
+          
+        enddo
+        
+c     global communications
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+c     make sure all nodes have same copy of gmass
+        
+        if(mxnode.gt.1)then
+          
+          do id=1,mxungp
+            
+            accum(id)=0.d0
+            if(gmass(id).gt.0.d0)accum(id)=1.d0
+            
+          enddo
+          
+          call gdsum(gmass(1),mxungp,buffer(1))
+          call gdsum(accum(1),mxungp,buffer(1))
+          
+          do id=1,mxungp
+            
+            dnorm=max(1.d0,accum(id))
+            gmass(id)=gmass(id)/dnorm
+            
+          enddo
+          
+        endif
+        
+c     find a group of each type on this node to 
+c     find principal axis system of the group type
+        
+        do id=1,mxungp
+          
+          jr=0
+          ij=0
+          safe=.false.
+          
+          do while(.not.safe.and.ij.lt.ngrp)
+            
+            ij=ij+1
+            jr=jr+numgsit(lstgtp(ij))
+            if(lstgtp(ij).eq.id)safe=.true.
+            
+          enddo
+          
+          if(safe)then
+
+c     rotational inertia accumulator
+            
+            do k=1,3
+              
+              do kk=1,3
+                
+                rotinr(k,kk)=0.d0
+                
+              enddo
+              
+            enddo
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+              xxt(jr)=xxx(i)-gcmx(ij)
+              yyt(jr)=yyy(i)-gcmy(ij)
+              zzt(jr)=zzz(i)-gcmz(ij)
+              
+              call images(imcon,0,1,1,cell,xxt(jr),yyt(jr),zzt(jr))
+              
+              rotinr(1,1)=rotinr(1,1)+weight(i)*(xxt(jr)**2)
+              rotinr(1,2)=rotinr(1,2)+weight(i)*xxt(jr)*yyt(jr)
+              rotinr(1,3)=rotinr(1,3)+weight(i)*xxt(jr)*zzt(jr)
+              rotinr(2,2)=rotinr(2,2)+weight(i)*(yyt(jr)**2)
+              rotinr(2,3)=rotinr(2,3)+weight(i)*yyt(jr)*zzt(jr)
+              rotinr(3,3)=rotinr(3,3)+weight(i)*(zzt(jr)**2)
+              
+            enddo
+            
+            rotinr(2,1)=rotinr(1,2)
+            rotinr(3,1)=rotinr(1,3)
+            rotinr(3,2)=rotinr(2,3)
+            
+            call jacobi(rotinr,rot1,3)
+            
+            rot(1)=rot1(1,1)
+            rot(4)=rot1(2,1)
+            rot(7)=rot1(3,1)
+            rot(2)=rot1(1,2)
+            rot(5)=rot1(2,2)
+            rot(8)=rot1(3,2)
+            rot(3)=rot1(1,3)
+            rot(6)=rot1(2,3)
+            rot(9)=rot1(3,3)
+            
+c     rotational inertia accumulators
+            
+            rotinx(id,1)=0.d0
+            rotiny(id,1)=0.d0
+            rotinz(id,1)=0.d0
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+c     site positions in principal axis system
+              
+              gxx(id,j)=rot(1)*xxt(jr)+rot(4)*yyt(jr)+rot(7)*zzt(jr)
+              gyy(id,j)=rot(2)*xxt(jr)+rot(5)*yyt(jr)+rot(8)*zzt(jr)
+              gzz(id,j)=rot(3)*xxt(jr)+rot(6)*yyt(jr)+rot(9)*zzt(jr)
+              
+c     impose rounding 
+              
+              if(abs(gxx(id,j)).lt.1.d-8)gxx(id,j)=0.d0
+              if(abs(gyy(id,j)).lt.1.d-8)gyy(id,j)=0.d0
+              if(abs(gzz(id,j)).lt.1.d-8)gzz(id,j)=0.d0
+              
+c     rotational inertia tensor of group type
+              
+              rotinx(id,1)=rotinx(id,1)+
+     x          weight(i)*(gyy(id,j)**2+gzz(id,j)**2)
+              rotiny(id,1)=rotiny(id,1)+
+     x          weight(i)*(gzz(id,j)**2+gxx(id,j)**2)
+              rotinz(id,1)=rotinz(id,1)+
+     x          weight(i)*(gxx(id,j)**2+gyy(id,j)**2)
+              
+            enddo
+            
+c     set axis system such that: Ixx >=Iyy >=Izz
+            
+            rotxyz=max(rotinx(id,1),rotiny(id,1),rotinz(id,1))
+            
+            if(rotxyz.ge.rotinx(id,1))then
+              
+              if(rotiny(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gyy(id,j)
+                  gyy(id,j)=-a1
+                  
+                enddo
+                
+                rotiny(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              elseif(rotinz(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gzz(id,j)
+                  gzz(id,j)=-a1
+                  
+                enddo
+                
+                rotinz(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              endif
+              
+            endif
+            
+            if(rotinz(id,1).gt.rotiny(id,1))then
+              
+              do j=1,numgsit(id)
+                
+                a1=gyy(id,j)
+                gyy(id,j)=gzz(id,j)
+                gzz(id,j)=-a1
+                
+              enddo
+              
+              a1=rotinz(id,1)
+              rotinz(id,1)=rotiny(id,1)
+              rotiny(id,1)=a1
+              
+            endif
+            
+c     set up principal axis system in terms of site positions
+            
+c     test for (near) linear unit
+            
+            ill=0
+            rtall=(rotinx(id,1)+rotiny(id,1)+rotinz(id,1))
+            
+            if(rtall.gt.1.d-5)then
+              rotall=rtall
+            else
+              rotall=1.d0
+            endif
+            
+            rotmin(id)=min(rotinx(id,1),rotiny(id,1))
+            rotmin(id)=min(rotmin(id),rotinz(id,1))/rotall
+            
+            if((rotinx(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotiny(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotinz(id,1)/rotall).lt.1.d-5)ill=ill+1
+            
+            if(ill.ge.2)then
+
+c     point particle only
+              
+              ind(id,1)=1
+              ind(id,2)=1
+              ind(id,3)=1
+              
+              do jj=1,9
+                gaxs(id,jj)=0.d0
+              enddo
+              
+            elseif(ill.eq.1)then
+              
+c     linear molecule
+              
+              ind(id,1)=1
+              ind(id,2)=2
+              ind(id,3)=1
+              
+              aa(1)=gxx(id,1)-gxx(id,2)
+              aa(4)=gyy(id,1)-gyy(id,2)
+              aa(7)=gzz(id,1)-gzz(id,2)
+              rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+              
+              if(abs(aa(7)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(7)**2)
+                aa(2)=0.d0
+                aa(5)=aa(7)/rsq
+                aa(8)=-aa(4)/rsq
+                
+              elseif(abs(aa(4)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(1)**2)
+                aa(2)=-aa(4)/rsq
+                aa(5)=aa(1)/rsq
+                aa(8)=0.d0
+                
+              elseif(abs(aa(1)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(1)**2+aa(7)**2)
+                aa(2)=-aa(7)/rsq
+                aa(5)=0.d0
+                aa(8)=aa(1)/rsq
+                
+              endif
+              
+              aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+              aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+              aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+              
+              call invert(aa,bb,det)
+              
+              if(abs(det).lt.1.d-5)call error(idnode,306)
+              
+              do j=1,9
+                gaxs(id,j)=bb(j)
+              enddo
+              
+            elseif(ill.eq.0)then
+              
+c     non-linear molecule
+              
+              i1=1
+              i2=1
+              i3=1
+              pass1=.true.
+              dettest=1.d-1
+              
+              do while(pass1.and.i2.lt.numgsit(id)-1)
+                
+                i2=i2+1
+                i3=i2
+                pass2=.true.
+                
+                do while(pass2.and.i3.lt.numgsit(id))
+                  
+                  i3=i3+1
+                  
+                  aa(1)=gxx(id,i1)-gxx(id,i2)
+                  aa(4)=gyy(id,i1)-gyy(id,i2)
+                  aa(7)=gzz(id,i1)-gzz(id,i2)
+                  aa(2)=gxx(id,i1)-gxx(id,i3)
+                  aa(5)=gyy(id,i1)-gyy(id,i3)
+                  aa(8)=gzz(id,i1)-gzz(id,i3)
+                  aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+                  aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+                  aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+                  
+c     invert matrix
+                  
+                  call invert(aa,bb,det)
+                  
+c     check on size of determinant - to see if the 3 sites are
+c     too close to being linear for safety.
+                  
+                  pass2=abs(det).lt.dettest
+                  
+                enddo
+                
+                pass1=abs(det).lt.dettest
+                
+              enddo
+              
+              if(abs(det).lt.dettest)call error(idnode,306)
+              
+c     store indices used
+              
+              ind(id,1)=i1
+              ind(id,2)=i2
+              ind(id,3)=i3
+              
+c     store coefficients 
+              
+              do j=1,9
+                
+                gaxs(id,j)=bb(j)
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     check that rigid unit does not contain frozen atoms
+        
+        safe=.true.
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            if(lstfrz(i).ne.0)safe=.false.
+            
+          enddo
+          
+        enddo
+        
+c     global check on error condition
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,360)
+        
+c     quaternions for all rigid groups in system
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          i1=lstrgd(jr+ind(id,1))
+          i2=lstrgd(jr+ind(id,2))
+          i3=lstrgd(jr+ind(id,3))
+          
+          jr=jr+numgsit(id)
+          
+c     group basis vectors
+          
+          aa(1)=xxx(i1)-xxx(i2)
+          aa(4)=yyy(i1)-yyy(i2)
+          aa(7)=zzz(i1)-zzz(i2)
+          
+          call images(imcon,0,1,1,cell,aa(1),aa(4),aa(7))
+          
+          if(rotmin(id).gt.1.d-5)then
+            
+            aa(2)=xxx(i1)-xxx(i3)
+            aa(5)=yyy(i1)-yyy(i3)
+            aa(8)=zzz(i1)-zzz(i3)
+            
+          else
+            
+            rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+            
+            if(abs(aa(7)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(7)**2)
+              aa(2)=0.d0
+              aa(5)=aa(7)/rsq
+              aa(8)=-aa(4)/rsq
+              
+            elseif(abs(aa(4)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(1)**2)
+              aa(2)=-aa(4)/rsq
+              aa(5)=aa(1)/rsq
+              aa(8)=0.d0
+              
+            elseif(abs(aa(1)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(1)**2+aa(7)**2)
+              aa(2)=-aa(7)/rsq
+              aa(5)=0.d0
+              aa(8)=aa(1)/rsq
+              
+            endif
+            
+          endif
+          
+          call images(imcon,0,1,1,cell,aa(2),aa(5),aa(8))
+          
+          aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+          aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+          aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+          
+c     group rotational matrix
+          
+          rot(1)=gaxs(id,1)*aa(1)+gaxs(id,4)*aa(2)+gaxs(id,7)*aa(3)
+          rot(2)=gaxs(id,2)*aa(1)+gaxs(id,5)*aa(2)+gaxs(id,8)*aa(3)
+          rot(3)=gaxs(id,3)*aa(1)+gaxs(id,6)*aa(2)+gaxs(id,9)*aa(3)
+          rot(4)=gaxs(id,1)*aa(4)+gaxs(id,4)*aa(5)+gaxs(id,7)*aa(6)
+          rot(5)=gaxs(id,2)*aa(4)+gaxs(id,5)*aa(5)+gaxs(id,8)*aa(6)
+          rot(6)=gaxs(id,3)*aa(4)+gaxs(id,6)*aa(5)+gaxs(id,9)*aa(6)
+          rot(7)=gaxs(id,1)*aa(7)+gaxs(id,4)*aa(8)+gaxs(id,7)*aa(9)
+          rot(8)=gaxs(id,2)*aa(7)+gaxs(id,5)*aa(8)+gaxs(id,8)*aa(9)
+          rot(9)=gaxs(id,3)*aa(7)+gaxs(id,6)*aa(8)+gaxs(id,9)*aa(9)
+          
+c     determine quaternions from rotational matrix
+          
+          aq=rot(1)+rot(5)
+          bq=rot(2)-rot(4)
+          cq=rot(6)-rot(8)
+          dq=rot(2)+rot(4)
+          eq=rot(3)+rot(7)
+          fq=rot(6)+rot(8)
+          gq=rot(3)-rot(7)
+          hq=rot(1)-rot(5)
+          
+          q0(ig)=0.5d0*sqrt(aq+sqrt(aq*aq+bq*bq))
+          
+          if(q0(ig).gt.1.d-4)then
+            
+            q1(ig)=-0.25d0*cq/q0(ig)
+            q2(ig)=0.25d0*gq/q0(ig)
+            q3(ig)=-0.25d0*bq/q0(ig)
+            
+          else
+            
+            q1(ig)=0.5d0*sqrt(hq+sqrt(hq*hq+dq*dq))
+            
+            if(q1(ig).gt.1.d-4)then
+              
+              q2(ig)=0.25d0*dq/q1(ig)
+              q3(ig)=0.25d0*eq/q1(ig)
+              
+            else
+              
+              q2(ig)=0.5d0*sqrt(-hq+sqrt(hq*hq+dq*dq))
+              
+              if(q2(ig).gt.1.d-4)then
+                
+                q3(ig)=0.25d0*fq/q2(ig)
+                
+              else
+                
+                q3(ig)=1.d0
+                
+              endif
+              
+            endif
+            
+          endif
+          
+c     normalise quaternions
+          
+          rnorm=1.d0/sqrt(q0(ig)**2+q1(ig)**2+q2(ig)**2+q3(ig)**2)
+          q0(ig)=rnorm*q0(ig)
+          q1(ig)=rnorm*q1(ig)
+          q2(ig)=rnorm*q2(ig)
+          q3(ig)=rnorm*q3(ig)
+          
+        enddo
+        
+c     test for redundant degrees of freedom
+c     and ensure rotational inertias are non-zero
+        
+        degrot=0.d0
+        
+        if(lsolva)then
+          degrot_sol(:)=0.d0
+        endif
+        
+        do ig=1,ngrp
+          
+          id=lstgtp(ig)
+          rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))
+          
+          if(rotall*rotinx(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotiny(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotinz(id,1).lt.1d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+        enddo
+        
+c     rotational degrees of freedom and rigid body contribution
+c     to total degrees of freedom
+        
+        degrot=degrot+dble(ngrp)*3.d0
+        degfre=degrot+dble(ngrp)*3.d0
+        
+        if(lsolva)then
+          
+          fngrp=1
+          lngrp=0
+          
+          do itmols=1,mxtmls
+            
+            lngrp=lngrp+nummols(itmols)*numgrp(itmols)
+            
+            do ig=fngrp,lngrp
+              
+              id=lstgtp(ig)
+              rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x          rotinz(id,1))
+              
+              if(rotall*rotinx(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotiny(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotinz(id,1).lt.1d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+            enddo
+            
+            fngrp=lngrp+1
+            
+          enddo
+          
+        endif
+        
+c     summarise results
+        
+        if(idnode.eq.0)then
+          
+          if(gmass(1).gt.0.d0)then
+            
+            write(nrite,'(/,/,12x,a)')' summary of rigid body set up'
+            
+            do id=1,mxungp
+              
+              if(gmass(id).gt.0.d0)then
+                
+                write(nrite,'(/,a,i10)')' group of type ',id
+                write(nrite,'(12x,a,f20.10)')' total mass    ',
+     x            gmass(id)
+                write(nrite,'(12x,a,3f20.10)')' rot. inertia  ',
+     x            rotinx(id,1),rotiny(id,1),rotinz(id,1)
+                write(nrite,'(/,12x,a,3(8x,a7))')' site','a coord',
+     x            'b coord','c coord'
+                do j=1,numgsit(id)
+                  write(nrite,'(12x,i5,1p,3e15.5)')j,gxx(id,j),
+     x              gyy(id,j),gzz(id,j)
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+c     find number of unique groups 
+        
+        ngp=0
+        do ig=1,ngrp
+          ngp=max(ngp,lstgtp(ig))
+        enddo
+        
+c     calculate reciprocal of rotational inertias 
+        
+        do id=1,ngp
+          
+          rotlim=max(1.d-2,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))*1.d-5
+          
+          if(rotinx(id,1).lt.rotlim)then
+            rotinx(id,2)=0.d0
+          else
+            rotinx(id,2)=1.d0/rotinx(id,1)
+          endif
+          
+          if(rotiny(id,1).lt.rotlim)then
+            rotiny(id,2)=0.d0
+          else
+            rotiny(id,2)=1.d0/rotiny(id,1)
+          endif
+          
+          if(rotinz(id,1).lt.rotlim)then
+            rotinz(id,2)=0.d0
+          else
+            rotinz(id,2)=1.d0/rotinz(id,1)
+          endif
+          
+        enddo
+        
+c     Check of quaternion set up with atomic positions
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     group type
+          
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+          rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+          rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+          rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+          rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+          rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+          rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+          rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+          rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxt(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x        rot(3)*gzz(id,j)+gcmx(ig)
+            yyt(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x        rot(6)*gzz(id,j)+gcmy(ig)
+            zzt(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x        rot(9)*gzz(id,j)+gcmz(ig)
+            
+            
+            txx(jr)=xxx(i)-xxt(i)
+            tyy(jr)=yyy(i)-yyt(i)
+            tzz(jr)=zzz(i)-zzt(i)
+            
+          enddo
+          
+        enddo
+        
+        call images(imcon,0,1,jr,cell,txx,tyy,tzz)
+        
+c     set tolerance for testing quaternion setup.
+        
+        rsq=0.d0
+        tol=1.d-2
+        
+        do i=1,jr
+          
+          rrr=txx(i)**2+tyy(i)**2+tzz(i)**2
+          if(rrr.gt.tol)then 
+            
+            rsq=rrr
+            
+          endif
+          
+        enddo
+        
+c     exit if error in set up
+        
+        safe=.true.
+        if(rsq.gt.tol)safe=.false.
+        if(mxnode.gt.1)call gstate(safe)
+        
+        if(.not.safe)call  error(idnode,310)
+        
+c     sort lstgot into ascending order
+        
+        call shellsort(jt,lstgot)
+        
+c     check that no site is in more than 1 rigid group
+        
+        i=1
+        safe=.true.
+        do while(i.lt.jt)
+          
+          i=i+1
+          linear=.true.
+          do while(linear)
+            
+            linear=.false.
+            
+            if(lstgot(i).eq.lstgot(i-1))then
+              
+              linear=.true.
+              safe=.false.
+              jt=jt-1
+              
+              do j=i,jt
+                lstgot(j)=lstgot(j+1)
+              enddo
+              
+            endif
+            
+            if(i.ge.jt)linear=.false.
+            
+          enddo
+          
+        enddo
+        
+        if(.not.safe)call error(idnode,320)
+        
+c     list of 'free' sites
+        
+        ii=1
+        jj=0
+        do i=1,natms
+          
+          if(lstgot(ii).eq.i)then
+            
+            ii=ii+1
+            
+          else
+            
+            if(lstfrz(i).eq.0)then
+              jj=jj+1
+              lstfre(jj)=i
+            endif
+            
+          endif
+          
+        enddo
+        
+c     number of free sites
+        
+        ntfree=jj
+        
+c     list of atoms integrated on this node
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          jr=jr+numgsit(id)
+          
+        enddo
+        
+        do i=1,jr
+          lstme(i)=lstrgd(i)
+        enddo
+        
+c     block parameters for free atoms
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+        do i=ifre1,ifre2
+          
+          jr=jr+1
+          lstme(jr)=lstfre(i)
+          
+        enddo
+        
+c     exchange quaternion data with other nodes
+        
+        if(mxnode.gt.1)call merge4
+     x    (idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+      if(lsolva)lstgot_sol(:)=lstgot(:)
+      
+c     deallocate work arrays
+      
+      deallocate (ind,lstgot,stat=fail(1))
+      deallocate (txx,tyy,tzz,stat=fail(2))
+      deallocate (xxt,yyt,zzt,stat=fail(3))
+      deallocate (gaxs,rotmin,stat=fail(4))
+      deallocate (accum,stat=fail(5))
+      
+      return
+      end subroutine quatbook
+      
+      subroutine abort_field_read(kode,idnode,nfield)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting FIELD file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nfield
+      
+      if(idnode.eq.0)close (nfield)
+      
+      if(kode.eq.1)then
+        
+c     end of field file error exit
+        
+        call error(idnode,52)
+        
+      elseif(kode.eq.2)then
+        
+c     unrecognised directive in field file
+        
+        call error(idnode,4)
+        
+      endif
+      
+      return
+      end subroutine abort_field_read
+      
+      subroutine abort_control_read(kode,idnode,nread)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nread
+      
+      if(idnode.eq.0)close (nread)
+      
+      if(kode.eq.1)then
+        
+c     end of control file error exit
+        
+        call error(idnode,53)
+        
+      elseif(kode.eq.2)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,0)
+        
+      endif
+      
+      return
+      end subroutine abort_control_read
+      
+      subroutine abort_config_read(kode,idnode,nconf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nconf
+      
+      if(idnode.eq.0)close (nconf)
+      
+      if(kode.eq.1)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,54)
+        
+      elseif(kode.eq.2)then
+        
+c     end of config file error exit
+        
+        call error(idnode,55)
+        
+      endif
+      
+      return
+      end subroutine abort_config_read
+      
+      subroutine neutbook(lneut,idnode,natms,nneut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for neutral group bookkeeping
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lneut,safe
+      integer idnode,natms,nneut,i
+      
+      safe=.true.
+      
+c     neutral group bookkeeping: sites must be listed consecutively
+      
+      if(lneut)then
+        
+        if(lstneu(1).ne.1)call error(idnode,230)
+        
+        neulst(1)=1
+        nneut=1
+        
+        do i=2,natms
+          
+          safe=.false.
+          if(lstneu(i).eq.lstneu(i-1))safe=.true.
+          if(lstneu(i).eq.lstneu(i-1)+1)then
+            
+            safe=.true.
+            nneut=nneut+1
+            if(nneut.gt.mxneut)call error(idnode,220)
+            neulst(nneut)=i
+            
+          endif
+          
+          if(.not.safe)call error(idnode,230)
+          
+        enddo
+        
+        neulst(nneut+1)=natms+1
+        
+      endif
+      
+      return
+      
+      end subroutine neutbook
+      
+      subroutine intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the interaction lists
+c     for the entire simulated system
+c     
+c     parallel replicated dat version : block data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        july 1992
+c     amended   - t.forester      oct 1993
+c     amended   - t.forester      dec 1994 : block data
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov,safe1,lcnb,lchk,lfail
+      integer idnode,mxnode,natms,nscons,ntangl,ntbond,ntcons
+      integer ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf
+      integer ibonds,jbonds,kbonds,ipmf,jpmf,iangle,jangle,kangle
+      integer idihed,jdihed,kdihed,iinver,jinver,kinver,iteths
+      integer jteths,kteths,ishels,jshels,kshels,ntbon0,ntpmf0
+      integer ntang0,ntdih0,ntinv0,nttet0,ntshl0,ntcon0,idum
+      integer itmols,isite,iconst,jconst,kconst,ibnd1,ibnd2,ipmf1
+      integer ipmf2,iang1,iang2,idih1,idih2,iinv1,iinv2,itet1
+      integer itet2,ishl1,ishl2,imols,lbonds,lpmf,jj,nnn,langle
+      integer ldihed,linver,lteths,lshels,i,ii,ntmp,klo,khi,ngrp
+      integer klo0,ifail,iloop,nnode,nscons0,nscons1,icon,fail
+      integer kcons,id,jdnode,lconst,itry,iatom,jatom,j,nfail
+      real(8) tol
+      
+      integer, allocatable :: itest(:),index(:),kscons(:)
+      integer, allocatable :: msite(:),mconst(:),listin(:)
+      
+      dimension fail(4)
+      
+      data fail/0,0,0,0/
+      
+c     allocate work arrays
+      
+      allocate (itest(mxtmls),index(mxtmls),stat=fail(1))
+      allocate (msite(mxtmls),mconst(mxtmls),stat=fail(2))
+      allocate (listin(mxatms),stat=fail(3))
+      allocate (kscons(0:mxproc-1),stat=fail(4))
+      do i=1,4
+        if(fail(i).ne.0)call error(idnode,1800)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      ibonds=0
+      jbonds=0
+      kbonds=0
+      ipmf=0
+      jpmf=0
+      iangle=0
+      jangle=0
+      kangle=0
+      idihed=0
+      jdihed=0
+      kdihed=0
+      iinver=0
+      jinver=0
+      kinver=0
+      iteths=0
+      jteths=0
+      kteths=0
+      ishels=0
+      jshels=0
+      kshels=0
+      safe=.true.
+      safe1=.true.
+      
+c     find total number of bonds,pmf constraints,bond constraints,
+c     angles,dihedrals,inversions, tethers,core-shells, in system 
+c     - ignoring frozen atoms
+      
+      ntbon0=0
+      ntpmf0=0
+      ntcon0=0
+      ntang0=0
+      ntdih0=0
+      ntinv0=0
+      nttet0=0
+      ntshl0=0
+      nscons=0
+      ntcons=0
+      
+      do itmols=1,ntpmls
+        
+        ntbon0=ntbon0+nummols(itmols)*numbonds(itmols)
+        ntpmf0=ntpmf0+nummols(itmols)*numpmf(itmols)
+        ntcon0=ntcon0+nummols(itmols)*numcon(itmols)
+        ntang0=ntang0+nummols(itmols)*numang(itmols)
+        ntdih0=ntdih0+nummols(itmols)*numdih(itmols)
+        ntinv0=ntinv0+nummols(itmols)*numinv(itmols)
+        nttet0=nttet0+nummols(itmols)*numteth(itmols)
+        ntshl0=ntshl0+nummols(itmols)*numshl(itmols)
+        
+      enddo
+      
+      isite=0
+      iconst=0
+      jconst=0
+      kconst=0
+      
+c     first and last index of bonds, angles etc for this node
+      
+      ibnd1=(idnode*ntbon0)/mxnode+1
+      ibnd2=((idnode+1)*ntbon0)/mxnode
+      
+      ipmf1=(idnode*ntpmf0)/mxnode+1
+      ipmf2=((idnode+1)*ntpmf0)/mxnode
+      ntpmf=ntpmf0
+      nspmf=ipmf2+1-ipmf1
+      
+      iang1=(idnode*ntang0)/mxnode+1
+      iang2=((idnode+1)*ntang0)/mxnode
+      
+      idih1=(idnode*ntdih0)/mxnode+1
+      idih2=((idnode+1)*ntdih0)/mxnode
+      
+      iinv1=(idnode*ntinv0)/mxnode+1
+      iinv2=((idnode+1)*ntinv0)/mxnode
+      
+      itet1=(idnode*nttet0)/mxnode+1
+      itet2=((idnode+1)*nttet0)/mxnode
+      
+      ishl1=(idnode*ntshl0)/mxnode+1
+      ishl2=((idnode+1)*ntshl0)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct bond constraint list later
+c     construct chemical bond interaction list
+          
+          do lbonds=1,numbonds(itmols)
+            
+            ibonds=ibonds+1
+            
+            if(ibonds.ge.ibnd1.and.ibonds.le.ibnd2)then
+              
+              jbonds=jbonds+1
+              if(jbonds.le.mxbond)then
+                
+                listbnd(jbonds,1)=lbonds+kbonds
+                listbnd(jbonds,2)=lstbnd(lbonds+kbonds,1)
+     x            +isite
+                listbnd(jbonds,3)=lstbnd(lbonds+kbonds,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,31)
+          
+c     construct pmf site lists - no exclusions
+          
+          do lpmf=1,numpmf(itmols)
+            
+            ipmf=ipmf+1
+            
+            if(ipmf.ge.ipmf1.and.ipmf.le.ipmf2)then
+              
+              jpmf=jpmf+1
+              if(jpmf.le.mspmf)then
+                
+                nnn=npmf(1)+npmf(2)
+                if(nnn.le.mxspmf)then
+                  
+                  do jj=1,npmf(1)+npmf(2)
+                    lstpmf(jj,jpmf)=indpmf(jj)+isite
+                  enddo
+                  
+                else
+                  
+                  safe=.false.
+                  
+                endif
+                
+              else
+                
+                safe1=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe1)
+          if(.not.safe1)call error(idnode,458)
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,460)
+          
+c     construct valence angle interaction list
+          
+          do langle=1,numang(itmols)
+            
+            iangle=iangle+1
+            
+            if(iangle.ge.iang1.and.iangle.le.iang2)then
+              
+              jangle=jangle+1
+              if(jangle.le.mxangl)then
+                
+                listang(jangle,1)=langle+kangle
+                listang(jangle,2)=lstang(langle+kangle,1)
+     x            +isite
+                listang(jangle,3)=lstang(langle+kangle,2)
+     x            +isite
+                listang(jangle,4)=lstang(langle+kangle,3)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,51)
+          
+c     construct dihedral angle interaction list
+          
+          do ldihed=1,numdih(itmols)
+            
+            idihed=idihed+1
+            
+            if(idihed.ge.idih1.and.idihed.le.idih2)then
+              
+              jdihed=jdihed+1
+              if(jdihed.le.mxdihd)then
+                
+                listdih(jdihed,1)=ldihed+kdihed
+                listdih(jdihed,2)=lstdih(ldihed+kdihed,1)
+     x            +isite
+                listdih(jdihed,3)=lstdih(ldihed+kdihed,2)
+     x            +isite
+                listdih(jdihed,4)=lstdih(ldihed+kdihed,3)
+     x            +isite
+                listdih(jdihed,5)=lstdih(ldihed+kdihed,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,61)
+          
+c     construct inversion potential list
+          
+          do linver=1,numinv(itmols)
+            
+            iinver=iinver+1
+            
+            if(iinver.ge.iinv1.and.iinver.le.iinv2)then
+              
+              jinver=jinver+1
+              if(jinver.le.mxinv)then
+                
+                listinv(jinver,1)=linver+kinver
+                listinv(jinver,2)=lstinv(linver+kinver,1)
+     x            +isite
+                listinv(jinver,3)=lstinv(linver+kinver,2)
+     x            +isite
+                listinv(jinver,4)=lstinv(linver+kinver,3)
+     x            +isite
+                listinv(jinver,5)=lstinv(linver+kinver,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,77)
+          
+c     construct tethered atoms interaction list
+          
+          do lteths=1,numteth(itmols)
+            
+            iteths=iteths+1
+            
+            if(iteths.ge.itet1.and.iteths.le.itet2)then
+              
+              jteths=jteths+1
+              if(jteths.le.msteth)then
+                
+                listtet(jteths,1)=lteths+kteths
+                listtet(jteths,2)=lsttet(lteths+kteths)+isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,63)
+          
+c     construct core-shell list
+          
+          do lshels=1,numshl(itmols)
+            
+            ishels=ishels+1
+            
+            if(ishels.ge.ishl1.and.ishels.le.ishl2)then
+              
+              jshels=jshels+1
+              if(jshels.le.mxshl)then
+                
+                listshl(jshels,1)=lshels+kshels
+                listshl(jshels,2)=lstshl(lshels+kshels,1)
+     x            +isite
+                listshl(jshels,3)=lstshl(lshels+kshels,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,59)
+          
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kbonds=kbonds+numbonds(itmols)
+        kangle=kangle+numang(itmols)
+        kdihed=kdihed+numdih(itmols)
+        kinver=kinver+numinv(itmols)
+        kteths=kteths+numteth(itmols)
+        kshels=kshels+numshl(itmols)
+        
+      enddo
+      
+c     store array counters for bookkeeping
+      
+      ntbond=ibonds
+      ntangl=iangle
+      ntdihd=idihed
+      ntinv=iinver
+      ntteth=iteths
+      ntshl=ishels
+      
+c     pass bond constraint information to other nodes
+      
+      if(ntcon0.gt.0)then
+        
+        ntcons=ntcon0
+        
+c     find starting site no. and constraint no. for each molec. type
+        
+        msite(1)=0
+        mconst(1)=0
+        
+        do itmols=2,ntpmls
+          
+          msite(itmols)=msite(itmols-1)+numsit(itmols-1)*
+     x      nummols(itmols-1)
+          mconst(itmols)=mconst(itmols-1)+numcon(itmols-1)
+          
+        enddo
+        
+c     sort molecules into ascending order of number of constraints
+        
+        do i=1,ntpmls
+          
+          itest(i)=numcon(i)
+          index(i)=0
+          
+        enddo
+        
+        call shellsort(ntpmls,itest)
+        
+        do i=1,ntpmls
+          
+          lchk=.true.
+          do j=1,ntpmls
+            
+            if(itest(i).eq.numcon(j))then
+              
+              if(lchk)then 
+                index(i)=j
+                lchk=.false.
+                
+              endif
+              
+              do ii=1,i-1
+                if(index(ii).eq.j)lchk=.true.
+              enddo
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     load balance to within 10%
+        
+        tol=1.0d0+(0.10d0)/2.d0
+        kcons=(ntcons)/mxnode
+        ntmp=0
+        
+c     find smallest constrained molecule to allocate to a node
+        
+        do i=1,ntpmls
+          
+          if(ntmp.le.mxnode)then
+            
+            if(numcon(index(i)).gt.0)then
+              ntmp=ntmp+nummols(index(i))
+              klo=max(0,kcons-numcon(index(i))/2)
+              khi=klo+numcon(index(i))+1
+            endif
+            
+          endif
+          
+        enddo
+        
+c     reset hi/lo limits if molecules contain too many constraints
+        
+        if(dble(khi)/dble(max(1,klo)).gt.tol)then
+          klo=nint(dble(kcons)/tol)
+          khi=nint(dble(kcons)*tol)+1
+        endif
+        
+c     store lo value for later
+        
+        klo0=klo
+        
+c     begin assignment of constraints ----------------------------------
+        
+        ifail=-1
+        lfail=.true.
+        do while(lfail)
+          
+          ifail=ifail+1
+          
+          if(ifail.gt.ntpmls)then
+            call error(idnode,432)
+          endif
+          
+          iconst=0
+          jconst=0
+          kconst=0
+          lconst=0
+          
+c     zero running totals of constraints on each processor
+          
+          do id=0,mxnode-1
+            kscons(id)=0
+          enddo
+          
+          iloop=0
+          lfail=.false.
+          iconst=0
+          jconst=0
+          nnode=0
+          
+c     assign difficult molecules in blocks
+          
+          if(ifail.gt.0)then
+            
+            nfail=0
+            do i=1,ifail
+              
+              ii=ntpmls+1-i
+              nfail=nfail+nummols(index(ii))*numcon(index(ii))
+              
+            enddo
+            
+c     decide on number of processors to split over
+            
+            nnode=int(dble(nfail)/dble(max(kcons,1))+1.d0/tol)
+            nnode=max(2,nnode)
+            nnode=min(nnode,mxnode)
+            
+c     assign to processors 0..nnode-1
+            
+            do id=0,nnode-1
+              
+              nscons0=(id*nfail)/nnode+1
+              nscons1=((id+1)*nfail)/nnode
+              
+              kscons(id)=nscons1+1-nscons0
+              
+            enddo
+            
+c     this processors block
+            
+            nscons0=(idnode*nfail)/nnode+1
+            nscons1=((idnode+1)*nfail)/nnode
+            
+c     assign in blocks
+            
+            do itmols=ntpmls,ntpmls-ifail+1,-1
+              
+              ii=index(itmols)
+              icon=numcon(ii)
+              kconst=mconst(ii)
+              
+              do imols=1,nummols(ii)
+                
+                isite=msite(ii)+(imols-1)*numsit(ii)
+                
+c     construct bond constraint list
+                
+                do lconst=1,numcon(ii)
+                  
+                  iconst=iconst+1
+                  
+                  if(iconst.ge.nscons0.and.iconst.le.nscons1)then
+                    
+                    jconst=jconst+1
+                    
+                    if(jconst.le.mxcons)then
+                      
+                      listcon(jconst,1)=lconst+kconst
+                      iatom=lstcon(lconst+kconst,1)+isite
+                      jatom=lstcon(lconst+kconst,2)+isite
+                      
+                      listcon(jconst,2)=iatom
+                      listcon(jconst,3)=jatom
+                      
+                    else
+                      
+                      safe=.false.
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+c     assign non-problematic molecules
+          
+          jdnode=mod(nnode+1,mxnode)
+          
+          do itmols=ntpmls-ifail,1,-1
+            
+            ii=index(itmols)
+            icon=numcon(ii)
+            kconst=mconst(ii)
+            
+            do imols=1,nummols(ii)
+              
+              itry=0
+              lchk=.true.
+              do while(lchk)
+                
+                if(kscons(jdnode)+icon.le.klo)then
+                  
+                  if(jdnode.ne.idnode)then
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                  else
+                    
+c     construct bond constraint list
+                    
+                    isite=msite(ii)+(imols-1)*numsit(ii)
+                    do lconst=1,numcon(ii)
+                      
+                      jconst=jconst+1
+                      
+                      if(jconst.le.mxcons)then
+                        
+                        listcon(jconst,1)=lconst+kconst
+                        iatom=lstcon(lconst+kconst,1)+isite
+                        jatom=lstcon(lconst+kconst,2)+isite
+                        listcon(jconst,2)=iatom
+                        listcon(jconst,3)=jatom
+                        
+                      else
+                        
+                        safe=.false.
+                        
+                      endif
+                      
+                    enddo
+                    
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                    
+                  endif
+                  
+                else
+                  
+                  jdnode=mod(jdnode+1,mxnode)
+                  lchk=.true.
+                  itry=itry+1
+                  
+                endif
+                
+                if(lchk.and.itry.gt.mxnode)then
+                  
+                  klo=kcons
+                  kcons=khi
+                  itry=0
+                  iloop=iloop+1
+                  
+                endif
+                
+c     split molecule across nodes if have to
+                
+                if(iloop.gt.3)then
+                  lfail=.true.
+                  kcons=ntcons/mxnode
+                  klo=klo0
+                  lchk=.false.
+                endif
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+c     check no node has less than minimum number
+          
+          do id=0,mxnode-1
+            if(kscons(id).lt.klo0)then 
+              lfail=.true.
+            endif
+          enddo
+          
+        enddo
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)then
+          
+          if(mxnode.gt.1)call gimax(jconst,1,idum)
+          if(idnode.eq.0)write(nrite,'(a,i10,a,i10)')
+     x      'Number of constraints found ',jconst,'Max allowed ',mxcons
+          
+          call error(idnode,41)
+          
+        endif
+        
+        nscons=kscons(idnode)
+        
+        call passcon
+     x    (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x    listin,listot,listcon,lstfrz)
+        
+      endif
+      
+      if(npmf(1).gt.0)then
+        
+        call passpmf
+     x    (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+        
+      endif
+      
+c     pass rigid body data
+      
+      lcnb=.false.
+      if(ntcons.gt.0.and.ngrp.gt.0)then
+        
+        call passquat
+     x    (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x    listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,
+     x    numgsit)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(itest,index,msite,stat=fail(1))
+      deallocate(mconst,kscons,listin,stat=fail(2))
+      
+      return
+      end subroutine intlist
+      
+      subroutine ensemble_selection
+     x  (directive,lens,kill,idnode,keyens,mode,taut,taup)
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ensemble and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical kill,lens
+      integer keyens,idnode,idum,mode
+      real(8) taut,taup
+      
+      if(findstring('nve',directive,idum))then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'microcanonical ensemble')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      elseif(findstring('nvt',directive,idum))then
+        
+        if(findstring('evans',directive,idum))then
+          
+          keyens=1
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Evans Gaussian temperature constraints',
+     x      ' in use')")
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('ber',directive,idum))then
+          
+          keyens=2
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen thermostat',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=3
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('npt',directive,idum))then
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=4
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen isotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=5
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover  (Melchionna) isotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('nst',directive,idum))then
+        
+        mode=0
+        if(findstring('block',directive,idum))mode=1
+        if(findstring('surf',directive,idum))mode=2
+        if(findstring('slab',directive,idum))mode=3
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=6
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen anisotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=7
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover (Melchionna) anisotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+        if(idnode.eq.0)then
+          
+          if(mode.eq.0)then
+            write(nrite,"(/,1x,'NST mode 0 X<>Y<>Z')")
+          elseif(mode.eq.1)then
+            write(nrite,
+     x        "(/,1x,'NST mode 1 X<>Y<>Z (rectangular block)')")
+          elseif(mode.eq.2)then
+            write(nrite,
+     x        "(/,1x,'NST mode 2 X=Y<>Z (liquid surface)')")
+          elseif(mode.eq.3)then
+            write(nrite,
+     x        "(/,1x,'NST mode 3 X<>Y<>Z (solid slab)')")
+          endif
+          
+        endif
+        
+      elseif(findstring('pmf',directive,idum))then
+        
+        keyens=8
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'potential of mean force calculation (NVE)')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      else
+        
+        call error(idnode,-436)
+        kill=.true.
+        
+      endif
+      
+      return
+      end subroutine ensemble_selection
+      
+      subroutine neb_option
+     x  (directive,lneb,lminopt,idnode,numneb,keytol,sprneb,
+     x  opttol,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for NEB option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical lneb,lminopt,endneb,safe
+      integer numneb,idnode,keytol,i,idum
+      real(8) sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      lminopt=.true.
+      lneb=.true.
+      endneb=.false.
+      numneb=intstr(directive,lenrec,idum)
+      if(numneb.eq.0)numneb=1
+      numneb=min(maxneb,numneb)
+      
+      hyp_units=1.d0
+      do while(.not.endneb)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endneb',directive,idum))then
+          endneb=.true.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('basin_1',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_1(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('basin_2',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_2(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,1x,'NEB calculation controls')")
+        write(nrite,"(/,1x,'identity of basin 1            ',
+     x    10i10)")(bsn_1(i),i=1,numneb)
+        write(nrite,"(1x,'identity of basin 2            ',
+     x    10i10)")(bsn_2(i),i=1,numneb)
+        write(nrite,
+     x    "(1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    sprneb,opttol,cunit
+        
+        call print_optim(keytol)
+        
+      endif
+      
+c     units conversion
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine  neb_option
+      
+      subroutine bpd_option
+     x  (directive,seek,lbpd,ltad,lminopt,prechk,nebgo,keybpd,idnode,
+     x  nblock,ntrack,keytol,ebias,vmin,catchrad,sprneb,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for bias potential
+c     dynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 directive(lenrec)
+      logical lbpd,ltad,lminopt,prechk,endbpd,safe,nebgo
+      integer keybpd,idnode,nblock,ntrack,keytol,idum
+      real(8) ebias,vmin,catchrad,sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(ltad)call error(idnode,2355)
+      lminopt=.true.
+      lbpd=.true.
+      endbpd=.false.
+      cunit=" dl_poly"
+      if(idnode.eq.0)
+     x  write(nrite,"(/,1x,'bias potential dynamics controls')")
+      
+      if(findstring('dyn',directive,idum))then
+        
+        keybpd=1
+        hyp_units=energy_unit()
+        ebias=dblstr(directive,lenrec,idum)
+        vmin=dblstr(directive,lenrec,idum)
+        call getword(cunit,directive,8,lenrec)
+        if(idnode.eq.0)write(nrite,"(
+     x    1x,'dynamics option selected       ',
+     x    /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x    /,1x,'bias potential V_min   (kelvin)',f10.4
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    ebias,vmin,cunit
+        
+      elseif(findstring('path',directive,idum))then
+        
+        keybpd=2
+        nebgo=.true.
+        hyp_units=1.d0
+        do while(.not.endbpd)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+            cycle
+          elseif(findstring('endbpd',directive,idum))then
+            endbpd=.true.
+          elseif(findstring('pre',directive,idum))then
+            prechk=.true.
+            if(findstring('false',directive,idum))prechk=.false.
+          elseif(findstring('noneb',directive,idum))then
+            nebgo=.false.
+          elseif(findstring('target',directive,idum))then
+            call getword(seek,directive,8,lenrec)
+            call getword(seek,directive,8,lenrec)
+          elseif(findstring('units',directive,idum))then
+            hyp_units=energy_unit()
+            call getword(cunit,directive,8,lenrec)
+            call getword(cunit,directive,8,lenrec)
+          elseif(findstring('ebias',directive,idum))then
+            ebias=dblstr(directive,lenrec,idum)
+          elseif(findstring('vmin',directive,idum))then
+            vmin=dblstr(directive,lenrec,idum)
+          elseif(findstring('num_block',directive,idum))then
+            nblock=intstr(directive,lenrec,idum)
+          elseif(findstring('num_track',directive,idum))then
+            ntrack=intstr(directive,lenrec,idum)
+          elseif(findstring('catch_radius',directive,idum))then
+            catchrad=dblstr(directive,lenrec,idum)
+          elseif(findstring('neb_spring',directive,idum))then
+            sprneb=dblstr(directive,lenrec,idum)
+          elseif(findstring('forc',directive,idum))then
+            keytol=0
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('ener',directive,idum))then
+            keytol=1
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('posi',directive,idum))then
+            keytol=2
+            opttol=dblstr(directive,lenrec,idum)
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,"(
+     x      1x,'dynamics with path analysis selected',
+     x      /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x      /,1x,'bias potential V_min   (kelvin)',f10.4,
+     x      /,1x,'steps per time block           ',i10,
+     x      /,1x,'steps per tracking block       ',i10,
+     x      /,1x,'configuration catch radius  (A)',f10.4,
+     x      /,1x,'minimisation tolerance         ',e12.4,
+     x      /,1x,'atom type to be tracked        ',2x,a8,
+     x      /,1x,'energy units                   ',2x,a8)")
+     x      ebias,vmin,nblock,ntrack,catchrad,opttol,seek,cunit
+          if(nebgo)write(nrite,
+     x      "(1x,'NEB spring constant            ',e12.4)")sprneb
+          if(prechk)write(nrite,
+     x      "(1x,'transition prechecking option selected')")
+          call print_optim(keytol)
+          
+        endif
+        
+c     energy unit conversions
+        
+        sprneb=sprneb*hyp_units
+        if(keytol.lt.2)opttol=opttol*hyp_units
+        
+      endif
+      
+      return
+      end subroutine bpd_option
+      
+      subroutine tad_option
+     x  (directive,ltad,lbpd,lminopt,prechk,tadall,idnode,nblock,
+     x  ntrack,blkout,keytol,catchrad,sprneb,tlow,deltad,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for TAD option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical ltad,lbpd,lminopt,prechk,tadall,endtad,safe
+      integer idnode,nblock,ntrack,blkout,keytol,idum
+      real(8) catchrad,sprneb,deltad,tlow,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(lbpd)call error(idnode,2355)
+      lminopt=.true.
+      ltad=.true.
+      endtad=.false.
+      hyp_units=1.d0
+      
+      do while(.not.endtad)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endtad',directive,idum))then
+          endtad=.true.
+        elseif(findstring('pre',directive,idum))then
+          prechk=.true.
+          if(findstring('false',directive,idum))prechk=.false.
+        elseif(findstring('all',directive,idum))then
+          tadall=.true.
+          if(findstring('false',directive,idum))tadall=.false.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('num_block',directive,idum))then
+          nblock=intstr(directive,lenrec,idum)
+        elseif(findstring('num_track',directive,idum))then
+          ntrack=intstr(directive,lenrec,idum)
+        elseif(findstring('blackout',directive,idum))then
+          blkout=intstr(directive,lenrec,idum)
+        elseif(findstring('catch_radius',directive,idum))then
+          catchrad=dblstr(directive,lenrec,idum)
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('deltad',directive,idum))then
+          deltad=dblstr(directive,lenrec,idum)
+        elseif(findstring('low_temp',directive,idum))then
+          tlow=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'TAD dynamics controls'
+     x    /,1x,'steps per time block           ',i10,
+     x    /,1x,'steps per tracking block       ',i10,
+     x    /,1x,'steps in blackout periods      ',i10,
+     x    /,1x,'configuration catch radius     ',1p,e12.4,
+     x    /,1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'stopping parameter             ',e12.4,
+     x    /,1x,'target low temperature         ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    nblock,ntrack,blkout,catchrad,sprneb,deltad,
+     x    tlow,opttol,cunit
+        if(prechk)write(nrite,
+     x    "(1x,'transition prechecking option selected')")
+        if(tadall)write(nrite,
+     x    "(1x,'option for all basins analysis selected')")
+        call print_optim(keytol)
+        
+      endif
+      
+c     energy unit conversions
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine tad_option
+
+      subroutine metadyn_option
+     x  (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x  ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x  locpe_scale,ref_W_aug,h_aug,wt_Dt)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for metadynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2011
+c     
+c     note: default values are set in metafreeze_module
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lmetadyn,endmet,lstein,ltet,lglobpe,llocpe,safe
+      integer idnode,idum,ncolvar,nq4,nq6,ntet,hkey,meta_step_int
+      real(8) globpe_scale,locpe_scale,ref_W_aug,h_aug,wt_Dt
+      
+      lmetadyn=.true.
+      endmet=.false.          
+      
+      do while(.not.endmet)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endmet',directive,idum))then
+          endmet=.true.
+        elseif(findstring('ncolvar',directive,idum))then
+          ncolvar=intstr(directive,lenrec,idum)
+        elseif(findstring('lstein',directive,idum))then
+          lstein=.true.
+          if(findstring('false',directive,idum))lstein=.false.
+        elseif(findstring('ltet',directive,idum))then
+          ltet=.true.
+          if(findstring('false',directive,idum))ltet=.false.
+        elseif(findstring('lglobpe',directive,idum))then
+          lglobpe=.true.
+          if(findstring('false',directive,idum))lglobpe=.false.
+        elseif(findstring('llocpe',directive,idum))then
+          llocpe=.true.
+          if(findstring('false',directive,idum))llocpe=.false.
+        elseif(findstring('globpe_scale',directive,idum))then
+          globpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('locpe_scale',directive,idum))then
+          locpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('nq4',directive,idum))then
+          nq4=intstr(directive,lenrec,idum)
+          nq4=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('nq6',directive,idum))then
+          nq6=intstr(directive,lenrec,idum)
+          nq6=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('ntet',directive,idum))then
+          ntet=intstr(directive,lenrec,idum)
+        elseif(findstring('meta_step_int',directive,idum))then
+          meta_step_int=intstr(directive,lenrec,idum)
+        elseif(findstring('ref_w_aug',directive,idum))then
+          ref_W_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('h_aug',directive,idum))then
+          h_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('hkey',directive,idum))then
+          hkey=intstr(directive,lenrec,idum)
+        elseif(findstring('wt_dt',directive,idum))then
+          wt_dt=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'metadynamics controls'
+     x    /,1x,'total number of collective variables',i10,
+     x    /,1x,'steinhardt parameters option (Q4/Q6)',l10,
+     x    /,1x,'tetrahedral parameters option (zeta)',l10,
+     x    /,1x,'global potential parameter option   ',l10,
+     x    /,1x,'local potential parameter option    ',l10,
+     x    /,1x,'global potential param. scale factor',e12.4,
+     x    /,1x,'local potential param. scale factor ',e12.4)")
+     x    ncolvar,lstein,ltet,lglobpe,llocpe,globpe_scale,locpe_scale
+        
+        write(nrite,
+     x    "(  1x,'number of Q4 atom pair types        ',i10,
+     x      /,1x,'number of Q6 atom pair types        ',i10,
+     x      /,1x,'number of zeta atom triplet types   ',i10)")
+     x    nq4,nq6,ntet
+        
+        write(nrite,
+     x    "(  1x,'gaussian deposition interval        ',i10,
+     x      /,1x,'reference gaussian height           ',e12.4,
+     x      /,1x,'gaussian width parameter            ',e12.4,
+     x      /,1x,'height control key                  ',i10,
+     x      /,1x,'well-tempered control parameter     ',e12.4)")
+     x    meta_step_int,ref_W_aug,h_aug,hkey,wt_Dt
+        
+      endif
+            
+      return
+      end subroutine metadyn_option
+      
+      subroutine ewald_selection
+     x  (directive,lhke,lspme,lewald,lcut,lforc,kill,idnode,keyfce,
+     x  imcon,nhko,nlatt,kmax1,kmax2,kmax3,alpha,rcut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ewald method and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lhke,lspme,lewald,lcut,lforc,kill,safe
+      integer idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,kmax3,idum
+      integer kmaxpow2
+      real(8) alpha,rcut,eps,tol,fac,tol1
+      
+      lhke=findstring('hke',directive,idum)
+      lspme=findstring('spme',directive,idum)
+      lewald=findstring('ewald',directive,idum)
+      if(lewald)keyfce=2
+      if(lspme)keyfce=12
+      if(lhke)keyfce=14
+      if(idnode.eq.0)open(nconf,file='CONFIG')
+      call getrec(safe,idnode,nconf)
+      call getrec(safe,idnode,nconf)
+      imcon=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(.not.lhke.and.(imcon.eq.0.or.imcon.eq.6))then
+        
+        call error(idnode,-180)
+        kill=.true.
+        
+      endif
+      
+      if(findstring('precision',directive,idum))then
+        
+        eps=dblstr(directive,lenrec,idum)
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'Ewald sum  precision    ',7x,1p,e12.4)")eps
+        
+        if(lhke)then
+          
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          if(nlatt.eq.0)nlatt=1
+          if(nhko.eq.0)nhko=1
+          
+        endif
+        
+        if(.not.lcut)then
+          call error(idnode,-433)
+          kill=.true.
+        else
+          
+c     retreive cell vectors
+          
+          call getrec(safe,idnode,nconf)
+          cell(1)=dblstr(record,lenrec,idum)
+          cell(2)=dblstr(record,lenrec,idum)
+          cell(3)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(4)=dblstr(record,lenrec,idum)
+          cell(5)=dblstr(record,lenrec,idum)
+          cell(6)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(7)=dblstr(record,lenrec,idum)
+          cell(8)=dblstr(record,lenrec,idum)
+          cell(9)=dblstr(record,lenrec,idum)
+          
+c     compute alpha and the kmax
+          
+          if(lewald.or.lspme)then
+            
+            call dcell(cell,celprp)
+            eps=min(abs(eps),0.5d0)
+            tol=sqrt(abs(log(eps*rcut)))
+            alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+            tol1=sqrt(-log(eps*rcut*(2.d0*tol*alpha)**2))
+            fac=1.d0
+            if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x        fac=2.d0**(1.d0/3.d0)
+            kmax1=nint(0.25d0+fac*celprp(1)*alpha*tol1/pi)
+            kmax2=nint(0.25d0+fac*celprp(2)*alpha*tol1/pi)
+            kmax3=nint(0.25d0+fac*celprp(3)*alpha*tol1/pi)
+            
+          elseif(lhke)then
+            
+            if(nhko.eq.0)then
+              if(eps.le.1.d-6)then
+                alpha=3.46d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=3.14d0/rcut
+              else
+                alpha=2.76d0/rcut
+              endif
+            elseif(nhko.eq.1)then
+              if(eps.le.1.d-6)then
+                alpha=4.37d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.08d0/rcut
+              else
+                alpha=3.75d0/rcut
+              endif                
+            elseif(nhko.eq.2)then
+              if(eps.le.1.d-6)then
+                alpha=5.01d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.74d0/rcut
+              else
+                alpha=4.44d0/rcut
+              endif
+            elseif(nhko.eq.3)then
+              if(eps.le.1.d-6)then
+                alpha=5.55d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=5.28d0/rcut
+              else
+                alpha=5.00d0/rcut
+              endif
+            endif
+            alpha=alpha/dble(2*nlatt+1)
+            if(abs(cell(9)).lt.1.d-8)cell(9)=1.d0
+            call dcell(cell,celprp)
+            tol=2.d0*alpha*sqrt(abs(log(eps*alpha)))
+            tol1=2.d0*alpha*sqrt(abs(log(eps*alpha*tol)))
+            kmax1=nint(0.25d0+0.5d0*celprp(1)*tol1/pi)
+            kmax2=nint(0.25d0+0.5d0*celprp(2)*tol1/pi)
+            kmax3=1
+            
+          endif
+          
+        endif
+        
+      else
+        
+        alpha=dblstr(directive,lenrec,idum)
+        kmax1=intstr(directive,lenrec,idum)
+        kmax2=intstr(directive,lenrec,idum)
+        
+        if(lhke)then
+          
+          kmax3=1
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          
+        else
+          
+          kmax3=intstr(directive,lenrec,idum)
+          
+        endif
+        
+      endif
+      
+c     if spme double kmax and set to next power of 2, with current upper
+c     limit of 512.
+      
+      if(lspme)then
+        
+        kmaxpow2=1
+        do while (kmax1.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax1=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax2.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax2=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax3.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax3=2 * kmaxpow2
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        close(nconf)
+        
+        if(lspme)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : SPME  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1/2,kmax2/2,kmax3/2
+          
+        elseif(lhke)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Hautman-Klein-Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2              ',2i5)")
+     x      alpha,kmax1,kmax2
+          
+          write(nrite,
+     x      "(1x,'HKE expansion order     ',7x,i10,
+     x      /,1x,'HKE lattice control     ',7x,i10)")nhko,nlatt
+          
+        else
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1,kmax2,kmax3
+          
+        endif
+        
+      endif
+      
+      if(lspme)then
+        
+c     Initialize fft tables
+        
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (fplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_FORWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+CFFTW
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (bplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_BACKWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+        
+CSGIC             call zzfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CSGIC     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+CCRAY             call ccfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CCRAY     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+      endif
+      
+      if(lspme)then
+        
+        if(kmax1.gt.kmaxd.or.kmax2.gt.kmaxe.or.kmax3.gt.kmaxf)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      elseif(lhke)then
+        
+        if(kmax2.gt.kmaxb)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      else
+        
+        if(kmax2.gt.kmaxb.or.kmax3.gt.kmaxc)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      endif
+      
+      if(lforc)then
+        call  error(idnode,-416)
+        kill=.true.
+      endif
+      lforc=.true.
+      
+      return
+      end subroutine ewald_selection
+      
+      subroutine print_optim(keytol)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing the optimisation option
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer keytol
+      
+      if(keytol.eq.0)then
+        write(nrite,
+     x    "(1x,'convergence to minimum force selected')")
+      elseif(keytol.eq.1)then
+        write(nrite,
+     x    "(1x,'convergence to minimum energy selected')")
+      else
+        write(nrite,
+     x    "(1x,'convergence to minimum position selected')")
+      endif
+      
+      return
+      end subroutine print_optim
+      
+      function energy_unit()
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for assigning energy conversion factors
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idum
+      real(8) energy_unit
+      
+      energy_unit=1.d0
+      if(findstring('ev',record,idum))then
+        energy_unit=9648.530821d0
+      elseif(findstring('kev',record,idum))then
+        energy_unit=9648530.821d0
+      elseif(findstring('kcal',record,idum))then
+        energy_unit=418.4d0
+      elseif(findstring('kj',record,idum))then
+        energy_unit=1.d2
+      elseif(findstring('k',record,idum))then
+        energy_unit=boltz
+      endif
+      
+      return
+      end function energy_unit
+      
+      subroutine solvation_option
+     x  (directive,lsolva,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for solvation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,endsol,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      endsol=.false.
+      
+      nsolva=intstr(directive,lenrec,idum)
+      isolva=intstr(directive,lenrec,idum)
+      
+      if(nsolva.eq.0.and.isolva.eq.0)then
+        
+        do while(.not.endsol)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(findstring('endsol',directive,idum))then
+            endsol=.true.
+          elseif(findstring('enddec',directive,idum))then
+            endsol=.true.
+          elseif(findstring('start',directive,idum))then
+            nsolva=intstr(directive,lenrec,idum)
+          elseif(findstring('inter',directive,idum))then
+            isolva=max(intstr(directive,lenrec,idum),1)
+          endif
+          
+        enddo
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'solvation calculation selected',
+     x    /,1x,'start of solvation calculation ',i10,
+     x    /,1x,'solvation calculation interval ',i10)")
+     x    nsolva,isolva
+        
+      endif
+      
+      return
+      end subroutine solvation_option
+      
+      subroutine free_energy_option(directive,lfree,lfrmas,idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for free energy option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lfree,lfrmas,endfre,safe
+      integer idnode,idum
+      
+      mfree=1
+      kfree=1
+      lfree=.true.
+      lfrmas=.false.
+      endfre=.false.
+      
+      do while(.not.endfre)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endfre',directive,idum))then
+          endfre=.true.
+        elseif(findstring('start',directive,idum))then
+          nfrn=intstr(directive,lenrec,idum)
+        elseif(findstring('interval',directive,idum))then
+          ifrn=intstr(directive,lenrec,idum)
+        elseif(findstring('lambda',directive,idum))then
+          pfree=dblstr(directive,lenrec,idum)
+        elseif(findstring('mix',directive,idum))then
+          mfree=intstr(directive,lenrec,idum)
+        elseif(findstring('expo',directive,idum))then
+          kfree=intstr(directive,lenrec,idum)
+        elseif(findstring('reset_mass',directive,idum))then
+          lfrmas=.true.
+          if(findstring('false',directive,idum))lfrmas=.false.
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(mfree.eq.1)kfree=1
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'free energy option selected',
+     x    /,1x,'start of free energy calculation ',i10,
+     x    /,1x,'sampling interval                ',i10,
+     x    /,1x,'free energy parameter (lambda)   ',f10.3,
+     x    /,1x,'mixing rule selected             ',i10,
+     x    /,1x,'mixing rule exponent             ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10,
+     x    /,1x,'mass scaling option              ',l10)")
+     x    nfrn,ifrn,pfree,mfree,kfree,ind_fre,lfrmas
+        
+      endif
+      
+c     define free energy scaling parameters
+
+      call freegen()
+      
+      return
+      end subroutine free_energy_option
+      
+      subroutine excitation_option
+     x  (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for excitation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lexcite,lghost,endexc,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lexcite=.true.
+      endexc=.false.
+      
+      do while(.not.endexc)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endexc',directive,idum))then
+          endexc=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'excitation option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,ind_fre
+        
+      endif
+      
+      return
+      end subroutine excitation_option
+      
+      subroutine switching_option
+     x  (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for switching option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lswitch,lghost,endswi,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lswitch=.true.
+      endswi=.false.
+      niswitch=0
+      
+      do while(.not.endswi)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endswi',directive,idum))then
+          endswi=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('period',directive,idum))then
+          niswitch=max(intstr(directive,lenrec,idum),2)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(niswitch.eq.0)niswitch=nsolva
+      nswitch=nsolva
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'switching option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'switching period                 ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,niswitch,ind_fre
+        
+      endif
+      
+      return
+      end subroutine switching_option
+      
+      end module define_system_module
+      
diff -urN dl_class_1.9.orig/srcmod/define_system_module.f.preplumed dl_class_1.9/srcmod/define_system_module.f.preplumed
--- dl_class_1.9.orig/srcmod/define_system_module.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/define_system_module.f.preplumed	2011-10-17 17:32:15.000000000 +0200
@@ -0,0 +1,5994 @@
+      module define_system_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for utility subroutines and functions
+c     copyright - daresbury laboratory
+c     author    - w. smith     aug 2006
+c     adapted   - p.-a. cazade oct 2007, solvation, free energy
+c     and excitation
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use dihedral_module
+      use ensemble_tools_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use inversion_module
+      use metafreeze_module
+      use metal_module
+      use parse_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use vdw_module
+      
+      contains
+      
+      subroutine simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the simulation control 
+c     parameters
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith july 1992.
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c     modified
+c     author   - t.forester       may  1993
+c     amended  - t.forester       sept 1994 - dl_poly_1.1
+c     amended  - t.forester       nov  1994 - macro version
+c     amended  - w.smith          dec  1994 - t3d adaptation
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 hms
+      character*1 directive(lenrec)
+      logical lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,lpsoc
+      logical ltscal,lzeql,loptim,ltraj,lfcap,lgofr,lpgr,lpres,safe
+      logical lstep,ltemp,lcut,ldelr,lprim,lforc,lens,lvdw,lrvdw,kill
+      logical lnsq,lzden,lewald,lspme,lhke,loop,lzero,nolink,newgau
+      logical lminim,lminopt,ltad,lneb,lhit,lbpd,prechk,tadall,nebgo
+      integer idnode,intsta,istraj,keyens,keyfce,keyres,nstbpo,nsbzdn
+      integer keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,khit,nhit
+      integer nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,ntrack
+      integer idum,imcon,keyver,keytol,nblock,blkout,numgau
+      integer minstp,numneb,i,keybpd,mode,nsolva,isolva,nofic
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,rlxtol,opttol
+      real(8) eps,tol,fm,densvar,delrdf,delzdn,zlen,ehit,hyp_units
+      real(8) catchrad,sprneb,deltad,tlow,xhit,yhit,zhit,ebias,vmin
+      real(8) prntim
+      
+CSGIC      real(8) dummy
+CCRAY      real(8) dummy
+CFFTWc     FFTW instruction codes
+CFFTW
+CFFTW      integer FFTW_FORWARD,FFTW_BACKWARD
+CFFTW      parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)
+CFFTW
+CFFTW      integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
+CFFTW      parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)
+CFFTW
+CFFTW      integer FFTW_ESTIMATE,FFTW_MEASURE
+CFFTW      parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)
+CFFTW
+CFFTW      integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
+CFFTW      parameter (FFTW_OUT_OF_PLACE=0)
+CFFTW      parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)
+CFFTW
+CFFTW      integer FFTW_THREADSAFE
+CFFTW      parameter (FFTW_THREADSAFE=128)
+CFFTW
+      
+c     intitialize system variables: temperature,pressure,ensemble key
+c     force key, cutoff, primary cutoff, verlet shell width, relative
+c     dielectric constant,timestep,temperature scaling flag, 
+c     temp scaling interval
+      
+      mode=0
+      nhko=0
+      nlatt=0
+      nsteql=0
+      nstrun=0
+      minstp=0
+      keybpd=0
+      keyres=0
+      keyens=0
+      keyver=0
+      taut=0.d0
+      nstbts=0
+      nstbgr=0
+      nsbzdn=0
+      nstbpo=100
+      nstack=mxstak
+      intsta=0
+      nstraj=0
+      istraj=1
+      keytrj=0
+      numgau=1
+      alpha=0.d0
+      kmax1=0
+      kmax2=0
+      kmax3=0
+      nospl=min(8,mxspl)
+      isolva=1
+      nsolva=0
+      niswitch=0
+      nswitch=0
+      nofic=1000
+      
+      fmax=1000.d0
+      keyfce=0
+      multt=1
+      keytol=0
+      tstep=0.d0
+      temp=0.d0
+      press=0.d0
+      rcut=0.d0
+      rprim=0.d0
+      rvdw=0.d0
+      delr=0.d0
+      epsq=1.d0
+      rlxtol=1.d0
+      opttol=1.d0
+      tolnce=1.d-8
+      quattol=1.d-8
+      timjob=0.d0
+      timcls=0.d0
+      delrdf=0.d0
+      delzdn=0.d0
+      zlen=0.d0
+      ehit=0.d0
+      xhit=0.d0
+      yhit=0.d0
+      zhit=0.d0
+      vmin=0.d0
+      ebias=0.d0
+      catchrad=0.d0
+      pfree=0.d0
+      
+      lhit=.false.
+      lbpd=.false.
+      ltad=.false.
+      lneb=.false.
+      loop=.true.
+      lnfic=.false.
+      lpsoc=.false.
+      lzero=.false.
+      ltscal=.false.
+      lewald=.false.
+      lspme=.false.
+      lhke=.false.
+      lgofr=.false.
+      lpgr=.false.
+      lzeql=.true.
+      loptim=.false.
+      lminim=.false.
+      lminopt=.false.
+      ltraj=.false.
+      lfcap=.false.
+      ltemp=.false.
+      lstep=.false.
+      lcut=.false.
+      ldelr=.false.
+      lprim=.false.
+      lforc=.false.
+      lens=.false.
+      lvdw=.false.
+      lrvdw=.false.
+      lpres=.false.
+      kill=.false.
+      lnsq=.false.
+      lzden=.false.
+      nolink=.false.
+      newgau=.false.
+      prechk=.false.
+      tadall=.false.
+      lsolva=.false.
+      lfree=.false.
+      lfrmas=.false.
+      lexcite=.false.
+      lswitch=.false.
+      lghost=.false.
+      nebgo=.true.
+      seek='all     '
+      
+c     open the simulation input file
+      
+      if(idnode.eq.0)open(nread,file='CONTROL',status='old')
+      
+c     read job title
+      
+      call getrec(safe,idnode,nread)
+      if(.not.safe)call abort_control_read(1,idnode,nread)
+      
+      call copystring(record,sysname,80)
+      if(idnode.eq.0)then 
+        
+        write(nrite,"(3(1x,120('*'),/),1x,15('*'),5x,80a1,5x,15('*'),/,
+     x    3(1x,120('*'),/),/,/,1x,'SIMULATION CONTROL PARAMETERS',/)")
+     x    sysname
+        
+      endif
+      
+c     read and process directives from CONTROL file
+      
+      do while(loop)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        
+c     convert to lowercase and strip out leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('redirect',directive,idum))then
+          
+c     ignore this option in this context
+          cycle
+          
+        elseif(findstring('steps',directive,idum))then
+          
+c     number of timesteps
+          
+          nstrun=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'selected number of timesteps',3x,i10)")nstrun
+          
+        elseif(findstring('integ',directive,idum))then
+          
+c     choice of integration algorithm
+          
+          if(findstring('leapfrog',directive,idum))then
+            
+            keyver=0
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'leapfrog verlet integration selected')")
+            
+          elseif(findstring('velocity',directive,idum))then
+            
+            keyver=1
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'velocity verlet integration selected')")
+            
+          endif
+          
+        elseif(findstring('no fic',directive,idum))then
+          
+c     cancel possible "flying ice cube" in Berendsen thermostats
+          
+          lnfic=.true.
+          nofic=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('shells',directive,idum).and.
+     x      findstring('on',directive,idum).and.
+     x      findstring('cores',directive,idum))then
+          
+c     put shells on cores at start - shell model only (else null)
+          
+          lpsoc=.true.
+          
+        elseif(findstring('densvar',directive,idum))then
+          
+c     specify allowed density variation
+          
+          densvar=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'allowed density variation   ',3x,1p,e12.4)")
+     x      densvar
+          
+        elseif(findstring('no link',directive,idum))then
+          
+c     switch off link cell option
+          
+          nolink=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'link cells option deactivated')")
+          
+        elseif(findstring('equil',directive,idum))then
+          
+c     number of equilibration timesteps
+          
+          nsteql=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration period        ',3x,i10)")nsteql
+          
+        elseif(findstring('restart',directive,idum))then
+          
+c     restart control
+          
+          if(findstring('noscale',directive,idum))then
+            
+            keyres=3
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'noscale restart requested')")
+            
+          elseif(findstring('scale',directive,idum))then
+            
+            keyres=2
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'scaled restart requested')")
+            
+          else
+            
+            keyres=1
+            if(idnode.eq.0)write(nrite,"(/,1x,'restart requested')")
+            
+          endif
+          
+        elseif(findstring('ensemble',directive,idum))then
+          
+c     ensemble selection
+          
+          call ensemble_selection(directive,lens,kill,idnode,keyens,
+     x      mode,taut,taup)
+          
+        elseif(findstring('regauss',directive,idum))then
+          
+c     re-initialise velocities option (regaussing)
+          
+          newgau=.true.
+          numgau=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'regaussing option activated',
+     x      /,1x,'regaussing interval set to  ',3x,i10)")
+     x      numgau
+          
+        elseif(findstring('scale',directive,idum))then
+          
+          nstbts=intstr(directive,lenrec,idum)
+          if(nstbts.gt.0)then
+            ltscal=.true.
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'temperature scaling on' 
+     x        /,1x,'temperature scaling interval',3x,i10)")
+     x        nstbts
+            
+          endif
+          
+        elseif(findstring('rdf',directive,idum))then
+          
+          if(findstring('print',directive,idum))then
+            
+            lpgr=.true.
+            lpgr=(lgofr.and.lpgr)
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'g(r) printing option on      ')")
+          
+          else
+            
+            lgofr=.true.
+            nstbgr=intstr(directive,lenrec,idum)
+            delrdf=dblstr(directive,lenrec,idum)
+            if(nstbgr.eq.0)nstbgr=10
+            if(delrdf.lt.1.d-8)delrdf=0.05d0
+            
+            if(idnode.eq.0)then
+              
+              write(nrite,
+     x          "(/,/,1x,'radial distribution functions on ',
+     x          /,1x,'g(r) collection interval    ',3x,i10)")nstbgr
+              write(nrite,
+     x          "(1x,'g(r) bin width              ',3x,1p,e12.4)")
+     x          delrdf
+              
+            endif
+            
+          endif
+          
+        elseif(findstring('zden',directive,idum))then
+          
+          lzden=.true.
+          nsbzdn=intstr(directive,lenrec,idum)
+          delzdn=dblstr(directive,lenrec,idum)
+          zlen=dblstr(directive,lenrec,idum)
+          if(nsbzdn.eq.0)nsbzdn=10
+          if(delzdn.lt.1.d-8)then
+            zlen=0.1d0*dble(mxzdn)
+            delzdn=0.1d0
+          elseif(zlen.lt.1.d-8)then
+            zlen=delzdn*dble(mxzdn)
+          endif
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,/,1x,'Z density profile requested',
+     x        /,1x,'zdensity collection interval',3x,i10)")nsbzdn
+            write(nrite,
+     x        "(1x,'zdensity bin width          ',3x,1p,e12.4)")
+     x        delzdn
+            write(nrite,
+     x        "(1x,'zdensity range              ',3x,1p,e12.4)")
+     x        zlen
+            
+          endif
+          
+        elseif(findstring('collect',directive,idum))then
+          
+          lzeql=.false.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration included in overall averages')")
+          
+        elseif(findstring('neb',directive,idum))then
+          
+c     activate nudged elastic band option
+          
+          call neb_option(directive,lneb,lminopt,idnode,
+     x      numneb,keytol,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('impact',directive,idum))then
+          
+c     activate the impact option
+          
+          if(lhit)call error(idnode,516)
+          lhit=.true.
+          khit=intstr(directive,lenrec,idum)
+          nhit=intstr(directive,lenrec,idum)
+          ehit=dblstr(directive,lenrec,idum)
+          xhit=dblstr(directive,lenrec,idum)
+          yhit=dblstr(directive,lenrec,idum)
+          zhit=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)then
+            
+            write(nrite,"(/,1x,'impact option selected')")
+            write(nrite,"(
+     x        /,1x,'identity of impact atom        ',i10,
+     x        /,1x,'time step of impact            ',i10,
+     x        /,1x,'impact recoil energy (keV)     ',1p,e12.4,
+     x        /,1x,'impact direction (x component) ',1p,e12.4,
+     x        /,1x,'impact direction (y component) ',1p,e12.4,
+     x        /,1x,'impact direction (z component) ',1p,e12.4)")
+     x        khit,nhit,ehit,xhit,yhit,zhit
+            
+          endif
+          
+c     convert impact energy from keV to internal units
+          
+          ehit=ehit*9648530.821d0
+          
+        elseif(findstring('bpd',directive,idum))then
+          
+c     activate the BPD option
+          
+          call bpd_option(directive,seek,lbpd,ltad,lminopt,prechk,
+     x      nebgo,keybpd,idnode,nblock,ntrack,keytol,ebias,vmin,
+     x      catchrad,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('tad',directive,idum))then
+          
+c     activate temperature accelerated dynamics option
+          
+          call tad_option(directive,ltad,lbpd,lminopt,prechk,tadall,
+     x      idnode,nblock,ntrack,blkout,keytol,catchrad,sprneb,tlow,
+     x      deltad,opttol,hyp_units)
+          
+        elseif(findstring('minim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          minstp=intstr(directive,lenrec,idum)
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          lminim=.true.
+          loptim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'minimisation programme requested')")
+            write(nrite,
+     x        "(1x,'structure minimisation interval ',
+     x        3x,i10)")minstp
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'structure minimisation tolerance',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('optim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          loptim=.true.
+          lminim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'structure optimisation requested')")
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'tolerance for structure optimisation ',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('zero',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          temp=1.d0
+          lzero=.true.
+          loptim=.false.
+          lminim=.false.
+          ltemp=.true.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'zero K optimisation requested')")
+            write(nrite,
+     x        "(' temperature reset to',1p,e12.4)")1.d0
+            
+          endif
+          
+        else if(findstring('solva',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        else if(findstring('decomp',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        elseif(findstring('metafreeze',directive,idum).or.
+     x      findstring('metadyn',directive,idum))then
+          
+c     activate metadynamics option - d. quigley
+          
+          call metadyn_option
+     x      (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x      ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x      locpe_scale,ref_W_aug,h_aug,wt_Dt)
+          
+        else if(findstring('free',directive,idum))then
+          
+          call free_energy_option(directive,lfree,lfrmas,idnode)
+          
+        else if(findstring('excite',directive,idum))then
+          
+          call excitation_option
+     x      (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+          
+        else if(findstring('switch',directive,idum))then
+          
+          call switching_option
+     x      (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+          
+        elseif(findstring('print',directive,idum))then
+          
+          nstbpo=intstr(directive,lenrec,idum)
+          nstbpo=max(nstbpo,1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data printing interval      ',3x,i10)")nstbpo
+          
+        elseif(findstring('stack',directive,idum))then
+          
+          nstack=intstr(directive,lenrec,idum)
+          
+c     reset stack limit if too large
+          
+          nstack=min(nstack,mxstak)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data stacking interval      ',3x,i10)")nstack
+          
+        elseif(findstring('stats',directive,idum))then
+          
+          intsta=intstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'statistics file interval    ',3x,i10)")intsta
+          
+        elseif(findstring('traj',directive,idum))then
+          
+          ltraj=.true.
+          nstraj=intstr(directive,lenrec,idum)
+          istraj=max(intstr(directive,lenrec,idum),1)
+          keytrj=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'trajectory file option on  ',
+     x      /,1x,'trajectory file start       ',3x,i10,
+     x      /,1x,'trajectory file interval    ',3x,i10
+     x      /,1x,'trajectory file info key    ',3x,i10)")
+     x      nstraj,istraj,keytrj
+          
+        elseif(findstring('ewald',directive,idum).or.
+     x      findstring('spme',directive,idum).or.
+     x      findstring('hke',directive,idum))then
+          
+c     read Ewald or HK-Ewald or SPM-Ewald sum parameters
+          
+          call ewald_selection(directive,lhke,lspme,lewald,lcut,
+     x      lforc,kill,idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,
+     x      kmax3,alpha,rcut)
+          
+        elseif(findstring('distan',directive,idum))then
+          
+          keyfce=4
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Distance dependent dielectric')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('coul',directive,idum))then
+          
+          keyfce=6
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Coulombic potential')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('shift',directive,idum))then
+          
+          keyfce=8
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Shifted Coulombic potential')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('reaction',directive,idum))then
+          
+          keyfce=10
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : reaction field')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('cap',directive,idum))then
+          
+          lfcap=.true.
+          fm=dblstr(directive,lenrec,idum)
+          if(fm.gt.0.d0)fmax=fm
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'force capping :',16x,1p,e12.4,' kT/A')")fmax
+          
+        elseif(findstring('no vdw',directive,idum))then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'short-range potential terms off')")
+          lvdw=.true.
+          
+        elseif(findstring('no elec',directive,idum))then
+          
+          keyfce=0
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'electrostatic potential terms off')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('mult',directive,idum))then
+          
+          multt=max(intstr(directive,lenrec,idum),1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'multiple timestep interval  ',3x,i10)")multt
+          
+        elseif(findstring('timestep',directive,idum))then
+          
+          lstep=.true.
+          tstep=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation timestep         ',3x,1p,e12.4)")tstep
+          
+        elseif(findstring('temp',directive,idum))then
+          
+          ltemp=.true.
+          temp=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation temperature      ',3x,1p,e12.4)")temp
+          
+        elseif(findstring('pres',directive,idum))then
+          
+          press=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation pressure (katm)  ',3x,1p,e12.4)")press
+          
+c     convert from katm to internal units of pressure
+          
+          press=press/prsunt
+          lpres=.true.
+          
+        elseif(findstring('prim',directive,idum))then
+          
+c     primary cutoff
+          
+          lprim=.true.
+          rprim=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'primary neighbour cut off   ',3x,1p,e12.4)")rprim
+          
+        elseif(findstring('rvdw',directive,idum))then
+          
+c     cutoff for short range potentials
+          
+          rvdw=dblstr(directive,lenrec,idum)
+          lrvdw=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off (vdw)    ',3x,1p,e12.4)")rvdw
+          
+        elseif(findstring('delr',directive,idum))then
+          
+c     Verlet shell width
+          
+          ldelr=.true.
+          delr=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'border width of Verlet shell',3x,1p,e12.4)")delr
+          
+        elseif(findstring('cut',directive,idum))then
+          
+c     cutoff
+          
+          lcut=.true.
+          rcut=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off          ',3x,1p,e12.4)")rcut
+          
+        elseif(findstring('eps',directive,idum))then
+          
+c     relative dielectric constant
+          
+          epsq=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'relative dielectric constant',3x,1p,e12.4)")epsq
+          
+        elseif(findstring('rlxtol',directive,idum))then
+          
+c     force tolerance for shell relaxation
+          
+          rlxtol=max(rlxtol,dblstr(directive,lenrec,idum))
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for shell relaxn. ',3x,1p,e12.4)")rlxtol
+          
+        elseif(findstring('shake',directive,idum))then
+          
+c     tolerance for shake
+          
+          tolnce=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for SHAKE         ',3x,1p,e12.4)")tolnce
+          
+        elseif(findstring('quaternion',directive,idum))then
+          
+c     tolerance for quaternion integration
+          
+          quattol=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for Quaternions   ',3x,1p,e12.4)")quattol
+          
+        elseif(findstring('job time',directive,idum))then
+          
+c     time for simulation (in seconds/minutes/hours/days or indefinite)
+          
+          if(findstring('indef',directive,idum))then
+             timjob=1.0d6*365.25d0*24.d0*60.d0*60.d0
+          else
+             timjob=dblstr(directive,lenrec,idum)
+             if(findstring('m',directive,idum))then
+               timjob=6.0d1*timjob
+             elseif(findstring('h',directive,idum))then
+               timjob=3.6d3*timjob
+             elseif(findstring('d',directive,idum))then
+               timjob=8.64d4*timjob
+             endif
+          endif
+          
+          call get_prntime(hms,timjob,prntim)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'user allocated job time (',a1,') ',3x,f8.4)")
+     x      hms,prntim
+          
+        elseif(findstring('close time',directive,idum))then
+          
+c     time for winding up a job (in seconds)
+          
+          timcls=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'job closure time        (s) ',3x,f8.3)")timcls
+          
+        elseif(findstring('all pairs',directive,idum))then
+          
+c     full minimum image - N^2 interactions each timestep
+          
+          lnsq=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'All-pairs requested for electrostatics')")
+          
+        elseif(findstring('nospl',directive,idum))then
+          
+c     set ewald_spme interpolation order
+          
+          nospl=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('finish',directive,idum))then
+          
+c     safe termination of reading CONTROL file
+          
+          loop=.false.
+          
+        else
+          
+c     unrecognised directive in control file
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      enddo
+      
+c     check on steps before temperature scaling
+      
+      if(nstbts.eq.0)nstbts=nstrun+1
+      
+c     conduct consistency checks on directives
+      
+      if(lminim)then
+        
+c     ensure final configuration follows minimisation
+        
+        if(minstp.eq.0)minstp=nstrun
+        nstrun=minstp*(nstrun/minstp)
+        
+      endif
+      
+c     check force activation options
+      
+      if(.not.lforc)then
+        
+c     check if any forces are in operation
+        
+        if(.not.lvdw)then
+          
+          kill=.true.
+          call error(idnode,-383)
+          
+        endif
+        
+      else
+        
+c     turn on short range forces
+        
+        if(lvdw)then
+          
+          if(keyfce.eq.0)then
+            
+            lcut=.true.
+            ldelr=.true.
+            
+          endif
+          
+        else
+          
+          keyfce=keyfce+1
+          
+        endif
+        
+      endif
+      
+c     if tad selected use only leap frog
+      
+      if(ltad.and.keyver.eq.1)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to leapfrog for TAD dynamics')")
+        keyver=0
+        
+      endif
+      
+c     error checking 
+      
+      if(lmetadyn.and.keyens.ne.3.and.keyens.ne.5.and.keyens.ne.7)then
+        
+        kill=.true.
+        call error(idnode,-2360)
+        
+      endif
+      
+      if(lsolva.or.lfree.or.lexcite.or.lswitch)then
+        
+        if(lspme)then
+          
+          kill=.true.
+          call error(idnode,-601)
+          
+        endif
+        
+        if(lhke)then
+          
+          kill=.true.
+          call error(idnode,-602)
+          
+        endif
+        
+      endif
+      
+      if(lghost.and.nstbgr.ne.isolva)then
+        
+        call warning(idnode,130,dble(isolva),0.d0,0.d0)
+        nstbgr=isolva
+        
+      endif
+      if(lfree.and.lgofr)then
+        
+        call warning(idnode,140,0.d0,0.d0,0.d0)
+        lgofr=.false.
+        lpgr=.false.
+        
+      endif
+      if(loptim)then
+        
+        temp=0.d0
+        
+      elseif(.not.ltemp)then
+        
+        kill=.true.
+        call error(idnode,-380)
+        
+      endif
+      
+      if(.not.lstep)then
+        
+        kill=.true.
+        call error(idnode,-381)
+        
+      endif
+      
+      if(.not.lcut)then
+        
+        kill=.true.
+        call error(idnode,-382)
+        
+      endif
+      
+c     check if van der Waals cutoff set
+      
+      if(.not.lrvdw.and.mod(keyfce,2).eq.1)then
+        
+        if(rcut.gt.0.d0)then
+          
+          rvdw=rcut
+          
+        else
+          
+          kill=.true.
+          call error(idnode,-402)
+          
+        endif      
+        
+      endif
+      
+      if(.not.ldelr)then
+        
+        kill=.true.
+        call error(idnode,-384)
+        
+      endif
+      
+      if(multt.gt.1)then
+        
+        if(.not.lprim)then
+          
+          kill=.true.
+          call error(idnode,-385)
+          
+        elseif(rprim.gt.rcut)then
+          
+          kill=.true.
+          call error(idnode,-386)
+          
+        endif
+        
+      endif
+      
+c     check settings in nvt ensemble
+      
+      if(keyens.ge.2.and.keyens.le.3)then
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        
+      endif
+      
+c     check settings in npt ensemble
+      
+      if(keyens.ge.4.and.keyens.le.7)then
+        
+        if(.not.lpres)then
+          
+          kill=.true.
+          call error(idnode,-387)
+          
+        endif
+        
+c     check barostat and thermostat rates non zero
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        if(taup.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-466)
+          
+        endif
+        
+      endif
+      
+c     check multiple timestep cutoffs are sensible
+      
+      if(multt.gt.1)then
+        if(rcut-rprim.lt.delr)then
+          
+          kill=.true.
+          call error(idnode,-398)
+          
+        endif
+      endif
+      
+c     check rcut > rvdw (for verlet list constructor)
+      
+      if(rcut.lt.rvdw)then 
+        
+        kill=.true.
+        call error(idnode,-400)
+        
+      endif
+      
+c     check spme is not being used with incorrect pbc
+      
+      if(lspme)then
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+          kill=.true.
+          call error(idnode,-513)
+          
+        endif
+        
+      endif
+      
+c     check on all-pairs calculation request
+      
+      if(lnsq)then
+        
+        if(multt.eq.1)then
+          
+          kill=.true.
+          call error(idnode,-422)
+          
+        endif
+        
+        if(keyfce/2.lt.2.or.keyfce/2.gt.3)then
+          
+          kill=.true.
+          call error(idnode,-424)
+          
+        endif
+        
+      endif
+      
+c     cancel rdf option if no vdw or coulombic forces
+      
+      if(lgofr.and.keyfce.eq.0)then
+        
+        lgofr=.false.
+        call warning(idnode,120,0.d0,0.d0,0.d0)
+        
+      endif
+      
+      if(kill)call abort_control_read(2,idnode,nread)
+      
+c     close CONTROL file
+      
+      if(idnode.eq.0)close(nread)
+      
+      return
+      end subroutine simdef
+      
+      subroutine sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the molecular specifications
+c     of the system to be simulated
+c     version for rigid unit data and neutral groups
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith may 1992.
+c     amended   - w.smith march 1994 
+c     amended   - t.forester april 1994
+c     amended   - w.smith  dec 1994 - getrec etc
+c     amended   - a.smondyrev may 2000 - keydih=5 for 
+c     ryckaert-bellemans potential in dihedrals
+c     amended   - a.smondyrev may 2000 - keydih=6 for 
+c     fluorinated ryckaert-bellemans potential in dihedrals
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lunits,lmols,lneut,ltable,lnsq,lshl,safe,lpmf
+      logical loop1,loop2,lsolva,lfree,lexcite,lswitch,lghost
+      
+      integer idnode,keyfce,keyfld,natms,ngrp,ntpatm,ntpmls
+      integer ntpvdw,ntptbp,ntpmet,ntpfbp,nshels,ksite
+      integer nsite,nconst,nangle,ndihed,ninver,nbonds
+      integer nteth,nspmf,itmols,i,idum,keyver
+      integer ntpter,keyshl,iatm,natmsr,ntghost
+      
+      real(8) dlrpot,engunit,rvdw,rcuttb,rctter,rcutfb
+      real(8) sumchg
+      
+      data loop1/.true./,loop2/.true./
+      
+c     initialise system counters: atomic site index, number of 
+c     constraints, bond angles, dihedrals, inversions, chemical bonds,
+c     unique atom types, total number of atoms,
+c     total number of rigid groups, number of tethered atoms,
+c     number of three body potentials
+      
+      nsite=0
+      nconst=0
+      nangle=0
+      ndihed=0
+      ninver=0
+      nbonds=0
+      ntpatm=0
+      natms=0
+      ngrp=0
+      nteth=0
+      ntptbp=0
+      ntpter=0
+      ntpmet=0
+      ntpvdw=0
+      ntpfbp=0
+      nshels=0
+      nspmf=0
+      keyfld=0
+      keyshl=0
+      ntghost=0
+      natmsr=0
+      ntcons_ghost=0
+      
+      lunits=.false.
+      lmols=.false.
+      lneut=.false.
+      ltable=.false.
+      lmetab=.false.
+      lshl=.false.
+      lpmf=.false.
+      engunit=1.d0
+      
+      numbonds(:)=0
+      numpmf(:)=0
+      numcon(:)=0
+      numdih(:)=0
+      numinv(:)=0
+      numgrp(:)=0
+      numsit(:)=0
+      numteth(:)=0
+      numshl(:)=0
+      npmf(:)=0
+      indpmf(:)=0
+      
+c     open force field data file
+      
+      if(idnode.eq.0)open (nfield,file='FIELD',status='old')
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,'SYSTEM SPECIFICATION')")
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)call abort_field_read(1,idnode,nfield)
+      
+c     read and process directives from field file
+      
+      do while(loop1)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)call abort_field_read(1,idnode,nfield)
+        
+c     convert to lowercase and remove leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('units',record,idum))then
+          
+c     identify energy unit for input/output
+          
+          lunits=.true.
+          call define_units(idnode,engunit)
+          
+c     neutral group control option
+          
+        elseif(findstring('neut',record,idum))then
+          
+          lneut=.true.
+          if(idnode.eq.0)
+     x      write(nrite,"(/,' neutral group implementation in use')")
+          
+c     can't have neutral groups with all-pairs
+          
+          if(lnsq)call error(idnode,426)
+          
+c     specify molecular species
+          
+        elseif(findstring('molecu',record,idum))then
+          
+c     number of molecular types
+          
+          if(lmols)call error(idnode,11)
+          lmols=.true.
+          ntpmls=intstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(/,/,1x,'number of molecular types',6x,i10)")
+     x      ntpmls
+          
+          if(ntpmls.gt.mxtmls)call error(idnode,10)
+          
+c     initialise total system charge
+          
+          sumchg=0.d0
+          
+c     read in molecular characteristics
+          
+          do itmols=1,ntpmls
+            
+            if(idnode.eq.0)
+     x        write(nrite,"(/,1x,'molecular species type',9x,i10)")
+     x        itmols
+            
+c     name of molecular species
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abort_field_read(1,idnode,nfield)
+            
+            call copystring(record,molnam(1,itmols),40)
+            if(idnode.eq.0)
+     x        write(nrite,"(/,/,1x,'name of species:',13x,40a1)")
+     x        (molnam(i,itmols),i=1,40)
+            
+c     stop processing if energy unit has not been specified
+            
+            if(.not.lunits)call error(idnode,6)
+            
+c     read molecular data
+            
+            loop2=.true.
+            
+            do while(loop2)
+              
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abort_field_read(1,idnode,nfield)
+              
+              call lowcase(record,lenrec)
+              call strip(record,lenrec)
+              
+              ksite=0
+              
+              if(findstring('nummol',record,idum))then
+                
+                nummols(itmols)=intstr(record,lenrec,idum)
+                if(idnode.eq.0)
+     x            write(nrite,"(/,1x,'number of molecules  ',
+     x            10x,i10)")nummols(itmols)
+                
+              elseif(findstring('atoms',record,idum))then
+                
+c     read in atomic details
+                
+                call define_atoms
+     x            (safe,lneut,idnode,itmols,nsite,ksite,ntpatm)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read core - shell spring parameters
+                
+              elseif(findstring('shell',record,idum))then
+                
+                lshl=.true.
+                call define_core_shell
+     x            (safe,idnode,itmols,nshels,nsite,keyshl,
+     x            engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read chemical bond force constant and bondlength
+                
+              elseif(findstring('bonds',record,idum))then
+                
+                call define_bonds
+     x            (safe,idnode,itmols,nbonds,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read bond atom indices and constraint bondlength
+                
+              elseif(findstring('constr',record,idum))then
+                
+                call define_constraints
+     x            (safe,lghost,idnode,itmols,nconst,nsite,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read pmf bond atom indices, weights and constraint bondlength
+                
+              elseif(findstring('pmf',record,idum))then
+                
+                if(lpmf)call error(idnode,484)
+                lpmf=.true.
+                call define_pmf(safe,idnode,itmols,nspmf)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular angular potential parameters
+                
+              elseif(findstring('angles',record,idum))then
+                
+                call define_angles
+     x            (safe,idnode,itmols,nangle,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular dihedral potential parameters
+                
+              elseif(findstring('dihedr',record,idum))then
+                
+                call define_dihedrals
+     x            (safe,idnode,itmols,ndihed,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular inversion potential parameters
+                
+              elseif(findstring('invers',record,idum))then
+                
+                call define_inversions
+     x            (safe,idnode,itmols,ninver,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read rigid body data
+                
+              elseif(findstring('rigid',record,idum))then
+                
+                call define_rigid_body
+     x            (safe,lghost,idnode,itmols,ngrp,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read tethered atom indices and tethering parameters
+                
+              elseif(findstring('teth',record,idum))then
+                
+                call define_tethers
+     x            (safe,idnode,itmols,nteth,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     finish of data for one molecular type
+                
+              elseif(findstring('finish',record,idum))then
+                
+c     running total of number of atoms in system
+                
+                natms=natms+nummols(itmols)*numsit(itmols)
+                if(natms.gt.mxatms)call error(idnode,75)
+                
+c     check core-shell units are not both in same rigid body unit
+                
+                call check_shells(idnode,itmols,nshels,ngrp)
+                
+                loop2=.false.
+                
+              else
+                
+c     error exit for unidentified directive in molecular data
+                
+                if(idnode.eq.0)write(nrite,'(12x,a)')record
+                call error(idnode,12)
+                
+              endif
+              
+            enddo
+            
+c     construction of atmolt table for solvation calculation
+            
+            if(lsolva)then
+              
+              do iatm=natmsr+1,natms
+                atmolt(iatm)=itmols
+              enddo
+              natmsr=natms
+              
+            endif
+            
+          enddo
+          
+c     construction of atm_fre table for free energy or excitation
+          
+          if(lfree.or.lexcite.or.lswitch)then
+            
+            atm_fre(:)=0
+            if((ind_fre(1).ne.0).and.(ind_fre(2).ne.0))then
+              
+              do iatm=ind_fre(1),ind_fre(2)
+                atm_fre(iatm)=1
+              enddo
+              
+            endif
+            
+            if((ind_fre(3).ne.0).and.(ind_fre(4).ne.0))then
+              
+              do iatm=ind_fre(3),ind_fre(4)
+                
+                atm_fre(iatm)=2
+                if(lghost)ntghost=ntghost+1
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+c     calculate system charge
+          
+          call check_syschg(idnode,ntpmls,sumchg)
+          
+c     read in the nonbonded potential energy parameters
+          
+        elseif(findstring('vdw',record,idum))then
+          
+          call define_van_der_waals
+     x      (safe,ltable,lunits,lmols,idnode,ntpvdw,
+     x      ntpatm,keyfce,dlrpot,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the metal potential energy parameters
+          
+        elseif(findstring('met',record,idum))then
+          
+          call define_metals
+     x      (safe,lunits,lmols,idnode,ntpmet,ntpatm,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the three body potential energy parameters
+          
+        elseif(findstring('tbp',record,idum))then
+          
+          call define_three_body
+     x      (safe,lunits,lmols,idnode,ntptbp,ntpatm,rcuttb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the tersoff potential energy parameters
+          
+        elseif(findstring('tersoff',record,idum))then
+          
+          call define_tersoff
+     x      (safe,lunits,lmols,idnode,ntpter,ntpatm,rctter,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the four body potential energy parameters
+          
+        elseif(findstring('fbp',record,idum))then
+          
+          call define_four_body
+     x      (safe,lunits,lmols,idnode,ntpfbp,ntpatm,
+     x      rcutfb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read external field data
+          
+        elseif(findstring('extern',record,idum))then
+          
+          call define_external_field
+     x      (safe,lunits,idnode,keyfld,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     normal end of FIELD file
+          
+        elseif(findstring('close',record,idum))then
+          
+          loop1=.false.
+          if(ntpvdw.eq.0.and.ntpmet.eq.0.and.
+     x      mod(keyfce,2).eq.1)call error(idnode,145)
+          
+c     error exit for unidentified directive
+          
+        else
+          
+          if(idnode.eq.0)write(nrite,'(100a)')record
+          call abort_field_read(2,idnode,nfield)
+          
+        endif
+        
+      enddo
+      
+c     close force field file
+      
+      if(idnode.eq.0)close (nfield)
+      
+      
+      if(lshl.and.idnode.eq.0)then
+        
+        if(keyshl.eq.1)write(nrite,
+     x    "(/,/,'adiabatic shell model in operation')")
+        
+        if(keyshl.eq.2)write(nrite,
+     x    "(/,/,'relaxed shell model in operation')")
+        
+      endif
+      
+      if(lshl.and.keyshl.eq.0)call error(idnode,1951)
+      
+c     if metadynamics and shell selected use only velocity verlet
+      
+      if(lshl.and.lmetadyn.and.keyver.eq.0)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to velocity verlet for metadynamics')")
+        keyver=1
+        
+      endif
+
+      return
+      end subroutine sysdef
+      
+      subroutine sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the configuration data file
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 atname(8)
+      
+      logical loglnk,safe,lneut,nolink,lfree,lfrmas
+      integer idnode,imcon,keyens,keyfce,keyres,levcfg,multt
+      integer ntpmls,i,indatm,indnam,indneu,k,ilx,ily,ilz
+      integer m,l,ncells,idum,mxnode
+      real(8) delr,rcut,volm,xcoord,ycoord,zcoord,totmas,xveloc
+      real(8) yveloc,zveloc,xforce,yforce,zforce,axx,rt3,xhi,yhi,zhi
+      real(8) width,dum1,dum2,test,com(3)
+      
+c     open the system input file
+      
+      if(idnode.eq.0)open (nconf,file='CONFIG')
+      
+c     read the CONFIG file header
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      call copystring(record,cfgname,80)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,1x,'configuration file name: ',/,/,10x,80a1)")cfgname
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      levcfg=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'selected image convention',6x,i10)")imcon
+      
+c     check config file contents for consistent data
+      
+      if((imcon.eq.0.or.imcon.eq.6).and.
+     x  (keyfce/2.eq.1.or.keyfce/2.eq.6))
+     x  call error(idnode,180)
+      
+      if(imcon.eq.0.and.(.not.lneut).and.(keyfce.gt.1)
+     x  .and.(multt.eq.1))call warning(idnode,30,0.d0,0.d0,0.d0)
+      
+      if(imcon.eq.0.and.(keyens.ge.4.and.keyens.le.7))
+     x  call error(idnode,390)
+      if(imcon.le.2.and.(keyens.eq.6.or.keyens.eq.7))imcon=3
+      if(keyres.gt.0.and.levcfg.lt.1)call error(idnode,85)
+      
+c     specify molecular dynamics simulation cell
+      
+      if(imcon.eq.0)then
+        
+c     if no periodic boundaries - set zero values for cell 
+c     vectors and cell volume
+        
+        cell(:)=0.d0
+        volm=0.d0
+        
+      else
+        
+c     read cell vectors
+        
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(1)=dblstr(record,lenrec,idum)
+        cell(2)=dblstr(record,lenrec,idum)
+        cell(3)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(4)=dblstr(record,lenrec,idum)
+        cell(5)=dblstr(record,lenrec,idum)
+        cell(6)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(7)=dblstr(record,lenrec,idum)
+        cell(8)=dblstr(record,lenrec,idum)
+        cell(9)=dblstr(record,lenrec,idum)
+        
+      endif
+      
+c     read the atomic coordinates
+      
+      indatm=0
+      indnam=0
+      indneu=0
+      safe=.true.
+      
+      do k=1,ntpmls
+        
+        do l=1,nummols(k)
+          
+          do m=1,numsit(k)
+            
+            indatm=indatm+1
+            
+            if(indatm.gt.mxatms)call error(idnode,45)
+            
+            xxx(indatm)=0.d0
+            yyy(indatm)=0.d0
+            zzz(indatm)=0.d0
+            vxx(indatm)=0.d0
+            vyy(indatm)=0.d0
+            vzz(indatm)=0.d0
+            fxx(indatm)=0.d0
+            fyy(indatm)=0.d0
+            fzz(indatm)=0.d0
+            
+            if(idnode.eq.0)then
+              
+              if(levcfg.eq.0)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                
+              elseif(levcfg.eq.1)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                
+              else
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                read(nconf,'(3f20.0)',end=100)xforce,yforce,zforce
+                
+              endif
+              
+c     strip blanks off atom name
+              
+              call strip(atname,8)
+              
+              if(sitnam(indnam+m).eq.mkwd8(atname))then
+                
+                xxx(indatm)=xcoord
+                yyy(indatm)=ycoord
+                zzz(indatm)=zcoord
+                
+                if(levcfg.gt.0)then
+                  
+                  vxx(indatm)=xveloc
+                  vyy(indatm)=yveloc
+                  vzz(indatm)=zveloc
+                  
+                endif
+                
+                if(levcfg.gt.1)then
+                  
+                  fxx(indatm)=xforce
+                  fyy(indatm)=yforce
+                  fzz(indatm)=zforce
+                  
+                endif
+                
+              else
+                
+                write(nrite,"(/,/,'unidentified atom label :',8a1,
+     x            ': atom number ',i5)")atname,indatm
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+            call gstate(safe)
+            if(.not.safe)call error(idnode,25)
+            
+            ltype(indatm)=ltpsit(indnam+m)
+            weight(indatm)=wgtsit(indnam+m)
+            chge(indatm)=chgsit(indnam+m)
+            atmnam(indatm)=sitnam(indnam+m)
+            lstfrz(indatm)=lfzsit(indnam+m)
+            if(lneut)lstneu(indatm)=nugrp(indnam+m)+indneu
+            
+c     reset atomic masses according to free energy definitions
+            
+            if(lfree)then
+
+              weight_sav(indatm)=weight(indatm)
+              
+              if(lfrmas)then
+                
+                if(indatm.ge.ind_fre(1).and.indatm.le.ind_fre(2))then
+                  weight(indatm)=lambda1*weight(indatm)
+                elseif(indatm.ge.ind_fre(3).and.indatm.le.ind_fre(4))
+     x              then
+                  weight(indatm)=lambda2*weight(indatm)
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          indneu=indneu+nugrp(indnam+numsit(k))
+          
+        enddo
+        
+        indnam=indnam+numsit(k)
+        
+      enddo
+      
+      if(mxnode.gt.1)then
+        
+        call gdsum(xxx,indatm,buffer)
+        call gdsum(yyy,indatm,buffer)
+        call gdsum(zzz,indatm,buffer)
+        
+        if(levcfg.gt.0)then
+          
+          call gdsum(vxx,indatm,buffer)
+          call gdsum(vyy,indatm,buffer)
+          call gdsum(vzz,indatm,buffer)
+          
+        endif
+        
+        if(levcfg.gt.1)then
+          
+          call gdsum(fxx,indatm,buffer)
+          call gdsum(fyy,indatm,buffer)
+          call gdsum(fzz,indatm,buffer)
+          
+        endif
+        
+      endif
+      
+c     check integrity of cell vectors : for cubic, TO and RD cases
+c     ie. cell(1)=cell(5)=cell(9) (or cell(9)/sqrt(2) for RD)
+      
+      if((imcon.eq.1).or.(imcon.eq.4).or.(imcon.eq.5))then
+        
+        axx=(abs(cell(1))+abs(cell(5)))/2.d0
+        test=1.d-8*axx
+        if(abs(cell(1)-axx).gt.test)call error(idnode,410)
+        if(abs(cell(5)-axx).gt.test)call error(idnode,410)
+        if(imcon.eq.5)then
+          if(abs(cell(9)-axx*sqrt(2.d0)).gt.test)
+     x      call error(idnode,410)
+        else
+          if(abs(cell(9)-axx).gt.test)call error(idnode,410)
+        endif
+        
+      endif
+      
+c     check integrity of hexagonal prism cell vectors
+      
+      if(imcon.eq.7)then
+        
+        rt3=sqrt(3.d0)
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,410)
+        
+      endif
+      
+c     check 2D PBC for imcon=6
+      
+      if(imcon.eq.6)then
+        
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     check for diagonal cell matrix if appropriate
+      
+      if((imcon.eq.1).or.(imcon.eq.2).or.(imcon.eq.4).or.
+     x  (imcon.eq.5).or.(imcon.eq.7))then
+        
+        if(abs(cell(2)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(4)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     put centre of mass at centre of coordinates if imcon=0
+      
+      if(imcon.eq.0)then
+        
+        totmas=getmass(indatm,idnode,mxnode)
+        call getcom(indatm,idnode,mxnode,totmas,com)
+        
+        do i=1,indatm
+          
+          xxx(i)=xxx(i)-com(1)
+          yyy(i)=yyy(i)-com(2)
+          zzz(i)=zzz(i)-com(3)
+          
+        enddo
+        
+      endif
+      
+c     set widths if unset - needed for check on link cells below
+      
+      if(imcon.eq.0.or.imcon.eq.6)then
+        
+        xhi=abs(xxx(1))
+        yhi=abs(yyy(1))
+        zhi=abs(zzz(1))
+        do i=2,indatm
+          
+          xhi=max(xhi,abs(xxx(i)))
+          yhi=max(yhi,abs(yyy(i)))
+          zhi=max(zhi,abs(zzz(i)))
+          
+        enddo
+        if(imcon.eq.0)then
+          
+          cell(1)=max(2.d0*xhi+rcut+delr,3.d0*(rcut+delr))
+          cell(5)=max(2.d0*yhi+rcut+delr,3.d0*(rcut+delr))
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+        if(imcon.eq.6.and.cell(9).lt.1.d-6)then
+          
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+      endif
+      
+c     calculate dimensional properties of simulation cell
+      
+      call dcell(cell,celprp)
+      
+      if(imcon.eq.0)then
+        
+        volm=0.d0
+        
+      elseif(imcon.eq.4)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.5)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.7)then
+        
+        volm=0.5d0*celprp(10)
+        
+      else
+        
+        volm=celprp(10)
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,/,1x,'simulation cell vectors'/,/)")
+        write(nrite,"(21x,3f12.6)")cell
+        
+        write(nrite,
+     x    "(/,/,1x,'system volume     ',2x,1p,g22.12)")volm
+        
+      endif
+      
+c     check value of cutoff and reset if necessary
+      
+      if(imcon.gt.0)then
+        
+        width=min(celprp(7),celprp(8),celprp(9))/2.d0
+        if(imcon.eq.4)width=sqrt(3.d0)*cell(1)/4.d0
+        if(imcon.eq.5)width=cell(1)/2.d0
+        if(imcon.eq.6)width=min(celprp(7),celprp(8))/2.d0
+        
+c     halt program if potential cutoff exceeds cell width
+        
+        if(rcut.gt.width)call error(idnode,95)
+        
+      endif
+      
+c     decide on whether to use link cells for verlet list constructor
+      
+      if(nolink)then
+        
+        loglnk=.false.
+        
+      else
+        
+        loglnk=.true.
+        
+        ilx=int(celprp(7)/(rcut+delr))
+        ily=int(celprp(8)/(rcut+delr))
+        ilz=int(celprp(9)/(rcut+delr))
+        if(ilx.lt.3.or.ily.lt.3.or.ilz.lt.3)loglnk=.false.
+        ncells=ilx*ily*ilz
+        if(lneut.and.ncells.le.36)loglnk=.false.
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)loglnk=.false.
+        if(loglnk.and.ncells.gt.mxcell)then
+          
+          dum1=dble(ncells)
+          dum2=dble(mxcell)
+          call warning(idnode,90,dum1,dum2,dum2)
+          loglnk=.false.
+          
+        endif
+        
+      endif
+      
+      if(loglnk.and.idnode.eq.0)
+     x  write(nrite,"(/,/,' link cell algorithm in use')")
+      
+      if(idnode.eq.0)close (nconf)
+      
+c     ensure PBC compliance of starting structure
+      
+      if(keyres.eq.0.and.imcon.gt.0)then
+        
+        call images(imcon,idnode,mxnode,indatm,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,indatm,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+      return
+      
+c     error exit for config file read
+      
+  100 call abort_config_read(2,idnode,nconf)
+      
+      end subroutine sysgen
+      
+      subroutine sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the REVIVE file data and 
+c     defining the initial thermodynamic and structural accumulators.
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzden,lfree,lsolva,lghost,lpsoc
+      integer idnode,imcon,keyfce,keyres,mxnode,natms,nstep,numacc
+      integer numrdf,ntpatm,nzden,i,j,k,ntpmet,ntshl,ntpvdw
+      real(8) chip,chit,conint,elrc,engunit,virlrc,rvdw,volm
+      real(8) dnumrd,dnstep,dnumac,dnzden,virtot,vircom,tboost
+      real(8) chit_shl
+      
+c     read or initialise accumulator arrays
+      
+      if(keyres.eq.1.and.idnode.eq.0)then
+        
+c     read accumulator data from dump file
+        
+        open(nrest,file='REVOLD',form='unformatted')
+        
+        read(nrest) dnstep,dnumac,dnumrd,chit,chip,conint,dnzden,
+     x    tboost,chit_shl
+        read(nrest) virtot,vircom,eta,strcns,strbod
+        read(nrest) stpval
+        read(nrest) sumval
+        read(nrest) ssqval
+        read(nrest) zumval
+        read(nrest) ravval
+        read(nrest) stkval
+        read(nrest) xx0,yy0,zz0
+        read(nrest) xxs,yys,zzs
+        
+        if(lgofr) read(nrest)rdf
+        if(lzden) read(nrest)zdens
+        
+        nstep=nint(dnstep)
+        numacc=nint(dnumac)
+        numrdf=nint(dnumrd)
+        nzden=nint(dnzden)
+        close (nrest)
+        
+      else
+         
+c     initialise step counters
+        
+        nstep=0
+        numacc=0
+        numrdf=0
+        nzden=0
+        
+c     initialise temperature and pressure coupling parameters
+c     and integral for conserved quantity
+        
+        chit=0.d0
+        chip=0.d0
+        conint=0.d0
+        virtot=0.d0
+        vircom=0.d0
+        chit_shl=0.d0
+        do i=1,9
+          
+          eta(i)=0.d0
+          strcns(i)=0.d0
+          strbod(i)=0.d0
+          
+        enddo
+        
+c     initialise accumulator arrays
+        
+        do i=1,mxnstk
+          
+          stpval(i)=0.d0
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          zumval(i)=0.d0
+          ravval(i)=0.d0
+          
+        enddo
+        
+        do i=1,mxatms
+          
+          xx0(i)=0.d0
+          yy0(i)=0.d0
+          zz0(i)=0.d0
+          xxs(i)=0.d0
+          yys(i)=0.d0
+          zzs(i)=0.d0
+          
+        enddo
+        
+        do j=1,mxnstk
+          
+          do i=1,mxstak
+            
+            stkval(i,j)=0.d0
+            
+          enddo
+          
+        enddo
+        
+        if(lgofr)then
+          
+          do i=1,mxxtyp
+            
+            do j=1,mxrdf
+              
+              rdf(j,i)=0.d0
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do i=1,mxatyp
+            
+            do j=1,mxzdn
+              zdens(j,i)=0.d0
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     put shells on cores at start
+      
+      if(lpsoc.and.keyres.ne.1.and.ntshl.gt.0)
+     x  call put_shells_on_cores(idnode,mxnode,ntshl)
+      
+c     if restart then broadcast stored variables via a global sum
+      
+      if(keyres.eq.1.and.mxnode.gt.1)then
+        
+        if(mxbuff.lt.natms.or.mxbuff.lt.mxnstk*mxstak)
+     x    call error(idnode,186)
+        
+        buffer(1)=chit
+        buffer(2)=chip
+        buffer(3)=conint
+        buffer(4)=dble(nstep)
+        buffer(5)=dble(numacc)
+        buffer(6)=dble(numrdf)
+        buffer(7)=dble(nzden)
+        buffer(8)=tboost
+        buffer(9)=virtot
+        buffer(10)=vircom
+        buffer(11)=chit_shl
+        call gdsum(buffer(1),11,buffer(12))
+        chit=buffer(1)
+        chip=buffer(2)
+        conint=buffer(3)
+        nstep=nint(buffer(4))
+        numacc=nint(buffer(5))
+        numrdf=nint(buffer(6))
+        nzden=nint(buffer(7))
+        tboost=buffer(8)
+        virtot=buffer(9)
+        vircom=buffer(10)
+        chit_shl=buffer(11)
+        
+        call gdsum(eta,9,buffer)
+        call gdsum(strcns,9,buffer)
+        call gdsum(strbod,9,buffer)
+        call gdsum(stpval,mxnstk,buffer)
+        call gdsum(sumval,mxnstk,buffer)
+        call gdsum(ssqval,mxnstk,buffer)
+        call gdsum(zumval,mxnstk,buffer)
+        call gdsum(ravval,mxnstk,buffer)    
+        call gdsum(stkval,mxnstk*mxstak,buffer)
+        call gdsum(xx0,natms,buffer)
+        call gdsum(yy0,natms,buffer)
+        call gdsum(zz0,natms,buffer)
+        call gdsum(xxs,natms,buffer)
+        call gdsum(yys,natms,buffer)
+        call gdsum(zzs,natms,buffer)
+        
+c     for rdf table - broadcast and normalise
+        
+        if(lgofr)then
+          
+          do k=1,mxxtyp
+            
+            call gdsum(rdf(1,k),mxrdf,buffer)
+            
+            do j=1,mxrdf
+              rdf(j,k)=rdf(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do k=1,mxatyp
+            
+            call gdsum(zdens(1,k),mxzdn,buffer)
+            
+            do j=1,mxzdn
+              zdens(j,k)=zdens(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     number densities and long-range corrections
+      
+      elrc=0.d0       
+      virlrc=0.d0
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=4.d0*pi/3.d0*rvdw**3
+      
+      call lrcorrect
+     x  (lsolva,lfree,lghost,idnode,imcon,keyfce,natms,
+     x  ntpatm,ntpvdw,elrc,engunit,virlrc,rvdw,volm)
+      
+      if(lmetab.or.ntpmet.eq.0)then
+        
+        elrcm(0)=0.d0
+        vlrcm(0)=0.d0
+        
+      else 
+        
+        call lrcmetal
+     x    (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+        
+      endif
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=0.d0
+      
+      return
+      end subroutine sysinit
+      
+      subroutine systemp
+     x  (idnode,imcon,keyres,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for setting the initial system temperature
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,imcon,keyres,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,ntshl,levcfg,i,io,k,keyshl
+      real(8) degfre,degshl,degrot,temp,tolnce,sigma,rsq
+      
+c     number of degrees of freedom 
+c     3 for com translation
+c     3 for angular momentum about origin (non-periodic systems only)
+      
+      degfre=dble(3*(ntfree-ntshl)-3-ntcons)+degfre
+      if(imcon.eq.0.or.imcon.eq.6)degfre=degfre-3.0d0
+      if(imcon.eq.0.or.imcon.eq.6)degrot=max(0.d0,degrot-3.0d0)
+      degshl=dble(3*ntshl)
+      
+c     lose one degree of freedom if temperature constrained
+c     gaussian constraints
+      
+c     if(keyens.eq.1)degfre=degfre-1.d0
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,' total degrees of freedom       ',f20.0,/,
+     x  ' rotational degrees of freedom  ',f20.0,/,
+     x  ' shell pseudo degrees of freedom',f20.0)")
+     x  degfre,degrot,degshl
+      if(degfre.lt.1.d0)call error(idnode,350)
+      
+c     define reciprocal masses of atoms
+      
+      do i=1,natms
+        
+        if(lstfrz(i).ne.0.or.weight(i).lt.1.d-6)then
+          
+          rmass(i)=0.d0
+          weight(i)=0.d0
+          
+        else
+          
+          rmass(i)=1.d0/weight(i)
+          
+        endif
+        
+      enddo
+      
+c     generate starting velocities
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+      if(keyres.eq.0)then
+        
+        call gauss(natms,vxx,vyy,vzz)
+        
+        do i=1,natms
+          
+          rsq=sqrt(rmass(i))
+          vxx(i)=vxx(i)*rsq
+          vyy(i)=vyy(i)*rsq
+          vzz(i)=vzz(i)*rsq
+          
+        enddo
+        
+        if(ntcons.gt.0)call quench
+     x    (imcon,idnode,mxnode,natms,nscons,tolnce)
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+        if(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      elseif(keyres.eq.1.or.keyres.eq.3)then 
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+      elseif(keyres.eq.2)then
+        
+        if(ngrp.gt.0)then 
+          
+          call vscaleg
+     x      (idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        elseif(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+c     print out sample of initial configuration 
+      
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'sample of starting configuration',/)")
+      
+      io=(natms+19)/20
+      if((levcfg.le.1).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',/,/)")
+      if((levcfg.eq.2).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',
+     x  7x,'fx(i)',7x,'fy(i)',7x,'fz(i)',/,/)")
+      
+      do i=1,natms,io
+        
+        if(levcfg.le.1)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),vxx(i),vyy(i),vzz(i)
+          
+        elseif(levcfg.eq.2)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),
+     x      vxx(i),vyy(i),vzz(i),fxx(i),fyy(i),fzz(i)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine systemp
+      
+      subroutine sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine  defining global bookkeeping
+c     arrays
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical loglnk,lneut,lshmov,lcnb,lsolva,lghost
+      integer idnode,imcon,mxnode,natms,nneut,ngrp,nscons,ntangl,i
+      integer ntbond,ntcons,ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,ii,isol,itmols,igsol,iggsol,natmsf,natmsl
+      integer ntghost,natms2
+      real(8) degfre,degrot
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     neutral group bookkeeping
+      
+      call neutbook(lneut,idnode,natms,nneut)
+      
+c     rigid body bookkeeping 
+      
+      call quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms2,ngrp,ntpmls,
+     x  ntfree,degfre,degrot)
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)+ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)+ngrp_ghost
+        
+      endif
+      
+c     construct list of excluded pair interactions
+      
+      if(lneut)then
+ 
+        call exclude(idnode,mxnode,natms,ntpmls)
+        call excludeneu(idnode,mxnode,nneut)
+        
+      elseif(.not.lneut)then
+        
+        call exclude(idnode,mxnode,natms,ntpmls)
+        
+        if(loglnk)then
+          
+          call exclude_link(idnode,mxnode,ntpmls)
+          
+        else
+          
+          call exclude_atom(idnode,mxnode,natms,ntpmls)
+          
+        endif
+        
+      endif
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)-ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)-ngrp_ghost
+        
+      endif
+      
+c     construct interaction lists for bonded forces
+      
+      call intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms2,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c     adaptations for solvation and excitation simulations
+      
+      if(lsolva.or.lghost)then
+                
+        natmsf=0
+        natmsl=0
+        natm_sol(:)=0
+        const_sol(:)=numcon(:)*nummols(:)
+        rigid_sol(:)=numgrp(:)*nummols(:)
+        
+        if(ngrp.eq.0)then
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstfrz(isol).eq.0)then
+                natm_sol(itmols)=natm_sol(itmols)+1
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+
+        else
+          
+          ii=1
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstgot_sol(ii).eq.isol)then
+                ii=ii+1
+              else
+                
+                if(lstfrz(isol).eq.0)then
+                  natm_sol(itmols)=natm_sol(itmols)+1
+                endif
+                
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+          
+          degrot_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          degfre_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          
+        endif
+        
+        if(lghost)natm_sol(mxtmls)=natm_sol(mxtmls)-ntghost
+        degfre_sol(:)=dble(3*(natm_sol(:))-const_sol(:))+degfre_sol(:)
+        
+      endif
+      
+      return
+      end subroutine sysbook
+      
+      subroutine define_units(idnode,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting energy units
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith august 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,idum,i
+      real(8) engunit
+      logical blank
+      
+      blank=.true.
+      
+      do i=6,lenrec
+        if(record(i).ne.' ')blank=.false.
+      enddo
+      
+      if(blank)then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal ',
+     x    'units ')")
+        
+      elseif(findstring('ev',record,idum))then
+        
+        engunit=9648.530821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=electron volts ')")
+        
+      elseif(findstring('kev',record,idum))then
+        
+        engunit=9648530.821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kilo electron volts ')")
+        
+      elseif(findstring('kcal',record,idum))then
+        
+        engunit=418.4d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kcal/ mol ')")
+        
+      elseif(findstring('kj',record,idum))then
+        
+        engunit=1.d2
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kjoule/mol ')")
+        
+      elseif(findstring('k',record,idum))then
+        
+        engunit=boltz
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kelvin ')")
+        
+      elseif(findstring('internal',record,idum))then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal',
+     x    ' units ')")
+        
+      else
+        
+        if(idnode.eq.0)write(nrite,'(a)')record
+        call error(idnode,5)
+        
+      endif
+      
+      return
+      end subroutine define_units
+      
+      subroutine quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree,
+     x  degfre,degrot)
+      
+c**************************************************************************
+c     
+c     dl_poly subroutine for setting up bookkeeping for rigid bodies
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c*************************************************************************
+      
+      implicit none
+      
+      logical safe,pass1,pass2,linear,lsolva
+      integer fail,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree
+      integer i,igrp,jgrp,kgrp,jr,jt,igrp1,igrp2,itmols,imols,lgrp,id
+      integer ii,jj,isite,k,kk,ill,i1,i2,i3,j,ngp,ifre1,ifre2,ig,ij
+      integer fngrp,lngrp
+      real(8) degfre,degrot,dnorm,a1,rtall,rotall,rot,aa,rotinr,bb,rot1
+      real(8) rsq,det,dettest,aq,bq,cq,dq,eq,fq,gq,hq,rnorm,tol,rotxyz
+      real(8) rotlim,rrr
+      
+      integer, allocatable :: ind(:,:),lstgot(:)
+      real(8), allocatable :: gaxs(:,:),rotmin(:),accum(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      dimension rot(9),aa(9),rotinr(3,3),bb(9),rot1(3,3),fail(5)
+      
+      data fail/0,0,0,0,0/
+      
+c     allocate working arrays
+      
+      allocate (ind(mxgrp,3),lstgot(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+      allocate (gaxs(mxungp,9),rotmin(mxungp),stat=fail(4))
+      allocate (accum(mxungp),stat=fail(5))
+      do i=1,5
+        if(fail(i).ne.0)call error(idnode,1790)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      igrp=0
+      jgrp=0
+      kgrp=0
+      isite=0
+      jr=0
+      jt=0
+      safe=.true.
+      degfre=0.d0
+      degrot=0.d0
+      
+c     rigid body identifier
+      
+      do i=1,natms
+        lstbod(i)=0
+      enddo
+      
+c     number of rigid groups in system
+      
+      ngrp=0
+      do itmols=1,ntpmls
+        ngrp=ngrp+nummols(itmols)*numgrp(itmols)
+      enddo
+      
+c     block indices for groups
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if(igrp.le.mxgrp)then
+              
+              lstgtp(igrp)=listyp(lgrp+kgrp)
+              id=listyp(lgrp+kgrp)
+              
+              if((igrp.ge.igrp1).and.(igrp.le.igrp2))then
+                
+                jgrp=jgrp+1
+                
+                do jj=1,numgsit(id)
+                  
+                  jr=jr+1
+                  jt=jt+1
+                  
+                  if(jr.le.mxatms.and.jt.le.mxatms)then
+                    
+                    lstrgd(jr)=lstgst(id,jj)+isite
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              else
+                
+                do jj=1,numgsit(id)
+                  
+                  jt=jt+1
+                  if(jt.le.mxatms)then
+                    
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            else
+              
+              safe=.false.
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,304)
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kgrp=kgrp+numgrp(itmols)
+        
+      enddo
+      
+      if(ngrp.eq.0)then
+        
+        j=0
+        do i=1,natms
+          
+          if(lstfrz(i).eq.0)then
+            
+            j=j+1
+            lstfre(j)=i
+            
+          endif
+          
+        enddo
+        ntfree=j
+        
+      else
+        
+c     centre of mass of groups
+c     assumes group dimensions are smaller than half box width
+        
+        do i=1,natms
+          lstme(i)=0
+        enddo
+        
+        do id=1,mxungp
+          gmass(id)=0.d0
+        enddo
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     working com is first site in group
+          
+          i=lstrgd(jr+1)
+          txx(ig)=xxx(i)
+          tyy(ig)=yyy(i)
+          tzz(ig)=zzz(i)
+          
+          id=lstgtp(ig)
+          safe=.false.
+          if(abs(gmass(id)).lt.1.d-10)safe=.true.
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            xxt(jr)=xxx(i)-txx(ig)
+            yyt(jr)=yyy(i)-tyy(ig)
+            zzt(jr)=zzz(i)-tzz(ig)
+            if(safe)gmass(id)=gmass(id)+weight(i)
+            
+          enddo
+          
+        enddo
+        
+c     minimum image from working com
+        
+        call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          gcmx(ig)=0.d0
+          gcmy(ig)=0.d0
+          gcmz(ig)=0.d0
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            gcmx(ig)=gcmx(ig)+weight(i)*xxt(jr)
+            gcmy(ig)=gcmy(ig)+weight(i)*yyt(jr)
+            gcmz(ig)=gcmz(ig)+weight(i)*zzt(jr)
+            
+          enddo
+          
+          gcmx(ig)=gcmx(ig)/gmass(id)+txx(ig)
+          gcmy(ig)=gcmy(ig)/gmass(id)+tyy(ig)
+          gcmz(ig)=gcmz(ig)/gmass(id)+tzz(ig)
+          
+        enddo
+        
+c     global communications
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+c     make sure all nodes have same copy of gmass
+        
+        if(mxnode.gt.1)then
+          
+          do id=1,mxungp
+            
+            accum(id)=0.d0
+            if(gmass(id).gt.0.d0)accum(id)=1.d0
+            
+          enddo
+          
+          call gdsum(gmass(1),mxungp,buffer(1))
+          call gdsum(accum(1),mxungp,buffer(1))
+          
+          do id=1,mxungp
+            
+            dnorm=max(1.d0,accum(id))
+            gmass(id)=gmass(id)/dnorm
+            
+          enddo
+          
+        endif
+        
+c     find a group of each type on this node to 
+c     find principal axis system of the group type
+        
+        do id=1,mxungp
+          
+          jr=0
+          ij=0
+          safe=.false.
+          
+          do while(.not.safe.and.ij.lt.ngrp)
+            
+            ij=ij+1
+            jr=jr+numgsit(lstgtp(ij))
+            if(lstgtp(ij).eq.id)safe=.true.
+            
+          enddo
+          
+          if(safe)then
+
+c     rotational inertia accumulator
+            
+            do k=1,3
+              
+              do kk=1,3
+                
+                rotinr(k,kk)=0.d0
+                
+              enddo
+              
+            enddo
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+              xxt(jr)=xxx(i)-gcmx(ij)
+              yyt(jr)=yyy(i)-gcmy(ij)
+              zzt(jr)=zzz(i)-gcmz(ij)
+              
+              call images(imcon,0,1,1,cell,xxt(jr),yyt(jr),zzt(jr))
+              
+              rotinr(1,1)=rotinr(1,1)+weight(i)*(xxt(jr)**2)
+              rotinr(1,2)=rotinr(1,2)+weight(i)*xxt(jr)*yyt(jr)
+              rotinr(1,3)=rotinr(1,3)+weight(i)*xxt(jr)*zzt(jr)
+              rotinr(2,2)=rotinr(2,2)+weight(i)*(yyt(jr)**2)
+              rotinr(2,3)=rotinr(2,3)+weight(i)*yyt(jr)*zzt(jr)
+              rotinr(3,3)=rotinr(3,3)+weight(i)*(zzt(jr)**2)
+              
+            enddo
+            
+            rotinr(2,1)=rotinr(1,2)
+            rotinr(3,1)=rotinr(1,3)
+            rotinr(3,2)=rotinr(2,3)
+            
+            call jacobi(rotinr,rot1,3)
+            
+            rot(1)=rot1(1,1)
+            rot(4)=rot1(2,1)
+            rot(7)=rot1(3,1)
+            rot(2)=rot1(1,2)
+            rot(5)=rot1(2,2)
+            rot(8)=rot1(3,2)
+            rot(3)=rot1(1,3)
+            rot(6)=rot1(2,3)
+            rot(9)=rot1(3,3)
+            
+c     rotational inertia accumulators
+            
+            rotinx(id,1)=0.d0
+            rotiny(id,1)=0.d0
+            rotinz(id,1)=0.d0
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+c     site positions in principal axis system
+              
+              gxx(id,j)=rot(1)*xxt(jr)+rot(4)*yyt(jr)+rot(7)*zzt(jr)
+              gyy(id,j)=rot(2)*xxt(jr)+rot(5)*yyt(jr)+rot(8)*zzt(jr)
+              gzz(id,j)=rot(3)*xxt(jr)+rot(6)*yyt(jr)+rot(9)*zzt(jr)
+              
+c     impose rounding 
+              
+              if(abs(gxx(id,j)).lt.1.d-8)gxx(id,j)=0.d0
+              if(abs(gyy(id,j)).lt.1.d-8)gyy(id,j)=0.d0
+              if(abs(gzz(id,j)).lt.1.d-8)gzz(id,j)=0.d0
+              
+c     rotational inertia tensor of group type
+              
+              rotinx(id,1)=rotinx(id,1)+
+     x          weight(i)*(gyy(id,j)**2+gzz(id,j)**2)
+              rotiny(id,1)=rotiny(id,1)+
+     x          weight(i)*(gzz(id,j)**2+gxx(id,j)**2)
+              rotinz(id,1)=rotinz(id,1)+
+     x          weight(i)*(gxx(id,j)**2+gyy(id,j)**2)
+              
+            enddo
+            
+c     set axis system such that: Ixx >=Iyy >=Izz
+            
+            rotxyz=max(rotinx(id,1),rotiny(id,1),rotinz(id,1))
+            
+            if(rotxyz.ge.rotinx(id,1))then
+              
+              if(rotiny(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gyy(id,j)
+                  gyy(id,j)=-a1
+                  
+                enddo
+                
+                rotiny(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              elseif(rotinz(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gzz(id,j)
+                  gzz(id,j)=-a1
+                  
+                enddo
+                
+                rotinz(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              endif
+              
+            endif
+            
+            if(rotinz(id,1).gt.rotiny(id,1))then
+              
+              do j=1,numgsit(id)
+                
+                a1=gyy(id,j)
+                gyy(id,j)=gzz(id,j)
+                gzz(id,j)=-a1
+                
+              enddo
+              
+              a1=rotinz(id,1)
+              rotinz(id,1)=rotiny(id,1)
+              rotiny(id,1)=a1
+              
+            endif
+            
+c     set up principal axis system in terms of site positions
+            
+c     test for (near) linear unit
+            
+            ill=0
+            rtall=(rotinx(id,1)+rotiny(id,1)+rotinz(id,1))
+            
+            if(rtall.gt.1.d-5)then
+              rotall=rtall
+            else
+              rotall=1.d0
+            endif
+            
+            rotmin(id)=min(rotinx(id,1),rotiny(id,1))
+            rotmin(id)=min(rotmin(id),rotinz(id,1))/rotall
+            
+            if((rotinx(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotiny(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotinz(id,1)/rotall).lt.1.d-5)ill=ill+1
+            
+            if(ill.ge.2)then
+
+c     point particle only
+              
+              ind(id,1)=1
+              ind(id,2)=1
+              ind(id,3)=1
+              
+              do jj=1,9
+                gaxs(id,jj)=0.d0
+              enddo
+              
+            elseif(ill.eq.1)then
+              
+c     linear molecule
+              
+              ind(id,1)=1
+              ind(id,2)=2
+              ind(id,3)=1
+              
+              aa(1)=gxx(id,1)-gxx(id,2)
+              aa(4)=gyy(id,1)-gyy(id,2)
+              aa(7)=gzz(id,1)-gzz(id,2)
+              rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+              
+              if(abs(aa(7)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(7)**2)
+                aa(2)=0.d0
+                aa(5)=aa(7)/rsq
+                aa(8)=-aa(4)/rsq
+                
+              elseif(abs(aa(4)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(1)**2)
+                aa(2)=-aa(4)/rsq
+                aa(5)=aa(1)/rsq
+                aa(8)=0.d0
+                
+              elseif(abs(aa(1)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(1)**2+aa(7)**2)
+                aa(2)=-aa(7)/rsq
+                aa(5)=0.d0
+                aa(8)=aa(1)/rsq
+                
+              endif
+              
+              aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+              aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+              aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+              
+              call invert(aa,bb,det)
+              
+              if(abs(det).lt.1.d-5)call error(idnode,306)
+              
+              do j=1,9
+                gaxs(id,j)=bb(j)
+              enddo
+              
+            elseif(ill.eq.0)then
+              
+c     non-linear molecule
+              
+              i1=1
+              i2=1
+              i3=1
+              pass1=.true.
+              dettest=1.d-1
+              
+              do while(pass1.and.i2.lt.numgsit(id)-1)
+                
+                i2=i2+1
+                i3=i2
+                pass2=.true.
+                
+                do while(pass2.and.i3.lt.numgsit(id))
+                  
+                  i3=i3+1
+                  
+                  aa(1)=gxx(id,i1)-gxx(id,i2)
+                  aa(4)=gyy(id,i1)-gyy(id,i2)
+                  aa(7)=gzz(id,i1)-gzz(id,i2)
+                  aa(2)=gxx(id,i1)-gxx(id,i3)
+                  aa(5)=gyy(id,i1)-gyy(id,i3)
+                  aa(8)=gzz(id,i1)-gzz(id,i3)
+                  aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+                  aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+                  aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+                  
+c     invert matrix
+                  
+                  call invert(aa,bb,det)
+                  
+c     check on size of determinant - to see if the 3 sites are
+c     too close to being linear for safety.
+                  
+                  pass2=abs(det).lt.dettest
+                  
+                enddo
+                
+                pass1=abs(det).lt.dettest
+                
+              enddo
+              
+              if(abs(det).lt.dettest)call error(idnode,306)
+              
+c     store indices used
+              
+              ind(id,1)=i1
+              ind(id,2)=i2
+              ind(id,3)=i3
+              
+c     store coefficients 
+              
+              do j=1,9
+                
+                gaxs(id,j)=bb(j)
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     check that rigid unit does not contain frozen atoms
+        
+        safe=.true.
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            if(lstfrz(i).ne.0)safe=.false.
+            
+          enddo
+          
+        enddo
+        
+c     global check on error condition
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,360)
+        
+c     quaternions for all rigid groups in system
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          i1=lstrgd(jr+ind(id,1))
+          i2=lstrgd(jr+ind(id,2))
+          i3=lstrgd(jr+ind(id,3))
+          
+          jr=jr+numgsit(id)
+          
+c     group basis vectors
+          
+          aa(1)=xxx(i1)-xxx(i2)
+          aa(4)=yyy(i1)-yyy(i2)
+          aa(7)=zzz(i1)-zzz(i2)
+          
+          call images(imcon,0,1,1,cell,aa(1),aa(4),aa(7))
+          
+          if(rotmin(id).gt.1.d-5)then
+            
+            aa(2)=xxx(i1)-xxx(i3)
+            aa(5)=yyy(i1)-yyy(i3)
+            aa(8)=zzz(i1)-zzz(i3)
+            
+          else
+            
+            rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+            
+            if(abs(aa(7)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(7)**2)
+              aa(2)=0.d0
+              aa(5)=aa(7)/rsq
+              aa(8)=-aa(4)/rsq
+              
+            elseif(abs(aa(4)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(1)**2)
+              aa(2)=-aa(4)/rsq
+              aa(5)=aa(1)/rsq
+              aa(8)=0.d0
+              
+            elseif(abs(aa(1)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(1)**2+aa(7)**2)
+              aa(2)=-aa(7)/rsq
+              aa(5)=0.d0
+              aa(8)=aa(1)/rsq
+              
+            endif
+            
+          endif
+          
+          call images(imcon,0,1,1,cell,aa(2),aa(5),aa(8))
+          
+          aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+          aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+          aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+          
+c     group rotational matrix
+          
+          rot(1)=gaxs(id,1)*aa(1)+gaxs(id,4)*aa(2)+gaxs(id,7)*aa(3)
+          rot(2)=gaxs(id,2)*aa(1)+gaxs(id,5)*aa(2)+gaxs(id,8)*aa(3)
+          rot(3)=gaxs(id,3)*aa(1)+gaxs(id,6)*aa(2)+gaxs(id,9)*aa(3)
+          rot(4)=gaxs(id,1)*aa(4)+gaxs(id,4)*aa(5)+gaxs(id,7)*aa(6)
+          rot(5)=gaxs(id,2)*aa(4)+gaxs(id,5)*aa(5)+gaxs(id,8)*aa(6)
+          rot(6)=gaxs(id,3)*aa(4)+gaxs(id,6)*aa(5)+gaxs(id,9)*aa(6)
+          rot(7)=gaxs(id,1)*aa(7)+gaxs(id,4)*aa(8)+gaxs(id,7)*aa(9)
+          rot(8)=gaxs(id,2)*aa(7)+gaxs(id,5)*aa(8)+gaxs(id,8)*aa(9)
+          rot(9)=gaxs(id,3)*aa(7)+gaxs(id,6)*aa(8)+gaxs(id,9)*aa(9)
+          
+c     determine quaternions from rotational matrix
+          
+          aq=rot(1)+rot(5)
+          bq=rot(2)-rot(4)
+          cq=rot(6)-rot(8)
+          dq=rot(2)+rot(4)
+          eq=rot(3)+rot(7)
+          fq=rot(6)+rot(8)
+          gq=rot(3)-rot(7)
+          hq=rot(1)-rot(5)
+          
+          q0(ig)=0.5d0*sqrt(aq+sqrt(aq*aq+bq*bq))
+          
+          if(q0(ig).gt.1.d-4)then
+            
+            q1(ig)=-0.25d0*cq/q0(ig)
+            q2(ig)=0.25d0*gq/q0(ig)
+            q3(ig)=-0.25d0*bq/q0(ig)
+            
+          else
+            
+            q1(ig)=0.5d0*sqrt(hq+sqrt(hq*hq+dq*dq))
+            
+            if(q1(ig).gt.1.d-4)then
+              
+              q2(ig)=0.25d0*dq/q1(ig)
+              q3(ig)=0.25d0*eq/q1(ig)
+              
+            else
+              
+              q2(ig)=0.5d0*sqrt(-hq+sqrt(hq*hq+dq*dq))
+              
+              if(q2(ig).gt.1.d-4)then
+                
+                q3(ig)=0.25d0*fq/q2(ig)
+                
+              else
+                
+                q3(ig)=1.d0
+                
+              endif
+              
+            endif
+            
+          endif
+          
+c     normalise quaternions
+          
+          rnorm=1.d0/sqrt(q0(ig)**2+q1(ig)**2+q2(ig)**2+q3(ig)**2)
+          q0(ig)=rnorm*q0(ig)
+          q1(ig)=rnorm*q1(ig)
+          q2(ig)=rnorm*q2(ig)
+          q3(ig)=rnorm*q3(ig)
+          
+        enddo
+        
+c     test for redundant degrees of freedom
+c     and ensure rotational inertias are non-zero
+        
+        degrot=0.d0
+        
+        if(lsolva)then
+          degrot_sol(:)=0.d0
+        endif
+        
+        do ig=1,ngrp
+          
+          id=lstgtp(ig)
+          rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))
+          
+          if(rotall*rotinx(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotiny(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotinz(id,1).lt.1d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+        enddo
+        
+c     rotational degrees of freedom and rigid body contribution
+c     to total degrees of freedom
+        
+        degrot=degrot+dble(ngrp)*3.d0
+        degfre=degrot+dble(ngrp)*3.d0
+        
+        if(lsolva)then
+          
+          fngrp=1
+          lngrp=0
+          
+          do itmols=1,mxtmls
+            
+            lngrp=lngrp+nummols(itmols)*numgrp(itmols)
+            
+            do ig=fngrp,lngrp
+              
+              id=lstgtp(ig)
+              rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x          rotinz(id,1))
+              
+              if(rotall*rotinx(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotiny(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotinz(id,1).lt.1d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+            enddo
+            
+            fngrp=lngrp+1
+            
+          enddo
+          
+        endif
+        
+c     summarise results
+        
+        if(idnode.eq.0)then
+          
+          if(gmass(1).gt.0.d0)then
+            
+            write(nrite,'(/,/,12x,a)')' summary of rigid body set up'
+            
+            do id=1,mxungp
+              
+              if(gmass(id).gt.0.d0)then
+                
+                write(nrite,'(/,a,i10)')' group of type ',id
+                write(nrite,'(12x,a,f20.10)')' total mass    ',
+     x            gmass(id)
+                write(nrite,'(12x,a,3f20.10)')' rot. inertia  ',
+     x            rotinx(id,1),rotiny(id,1),rotinz(id,1)
+                write(nrite,'(/,12x,a,3(8x,a7))')' site','a coord',
+     x            'b coord','c coord'
+                do j=1,numgsit(id)
+                  write(nrite,'(12x,i5,1p,3e15.5)')j,gxx(id,j),
+     x              gyy(id,j),gzz(id,j)
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+c     find number of unique groups 
+        
+        ngp=0
+        do ig=1,ngrp
+          ngp=max(ngp,lstgtp(ig))
+        enddo
+        
+c     calculate reciprocal of rotational inertias 
+        
+        do id=1,ngp
+          
+          rotlim=max(1.d-2,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))*1.d-5
+          
+          if(rotinx(id,1).lt.rotlim)then
+            rotinx(id,2)=0.d0
+          else
+            rotinx(id,2)=1.d0/rotinx(id,1)
+          endif
+          
+          if(rotiny(id,1).lt.rotlim)then
+            rotiny(id,2)=0.d0
+          else
+            rotiny(id,2)=1.d0/rotiny(id,1)
+          endif
+          
+          if(rotinz(id,1).lt.rotlim)then
+            rotinz(id,2)=0.d0
+          else
+            rotinz(id,2)=1.d0/rotinz(id,1)
+          endif
+          
+        enddo
+        
+c     Check of quaternion set up with atomic positions
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     group type
+          
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+          rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+          rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+          rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+          rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+          rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+          rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+          rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+          rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxt(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x        rot(3)*gzz(id,j)+gcmx(ig)
+            yyt(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x        rot(6)*gzz(id,j)+gcmy(ig)
+            zzt(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x        rot(9)*gzz(id,j)+gcmz(ig)
+            
+            
+            txx(jr)=xxx(i)-xxt(i)
+            tyy(jr)=yyy(i)-yyt(i)
+            tzz(jr)=zzz(i)-zzt(i)
+            
+          enddo
+          
+        enddo
+        
+        call images(imcon,0,1,jr,cell,txx,tyy,tzz)
+        
+c     set tolerance for testing quaternion setup.
+        
+        rsq=0.d0
+        tol=1.d-2
+        
+        do i=1,jr
+          
+          rrr=txx(i)**2+tyy(i)**2+tzz(i)**2
+          if(rrr.gt.tol)then 
+            
+            rsq=rrr
+            
+          endif
+          
+        enddo
+        
+c     exit if error in set up
+        
+        safe=.true.
+        if(rsq.gt.tol)safe=.false.
+        if(mxnode.gt.1)call gstate(safe)
+        
+        if(.not.safe)call  error(idnode,310)
+        
+c     sort lstgot into ascending order
+        
+        call shellsort(jt,lstgot)
+        
+c     check that no site is in more than 1 rigid group
+        
+        i=1
+        safe=.true.
+        do while(i.lt.jt)
+          
+          i=i+1
+          linear=.true.
+          do while(linear)
+            
+            linear=.false.
+            
+            if(lstgot(i).eq.lstgot(i-1))then
+              
+              linear=.true.
+              safe=.false.
+              jt=jt-1
+              
+              do j=i,jt
+                lstgot(j)=lstgot(j+1)
+              enddo
+              
+            endif
+            
+            if(i.ge.jt)linear=.false.
+            
+          enddo
+          
+        enddo
+        
+        if(.not.safe)call error(idnode,320)
+        
+c     list of 'free' sites
+        
+        ii=1
+        jj=0
+        do i=1,natms
+          
+          if(lstgot(ii).eq.i)then
+            
+            ii=ii+1
+            
+          else
+            
+            if(lstfrz(i).eq.0)then
+              jj=jj+1
+              lstfre(jj)=i
+            endif
+            
+          endif
+          
+        enddo
+        
+c     number of free sites
+        
+        ntfree=jj
+        
+c     list of atoms integrated on this node
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          jr=jr+numgsit(id)
+          
+        enddo
+        
+        do i=1,jr
+          lstme(i)=lstrgd(i)
+        enddo
+        
+c     block parameters for free atoms
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+        do i=ifre1,ifre2
+          
+          jr=jr+1
+          lstme(jr)=lstfre(i)
+          
+        enddo
+        
+c     exchange quaternion data with other nodes
+        
+        if(mxnode.gt.1)call merge4
+     x    (idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+      if(lsolva)lstgot_sol(:)=lstgot(:)
+      
+c     deallocate work arrays
+      
+      deallocate (ind,lstgot,stat=fail(1))
+      deallocate (txx,tyy,tzz,stat=fail(2))
+      deallocate (xxt,yyt,zzt,stat=fail(3))
+      deallocate (gaxs,rotmin,stat=fail(4))
+      deallocate (accum,stat=fail(5))
+      
+      return
+      end subroutine quatbook
+      
+      subroutine abort_field_read(kode,idnode,nfield)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting FIELD file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nfield
+      
+      if(idnode.eq.0)close (nfield)
+      
+      if(kode.eq.1)then
+        
+c     end of field file error exit
+        
+        call error(idnode,52)
+        
+      elseif(kode.eq.2)then
+        
+c     unrecognised directive in field file
+        
+        call error(idnode,4)
+        
+      endif
+      
+      return
+      end subroutine abort_field_read
+      
+      subroutine abort_control_read(kode,idnode,nread)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nread
+      
+      if(idnode.eq.0)close (nread)
+      
+      if(kode.eq.1)then
+        
+c     end of control file error exit
+        
+        call error(idnode,53)
+        
+      elseif(kode.eq.2)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,0)
+        
+      endif
+      
+      return
+      end subroutine abort_control_read
+      
+      subroutine abort_config_read(kode,idnode,nconf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nconf
+      
+      if(idnode.eq.0)close (nconf)
+      
+      if(kode.eq.1)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,54)
+        
+      elseif(kode.eq.2)then
+        
+c     end of config file error exit
+        
+        call error(idnode,55)
+        
+      endif
+      
+      return
+      end subroutine abort_config_read
+      
+      subroutine neutbook(lneut,idnode,natms,nneut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for neutral group bookkeeping
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lneut,safe
+      integer idnode,natms,nneut,i
+      
+      safe=.true.
+      
+c     neutral group bookkeeping: sites must be listed consecutively
+      
+      if(lneut)then
+        
+        if(lstneu(1).ne.1)call error(idnode,230)
+        
+        neulst(1)=1
+        nneut=1
+        
+        do i=2,natms
+          
+          safe=.false.
+          if(lstneu(i).eq.lstneu(i-1))safe=.true.
+          if(lstneu(i).eq.lstneu(i-1)+1)then
+            
+            safe=.true.
+            nneut=nneut+1
+            if(nneut.gt.mxneut)call error(idnode,220)
+            neulst(nneut)=i
+            
+          endif
+          
+          if(.not.safe)call error(idnode,230)
+          
+        enddo
+        
+        neulst(nneut+1)=natms+1
+        
+      endif
+      
+      return
+      
+      end subroutine neutbook
+      
+      subroutine intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the interaction lists
+c     for the entire simulated system
+c     
+c     parallel replicated dat version : block data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        july 1992
+c     amended   - t.forester      oct 1993
+c     amended   - t.forester      dec 1994 : block data
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov,safe1,lcnb,lchk,lfail
+      integer idnode,mxnode,natms,nscons,ntangl,ntbond,ntcons
+      integer ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf
+      integer ibonds,jbonds,kbonds,ipmf,jpmf,iangle,jangle,kangle
+      integer idihed,jdihed,kdihed,iinver,jinver,kinver,iteths
+      integer jteths,kteths,ishels,jshels,kshels,ntbon0,ntpmf0
+      integer ntang0,ntdih0,ntinv0,nttet0,ntshl0,ntcon0,idum
+      integer itmols,isite,iconst,jconst,kconst,ibnd1,ibnd2,ipmf1
+      integer ipmf2,iang1,iang2,idih1,idih2,iinv1,iinv2,itet1
+      integer itet2,ishl1,ishl2,imols,lbonds,lpmf,jj,nnn,langle
+      integer ldihed,linver,lteths,lshels,i,ii,ntmp,klo,khi,ngrp
+      integer klo0,ifail,iloop,nnode,nscons0,nscons1,icon,fail
+      integer kcons,id,jdnode,lconst,itry,iatom,jatom,j,nfail
+      real(8) tol
+      
+      integer, allocatable :: itest(:),index(:),kscons(:)
+      integer, allocatable :: msite(:),mconst(:),listin(:)
+      
+      dimension fail(4)
+      
+      data fail/0,0,0,0/
+      
+c     allocate work arrays
+      
+      allocate (itest(mxtmls),index(mxtmls),stat=fail(1))
+      allocate (msite(mxtmls),mconst(mxtmls),stat=fail(2))
+      allocate (listin(mxatms),stat=fail(3))
+      allocate (kscons(0:mxproc-1),stat=fail(4))
+      do i=1,4
+        if(fail(i).ne.0)call error(idnode,1800)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      ibonds=0
+      jbonds=0
+      kbonds=0
+      ipmf=0
+      jpmf=0
+      iangle=0
+      jangle=0
+      kangle=0
+      idihed=0
+      jdihed=0
+      kdihed=0
+      iinver=0
+      jinver=0
+      kinver=0
+      iteths=0
+      jteths=0
+      kteths=0
+      ishels=0
+      jshels=0
+      kshels=0
+      safe=.true.
+      safe1=.true.
+      
+c     find total number of bonds,pmf constraints,bond constraints,
+c     angles,dihedrals,inversions, tethers,core-shells, in system 
+c     - ignoring frozen atoms
+      
+      ntbon0=0
+      ntpmf0=0
+      ntcon0=0
+      ntang0=0
+      ntdih0=0
+      ntinv0=0
+      nttet0=0
+      ntshl0=0
+      nscons=0
+      ntcons=0
+      
+      do itmols=1,ntpmls
+        
+        ntbon0=ntbon0+nummols(itmols)*numbonds(itmols)
+        ntpmf0=ntpmf0+nummols(itmols)*numpmf(itmols)
+        ntcon0=ntcon0+nummols(itmols)*numcon(itmols)
+        ntang0=ntang0+nummols(itmols)*numang(itmols)
+        ntdih0=ntdih0+nummols(itmols)*numdih(itmols)
+        ntinv0=ntinv0+nummols(itmols)*numinv(itmols)
+        nttet0=nttet0+nummols(itmols)*numteth(itmols)
+        ntshl0=ntshl0+nummols(itmols)*numshl(itmols)
+        
+      enddo
+      
+      isite=0
+      iconst=0
+      jconst=0
+      kconst=0
+      
+c     first and last index of bonds, angles etc for this node
+      
+      ibnd1=(idnode*ntbon0)/mxnode+1
+      ibnd2=((idnode+1)*ntbon0)/mxnode
+      
+      ipmf1=(idnode*ntpmf0)/mxnode+1
+      ipmf2=((idnode+1)*ntpmf0)/mxnode
+      ntpmf=ntpmf0
+      nspmf=ipmf2+1-ipmf1
+      
+      iang1=(idnode*ntang0)/mxnode+1
+      iang2=((idnode+1)*ntang0)/mxnode
+      
+      idih1=(idnode*ntdih0)/mxnode+1
+      idih2=((idnode+1)*ntdih0)/mxnode
+      
+      iinv1=(idnode*ntinv0)/mxnode+1
+      iinv2=((idnode+1)*ntinv0)/mxnode
+      
+      itet1=(idnode*nttet0)/mxnode+1
+      itet2=((idnode+1)*nttet0)/mxnode
+      
+      ishl1=(idnode*ntshl0)/mxnode+1
+      ishl2=((idnode+1)*ntshl0)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct bond constraint list later
+c     construct chemical bond interaction list
+          
+          do lbonds=1,numbonds(itmols)
+            
+            ibonds=ibonds+1
+            
+            if(ibonds.ge.ibnd1.and.ibonds.le.ibnd2)then
+              
+              jbonds=jbonds+1
+              if(jbonds.le.mxbond)then
+                
+                listbnd(jbonds,1)=lbonds+kbonds
+                listbnd(jbonds,2)=lstbnd(lbonds+kbonds,1)
+     x            +isite
+                listbnd(jbonds,3)=lstbnd(lbonds+kbonds,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,31)
+          
+c     construct pmf site lists - no exclusions
+          
+          do lpmf=1,numpmf(itmols)
+            
+            ipmf=ipmf+1
+            
+            if(ipmf.ge.ipmf1.and.ipmf.le.ipmf2)then
+              
+              jpmf=jpmf+1
+              if(jpmf.le.mspmf)then
+                
+                nnn=npmf(1)+npmf(2)
+                if(nnn.le.mxspmf)then
+                  
+                  do jj=1,npmf(1)+npmf(2)
+                    lstpmf(jj,jpmf)=indpmf(jj)+isite
+                  enddo
+                  
+                else
+                  
+                  safe=.false.
+                  
+                endif
+                
+              else
+                
+                safe1=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe1)
+          if(.not.safe1)call error(idnode,458)
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,460)
+          
+c     construct valence angle interaction list
+          
+          do langle=1,numang(itmols)
+            
+            iangle=iangle+1
+            
+            if(iangle.ge.iang1.and.iangle.le.iang2)then
+              
+              jangle=jangle+1
+              if(jangle.le.mxangl)then
+                
+                listang(jangle,1)=langle+kangle
+                listang(jangle,2)=lstang(langle+kangle,1)
+     x            +isite
+                listang(jangle,3)=lstang(langle+kangle,2)
+     x            +isite
+                listang(jangle,4)=lstang(langle+kangle,3)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,51)
+          
+c     construct dihedral angle interaction list
+          
+          do ldihed=1,numdih(itmols)
+            
+            idihed=idihed+1
+            
+            if(idihed.ge.idih1.and.idihed.le.idih2)then
+              
+              jdihed=jdihed+1
+              if(jdihed.le.mxdihd)then
+                
+                listdih(jdihed,1)=ldihed+kdihed
+                listdih(jdihed,2)=lstdih(ldihed+kdihed,1)
+     x            +isite
+                listdih(jdihed,3)=lstdih(ldihed+kdihed,2)
+     x            +isite
+                listdih(jdihed,4)=lstdih(ldihed+kdihed,3)
+     x            +isite
+                listdih(jdihed,5)=lstdih(ldihed+kdihed,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,61)
+          
+c     construct inversion potential list
+          
+          do linver=1,numinv(itmols)
+            
+            iinver=iinver+1
+            
+            if(iinver.ge.iinv1.and.iinver.le.iinv2)then
+              
+              jinver=jinver+1
+              if(jinver.le.mxinv)then
+                
+                listinv(jinver,1)=linver+kinver
+                listinv(jinver,2)=lstinv(linver+kinver,1)
+     x            +isite
+                listinv(jinver,3)=lstinv(linver+kinver,2)
+     x            +isite
+                listinv(jinver,4)=lstinv(linver+kinver,3)
+     x            +isite
+                listinv(jinver,5)=lstinv(linver+kinver,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,77)
+          
+c     construct tethered atoms interaction list
+          
+          do lteths=1,numteth(itmols)
+            
+            iteths=iteths+1
+            
+            if(iteths.ge.itet1.and.iteths.le.itet2)then
+              
+              jteths=jteths+1
+              if(jteths.le.msteth)then
+                
+                listtet(jteths,1)=lteths+kteths
+                listtet(jteths,2)=lsttet(lteths+kteths)+isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,63)
+          
+c     construct core-shell list
+          
+          do lshels=1,numshl(itmols)
+            
+            ishels=ishels+1
+            
+            if(ishels.ge.ishl1.and.ishels.le.ishl2)then
+              
+              jshels=jshels+1
+              if(jshels.le.mxshl)then
+                
+                listshl(jshels,1)=lshels+kshels
+                listshl(jshels,2)=lstshl(lshels+kshels,1)
+     x            +isite
+                listshl(jshels,3)=lstshl(lshels+kshels,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,59)
+          
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kbonds=kbonds+numbonds(itmols)
+        kangle=kangle+numang(itmols)
+        kdihed=kdihed+numdih(itmols)
+        kinver=kinver+numinv(itmols)
+        kteths=kteths+numteth(itmols)
+        kshels=kshels+numshl(itmols)
+        
+      enddo
+      
+c     store array counters for bookkeeping
+      
+      ntbond=ibonds
+      ntangl=iangle
+      ntdihd=idihed
+      ntinv=iinver
+      ntteth=iteths
+      ntshl=ishels
+      
+c     pass bond constraint information to other nodes
+      
+      if(ntcon0.gt.0)then
+        
+        ntcons=ntcon0
+        
+c     find starting site no. and constraint no. for each molec. type
+        
+        msite(1)=0
+        mconst(1)=0
+        
+        do itmols=2,ntpmls
+          
+          msite(itmols)=msite(itmols-1)+numsit(itmols-1)*
+     x      nummols(itmols-1)
+          mconst(itmols)=mconst(itmols-1)+numcon(itmols-1)
+          
+        enddo
+        
+c     sort molecules into ascending order of number of constraints
+        
+        do i=1,ntpmls
+          
+          itest(i)=numcon(i)
+          index(i)=0
+          
+        enddo
+        
+        call shellsort(ntpmls,itest)
+        
+        do i=1,ntpmls
+          
+          lchk=.true.
+          do j=1,ntpmls
+            
+            if(itest(i).eq.numcon(j))then
+              
+              if(lchk)then 
+                index(i)=j
+                lchk=.false.
+                
+              endif
+              
+              do ii=1,i-1
+                if(index(ii).eq.j)lchk=.true.
+              enddo
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     load balance to within 10%
+        
+        tol=1.0d0+(0.10d0)/2.d0
+        kcons=(ntcons)/mxnode
+        ntmp=0
+        
+c     find smallest constrained molecule to allocate to a node
+        
+        do i=1,ntpmls
+          
+          if(ntmp.le.mxnode)then
+            
+            if(numcon(index(i)).gt.0)then
+              ntmp=ntmp+nummols(index(i))
+              klo=max(0,kcons-numcon(index(i))/2)
+              khi=klo+numcon(index(i))+1
+            endif
+            
+          endif
+          
+        enddo
+        
+c     reset hi/lo limits if molecules contain too many constraints
+        
+        if(dble(khi)/dble(max(1,klo)).gt.tol)then
+          klo=nint(dble(kcons)/tol)
+          khi=nint(dble(kcons)*tol)+1
+        endif
+        
+c     store lo value for later
+        
+        klo0=klo
+        
+c     begin assignment of constraints ----------------------------------
+        
+        ifail=-1
+        lfail=.true.
+        do while(lfail)
+          
+          ifail=ifail+1
+          
+          if(ifail.gt.ntpmls)then
+            call error(idnode,432)
+          endif
+          
+          iconst=0
+          jconst=0
+          kconst=0
+          lconst=0
+          
+c     zero running totals of constraints on each processor
+          
+          do id=0,mxnode-1
+            kscons(id)=0
+          enddo
+          
+          iloop=0
+          lfail=.false.
+          iconst=0
+          jconst=0
+          nnode=0
+          
+c     assign difficult molecules in blocks
+          
+          if(ifail.gt.0)then
+            
+            nfail=0
+            do i=1,ifail
+              
+              ii=ntpmls+1-i
+              nfail=nfail+nummols(index(ii))*numcon(index(ii))
+              
+            enddo
+            
+c     decide on number of processors to split over
+            
+            nnode=int(dble(nfail)/dble(max(kcons,1))+1.d0/tol)
+            nnode=max(2,nnode)
+            nnode=min(nnode,mxnode)
+            
+c     assign to processors 0..nnode-1
+            
+            do id=0,nnode-1
+              
+              nscons0=(id*nfail)/nnode+1
+              nscons1=((id+1)*nfail)/nnode
+              
+              kscons(id)=nscons1+1-nscons0
+              
+            enddo
+            
+c     this processors block
+            
+            nscons0=(idnode*nfail)/nnode+1
+            nscons1=((idnode+1)*nfail)/nnode
+            
+c     assign in blocks
+            
+            do itmols=ntpmls,ntpmls-ifail+1,-1
+              
+              ii=index(itmols)
+              icon=numcon(ii)
+              kconst=mconst(ii)
+              
+              do imols=1,nummols(ii)
+                
+                isite=msite(ii)+(imols-1)*numsit(ii)
+                
+c     construct bond constraint list
+                
+                do lconst=1,numcon(ii)
+                  
+                  iconst=iconst+1
+                  
+                  if(iconst.ge.nscons0.and.iconst.le.nscons1)then
+                    
+                    jconst=jconst+1
+                    
+                    if(jconst.le.mxcons)then
+                      
+                      listcon(jconst,1)=lconst+kconst
+                      iatom=lstcon(lconst+kconst,1)+isite
+                      jatom=lstcon(lconst+kconst,2)+isite
+                      
+                      listcon(jconst,2)=iatom
+                      listcon(jconst,3)=jatom
+                      
+                    else
+                      
+                      safe=.false.
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+c     assign non-problematic molecules
+          
+          jdnode=mod(nnode+1,mxnode)
+          
+          do itmols=ntpmls-ifail,1,-1
+            
+            ii=index(itmols)
+            icon=numcon(ii)
+            kconst=mconst(ii)
+            
+            do imols=1,nummols(ii)
+              
+              itry=0
+              lchk=.true.
+              do while(lchk)
+                
+                if(kscons(jdnode)+icon.le.klo)then
+                  
+                  if(jdnode.ne.idnode)then
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                  else
+                    
+c     construct bond constraint list
+                    
+                    isite=msite(ii)+(imols-1)*numsit(ii)
+                    do lconst=1,numcon(ii)
+                      
+                      jconst=jconst+1
+                      
+                      if(jconst.le.mxcons)then
+                        
+                        listcon(jconst,1)=lconst+kconst
+                        iatom=lstcon(lconst+kconst,1)+isite
+                        jatom=lstcon(lconst+kconst,2)+isite
+                        listcon(jconst,2)=iatom
+                        listcon(jconst,3)=jatom
+                        
+                      else
+                        
+                        safe=.false.
+                        
+                      endif
+                      
+                    enddo
+                    
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                    
+                  endif
+                  
+                else
+                  
+                  jdnode=mod(jdnode+1,mxnode)
+                  lchk=.true.
+                  itry=itry+1
+                  
+                endif
+                
+                if(lchk.and.itry.gt.mxnode)then
+                  
+                  klo=kcons
+                  kcons=khi
+                  itry=0
+                  iloop=iloop+1
+                  
+                endif
+                
+c     split molecule across nodes if have to
+                
+                if(iloop.gt.3)then
+                  lfail=.true.
+                  kcons=ntcons/mxnode
+                  klo=klo0
+                  lchk=.false.
+                endif
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+c     check no node has less than minimum number
+          
+          do id=0,mxnode-1
+            if(kscons(id).lt.klo0)then 
+              lfail=.true.
+            endif
+          enddo
+          
+        enddo
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)then
+          
+          if(mxnode.gt.1)call gimax(jconst,1,idum)
+          if(idnode.eq.0)write(nrite,'(a,i10,a,i10)')
+     x      'Number of constraints found ',jconst,'Max allowed ',mxcons
+          
+          call error(idnode,41)
+          
+        endif
+        
+        nscons=kscons(idnode)
+        
+        call passcon
+     x    (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x    listin,listot,listcon,lstfrz)
+        
+      endif
+      
+      if(npmf(1).gt.0)then
+        
+        call passpmf
+     x    (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+        
+      endif
+      
+c     pass rigid body data
+      
+      lcnb=.false.
+      if(ntcons.gt.0.and.ngrp.gt.0)then
+        
+        call passquat
+     x    (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x    listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,
+     x    numgsit)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(itest,index,msite,stat=fail(1))
+      deallocate(mconst,kscons,listin,stat=fail(2))
+      
+      return
+      end subroutine intlist
+      
+      subroutine ensemble_selection
+     x  (directive,lens,kill,idnode,keyens,mode,taut,taup)
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ensemble and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical kill,lens
+      integer keyens,idnode,idum,mode
+      real(8) taut,taup
+      
+      if(findstring('nve',directive,idum))then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'microcanonical ensemble')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      elseif(findstring('nvt',directive,idum))then
+        
+        if(findstring('evans',directive,idum))then
+          
+          keyens=1
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Evans Gaussian temperature constraints',
+     x      ' in use')")
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('ber',directive,idum))then
+          
+          keyens=2
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen thermostat',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=3
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('npt',directive,idum))then
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=4
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen isotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=5
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover  (Melchionna) isotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('nst',directive,idum))then
+        
+        mode=0
+        if(findstring('block',directive,idum))mode=1
+        if(findstring('surf',directive,idum))mode=2
+        if(findstring('slab',directive,idum))mode=3
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=6
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen anisotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=7
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover (Melchionna) anisotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+        if(idnode.eq.0)then
+          
+          if(mode.eq.0)then
+            write(nrite,"(/,1x,'NST mode 0 X<>Y<>Z')")
+          elseif(mode.eq.1)then
+            write(nrite,
+     x        "(/,1x,'NST mode 1 X<>Y<>Z (rectangular block)')")
+          elseif(mode.eq.2)then
+            write(nrite,
+     x        "(/,1x,'NST mode 2 X=Y<>Z (liquid surface)')")
+          elseif(mode.eq.3)then
+            write(nrite,
+     x        "(/,1x,'NST mode 3 X<>Y<>Z (solid slab)')")
+          endif
+          
+        endif
+        
+      elseif(findstring('pmf',directive,idum))then
+        
+        keyens=8
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'potential of mean force calculation (NVE)')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      else
+        
+        call error(idnode,-436)
+        kill=.true.
+        
+      endif
+      
+      return
+      end subroutine ensemble_selection
+      
+      subroutine neb_option
+     x  (directive,lneb,lminopt,idnode,numneb,keytol,sprneb,
+     x  opttol,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for NEB option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical lneb,lminopt,endneb,safe
+      integer numneb,idnode,keytol,i,idum
+      real(8) sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      lminopt=.true.
+      lneb=.true.
+      endneb=.false.
+      numneb=intstr(directive,lenrec,idum)
+      if(numneb.eq.0)numneb=1
+      numneb=min(maxneb,numneb)
+      
+      hyp_units=1.d0
+      do while(.not.endneb)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endneb',directive,idum))then
+          endneb=.true.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('basin_1',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_1(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('basin_2',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_2(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,1x,'NEB calculation controls')")
+        write(nrite,"(/,1x,'identity of basin 1            ',
+     x    10i10)")(bsn_1(i),i=1,numneb)
+        write(nrite,"(1x,'identity of basin 2            ',
+     x    10i10)")(bsn_2(i),i=1,numneb)
+        write(nrite,
+     x    "(1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    sprneb,opttol,cunit
+        
+        call print_optim(keytol)
+        
+      endif
+      
+c     units conversion
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine  neb_option
+      
+      subroutine bpd_option
+     x  (directive,seek,lbpd,ltad,lminopt,prechk,nebgo,keybpd,idnode,
+     x  nblock,ntrack,keytol,ebias,vmin,catchrad,sprneb,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for bias potential
+c     dynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 directive(lenrec)
+      logical lbpd,ltad,lminopt,prechk,endbpd,safe,nebgo
+      integer keybpd,idnode,nblock,ntrack,keytol,idum
+      real(8) ebias,vmin,catchrad,sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(ltad)call error(idnode,2355)
+      lminopt=.true.
+      lbpd=.true.
+      endbpd=.false.
+      cunit=" dl_poly"
+      if(idnode.eq.0)
+     x  write(nrite,"(/,1x,'bias potential dynamics controls')")
+      
+      if(findstring('dyn',directive,idum))then
+        
+        keybpd=1
+        hyp_units=energy_unit()
+        ebias=dblstr(directive,lenrec,idum)
+        vmin=dblstr(directive,lenrec,idum)
+        call getword(cunit,directive,8,lenrec)
+        if(idnode.eq.0)write(nrite,"(
+     x    1x,'dynamics option selected       ',
+     x    /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x    /,1x,'bias potential V_min   (kelvin)',f10.4
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    ebias,vmin,cunit
+        
+      elseif(findstring('path',directive,idum))then
+        
+        keybpd=2
+        nebgo=.true.
+        hyp_units=1.d0
+        do while(.not.endbpd)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+            cycle
+          elseif(findstring('endbpd',directive,idum))then
+            endbpd=.true.
+          elseif(findstring('pre',directive,idum))then
+            prechk=.true.
+            if(findstring('false',directive,idum))prechk=.false.
+          elseif(findstring('noneb',directive,idum))then
+            nebgo=.false.
+          elseif(findstring('target',directive,idum))then
+            call getword(seek,directive,8,lenrec)
+            call getword(seek,directive,8,lenrec)
+          elseif(findstring('units',directive,idum))then
+            hyp_units=energy_unit()
+            call getword(cunit,directive,8,lenrec)
+            call getword(cunit,directive,8,lenrec)
+          elseif(findstring('ebias',directive,idum))then
+            ebias=dblstr(directive,lenrec,idum)
+          elseif(findstring('vmin',directive,idum))then
+            vmin=dblstr(directive,lenrec,idum)
+          elseif(findstring('num_block',directive,idum))then
+            nblock=intstr(directive,lenrec,idum)
+          elseif(findstring('num_track',directive,idum))then
+            ntrack=intstr(directive,lenrec,idum)
+          elseif(findstring('catch_radius',directive,idum))then
+            catchrad=dblstr(directive,lenrec,idum)
+          elseif(findstring('neb_spring',directive,idum))then
+            sprneb=dblstr(directive,lenrec,idum)
+          elseif(findstring('forc',directive,idum))then
+            keytol=0
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('ener',directive,idum))then
+            keytol=1
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('posi',directive,idum))then
+            keytol=2
+            opttol=dblstr(directive,lenrec,idum)
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,"(
+     x      1x,'dynamics with path analysis selected',
+     x      /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x      /,1x,'bias potential V_min   (kelvin)',f10.4,
+     x      /,1x,'steps per time block           ',i10,
+     x      /,1x,'steps per tracking block       ',i10,
+     x      /,1x,'configuration catch radius  (A)',f10.4,
+     x      /,1x,'minimisation tolerance         ',e12.4,
+     x      /,1x,'atom type to be tracked        ',2x,a8,
+     x      /,1x,'energy units                   ',2x,a8)")
+     x      ebias,vmin,nblock,ntrack,catchrad,opttol,seek,cunit
+          if(nebgo)write(nrite,
+     x      "(1x,'NEB spring constant            ',e12.4)")sprneb
+          if(prechk)write(nrite,
+     x      "(1x,'transition prechecking option selected')")
+          call print_optim(keytol)
+          
+        endif
+        
+c     energy unit conversions
+        
+        sprneb=sprneb*hyp_units
+        if(keytol.lt.2)opttol=opttol*hyp_units
+        
+      endif
+      
+      return
+      end subroutine bpd_option
+      
+      subroutine tad_option
+     x  (directive,ltad,lbpd,lminopt,prechk,tadall,idnode,nblock,
+     x  ntrack,blkout,keytol,catchrad,sprneb,tlow,deltad,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for TAD option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical ltad,lbpd,lminopt,prechk,tadall,endtad,safe
+      integer idnode,nblock,ntrack,blkout,keytol,idum
+      real(8) catchrad,sprneb,deltad,tlow,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(lbpd)call error(idnode,2355)
+      lminopt=.true.
+      ltad=.true.
+      endtad=.false.
+      hyp_units=1.d0
+      
+      do while(.not.endtad)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endtad',directive,idum))then
+          endtad=.true.
+        elseif(findstring('pre',directive,idum))then
+          prechk=.true.
+          if(findstring('false',directive,idum))prechk=.false.
+        elseif(findstring('all',directive,idum))then
+          tadall=.true.
+          if(findstring('false',directive,idum))tadall=.false.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('num_block',directive,idum))then
+          nblock=intstr(directive,lenrec,idum)
+        elseif(findstring('num_track',directive,idum))then
+          ntrack=intstr(directive,lenrec,idum)
+        elseif(findstring('blackout',directive,idum))then
+          blkout=intstr(directive,lenrec,idum)
+        elseif(findstring('catch_radius',directive,idum))then
+          catchrad=dblstr(directive,lenrec,idum)
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('deltad',directive,idum))then
+          deltad=dblstr(directive,lenrec,idum)
+        elseif(findstring('low_temp',directive,idum))then
+          tlow=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'TAD dynamics controls'
+     x    /,1x,'steps per time block           ',i10,
+     x    /,1x,'steps per tracking block       ',i10,
+     x    /,1x,'steps in blackout periods      ',i10,
+     x    /,1x,'configuration catch radius     ',1p,e12.4,
+     x    /,1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'stopping parameter             ',e12.4,
+     x    /,1x,'target low temperature         ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    nblock,ntrack,blkout,catchrad,sprneb,deltad,
+     x    tlow,opttol,cunit
+        if(prechk)write(nrite,
+     x    "(1x,'transition prechecking option selected')")
+        if(tadall)write(nrite,
+     x    "(1x,'option for all basins analysis selected')")
+        call print_optim(keytol)
+        
+      endif
+      
+c     energy unit conversions
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine tad_option
+
+      subroutine metadyn_option
+     x  (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x  ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x  locpe_scale,ref_W_aug,h_aug,wt_Dt)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for metadynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2011
+c     
+c     note: default values are set in metafreeze_module
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lmetadyn,endmet,lstein,ltet,lglobpe,llocpe,safe
+      integer idnode,idum,ncolvar,nq4,nq6,ntet,hkey,meta_step_int
+      real(8) globpe_scale,locpe_scale,ref_W_aug,h_aug,wt_Dt
+      
+      lmetadyn=.true.
+      endmet=.false.          
+      
+      do while(.not.endmet)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endmet',directive,idum))then
+          endmet=.true.
+        elseif(findstring('ncolvar',directive,idum))then
+          ncolvar=intstr(directive,lenrec,idum)
+        elseif(findstring('lstein',directive,idum))then
+          lstein=.true.
+          if(findstring('false',directive,idum))lstein=.false.
+        elseif(findstring('ltet',directive,idum))then
+          ltet=.true.
+          if(findstring('false',directive,idum))ltet=.false.
+        elseif(findstring('lglobpe',directive,idum))then
+          lglobpe=.true.
+          if(findstring('false',directive,idum))lglobpe=.false.
+        elseif(findstring('llocpe',directive,idum))then
+          llocpe=.true.
+          if(findstring('false',directive,idum))llocpe=.false.
+        elseif(findstring('globpe_scale',directive,idum))then
+          globpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('locpe_scale',directive,idum))then
+          locpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('nq4',directive,idum))then
+          nq4=intstr(directive,lenrec,idum)
+          nq4=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('nq6',directive,idum))then
+          nq6=intstr(directive,lenrec,idum)
+          nq6=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('ntet',directive,idum))then
+          ntet=intstr(directive,lenrec,idum)
+        elseif(findstring('meta_step_int',directive,idum))then
+          meta_step_int=intstr(directive,lenrec,idum)
+        elseif(findstring('ref_w_aug',directive,idum))then
+          ref_W_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('h_aug',directive,idum))then
+          h_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('hkey',directive,idum))then
+          hkey=intstr(directive,lenrec,idum)
+        elseif(findstring('wt_dt',directive,idum))then
+          wt_dt=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'metadynamics controls'
+     x    /,1x,'total number of collective variables',i10,
+     x    /,1x,'steinhardt parameters option (Q4/Q6)',l10,
+     x    /,1x,'tetrahedral parameters option (zeta)',l10,
+     x    /,1x,'global potential parameter option   ',l10,
+     x    /,1x,'local potential parameter option    ',l10,
+     x    /,1x,'global potential param. scale factor',e12.4,
+     x    /,1x,'local potential param. scale factor ',e12.4)")
+     x    ncolvar,lstein,ltet,lglobpe,llocpe,globpe_scale,locpe_scale
+        
+        write(nrite,
+     x    "(  1x,'number of Q4 atom pair types        ',i10,
+     x      /,1x,'number of Q6 atom pair types        ',i10,
+     x      /,1x,'number of zeta atom triplet types   ',i10)")
+     x    nq4,nq6,ntet
+        
+        write(nrite,
+     x    "(  1x,'gaussian deposition interval        ',i10,
+     x      /,1x,'reference gaussian height           ',e12.4,
+     x      /,1x,'gaussian width parameter            ',e12.4,
+     x      /,1x,'height control key                  ',i10,
+     x      /,1x,'well-tempered control parameter     ',e12.4)")
+     x    meta_step_int,ref_W_aug,h_aug,hkey,wt_Dt
+        
+      endif
+            
+      return
+      end subroutine metadyn_option
+      
+      subroutine ewald_selection
+     x  (directive,lhke,lspme,lewald,lcut,lforc,kill,idnode,keyfce,
+     x  imcon,nhko,nlatt,kmax1,kmax2,kmax3,alpha,rcut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ewald method and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lhke,lspme,lewald,lcut,lforc,kill,safe
+      integer idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,kmax3,idum
+      integer kmaxpow2
+      real(8) alpha,rcut,eps,tol,fac,tol1
+      
+      lhke=findstring('hke',directive,idum)
+      lspme=findstring('spme',directive,idum)
+      lewald=findstring('ewald',directive,idum)
+      if(lewald)keyfce=2
+      if(lspme)keyfce=12
+      if(lhke)keyfce=14
+      if(idnode.eq.0)open(nconf,file='CONFIG')
+      call getrec(safe,idnode,nconf)
+      call getrec(safe,idnode,nconf)
+      imcon=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(.not.lhke.and.(imcon.eq.0.or.imcon.eq.6))then
+        
+        call error(idnode,-180)
+        kill=.true.
+        
+      endif
+      
+      if(findstring('precision',directive,idum))then
+        
+        eps=dblstr(directive,lenrec,idum)
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'Ewald sum  precision    ',7x,1p,e12.4)")eps
+        
+        if(lhke)then
+          
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          if(nlatt.eq.0)nlatt=1
+          if(nhko.eq.0)nhko=1
+          
+        endif
+        
+        if(.not.lcut)then
+          call error(idnode,-433)
+          kill=.true.
+        else
+          
+c     retreive cell vectors
+          
+          call getrec(safe,idnode,nconf)
+          cell(1)=dblstr(record,lenrec,idum)
+          cell(2)=dblstr(record,lenrec,idum)
+          cell(3)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(4)=dblstr(record,lenrec,idum)
+          cell(5)=dblstr(record,lenrec,idum)
+          cell(6)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(7)=dblstr(record,lenrec,idum)
+          cell(8)=dblstr(record,lenrec,idum)
+          cell(9)=dblstr(record,lenrec,idum)
+          
+c     compute alpha and the kmax
+          
+          if(lewald.or.lspme)then
+            
+            call dcell(cell,celprp)
+            eps=min(abs(eps),0.5d0)
+            tol=sqrt(abs(log(eps*rcut)))
+            alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+            tol1=sqrt(-log(eps*rcut*(2.d0*tol*alpha)**2))
+            fac=1.d0
+            if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x        fac=2.d0**(1.d0/3.d0)
+            kmax1=nint(0.25d0+fac*celprp(1)*alpha*tol1/pi)
+            kmax2=nint(0.25d0+fac*celprp(2)*alpha*tol1/pi)
+            kmax3=nint(0.25d0+fac*celprp(3)*alpha*tol1/pi)
+            
+          elseif(lhke)then
+            
+            if(nhko.eq.0)then
+              if(eps.le.1.d-6)then
+                alpha=3.46d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=3.14d0/rcut
+              else
+                alpha=2.76d0/rcut
+              endif
+            elseif(nhko.eq.1)then
+              if(eps.le.1.d-6)then
+                alpha=4.37d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.08d0/rcut
+              else
+                alpha=3.75d0/rcut
+              endif                
+            elseif(nhko.eq.2)then
+              if(eps.le.1.d-6)then
+                alpha=5.01d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.74d0/rcut
+              else
+                alpha=4.44d0/rcut
+              endif
+            elseif(nhko.eq.3)then
+              if(eps.le.1.d-6)then
+                alpha=5.55d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=5.28d0/rcut
+              else
+                alpha=5.00d0/rcut
+              endif
+            endif
+            alpha=alpha/dble(2*nlatt+1)
+            if(abs(cell(9)).lt.1.d-8)cell(9)=1.d0
+            call dcell(cell,celprp)
+            tol=2.d0*alpha*sqrt(abs(log(eps*alpha)))
+            tol1=2.d0*alpha*sqrt(abs(log(eps*alpha*tol)))
+            kmax1=nint(0.25d0+0.5d0*celprp(1)*tol1/pi)
+            kmax2=nint(0.25d0+0.5d0*celprp(2)*tol1/pi)
+            kmax3=1
+            
+          endif
+          
+        endif
+        
+      else
+        
+        alpha=dblstr(directive,lenrec,idum)
+        kmax1=intstr(directive,lenrec,idum)
+        kmax2=intstr(directive,lenrec,idum)
+        
+        if(lhke)then
+          
+          kmax3=1
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          
+        else
+          
+          kmax3=intstr(directive,lenrec,idum)
+          
+        endif
+        
+      endif
+      
+c     if spme double kmax and set to next power of 2, with current upper
+c     limit of 512.
+      
+      if(lspme)then
+        
+        kmaxpow2=1
+        do while (kmax1.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax1=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax2.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax2=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax3.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax3=2 * kmaxpow2
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        close(nconf)
+        
+        if(lspme)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : SPME  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1/2,kmax2/2,kmax3/2
+          
+        elseif(lhke)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Hautman-Klein-Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2              ',2i5)")
+     x      alpha,kmax1,kmax2
+          
+          write(nrite,
+     x      "(1x,'HKE expansion order     ',7x,i10,
+     x      /,1x,'HKE lattice control     ',7x,i10)")nhko,nlatt
+          
+        else
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1,kmax2,kmax3
+          
+        endif
+        
+      endif
+      
+      if(lspme)then
+        
+c     Initialize fft tables
+        
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (fplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_FORWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+CFFTW
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (bplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_BACKWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+        
+CSGIC             call zzfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CSGIC     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+CCRAY             call ccfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CCRAY     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+      endif
+      
+      if(lspme)then
+        
+        if(kmax1.gt.kmaxd.or.kmax2.gt.kmaxe.or.kmax3.gt.kmaxf)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      elseif(lhke)then
+        
+        if(kmax2.gt.kmaxb)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      else
+        
+        if(kmax2.gt.kmaxb.or.kmax3.gt.kmaxc)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      endif
+      
+      if(lforc)then
+        call  error(idnode,-416)
+        kill=.true.
+      endif
+      lforc=.true.
+      
+      return
+      end subroutine ewald_selection
+      
+      subroutine print_optim(keytol)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing the optimisation option
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer keytol
+      
+      if(keytol.eq.0)then
+        write(nrite,
+     x    "(1x,'convergence to minimum force selected')")
+      elseif(keytol.eq.1)then
+        write(nrite,
+     x    "(1x,'convergence to minimum energy selected')")
+      else
+        write(nrite,
+     x    "(1x,'convergence to minimum position selected')")
+      endif
+      
+      return
+      end subroutine print_optim
+      
+      function energy_unit()
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for assigning energy conversion factors
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idum
+      real(8) energy_unit
+      
+      energy_unit=1.d0
+      if(findstring('ev',record,idum))then
+        energy_unit=9648.530821d0
+      elseif(findstring('kev',record,idum))then
+        energy_unit=9648530.821d0
+      elseif(findstring('kcal',record,idum))then
+        energy_unit=418.4d0
+      elseif(findstring('kj',record,idum))then
+        energy_unit=1.d2
+      elseif(findstring('k',record,idum))then
+        energy_unit=boltz
+      endif
+      
+      return
+      end function energy_unit
+      
+      subroutine solvation_option
+     x  (directive,lsolva,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for solvation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,endsol,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      endsol=.false.
+      
+      nsolva=intstr(directive,lenrec,idum)
+      isolva=intstr(directive,lenrec,idum)
+      
+      if(nsolva.eq.0.and.isolva.eq.0)then
+        
+        do while(.not.endsol)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(findstring('endsol',directive,idum))then
+            endsol=.true.
+          elseif(findstring('enddec',directive,idum))then
+            endsol=.true.
+          elseif(findstring('start',directive,idum))then
+            nsolva=intstr(directive,lenrec,idum)
+          elseif(findstring('inter',directive,idum))then
+            isolva=max(intstr(directive,lenrec,idum),1)
+          endif
+          
+        enddo
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'solvation calculation selected',
+     x    /,1x,'start of solvation calculation ',i10,
+     x    /,1x,'solvation calculation interval ',i10)")
+     x    nsolva,isolva
+        
+      endif
+      
+      return
+      end subroutine solvation_option
+      
+      subroutine free_energy_option(directive,lfree,lfrmas,idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for free energy option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lfree,lfrmas,endfre,safe
+      integer idnode,idum
+      
+      mfree=1
+      kfree=1
+      lfree=.true.
+      lfrmas=.false.
+      endfre=.false.
+      
+      do while(.not.endfre)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endfre',directive,idum))then
+          endfre=.true.
+        elseif(findstring('start',directive,idum))then
+          nfrn=intstr(directive,lenrec,idum)
+        elseif(findstring('interval',directive,idum))then
+          ifrn=intstr(directive,lenrec,idum)
+        elseif(findstring('lambda',directive,idum))then
+          pfree=dblstr(directive,lenrec,idum)
+        elseif(findstring('mix',directive,idum))then
+          mfree=intstr(directive,lenrec,idum)
+        elseif(findstring('expo',directive,idum))then
+          kfree=intstr(directive,lenrec,idum)
+        elseif(findstring('reset_mass',directive,idum))then
+          lfrmas=.true.
+          if(findstring('false',directive,idum))lfrmas=.false.
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(mfree.eq.1)kfree=1
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'free energy option selected',
+     x    /,1x,'start of free energy calculation ',i10,
+     x    /,1x,'sampling interval                ',i10,
+     x    /,1x,'free energy parameter (lambda)   ',f10.3,
+     x    /,1x,'mixing rule selected             ',i10,
+     x    /,1x,'mixing rule exponent             ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10,
+     x    /,1x,'mass scaling option              ',l10)")
+     x    nfrn,ifrn,pfree,mfree,kfree,ind_fre,lfrmas
+        
+      endif
+      
+c     define free energy scaling parameters
+
+      call freegen()
+      
+      return
+      end subroutine free_energy_option
+      
+      subroutine excitation_option
+     x  (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for excitation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lexcite,lghost,endexc,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lexcite=.true.
+      endexc=.false.
+      
+      do while(.not.endexc)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endexc',directive,idum))then
+          endexc=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'excitation option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,ind_fre
+        
+      endif
+      
+      return
+      end subroutine excitation_option
+      
+      subroutine switching_option
+     x  (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for switching option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lswitch,lghost,endswi,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lswitch=.true.
+      endswi=.false.
+      niswitch=0
+      
+      do while(.not.endswi)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endswi',directive,idum))then
+          endswi=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('period',directive,idum))then
+          niswitch=max(intstr(directive,lenrec,idum),2)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(niswitch.eq.0)niswitch=nsolva
+      nswitch=nsolva
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'switching option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'switching period                 ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,niswitch,ind_fre
+        
+      endif
+      
+      return
+      end subroutine switching_option
+      
+      end module define_system_module
+      
diff -urN dl_class_1.9.orig/srcmod/dihedral_module.f dl_class_1.9/srcmod/dihedral_module.f
--- dl_class_1.9.orig/srcmod/dihedral_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dihedral_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1121 @@
+      module dihedral_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining dihedral potential arrays
+c     copyright - daresbury laboratory
+c     
+c     author  - w. smith     sep 2003
+c     adapted - p.-a. cazade oct 2007 : solvation, free energy, etc.
+c     adapted - w.smith      jan 2011 : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+      use vdw_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmdih(:,:)
+      integer, allocatable :: listdih(:,:)
+      integer, allocatable :: numdih(:),keydih(:),lstdih(:,:)
+      
+      save prmdih,listdih,numdih,keydih,lstdih
+      
+      contains
+      
+      subroutine alloc_dih_arrays(idnode)
+      
+      implicit none
+      
+      integer i,fail,idnode
+      dimension fail(5)
+      
+      do i=1,5
+        fail(i)=0
+      enddo
+      
+      allocate (prmdih(mxtdih,mxpdih),stat=fail(1))
+      allocate (numdih(mxtmls),stat=fail(2))
+      allocate (keydih(mxtdih),stat=fail(3))
+      allocate (lstdih(mxtdih,4),stat=fail(4))
+      allocate (listdih(mxdihd,5),stat=fail(5))
+      
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1011)
+      enddo
+      
+      do i=1,mxtmls
+        numdih(i)=0
+      enddo
+      
+      end subroutine alloc_dih_arrays
+      
+      subroutine define_dihedrals
+     x  (safe,idnode,itmols,ndihed,nsite,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining dihedral angles
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,ndihed,nsite,ntmp,idih,idih1,i
+      integer iatm1,iatm2,iatm3,iatm4,idum,isite1,isite2,isite3
+      integer isite4,ia,ja
+      real(8) engunit
+      
+      ntmp=intstr(record,lenrec,idum)
+      numdih(itmols)=numdih(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of dihedral angles',
+     x    6x,i10)")ntmp
+        write(nrite,"(/,/,1x,'dihedral angle details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',5x,
+     x    'index',5x,'index',5x,'f-const',7x,'angle',
+     x    8x,'trig',4x,'1-4 elec',5x,'1-4 vdw',/)")
+      endif
+      
+      idih1=numdih(itmols)
+      do idih=1,idih1
+        
+c     read dihedral bond angle potential parameters
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        iatm3=intstr(record,lenrec,idum)
+        iatm4=intstr(record,lenrec,idum)
+        
+c     test for frozen atom pairs
+        
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        isite3=nsite-numsit(itmols)+iatm3
+        isite4=nsite-numsit(itmols)+iatm4
+        
+        if(lfzsit(isite1)*lfzsit(isite2)*
+     x    lfzsit(isite3)*lfzsit(isite4).ne.0)then
+          
+          numdih(itmols)=numdih(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+          
+        else
+          
+          ndihed=ndihed+1
+          
+          if(ndihed.gt.mxtdih)call error(idnode,60)
+          
+          if(keyword(1:4).eq.'cos ')then
+            keydih(ndihed)=1
+          elseif(keyword(1:4).eq.'harm')then
+            keydih(ndihed)=2
+          elseif(keyword(1:4).eq.'hcos')then
+            keydih(ndihed)=3
+          elseif(keyword(1:4).eq.'cos3')then
+            keydih(ndihed)=4
+          elseif(keyword(1:4).eq.'ryck')then
+            keydih(ndihed)=5
+          elseif(keyword(1:4).eq.'rbf')then 
+            keydih(ndihed)=6
+          elseif(keyword(1:4).eq.'opls')then 
+            keydih(ndihed)=7
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,448)
+          endif
+          
+          lstdih(ndihed,1)=iatm1
+          lstdih(ndihed,2)=iatm2
+          lstdih(ndihed,3)=iatm3
+          lstdih(ndihed,4)=iatm4
+          prmdih(ndihed,1)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,2)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,3)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,4)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,5)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,4i10,1p,e12.4,0p,9f12.6)")
+     x      keyword(1:4),(lstdih(ndihed,ia),ia=1,4),
+     x      (prmdih(ndihed,ja),ja=1,mxpdih)
+          
+c     convert energies to internal units and angles to radians
+          
+          prmdih(ndihed,1)=prmdih(ndihed,1)*engunit
+          
+          if(keydih(ndihed).eq.4)then
+            
+            prmdih(ndihed,2)=prmdih(ndihed,2)*engunit
+            prmdih(ndihed,3)=prmdih(ndihed,3)*engunit
+            
+          elseif(keydih(ndihed).eq.7)then
+            
+            prmdih(ndihed,2)=prmdih(ndihed,2)*engunit
+            prmdih(ndihed,3)=prmdih(ndihed,3)*engunit
+            prmdih(ndihed,4)=prmdih(ndihed,4)*engunit
+            prmdih(ndihed,5)=prmdih(ndihed,5)*(pi/180.d0)
+            
+          else
+            
+            prmdih(ndihed,2)=prmdih(ndihed,2)*(pi/180.d0)
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_dihedrals
+      
+      subroutine dihfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntdihd,keyfce,
+     x  dlrpot,epsq,engcpe,engdih,engsrp,rcut,rvdw,alpha,vircpe,
+     x  virdih,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating dihedral energy and force 
+c     terms in molecular dynamics.
+c     
+c     version 3: scale factors for reduces electrostatic and vdw
+c     1-4 interactions.
+c     
+c     NOTE: assumes 1-4 interactions are in the exclude list
+c     
+c     block as opposed to stride version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith       mar 1992
+c     modified  - t. forester    dec 1993
+c     modified  - t. forester    jun 1995 - stress tensor added
+c     modified  - a. smondyrev   may 2000 - ryckaert-bellemans potentials
+c     modified  - p.-a. cazade   oct 2007 - solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect
+      logical idrive,jdrive,kdrive,ldrive
+      integer i,k,ii,kk,ntdihd,idnode,mxnode,idih1,idih2,ia,ib
+      integer ic,id,imcon,ka,kb,l,keyfce,fail1,fail2,fail3,kkk
+      real(8) phi,twopi,rtwopi,dterm,srpot
+      real(8) engdih,virdih,engc14,engs14,virs14,rrbc,xab,yab,erc,fer
+      real(8) zab,xbc,ybc,zbc,xcd,ycd,zcd,pbx,pby,pbz,pb2,rpb1,rpb2
+      real(8) pcx,pcy,pcz,pc2,rpc1,rpc2,pbpc,cosp,sinp,rsinp,exp1
+      real(8) gamma,fax,fay,faz,fcx,fcy,fcz,fb1x,fb1y,fb1z,fd1x,fd1y
+      real(8) fd1z,scale,xad,yad,zad,rad,chgprd,coul,fcoul,fx,fy,fz
+      real(8) ppp,dlrpot,t1,t2,vk0,vk1,vk2,gk0,gk1,gk2,epsq,engcpe
+      real(8) vircpe,rcut,rvdw,engsrp,virsrp,xac,yac,zac,vcon,fcon
+      real(8) virc14,b0,rfld0,rfld1,rfld2,alpha,a1,a2,a3,a4,a5,pp,tt
+      real(8) cou14_vir,vdw14_vir,strs(6),strs_loc(6)
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      real(8), allocatable :: xdbc(:),ydbc(:),zdbc(:)
+      real(8), allocatable :: xdcd(:),ydcd(:),zdcd(:)
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      data fail1,fail2,fail3/0,0,0/
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail1)
+      allocate (xdbc(msbad),ydbc(msbad),zdbc(msbad),stat=fail2)
+      allocate (xdcd(msbad),ydcd(msbad),zdcd(msbad),stat=fail3)
+      if(fail1.ne.0.or.fail2.ne.0.or.fail3.ne.0)
+     x  call error(idnode,1060)
+      
+      twopi=2.d0*pi
+      rtwopi=1.d0/twopi
+      safe=.true.
+      
+c     check size of work arrays
+      
+      if((ntdihd-mxnode+1)/mxnode.gt.msbad) call error(idnode,421)
+      
+c     block indices
+      
+      idih1=(idnode*ntdihd)/mxnode+1
+      idih2=((idnode+1)*ntdihd)/mxnode
+      
+c     initialise accumulators
+      
+      engdih=0.d0
+      virdih=0.d0
+      dih_fre=0.d0
+      dih_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+      if(lsolva)then
+        
+        lcomp(3)=.true.
+        dih_sol(:)=0.d0
+        if(lexcite)dih_exc(:)=0.d0
+        
+      endif
+      
+      if(keyfce/2.eq.4)then
+        
+c     constant terms for shifted coulombic potential
+        
+        tt=1.d0/(1.d0+pp*alpha*rcut)
+        exp1=exp(-(alpha*rcut)**2)
+        vcon=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rcut
+        fcon=(vcon+2.d0*(alpha/sqrpi)*exp1)/rcut
+        
+      elseif(keyfce/2.eq.5)then
+        
+c     constant terms for reaction field potential
+        
+        b0=2.d0*(epsq-1.d0)/(2.d0*epsq+1.d0)
+        rfld0=b0/rcut**3
+        rfld1=(1.d0+b0*0.5d0)/rcut
+        rfld2=rfld0*0.5d0
+        tt=1.d0/(1.d0+pp*alpha*rcut)
+        exp1=exp(-(alpha*rcut)**2)
+        vcon=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rcut
+        fcon=(vcon+2.d0*(alpha/sqrpi)*exp1)/rcut-rfld0*rcut
+        vcon=vcon+rfld2*rcut**2-rfld1
+        
+      endif
+      
+c     calculate bond vectors
+      
+      ii=0
+      do i=idih1,idih2
+        
+        ii=ii+1
+        
+c     indices of bonded atoms
+        
+        ia=listdih(ii,2)
+        ib=listdih(ii,3)
+        ic=listdih(ii,4)
+        id=listdih(ii,5)
+        
+c     define components of bond vectors
+        
+        xdab(ii)=xxx(ia)-xxx(ib)
+        ydab(ii)=yyy(ia)-yyy(ib)
+        zdab(ii)=zzz(ia)-zzz(ib)
+        
+        xdbc(ii)=xxx(ib)-xxx(ic)
+        ydbc(ii)=yyy(ib)-yyy(ic)
+        zdbc(ii)=zzz(ib)-zzz(ic)
+        
+        xdcd(ii)=xxx(ic)-xxx(id)
+        ydcd(ii)=yyy(ic)-yyy(id)
+        zdcd(ii)=zzz(ic)-zzz(id)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      call images(imcon,0,1,ii,cell,xdbc,ydbc,zdbc)
+      call images(imcon,0,1,ii,cell,xdcd,ydcd,zdcd)
+      
+c     zero dihedral energy accumulator
+      
+      engdih=0.d0
+      virdih=0.d0
+      
+c     zero scaled 1-4 electrostatic and short range potential accumulators
+      
+      engc14=0.d0
+      virc14=0.d0
+      engs14=0.d0
+      virs14=0.d0
+      vdw14_vir=0.d0
+      cou14_vir=0.d0
+      
+c     loop over all specified dihedrals
+      
+      ii=0
+      do i=idih1,idih2
+        
+c     define components of bond vectors
+        
+        ii=ii+1
+        
+        xab=xdab(ii)
+        yab=ydab(ii)
+        zab=zdab(ii)
+        
+        xbc=xdbc(ii)
+        ybc=ydbc(ii)
+        zbc=zdbc(ii)
+        rrbc=1.d0/sqrt(xbc*xbc+ybc*ybc+zbc*zbc)
+        
+        xcd=xdcd(ii)
+        ycd=ydcd(ii)
+        zcd=zdcd(ii)
+        
+        xac=xab+xbc
+        yac=yab+ybc
+        zac=zab+zbc
+        
+c     construct first dihedral vector
+        
+        pbx=yab*zbc-zab*ybc
+        pby=zab*xbc-xab*zbc
+        pbz=xab*ybc-yab*xbc
+        pb2=pbx*pbx+pby*pby+pbz*pbz
+        rpb1=1.d0/sqrt(pb2)
+        rpb2=rpb1*rpb1
+        
+c     construct second dihedral vector
+        
+        pcx=ybc*zcd-zbc*ycd
+        pcy=zbc*xcd-xbc*zcd
+        pcz=xbc*ycd-ybc*xcd
+        pc2=pcx*pcx+pcy*pcy+pcz*pcz
+        rpc1=1.d0/sqrt(pc2)
+        rpc2=rpc1*rpc1
+        
+c     determine dihedral angle 
+        
+        pbpc=pbx*pcx+pby*pcy+pbz*pcz
+        cosp=pbpc*rpb1*rpc1
+        sinp=(xbc*(pcy*pbz-pcz*pby)+ybc*(pbx*pcz-pbz*pcx)+
+     x    zbc*(pcx*pby-pcy*pbx))*(rpb1*rpc1*rrbc)
+        
+        phi=atan2(sinp,cosp)
+        
+c     avoid singularity in sinp
+        
+        sinp=sign(max(1.d-8,abs(sinp)),sinp)
+        rsinp=1.d0/sinp
+        
+c     selection of potential energy function type
+        
+        kk=listdih(ii,1)
+        
+c     calculate potential energy and scalar force term
+        
+        if(keydih(kk).eq.1)then
+          
+c     key=1 for torsion dihedral potential
+          
+          dterm=prmdih(kk,1)*(1.d0+cos(prmdih(kk,3)*phi-
+     x      prmdih(kk,2)))
+          gamma=-rpb1*rpc1*rsinp*prmdih(kk,1)*prmdih(kk,3)*
+     x      sin(prmdih(kk,3)*phi-prmdih(kk,2))
+          
+        else if(keydih(kk).eq.2)then
+          
+c     key=2 for harmonic improper dihedral
+          
+          phi=phi-prmdih(kk,2)
+          phi=phi-nint(phi*rtwopi)*twopi
+          dterm=0.5d0*prmdih(kk,1)*(phi*phi)
+          gamma=rpb1*rpc1*rsinp*prmdih(kk,1)*phi
+          
+        else if(keydih(kk).eq.3)then
+          
+c     key=3 for harmonic cosine dihedral
+          
+          dterm=0.5d0*prmdih(kk,1)*(cos(phi)-
+     x      cos(prmdih(kk,2)))**2
+          gamma=-rpb1*rpc1*prmdih(kk,1)*(cos(phi)-cos(prmdih(kk,2)))
+          
+        else if(keydih(kk).eq.4)then
+          
+c     key=4 for 3-term cosine dihedral
+          
+          dterm=0.5d0*(prmdih(kk,1)*(1.d0+cos(phi))+
+     x      prmdih(kk,2)*(1.d0-cos(2.d0*phi))+prmdih(kk,3)*
+     x      (1.d0+cos(3.d0*phi)))
+          gamma=-rpb1*rpc1*rsinp*0.5d0*(prmdih(kk,1)*sin(phi)-
+     x      2.d0*prmdih(kk,2)*sin(2.d0*phi)+3.d0*prmdih(kk,3)*
+     x      sin(3.d0*phi))
+          
+        else if(keydih(kk).eq.5)then
+          
+c     key=5 for ryckaert-bellemans potential      
+c     chem.phys.lett., vol.30, p.123, 1975.
+c     ATTENTION !!! Modified to have trans configuration
+c     correspond to phi=180 rather than 
+c     phi=0 as in original form.
+          
+          dterm=prmdih(kk,1)*(1.116d0-1.462d0*cos(phi)-
+     x      1.578d0*(cos(phi))**2+0.368d0*(cos(phi))**3+
+     x      3.156d0*(cos(phi))**4+3.788d0*(cos(phi))**5)
+          gamma=prmdih(kk,1)*(1.462d0+3.156d0*cos(phi)-
+     x      1.104d0*(cos(phi))**2-12.624d0*(cos(phi))**3-
+     x      18.94d0*(cos(phi))**4)*rpb1*rpc1
+          
+        else if(keydih(kk).eq.6)then
+          
+c     key=6 for fluorinated ryckaert-bellemans potential
+c     Rice at al., JCP 104, 2101, (1996).
+          
+          dterm=prmdih(kk,1)*(3.55d0-2.78d0*cos(phi)-
+     x      3.56d0*(cos(phi))**2-1.64d0*(cos(phi))**3+
+     x      7.13d0*(cos(phi))**4+12.84d0*(cos(phi))**5+
+     x      9.67d0*exp(-56.d0*(phi-pi)**2))
+          gamma=(prmdih(kk,1)*(2.78d0+7.12d0*cos(phi)+
+     x      4.92d0*(cos(phi))**2-28.52d0*(cos(phi))**3-
+     x      64.2d0*(cos(phi))**4)-1083.04d0*(phi-pi)*
+     x      exp(-56.0*(phi-pi)**2))*rpb1*rpc1
+          
+        else if(keydih(kk).eq.7)then
+          
+c     key=7 for opls cosine dihedral
+          
+          phi=phi-prmdih(kk,5)
+          dterm=prmdih(kk,1)+0.5d0*(prmdih(kk,2)*
+     x      (1.d0+cos(phi))+prmdih(kk,3)*(1.d0-cos(2.d0*phi))+
+     x      prmdih(kk,4)*(1.d0+cos(3.d0*phi)))
+          gamma=-0.5d0*(prmdih(kk,2)*sin(phi)-2.d0*prmdih(kk,3)*
+     x      sin(2.d0*phi)+3.d0*prmdih(kk,4)*sin(3.d0*phi))*rpb1*
+     x      rpc1*rsinp
+          
+        else
+          
+c     undefined potential
+          
+          safe=.false.
+          dterm=0.d0
+          gamma=0.d0
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listdih(ii,2)
+        ib=listdih(ii,3)
+        ic=listdih(ii,4)
+        id=listdih(ii,5)
+        
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          kdrive=driven(ltype(ic))
+          ldrive=driven(ltype(id))
+          
+        endif
+        
+c     set selection control for angle potential
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+          
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x      (atm_fre(ic).ne.1).and.(atm_fre(id).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic)+
+     x        atm_fre(id).eq.0)
+            
+            if(lsolva)then
+              dih_exc(atmolt(ia))=dih_exc(atmolt(ia))+dterm
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x      (atm_fre(ic).eq.1).or.(atm_fre(id).eq.1))then
+            
+c     set hamiltonian mixing parameter
+            
+            dih_fre=dih_fre-dterm
+            dterm=lambda1*dterm
+            gamma=lambda1*gamma
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x        (atm_fre(ic).eq.2).or.(atm_fre(id).eq.2))then
+            
+c     set hamiltonian mixing parameter
+            
+            dih_fre=dih_fre+dterm
+            dterm=lambda2*dterm
+            gamma=lambda2*gamma
+            
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate potential energy
+          
+          engdih=engdih+dterm
+          
+c     calculate solvation energy for dihedral term
+          
+          if(lsolva)then
+            dih_sol(atmolt(ia))=dih_sol(atmolt(ia))+dterm
+          endif
+          
+c     calculate atomic forces for dihedral term
+          
+          fax=gamma*((-pcy*zbc+pcz*ybc)-pbpc*rpb2*(-pby*zbc+pbz*ybc))
+          fay=gamma*(( pcx*zbc-pcz*xbc)-pbpc*rpb2*( pbx*zbc-pbz*xbc))
+          faz=gamma*((-pcx*ybc+pcy*xbc)-pbpc*rpb2*(-pbx*ybc+pby*xbc))
+          
+          fcx=gamma*((-pcy*zab+pcz*yab)-pbpc*rpb2*(-pby*zab+pbz*yab))
+          fcy=gamma*(( pcx*zab-pcz*xab)-pbpc*rpb2*( pbx*zab-pbz*xab))
+          fcz=gamma*((-pcx*yab+pcy*xab)-pbpc*rpb2*(-pbx*yab+pby*xab))
+          
+          fb1x=gamma*((-pby*zcd+pbz*ycd)-pbpc*rpc2*(-pcy*zcd+pcz*ycd))
+          fb1y=gamma*(( pbx*zcd-pbz*xcd)-pbpc*rpc2*( pcx*zcd-pcz*xcd))
+          fb1z=gamma*((-pbx*ycd+pby*xcd)-pbpc*rpc2*(-pcx*ycd+pcy*xcd))
+          
+          fd1x=gamma*((-pby*zbc+pbz*ybc)-pbpc*rpc2*(-pcy*zbc+pcz*ybc))
+          fd1y=gamma*(( pbx*zbc-pbz*xbc)-pbpc*rpc2*( pcx*zbc-pcz*xbc))
+          fd1z=gamma*((-pbx*ybc+pby*xbc)-pbpc*rpc2*(-pcx*ybc+pcy*xbc))
+          
+          fxx(ia)=fxx(ia)+fax
+          fyy(ia)=fyy(ia)+fay
+          fzz(ia)=fzz(ia)+faz
+          
+          fxx(ib)=fxx(ib)-fax-fcx+fb1x
+          fyy(ib)=fyy(ib)-fay-fcy+fb1y
+          fzz(ib)=fzz(ib)-faz-fcz+fb1z
+          
+          fxx(ic)=fxx(ic)+fcx-fb1x-fd1x
+          fyy(ic)=fyy(ic)+fcy-fb1y-fd1y
+          fzz(ic)=fzz(ic)+fcz-fb1z-fd1z
+          
+          fxx(id)=fxx(id)+fd1x
+          fyy(id)=fyy(id)+fd1y
+          fzz(id)=fzz(id)+fd1z
+          
+c     stress tensor for dihedral term
+          
+          strs(1)=strs(1)+xab*fax+xbc*(fb1x-fcx)-xcd*fd1x 
+          strs(2)=strs(2)+yab*fax+ybc*(fb1x-fcx)-ycd*fd1x 
+          strs(3)=strs(3)+zab*fax+zbc*(fb1x-fcx)-zcd*fd1x 
+          strs(4)=strs(4)+yab*fay+ybc*(fb1y-fcy)-ycd*fd1y 
+          strs(5)=strs(5)+yab*faz+ybc*(fb1z-fcz)-ycd*fd1z 
+          strs(6)=strs(6)+zab*faz+zbc*(fb1z-fcz)-zcd*fd1z 
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive.or.kdrive.or.ldrive))then
+          
+c     local energy (no virial)
+          
+          eng_loc=eng_loc+dterm
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fax
+          fyy_loc(ia)=fyy_loc(ia)+fay
+          fzz_loc(ia)=fzz_loc(ia)+faz
+          
+          fxx_loc(ib)=fxx_loc(ib)-fax-fcx+fb1x
+          fyy_loc(ib)=fyy_loc(ib)-fay-fcy+fb1y
+          fzz_loc(ib)=fzz_loc(ib)-faz-fcz+fb1z
+          
+          fxx_loc(ic)=fxx_loc(ic)+fcx-fb1x-fd1x
+          fyy_loc(ic)=fyy_loc(ic)+fcy-fb1y-fd1y
+          fzz_loc(ic)=fzz_loc(ic)+fcz-fb1z-fd1z
+          
+          fxx_loc(id)=fxx_loc(id)+fd1x
+          fyy_loc(id)=fyy_loc(id)+fd1y
+          fzz_loc(id)=fzz_loc(id)+fd1z
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xab*fax+xbc*(fb1x-fcx)-xcd*fd1x
+          strs_loc(2)=strs_loc(2)+yab*fax+ybc*(fb1x-fcx)-ycd*fd1x
+          strs_loc(3)=strs_loc(3)+zab*fax+zbc*(fb1x-fcx)-zcd*fd1x
+          strs_loc(4)=strs_loc(4)+yab*fay+ybc*(fb1y-fcy)-ycd*fd1y
+          strs_loc(5)=strs_loc(5)+yab*faz+ybc*(fb1z-fcz)-ycd*fd1z
+          strs_loc(6)=strs_loc(6)+zab*faz+zbc*(fb1z-fcz)-zcd*fd1z
+          
+        endif
+        
+c     calculate 1-4 dihedral interactions (coulombic and short ranged)
+c     assumes 1-4 interactions are in the exclude list
+        
+        kk=listdih(ii,1)
+        
+c     bypass OPLS 1-4 terms (not present)
+        
+        if(keydih(kk).ne.7)then
+          
+c     1-4 electrostatics : adjust by weighting factor
+          
+          scale=prmdih(kk,4)
+          
+          xad=xac+xcd
+          yad=yac+ycd
+          zad=zac+zcd
+          
+          rad=sqrt(xad**2+yad**2+zad**2)
+          
+c     scaled charge product*dielectric
+          
+          chgprd=scale*chge(ia)*chge(id)*r4pie0
+          coul=0.d0
+          fcoul=0.d0
+          
+c     truncation of potential for all schemes except ewald sum
+          
+          if(abs(chgprd).gt.1.d-10.and.keyfce.gt.0)then
+            
+c     electrostatics by ewald sum
+            
+            if(keyfce/2.eq.1.or.keyfce/2.eq.6.or.keyfce/2.eq.7)then
+              
+              coul=chgprd/(epsq*rad)
+              fcoul=coul/(rad**2)
+              
+c     distance dependent dielectric
+              
+            elseif(rcut.gt.rad)then
+              
+              if(keyfce/2.eq.2)then
+                
+                coul=chgprd/(epsq*rad**2)
+                fcoul=2.0d0*coul/(rad**2)
+                
+c     unmodified coulombic
+                
+              else if(keyfce/2.eq.3)then
+                
+                coul=chgprd/(epsq*rad)
+                fcoul=coul/(rad**2)
+                
+c     truncated and shifted coulombic
+                
+              else if(keyfce/2.eq.4)then
+                
+                tt=1.d0/(1.d0+pp*alpha*rad)
+                exp1=exp(-(alpha*rad)**2)
+                erc=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rad
+                fer=(erc+2.d0*(alpha/sqrpi)*exp1)/rad**2
+                
+c     calculate potential energy and forces
+                
+                coul=chgprd*(erc-vcon+fcon*(rad-rcut))/epsq
+                fcoul=chgprd*(fer-fcon/rad)/epsq
+                
+c     reaction field
+                
+              else if(keyfce/2.eq.5)then
+                
+                tt=1.d0/(1.d0+pp*alpha*rad)
+                exp1=exp(-(alpha*rad)**2)
+                erc=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rad
+                fer=(erc+2.d0*(alpha/sqrpi)*exp1)/rad**2
+                coul=chgprd*(erc-vcon+fcon*(rad-rcut)+
+     x            rfld2*rad*rad-rfld1)
+                fcoul=chgprd*(fer-fcon/rad-rfld0)
+                
+              elseif(keyfce/2.eq.0)then
+                
+                coul=0.d0
+                fcoul=0.d0
+                
+              else
+                
+                call error(idnode,446)
+                
+              endif
+              
+            endif
+            
+c     set selection control for coulombic 1-4 terms
+            
+            lselect=.true.
+            
+c     set double index
+            
+            if(lsolva)kkk=loc2(atmolt(ia),atmolt(id))
+            
+            if(lexcite)then
+              
+c     selected excitation option
+              
+              if((atm_fre(ia).ne.1).and.(atm_fre(id).ne.1))then
+                
+c     set selection control
+                
+                lselect=(atm_fre(ia)+atm_fre(id).eq.0)
+                
+                if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                
+              endif
+              
+            elseif(lfree)then
+              
+c     selected free energy option
+              
+              if((atm_fre(ia).eq.1).or.(atm_fre(id).eq.1))then
+                
+c     set hamiltonian mixing parameter
+                
+                cou_fre=cou_fre-coul
+                cou14_vir=cou14_vir+fcoul*rad**2
+                coul=lambda1*coul
+                fcoul=lambda1*fcoul
+                
+              elseif((atm_fre(ia).eq.2).or.(atm_fre(id).eq.2))then
+                
+c     set hamiltonian mixing parameter
+                
+                cou_fre=cou_fre+coul
+                cou14_vir=cou14_vir-fcoul*rad**2
+                coul=lambda2*coul
+                fcoul=lambda2*fcoul
+                
+              endif
+              
+            endif
+            
+            if(lselect)then
+              
+c     electrostatic energy and virial for 1-4 term
+              
+              engc14=engc14+coul
+              virc14=virc14-fcoul*rad**2
+              
+c     solvation energy for coulombic 1-4 term
+              
+              if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+              
+c     coulombic force for 1-4 term
+              
+              fx=fcoul*xad
+              fy=fcoul*yad
+              fz=fcoul*zad
+              
+              fxx(ia)=fxx(ia)+fx
+              fyy(ia)=fyy(ia)+fy
+              fzz(ia)=fzz(ia)+fz
+              
+              fxx(id)=fxx(id)-fx
+              fyy(id)=fyy(id)-fy
+              fzz(id)=fzz(id)-fz
+              
+c     stress tensor for coulombic 1-4 term
+              
+              strs(1)=strs(1)+xad*fx
+              strs(2)=strs(2)+xad*fy
+              strs(3)=strs(3)+xad*fz
+              strs(4)=strs(4)+yad*fy
+              strs(5)=strs(5)+yad*fz
+              strs(6)=strs(6)+zad*fz
+            
+            endif
+            
+c     metadynamics local parameters
+            
+            if(lmetadyn.and.(idrive.or.ldrive))then
+              
+c     local energy and virial
+              
+              eng_loc=eng_loc+coul
+              vir_loc=vir_loc-fcoul*rad**2
+              
+c     local forces
+              
+              fxx_loc(ia)=fxx_loc(ia)+fx
+              fyy_loc(ia)=fyy_loc(ia)+fy
+              fzz_loc(ia)=fzz_loc(ia)+fz
+              
+              fxx_loc(id)=fxx_loc(id)-fx
+              fyy_loc(id)=fyy_loc(id)-fy
+              fzz_loc(id)=fzz_loc(id)-fz
+              
+c     local stress tensor
+              
+              strs_loc(1)=strs_loc(1)+xad*fx
+              strs_loc(2)=strs_loc(2)+xad*fy
+              strs_loc(3)=strs_loc(3)+xad*fz
+              strs_loc(4)=strs_loc(4)+yad*fy
+              strs_loc(5)=strs_loc(5)+yad*fz
+              strs_loc(6)=strs_loc(6)+zad*fz
+              
+            endif
+            
+          endif
+          
+c     1-4 short ranged : adjust by weighting factor
+          
+          scale=prmdih(kk,5)
+          gamma=0.d0
+          
+          if(mod(keyfce,2).eq.1)then
+            
+c     atomic and potential function indices
+            
+            ka=max(ltype(ia),ltype(id))
+            kb=min(ltype(ia),ltype(id))
+            k=lstvdw((ka*(ka-1))/2+kb)
+            
+            if(abs(scale*vvv(1,k)).gt.1.d-10)then
+              
+c     apply truncation of potential
+              
+              if(rvdw.gt.rad)then
+                
+c     determine interpolation panel for force arrays
+                
+                l=int(rad/dlrpot)
+                ppp=rad/dlrpot-dble(l)
+                
+c     calculate interaction energy using 3-point interpolation
+                
+                vk0=vvv(l,k)
+                vk1=vvv(l+1,k)
+                vk2=vvv(l+2,k)
+                
+                t1=vk0+(vk1-vk0)*ppp
+                t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+                
+                srpot=scale*(t1+(t2-t1)*ppp*0.5d0)
+                
+c     calculate forces using 3-point interpolation
+                
+                gk0=ggg(l,k)
+                gk1=ggg(l+1,k)
+                gk2=ggg(l+2,k)
+                
+                t1=gk0+(gk1-gk0)*ppp
+                t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+                
+                gamma=scale*(t1+(t2-t1)*ppp*0.5d0)/(rad**2)
+                
+c     set selection control for short ranged 1-4 terms
+                
+                lselect=.true.
+                
+c     set double index
+                
+                if(lsolva)kkk=loc2(atmolt(ia),atmolt(id))
+                
+                if(lexcite)then
+                  
+c     selected excitation option
+                  
+                  if((atm_fre(ia).ne.1).and.(atm_fre(id).ne.1))then
+                    
+c     set selection control
+                    
+                    lselect=(atm_fre(ia)+atm_fre(id).eq.0)
+                    
+                    if(lsolva)vdw_exc(kkk)=vdw_exc(kkk)+srpot
+                    
+                  endif
+                  
+                elseif(lfree)then
+                  
+c     selected free energy option
+                  
+                  if((atm_fre(ia).eq.1).or.(atm_fre(id).eq.1))then
+                    
+c     set hamiltonian mixing parameter
+                    
+                    vdw_fre=vdw_fre-srpot
+                    vdw14_vir=vdw14_vir+gamma*rad**2
+                    srpot=lambda1*srpot
+                    gamma=lambda1*gamma
+                    
+                  elseif((atm_fre(ia).eq.2).or.(atm_fre(id).eq.2))then
+                    
+c     set hamiltonian mixing parameter
+                    
+                    vdw_fre=vdw_fre+srpot
+                    vdw14_vir=vdw14_vir-gamma*rad**2
+                    srpot=lambda2*srpot
+                    gamma=lambda2*gamma
+                    
+                  endif
+                  
+                endif
+                
+                if(lselect)then
+                  
+c     short ranged energy and virial for 1-4 term
+                  
+                  engs14=engs14+srpot
+                  virs14=virs14-gamma*rad**2
+                  
+c     solvation energy for short ranged 1-4 term
+                  
+                  if(lsolva)vdw_sol(kkk)=vdw_sol(kkk)+srpot
+                  
+c     short ranged forces for 1-4 term
+                  
+                  fx=gamma*xad
+                  fy=gamma*yad
+                  fz=gamma*zad
+                  
+                  fxx(ia)=fxx(ia)+fx
+                  fyy(ia)=fyy(ia)+fy
+                  fzz(ia)=fzz(ia)+fz
+                  
+                  fxx(id)=fxx(id)-fx
+                  fyy(id)=fyy(id)-fy
+                  fzz(id)=fzz(id)-fz
+                  
+c     stress tensor for short ranged 1-4 term
+                  
+                  strs(1)=strs(1)+xad*fx
+                  strs(2)=strs(2)+xad*fy
+                  strs(3)=strs(3)+xad*fz
+                  strs(4)=strs(4)+yad*fy
+                  strs(5)=strs(5)+yad*fz
+                  strs(6)=strs(6)+zad*fz
+                  
+                endif
+                
+c     metadynamics local parameters
+                  
+                if(lmetadyn.and.(idrive.or.ldrive))then
+                  
+c     local energy and virial
+                  
+                  eng_loc=eng_loc+srpot
+                  vir_loc=vir_loc-gamma*rad**2
+                  
+c     local forces
+                  
+                  fxx_loc(ia)=fxx_loc(ia)+fx
+                  fyy_loc(ia)=fyy_loc(ia)+fy
+                  fzz_loc(ia)=fzz_loc(ia)+fz
+                  
+                  fxx_loc(id)=fxx_loc(id)-fx
+                  fyy_loc(id)=fyy_loc(id)-fy
+                  fzz_loc(id)=fzz_loc(id)-fz
+                  
+c     stress tensor for short ranged 1-4 term
+                  
+                  strs_loc(1)=strs_loc(1)+xad*fx
+                  strs_loc(2)=strs_loc(2)+xad*fy
+                  strs_loc(3)=strs_loc(3)+xad*fz
+                  strs_loc(4)=strs_loc(4)+yad*fy
+                  strs_loc(5)=strs_loc(5)+yad*fz
+                  strs_loc(6)=strs_loc(6)+zad*fz
+                  
+                endif
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        endif
+
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     sum contributions to potentials
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engdih
+        buffer(2)=engc14
+        buffer(3)=virc14
+        buffer(4)=engs14
+        buffer(5)=virs14
+        buffer(6)=dih_fre
+        buffer(7)=dih_vir
+        buffer(8)=vdw14_vir
+        buffer(9)=cou14_vir
+        call gdsum(buffer(1),9,buffer(10))
+        engdih=buffer(1)
+        engc14=buffer(2)
+        virc14=buffer(3)
+        engs14=buffer(4)
+        virs14=buffer(5)
+        dih_fre=buffer(6)
+        dih_vir=buffer(7)
+        vdw14_vir=buffer(8)
+        cou14_vir=buffer(9)
+        
+        if(lsolva)then
+          
+          call gdsum(dih_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(dih_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      engcpe=engcpe+engc14
+      vircpe=vircpe+virc14
+      engsrp=engsrp+engs14
+      virsrp=virsrp+virs14
+      vdw_vir=vdw_vir+vdw14_vir
+      cou_vir=cou_vir+cou14_vir
+      
+c     check for undefined potentials
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,448)
+      
+      deallocate (xdab,ydab,zdab,stat=fail1)
+      deallocate (xdbc,ydbc,zdbc,stat=fail2)
+      deallocate (xdcd,ydcd,zdcd,stat=fail3)
+      
+      return
+      end subroutine dihfrc
+      
+      end module dihedral_module
diff -urN dl_class_1.9.orig/srcmod/dlpoly.f dl_class_1.9/srcmod/dlpoly.f
--- dl_class_1.9.orig/srcmod/dlpoly.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dlpoly.f	2015-11-09 15:05:00.200575192 +0100
@@ -0,0 +1,975 @@
+      program dlpoly_classic
+      
+c***********************************************************************
+c     
+c     dl_poly classic is an stfc/ccp5 program package for the 
+c     dynamical simulation of molecular systems.
+c     
+c     dl_poly is the copyright of the stfc daresbury laboratory, 
+c     daresbury, warrington wa4 4ad. 
+c     
+c     neither the stfc, daresbury laboratory, ccp5 nor the authors
+c     of this package claim that it is free from errors and do not
+c     accept liability for any loss or damage that may arise from
+c     its use. it is the users responsibility to verify that the 
+c     package dl_poly is fit for the purpose the user intends for
+c     it.
+c     
+c     users of this package are recommended to consult the dl_poly
+c     user manual for the full description of its use and purpose.
+c     
+c     authors: w.smith and t.r.forester 1995
+c     copyright daresbury laboratory 1995
+c     
+c                       DL_POLY CLASSIC VERSION 1.9
+c
+c***********************************************************************
+      
+c     declare required modules
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use define_system_module
+      use dihedral_module
+      use driver_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use forces_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use integrator_module
+      use inversion_module
+      use metal_module
+      use metafreeze_module
+      use nlist_builders_module
+      use pair_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      implicit none
+      
+      character*1 hms,dec
+      character*8 seek
+      
+      logical ltscal,lzeql,loptim,ltraj,lgofr,lpgr,lfcap,recycle
+      logical newlst,lneut,loglnk,lnsq,lzden,lshmov,lcnb,ltad,lneb
+      logical stropt,lzero,nolink,newgau,lminim,lminnow,lhit,lbpd
+      logical prechk,tadall,lexcite,lsolva,lfree,lfrmas,lswitch
+      logical lghost,llswitch,lnfic,nebgo,lpsoc,redirect
+      
+      integer npage,lines,idnode,mxnode,memr,intsta,istraj,nsbzdn
+      integer keyens,keyfce,keyres,keytrj,kmax1,kmax2,kmax3,multt
+      integer nstack,nstbgr,nstbpo,nhko,nlatt,nstbts,nsteql,nstraj
+      integer nstrun,nospl,keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw
+      integer ntptbp,ntpmet,ntpfbp,nshels,imcon,levcfg,nneut,minstp
+      integer ntangl,ntbond,ntcons,ntdihd,ntinv,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,nstep,numacc,numrdf,nzden,nscons,i,k
+      integer ntpter,keyshl,isw,keyver,keystr,keytol,numgau,khit
+      integer nhit,keybpd,ntrack,nblock,blkout,numneb,nturn,mode
+      integer natms2,ntghost,nsolva,isolva,nofic
+      
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,tzero,dlrpot,drewd
+      real(8) engunit,rcuttb,rctter,rcutfb,degfre,degrot,chit,conint
+      real(8) elrc,virlrc,engbnd,volm,degshl,chip,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtbp,virtbp,engter,virter
+      real(8) engfbp,virfbp,engsrp,virsrp,engcpe,vircpe,vircon,vircom
+      real(8) engfld,virfld,engshl,virshl,shlke,engtet,virtet,virpmf
+      real(8) consv,engke,engrot,sigma,virtot,engcfg,prntim,simtim
+      real(8) stpeng,stpeth,stpprs,stptmp,stpvir,stpvol,width,zlen
+      real(8) timelp,engmet,virmet,pass0,pass1,pass2,rlxtol,opttol
+      real(8) catchrad,sprneb,deltad,tlow,engtke,ehit,xhit,yhit,zhit
+      real(8) ebias,vmin,hyp_units,estar,chit_shl,sigma_shl
+      real(8) engord,virord
+c PLUMED modifications
+      real(8) energyUnits,lengthUnits,timeUnits
+      integer(8) get_comms
+c PLUMED modifications
+
+      real(8), allocatable :: tbuffer(:)
+      integer :: plumedavaiable
+      
+      data timelp/0.d0/,lminnow/.false./,ntrack/10/
+      data npage,lines/8,0/,recycle/.true./
+      data pass0/0.d0/,pass1/0.d0/,pass2/0.d0/
+      data delr,epsq,press,quattol,rprim,rvdw/6*0.d0/
+      data temp,timcls,timjob,tolnce,rlxtol/5*0.d0/
+      
+c     set up the communications
+      
+      call initcomms()
+      call gsync()
+      
+c     determine processor identities
+      
+      call machine(idnode,mxnode)
+            
+c     activate for limited-life executable
+      
+CBOMB      call bomb(idnode,2008,6,30)
+      
+      allocate (tbuffer(10),stat=memr)
+      
+      call parset(redirect,idnode,mxnode,tbuffer)
+      
+c     open main printing file
+      
+      if(.not.redirect.and.idnode.eq.0)open(nrite,file='OUTPUT')
+      if(idnode.eq.0) write (nrite,
+     x  "(/,20x,'DL_POLY Classic 1.9',
+     x  /,/,30x,'Running on ',i4,' nodes',/,/)") mxnode
+
+c     allocate arrays for each function
+      
+      call alloc_ang_arrays(idnode)
+      call alloc_bnd_arrays(idnode)
+      call alloc_config_arrays(idnode)
+      call alloc_csh_arrays(idnode)
+      call alloc_dih_arrays(idnode)
+      call alloc_ewald_arrays(idnode)
+      call alloc_exc_arrays(idnode)
+      call alloc_exi_arrays(idnode)
+      call alloc_fbp_arrays(idnode)
+      call alloc_fld_arrays(idnode)
+      call alloc_free_arrays(idnode)
+      call alloc_hke_arrays(idnode)
+      call alloc_hyper_arrays(idnode)
+      call alloc_inv_arrays(idnode)
+      call alloc_met_arrays(idnode)
+      call alloc_pair_arrays(idnode)
+      call alloc_pmf_arrays(idnode)
+      call alloc_prp_arrays(idnode)
+      call alloc_rgbdy_arrays(idnode)
+      call alloc_shake_arrays(idnode)
+      call alloc_site_arrays(idnode)
+      call alloc_sol_arrays(idnode)
+      call alloc_spme_arrays(idnode)
+      call alloc_tbp_arrays(idnode)
+      call alloc_ter_arrays(idnode)
+      call alloc_tet_arrays(idnode)
+      call alloc_vdw_arrays(idnode)
+      
+c     start clock
+      
+      call timchk(0,tzero)
+      
+c     input the control parameters defining the simulation
+      
+      call simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c     input the system force field
+      
+      call sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+      if(ntpmet.gt.0.and.multt.gt.1)call error(idnode,153)
+      
+c     construct initial configuration of system
+      
+      call sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c     construct initial bookkeeping arrays
+      
+      call sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c     reset atom numbers for excitation simulation
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     set initial system temperature
+      
+      call systemp
+     x  (idnode,imcon,keyres,mxnode,natms2,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c     read thermodynamic and structural data from restart file
+      
+      call sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c     metadynamics by d. quigley
+      
+      if(lmetadyn) then
+
+c        make copy of excluded atom list for use by metadynamics
+         call exclude_copy_mtd(idnode)
+
+c        initialise metadynamics, read order parameter definitions etc.
+         call define_metadynamics(idnode,mxnode,natms,ntpatm,temp)   
+
+      end if
+
+c     synchronise LRC, SIC and system charge terms for switching
+      
+      llswitch=.false.
+      if(lswitch)then
+        
+        if(nstep.ge.nswitch)then
+          
+          if(mod((nstep-nswitch)/niswitch,2).eq.0)then
+            
+            call switch_atm(lfrmas)
+            call switch(elrc,virlrc)
+            llswitch=.true.
+            
+          endif
+          
+        endif
+        
+      endif
+
+c PLUMED modifications
+      if(lplumed)then
+
+         call plumed_f_installed(plumedavaiable)
+
+       if (plumedavaiable<=0) then
+        if(idnode.eq.0) write(nrite,*)"PLUMED NOT AVAILABLE" 
+        stop
+       else 
+        call plumed_f_gcreate()
+        call plumed_f_gcmd("setMPIFComm"//char(0),get_comms())
+        call plumed_f_gcmd("setRealPrecision"//char(0),8)
+        energyUnits=0.01
+        lengthUnits=0.1
+        timeUnits=1
+        call plumed_f_gcmd("setMDEnergyUnits"//char(0),energyUnits)
+        call plumed_f_gcmd("setMDLengthUnits"//char(0),lengthUnits)
+        call plumed_f_gcmd("setMDTimeUnits"//char(0),timeUnits)
+       call plumed_f_gcmd("setPlumedDat"//char(0),"plumed.dat"//char(0))
+        call plumed_f_gcmd("setLogFile"//char(0),"PLUMED.OUT"//char(0))
+        call plumed_f_gcmd("setNatoms"//char(0),natms)
+        call plumed_f_gcmd("setMDEngine"//char(0),"dlpoly2.20"//char(0))
+        call plumed_f_gcmd("setTimestep"//char(0),tstep)
+        call plumed_f_gcmd("init"//char(0),0)
+       end if 
+      endif
+
+c PLUMED modifications
+      
+c     zero long range component of stress
+      
+      do i=1,9
+        stresl(i)=0.d0
+      enddo
+      
+c     zero contraint terms
+      
+      vircon=0.d0
+      virpmf=0.d0
+      if(lminim.or.loptim.or.ntcons.eq.0)then
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     define target kinetic energy
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+c     metadynamics by d. quigley
+      
+      sigma_shl=boltz*degshl*0.5d0      
+      
+c     convert BPD parameters to internal units
+      
+      if(lbpd)then
+        
+        ebias=0.5d0*boltz*degfre*ebias
+        vmin=0.5d0*boltz*degfre*vmin
+        
+      endif
+      
+c     time check
+
+      call timchk(1,tzero)
+
+c     control variable for structure optimizer
+      
+      keystr=0
+      stropt=.false.
+      
+      if(lminim)then
+        
+c     first step of minimisation programme
+
+        if(idnode.eq.0)write(nrite,"(1x,120('-'))")
+        
+        call minimiser
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x    keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x    ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x    nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x    ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x    engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x    virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x    virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x    virtot,sigma,tolnce,engunit,engord,virord)
+      
+c     calculate initial conditions for velocity verlet
+      
+      elseif(keyver.eq.1.and.nstep.eq.0)then
+        
+c     kinetic stress tensor at start
+        
+        call dcell(cell,celprp)
+        width=min(celprp(7),celprp(8),celprp(9))
+        call kinstress(natms,idnode,mxnode,stress)
+        engke=0.5d0*(stress(1)+stress(5)+stress(9))
+        do i=1,9
+          stress(i)=stress(i)/dble(mxnode)
+        enddo
+        
+c     calculate initial forces
+        
+        call molecular_dynamics
+     x    (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x    newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x    kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x    nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x    ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x    ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x    enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x    opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x    engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x    virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x    virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+      endif
+      
+      if(ltad.or.(lbpd.and.keybpd.eq.2))then
+        
+c     construct the first reference state
+        
+        call hyper_start
+     x    (ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x    imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x    mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,
+     x    nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,
+     x    ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,ntcons,ntrack,alpha,
+     x    delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,sigma,
+     x    hyp_units)
+        
+      endif
+      
+c     perform selected NEB calculation
+        
+      if(lneb)then
+        
+        do i=1,numneb
+          
+          call neb_driver
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn_1(i),
+     x      bsn_2(i),idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x      keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x      ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x      keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x      ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x      rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x      engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x      engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x      engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x      virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x      temp,tstep,opttol,sprneb,hyp_units)
+          
+          call scan_profile(nturn,estar)
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,"(1x,120('-'))")
+            write(nrite,'(1x,"TRA",3i6,1p,4e14.5)')
+     x        bsn_1(i),bsn_2(i),nturn,estar/hyp_units
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+        enddo
+        
+c     bypass the MD cycle for this option
+        
+        recycle=.false.
+        
+      endif
+        
+c***********************************************************************
+c     start of molecular dynamics calculations
+c***********************************************************************
+      
+      do while(recycle)
+        
+c     increase step counter
+        
+        nstep=nstep+1
+        recycle=(nstep.lt.nstrun)
+        
+c     store velocities for free energy or solvation simulation
+        
+        if(keyver.eq.0)then
+          
+          if(lsolva)then
+            
+            vxo_sol(:)=vxx(:)
+            vyo_sol(:)=vyy(:)
+            vzo_sol(:)=vzz(:)
+            
+          elseif(lfree)then
+            
+            vxo_fre(:)=vxx(:)
+            vyo_fre(:)=vyy(:)
+            vzo_fre(:)=vzz(:)
+            
+          endif
+          
+        endif
+        
+c     molecular switching option for excitation
+        
+        if(lswitch)then
+          
+          if(nstep.ge.nswitch)then
+            
+            if(mod(nstep-nswitch,niswitch).eq.0)then
+              
+              call switch_atm(lfrmas)
+              call switch(elrc,virlrc)
+              llswitch=.not.llswitch
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     switch on the minimiser
+        
+        if(lminim)then
+          
+          lminnow=(mod(nstep,minstp).eq.0)
+          
+        endif
+        
+c     conserved quantity (other than K + U)
+        
+        consv=0.d0
+        
+c     energy accumulators
+        
+        if(.not.lminnow)then
+          
+          engke=0.d0
+          engrot=0.d0
+        
+        endif
+        
+c     calculate volume of simulation cell
+        
+        if(imcon.ne.0.and.imcon.ne.6)then
+          
+          call dcell(cell,celprp)
+          volm=celprp(10)
+          if(imcon.eq.4)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.5)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.7)then
+            
+            volm=0.5d0*celprp(10)
+            
+          endif
+          
+        else
+          
+          volm=0.d0
+          
+        endif
+        
+c     reset sutton chen long range corrections (constant pressure only)
+        
+        if(ntpmet.gt.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call lrcmetal
+     x      (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+          
+        endif
+        
+c     activate the impact option at designated time step
+        
+        if(lhit.and.nstep.eq.nhit)call impact
+     x    (khit,natms,idnode,mxnode,ehit,xhit,yhit,zhit)
+        
+c     integrate equations of motion stage 1 of velocity verlet
+        
+        if(keyver.gt.0)then
+          
+          isw=1
+          if(.not.loptim)then
+            
+            if(llswitch)call copy_force(idnode,mxnode)
+            
+            call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+            
+            if(lghost)call update_ghost(idnode,mxnode)
+            
+            if(lfree.or.lghost)
+     x        call lrcorrect_fre(lfree,volm,elrc,virlrc)
+            if(lsolva)call lrcorrect_sol(lghost,volm)
+            
+          endif
+
+c     scale t=0 tether reference positions (constant pressure only)
+          
+          if(keyens.ge.4.and.keyens.le.7) then
+            
+            call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+            
+          endif
+          
+        endif
+        
+        if(lminnow)then
+          
+          call minimiser
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x      keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x      ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x      nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x      ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x      engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x      rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x      virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x      virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x      virtot,sigma,tolnce,engunit,engord,virord)
+        
+        elseif(loptim.or.keyshl.ne.2)then
+          
+          call molecular_dynamics
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x      newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x      idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x      kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x      nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x      ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x      ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x      enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x      engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x      virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+          
+        else
+          
+          call shell_relaxation
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,lzeql,newlst,ltad,lsolva,
+     x      lfree,lghost,idnode,imcon,keyfce,keyfld,keyshl,
+     x      kmax1,kmax2,kmax3,multt,mxnode,natms,nhko,nlatt,nneut,
+     x      nospl,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,
+     x      ntpmls,nsolva,isolva,alpha,delr,dlrpot,drewd,elrc,engang,
+     x      engbnd,engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp,
+     x      engtbp,engter,engtet,epsq,fmax,rctter,rcut,rcutfb,rcuttb,
+     x      rprim,rvdw,shlke,engcfg,temp,tstep,virang,virbnd,vircpe,
+     x      virdih,virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,rlxtol,pass0,
+     x      pass1,pass2,engord,virord)
+          
+        endif
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+c     switching option for excitation simulation
+        
+        if(llswitch)call copy_force(idnode,mxnode)
+        
+c     integrate equations of motion
+        
+        if(keyver.eq.0)then
+          
+c     integrate equations of motion by leapfrog verlet
+          
+          if(.not.(loptim.or.lminnow))call lf_integrate
+     x      (lcnb,lshmov,lnfic,idnode,mxnode,imcon,natms2,nstep,ngrp,
+     x      keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x      tstep,engke,engrot,tolnce,quattol,vircon,vircom,virtot,
+     x      temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,
+     x      elrc,virlrc,virpmf)
+          
+        else if(keyver.gt.0)then
+          
+c     integrate equations of motion by velocity verlet (stage 2)
+          
+          isw=2
+          if(.not.loptim)call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+          
+        endif
+        
+c     update the atomic positions for the ghost molecule
+        
+        if(lghost)call update_ghost(idnode,mxnode)
+        
+c     long range correction adjustment for free energy and solvation
+        
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+        if(lfree.or.lghost)
+     x    call lrcorrect_fre(lfree,volm,elrc,virlrc)
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+c     application of transition analysis procedures
+        
+        if(ltad.or.(lbpd.and.keybpd.eq.2))then
+          
+          engtke=engke+engrot
+          call hyper_driver
+     x      (seek,ltad,lbpd,recycle,lfcap,lneut,lnsq,loglnk,lzeql,
+     x      newlst,prechk,tadall,nebgo,nblock,ntrack,idnode,imcon,
+     x      keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x      mxnode,natms,ngrp,ntcons,nhko,nlatt,nneut,nospl,nscons,
+     x      nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,blkout,
+     x      alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x      tstep,volm,engcfg,catchrad,sprneb,deltad,tlow,engtke,
+     x      tolnce,hyp_units,ebias,vmin)
+          
+        endif
+        
+c     reset average boost factor in BPD during equilibration
+      
+      if(lbpd.and.keybpd.eq.1)then
+      
+        if(lzeql.and.nstep.le.nsteql)then
+          
+          numbpd=0
+          tboost=0.d0
+          
+        endif
+        
+      endif
+      
+c     calculate shell kinetic energy
+        
+        if(keyshl.eq.1)then
+          
+          call corshl(idnode,mxnode,ntshl,shlke)
+          
+        endif
+        
+c     scale t=0 tether reference positions (constant pressure only)
+        
+        if(keyver.eq.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+          
+        endif
+        
+c     apply temperature scaling
+        
+        if((ltscal.and.nstep.le.nsteql).and.
+     x    mod(nstep-nsteql,nstbts).eq.0)then
+          
+          chit=0.d0
+          chit_shl=0.d0
+          chip=0.d0
+          do i=1,9
+            eta(i)=0.d0
+          enddo
+          
+          if(keyshl.eq.1) then
+            
+            do k=1,4
+              
+              call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+              call shlqnch(idnode,mxnode,ntshl,temp)
+              
+            enddo
+            
+          else
+            
+            call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+            
+          endif
+          
+        endif
+        
+c     reset atom velocities at intervals if required
+        
+        if(newgau)then
+          
+          if(mod(nstep,numgau).eq.0)call regauss
+     x      (idnode,imcon,mxnode,natms2,ngrp,nscons,ntcons,
+     x      ntshl,keyshl,sigma,temp,tolnce)
+          
+        endif
+        
+c     calculate physical quantities
+        
+        if(nstep.gt.0)call static
+     x    (lbpd,lzeql,idnode,intsta,imcon,keyens,natms,nstack,
+     x    nstep,nsteql,ntpatm,numacc,mxnode,nblock,keybpd,numbpd,
+     x    consv,degfre,degrot,engang,engbnd,engcpe,engdih,enginv,
+     x    engke,engrot,engsrp,engunit,engcfg,stpeng,stpeth,stpprs,
+     x    stptmp,stpvir,stpvol,tstep,virbnd,engfbp,vircom,vircon,
+     x    vircpe,virsrp,engfld,virfld,engtbp,virtbp,virpmf,virshl,
+     x    engshl,engtet,virtet,degshl,shlke,virang,width,engmet,
+     x    virmet,engter,virter,boost,tboost)
+        
+c     z density calculation
+        
+        if(lzden.and.((.not.lzeql).or.(nstep.gt.nsteql))) then
+          
+          call zden0(idnode,natms,mxnode,nzden,zlen)
+          
+        endif
+        
+c     terminate program if boundary conditions violated
+        
+        if(imcon.gt.0.and.rcut.gt.width)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          call error(idnode,95)
+          
+        endif
+        
+c     line-printer output every nstbpo steps
+        
+        if(nstep.eq.1.or.(nstep.gt.1.and.mod(nstep,nstbpo).eq.0))then
+          
+          call timchk(0,timelp)
+          if(idnode.eq.0)then
+            
+            call get_prntime(hms,timelp,prntim)
+            call get_simtime(dec,nstep,tstep,simtim)
+            if(mod(lines,npage).eq.0)
+     x        write(nrite,"(1x,120('-'),
+     x        /,/,1x,'    step',5x,'eng_tot',4x,'temp_tot',5x,
+     x        'eng_cfg',5x,'eng_vdw',5x,'eng_cou',5x,'eng_bnd',
+     x        5x,'eng_ang',5x,'eng_dih',5x,'eng_tet',/,1x,
+     x        'time    ',5x,' eng_pv',4x,'temp_rot',5x,'vir_cfg',
+     x        5x,'vir_vdw',5x,'vir_cou',5x,'vir_bnd',5x,'vir_ang',
+     x        5x,'vir_con',5x,'vir_tet',/,1x,'cpu time',6x,
+     x        'volume',4x,'temp_shl',5x,'eng_shl',5x,'vir_shl',
+     x        7x,'alpha',8x,'beta',7x,'gamma',5x,'vir_pmf',
+     x        7x,'press',/,/,
+     x        1x,120('-'))")
+            write(nrite,"(1x,i8,1p,9e12.4,/,1x,0p,f7.3,a1,1p,9e12.4,
+     x        /,1x,0p,f7.3,a1,1p,9e12.4)")
+     x        nstep,(stpval(i),i=1,9),
+     x        simtim,dec,(stpval(i),i=10,18),
+     x        prntim,hms,(stpval(i),i=19,27)
+            write(nrite,"(/,1x,' rolling',1p,9e12.4,/,1x,'averages',
+     x        1p,9e12.4,/,9x,1p,9e12.4)") (ravval(i),i=1,27)
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+          lines=lines+1
+          
+        endif
+        
+c     report end of equilibration period
+        
+        if((.not.loptim).and.(.not.lzero).and.(nstep.ge.nsteql))then
+          
+          if((ltscal.and.idnode.eq.0).and.(nstep.eq.nsteql))
+     x      write(nrite,"(/,/,1x,'switching off temperature ',
+     x      'scaling at step ',i6,/,/,/,1x,120('-'))") nstep
+          ltscal=.false.
+          
+        endif
+        
+c     write trajectory data
+        
+        if(ltraj.and.nstep.ge.nstraj) then
+          if(idnode.eq.0.and.mod(nstep-nstraj,istraj).eq.0)then
+            
+            call traject
+     x        (ltraj,idnode,imcon,istraj,keytrj,natms,
+     x        nstraj,nstep,tstep)
+            
+          endif
+          
+        endif
+        
+c     write solvation energy file
+        
+        if(lsolva.and.nstep.ge.nsolva)then
+          
+          if(mod(nstep-nsolva,isolva).eq.0)then
+            
+            call solva_temp(idnode,mxnode,natms2,keyver)
+            call solvation_write(lexcite,lswitch,idnode,natms,
+     x        nstep,nsolva,isolva,tstep,engunit,elrc)
+            
+          endif
+          
+        endif
+        
+c     write free energy file
+        
+        if(lfree.and.nstep.ge.nfrn)then
+          
+          if(mod(nstep-nfrn,ifrn).eq.0)then
+            
+            call free_kinetic(lfrmas,idnode,mxnode,keyver)
+            call free_energy_write(idnode,nstep,engunit)
+          
+          endif
+          
+        endif
+        
+c     save restart data in event of system crash
+        
+        if(mod(nstep,ndump).eq.0.and.nstep.ne.nstrun)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          
+          if(ltad.or.lbpd)
+     x      call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+          
+        endif
+        
+c     cycle time check
+        
+        call timchk(0,timelp)
+        recycle=(recycle.and.timjob-timelp.gt.timcls)
+        
+      enddo
+      
+c***********************************************************************
+c     end of molecular dynamics calculations
+c***********************************************************************
+      
+c     last time check
+        
+      call timchk(0,timelp)
+      call get_prntime(hms,timjob,prntim)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'run terminating. elapsed cpu time = ',1p,e13.5,
+     x  ', job time = ',0p,f7.3,a1,', close time = ',f7.2,'s',/)")
+     x  timelp,prntim,hms,timcls
+      
+c     shell relaxation convergence statistics
+      
+      if(.not.loptim.and.keyshl.eq.2)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,/,1x,'shell relaxation statistics : average cycles = ',
+     x    f8.3,' maximum cycles = ',f8.3)")pass1,pass2
+      
+      endif
+
+c     produce summary of simulation
+      
+      levcfg=2
+      if(loptim)levcfg=0
+      if(.not.lneb)call result
+     x  (ltad,lbpd,lgofr,lpgr,lzden,idnode,imcon,keyens,mxnode,natms,
+     x  levcfg,nzden,nstep,ntpatm,numacc,numrdf,keybpd,chip,chit,
+     x  conint,rcut,tstep,engcfg,volm,virtot,vircom,zlen,tboost,
+     x  chit_shl)
+
+c   PLUMED
+      if(lplumed) call plumed_f_gcmd()
+c   PLUMED
+      
+c     write hyperdynamics restart file
+      
+      if(ltad.or.lbpd)
+     x  call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+      
+c     close output channels
+      
+      if(idnode.eq.0) then
+        
+        close (nrite)
+        close (nstats)
+        close (nhist)
+        close (nevnt)
+        
+      endif
+      
+c     terminate job
+      
+      call exitcomms()
+      
+      end
diff -urN dl_class_1.9.orig/srcmod/dlpoly.f.preplumed dl_class_1.9/srcmod/dlpoly.f.preplumed
--- dl_class_1.9.orig/srcmod/dlpoly.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dlpoly.f.preplumed	2012-04-24 18:30:31.000000000 +0200
@@ -0,0 +1,936 @@
+      program dlpoly_classic
+      
+c***********************************************************************
+c     
+c     dl_poly classic is an stfc/ccp5 program package for the 
+c     dynamical simulation of molecular systems.
+c     
+c     dl_poly is the copyright of the stfc daresbury laboratory, 
+c     daresbury, warrington wa4 4ad. 
+c     
+c     neither the stfc, daresbury laboratory, ccp5 nor the authors
+c     of this package claim that it is free from errors and do not
+c     accept liability for any loss or damage that may arise from
+c     its use. it is the users responsibility to verify that the 
+c     package dl_poly is fit for the purpose the user intends for
+c     it.
+c     
+c     users of this package are recommended to consult the dl_poly
+c     user manual for the full description of its use and purpose.
+c     
+c     authors: w.smith and t.r.forester 1995
+c     copyright daresbury laboratory 1995
+c     
+c                       DL_POLY CLASSIC VERSION 1.9
+c
+c***********************************************************************
+      
+c     declare required modules
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use define_system_module
+      use dihedral_module
+      use driver_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use forces_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use integrator_module
+      use inversion_module
+      use metal_module
+      use metafreeze_module
+      use nlist_builders_module
+      use pair_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      implicit none
+      
+      character*1 hms,dec
+      character*8 seek
+      
+      logical ltscal,lzeql,loptim,ltraj,lgofr,lpgr,lfcap,recycle
+      logical newlst,lneut,loglnk,lnsq,lzden,lshmov,lcnb,ltad,lneb
+      logical stropt,lzero,nolink,newgau,lminim,lminnow,lhit,lbpd
+      logical prechk,tadall,lexcite,lsolva,lfree,lfrmas,lswitch
+      logical lghost,llswitch,lnfic,nebgo,lpsoc,redirect
+      
+      integer npage,lines,idnode,mxnode,memr,intsta,istraj,nsbzdn
+      integer keyens,keyfce,keyres,keytrj,kmax1,kmax2,kmax3,multt
+      integer nstack,nstbgr,nstbpo,nhko,nlatt,nstbts,nsteql,nstraj
+      integer nstrun,nospl,keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw
+      integer ntptbp,ntpmet,ntpfbp,nshels,imcon,levcfg,nneut,minstp
+      integer ntangl,ntbond,ntcons,ntdihd,ntinv,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,nstep,numacc,numrdf,nzden,nscons,i,k
+      integer ntpter,keyshl,isw,keyver,keystr,keytol,numgau,khit
+      integer nhit,keybpd,ntrack,nblock,blkout,numneb,nturn,mode
+      integer natms2,ntghost,nsolva,isolva,nofic
+      
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,tzero,dlrpot,drewd
+      real(8) engunit,rcuttb,rctter,rcutfb,degfre,degrot,chit,conint
+      real(8) elrc,virlrc,engbnd,volm,degshl,chip,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtbp,virtbp,engter,virter
+      real(8) engfbp,virfbp,engsrp,virsrp,engcpe,vircpe,vircon,vircom
+      real(8) engfld,virfld,engshl,virshl,shlke,engtet,virtet,virpmf
+      real(8) consv,engke,engrot,sigma,virtot,engcfg,prntim,simtim
+      real(8) stpeng,stpeth,stpprs,stptmp,stpvir,stpvol,width,zlen
+      real(8) timelp,engmet,virmet,pass0,pass1,pass2,rlxtol,opttol
+      real(8) catchrad,sprneb,deltad,tlow,engtke,ehit,xhit,yhit,zhit
+      real(8) ebias,vmin,hyp_units,estar,chit_shl,sigma_shl
+      real(8) engord,virord
+      real(8), allocatable :: tbuffer(:)
+      
+      data timelp/0.d0/,lminnow/.false./,ntrack/10/
+      data npage,lines/8,0/,recycle/.true./
+      data pass0/0.d0/,pass1/0.d0/,pass2/0.d0/
+      data delr,epsq,press,quattol,rprim,rvdw/6*0.d0/
+      data temp,timcls,timjob,tolnce,rlxtol/5*0.d0/
+      
+c     set up the communications
+      
+      call initcomms()
+      call gsync()
+      
+c     determine processor identities
+      
+      call machine(idnode,mxnode)
+            
+c     activate for limited-life executable
+      
+CBOMB      call bomb(idnode,2008,6,30)
+      
+      allocate (tbuffer(10),stat=memr)
+      
+      call parset(redirect,idnode,mxnode,tbuffer)
+      
+c     open main printing file
+      
+      if(.not.redirect.and.idnode.eq.0)open(nrite,file='OUTPUT')
+      if(idnode.eq.0) write (nrite,
+     x  "(/,20x,'DL_POLY Classic 1.9',
+     x  /,/,30x,'Running on ',i4,' nodes',/,/)") mxnode
+
+c     allocate arrays for each function
+      
+      call alloc_ang_arrays(idnode)
+      call alloc_bnd_arrays(idnode)
+      call alloc_config_arrays(idnode)
+      call alloc_csh_arrays(idnode)
+      call alloc_dih_arrays(idnode)
+      call alloc_ewald_arrays(idnode)
+      call alloc_exc_arrays(idnode)
+      call alloc_exi_arrays(idnode)
+      call alloc_fbp_arrays(idnode)
+      call alloc_fld_arrays(idnode)
+      call alloc_free_arrays(idnode)
+      call alloc_hke_arrays(idnode)
+      call alloc_hyper_arrays(idnode)
+      call alloc_inv_arrays(idnode)
+      call alloc_met_arrays(idnode)
+      call alloc_pair_arrays(idnode)
+      call alloc_pmf_arrays(idnode)
+      call alloc_prp_arrays(idnode)
+      call alloc_rgbdy_arrays(idnode)
+      call alloc_shake_arrays(idnode)
+      call alloc_site_arrays(idnode)
+      call alloc_sol_arrays(idnode)
+      call alloc_spme_arrays(idnode)
+      call alloc_tbp_arrays(idnode)
+      call alloc_ter_arrays(idnode)
+      call alloc_tet_arrays(idnode)
+      call alloc_vdw_arrays(idnode)
+      
+c     start clock
+      
+      call timchk(0,tzero)
+      
+c     input the control parameters defining the simulation
+      
+      call simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c     input the system force field
+      
+      call sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+      if(ntpmet.gt.0.and.multt.gt.1)call error(idnode,153)
+      
+c     construct initial configuration of system
+      
+      call sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c     construct initial bookkeeping arrays
+      
+      call sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c     reset atom numbers for excitation simulation
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     set initial system temperature
+      
+      call systemp
+     x  (idnode,imcon,keyres,mxnode,natms2,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c     read thermodynamic and structural data from restart file
+      
+      call sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c     metadynamics by d. quigley
+      
+      if(lmetadyn) then
+
+c        make copy of excluded atom list for use by metadynamics
+         call exclude_copy_mtd(idnode)
+
+c        initialise metadynamics, read order parameter definitions etc.
+         call define_metadynamics(idnode,mxnode,natms,ntpatm,temp)   
+
+      end if
+
+c     synchronise LRC, SIC and system charge terms for switching
+      
+      llswitch=.false.
+      if(lswitch)then
+        
+        if(nstep.ge.nswitch)then
+          
+          if(mod((nstep-nswitch)/niswitch,2).eq.0)then
+            
+            call switch_atm(lfrmas)
+            call switch(elrc,virlrc)
+            llswitch=.true.
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     zero long range component of stress
+      
+      do i=1,9
+        stresl(i)=0.d0
+      enddo
+      
+c     zero contraint terms
+      
+      vircon=0.d0
+      virpmf=0.d0
+      if(lminim.or.loptim.or.ntcons.eq.0)then
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     define target kinetic energy
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+c     metadynamics by d. quigley
+      
+      sigma_shl=boltz*degshl*0.5d0      
+      
+c     convert BPD parameters to internal units
+      
+      if(lbpd)then
+        
+        ebias=0.5d0*boltz*degfre*ebias
+        vmin=0.5d0*boltz*degfre*vmin
+        
+      endif
+      
+c     time check
+
+      call timchk(1,tzero)
+
+c     control variable for structure optimizer
+      
+      keystr=0
+      stropt=.false.
+      
+      if(lminim)then
+        
+c     first step of minimisation programme
+
+        if(idnode.eq.0)write(nrite,"(1x,120('-'))")
+        
+        call minimiser
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x    keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x    ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x    nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x    ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x    engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x    virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x    virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x    virtot,sigma,tolnce,engunit,engord,virord)
+      
+c     calculate initial conditions for velocity verlet
+      
+      elseif(keyver.eq.1.and.nstep.eq.0)then
+        
+c     kinetic stress tensor at start
+        
+        call dcell(cell,celprp)
+        width=min(celprp(7),celprp(8),celprp(9))
+        call kinstress(natms,idnode,mxnode,stress)
+        engke=0.5d0*(stress(1)+stress(5)+stress(9))
+        do i=1,9
+          stress(i)=stress(i)/dble(mxnode)
+        enddo
+        
+c     calculate initial forces
+        
+        call molecular_dynamics
+     x    (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x    newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x    kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x    nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x    ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x    ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x    enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x    opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x    engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x    virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x    virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+      endif
+      
+      if(ltad.or.(lbpd.and.keybpd.eq.2))then
+        
+c     construct the first reference state
+        
+        call hyper_start
+     x    (ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x    imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x    mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,
+     x    nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,
+     x    ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,ntcons,ntrack,alpha,
+     x    delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,sigma,
+     x    hyp_units)
+        
+      endif
+      
+c     perform selected NEB calculation
+        
+      if(lneb)then
+        
+        do i=1,numneb
+          
+          call neb_driver
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn_1(i),
+     x      bsn_2(i),idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x      keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x      ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x      keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x      ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x      rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x      engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x      engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x      engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x      virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x      temp,tstep,opttol,sprneb,hyp_units)
+          
+          call scan_profile(nturn,estar)
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,"(1x,120('-'))")
+            write(nrite,'(1x,"TRA",3i6,1p,4e14.5)')
+     x        bsn_1(i),bsn_2(i),nturn,estar/hyp_units
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+        enddo
+        
+c     bypass the MD cycle for this option
+        
+        recycle=.false.
+        
+      endif
+        
+c***********************************************************************
+c     start of molecular dynamics calculations
+c***********************************************************************
+      
+      do while(recycle)
+        
+c     increase step counter
+        
+        nstep=nstep+1
+        recycle=(nstep.lt.nstrun)
+        
+c     store velocities for free energy or solvation simulation
+        
+        if(keyver.eq.0)then
+          
+          if(lsolva)then
+            
+            vxo_sol(:)=vxx(:)
+            vyo_sol(:)=vyy(:)
+            vzo_sol(:)=vzz(:)
+            
+          elseif(lfree)then
+            
+            vxo_fre(:)=vxx(:)
+            vyo_fre(:)=vyy(:)
+            vzo_fre(:)=vzz(:)
+            
+          endif
+          
+        endif
+        
+c     molecular switching option for excitation
+        
+        if(lswitch)then
+          
+          if(nstep.ge.nswitch)then
+            
+            if(mod(nstep-nswitch,niswitch).eq.0)then
+              
+              call switch_atm(lfrmas)
+              call switch(elrc,virlrc)
+              llswitch=.not.llswitch
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     switch on the minimiser
+        
+        if(lminim)then
+          
+          lminnow=(mod(nstep,minstp).eq.0)
+          
+        endif
+        
+c     conserved quantity (other than K + U)
+        
+        consv=0.d0
+        
+c     energy accumulators
+        
+        if(.not.lminnow)then
+          
+          engke=0.d0
+          engrot=0.d0
+        
+        endif
+        
+c     calculate volume of simulation cell
+        
+        if(imcon.ne.0.and.imcon.ne.6)then
+          
+          call dcell(cell,celprp)
+          volm=celprp(10)
+          if(imcon.eq.4)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.5)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.7)then
+            
+            volm=0.5d0*celprp(10)
+            
+          endif
+          
+        else
+          
+          volm=0.d0
+          
+        endif
+        
+c     reset sutton chen long range corrections (constant pressure only)
+        
+        if(ntpmet.gt.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call lrcmetal
+     x      (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+          
+        endif
+        
+c     activate the impact option at designated time step
+        
+        if(lhit.and.nstep.eq.nhit)call impact
+     x    (khit,natms,idnode,mxnode,ehit,xhit,yhit,zhit)
+        
+c     integrate equations of motion stage 1 of velocity verlet
+        
+        if(keyver.gt.0)then
+          
+          isw=1
+          if(.not.loptim)then
+            
+            if(llswitch)call copy_force(idnode,mxnode)
+            
+            call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+            
+            if(lghost)call update_ghost(idnode,mxnode)
+            
+            if(lfree.or.lghost)
+     x        call lrcorrect_fre(lfree,volm,elrc,virlrc)
+            if(lsolva)call lrcorrect_sol(lghost,volm)
+            
+          endif
+
+c     scale t=0 tether reference positions (constant pressure only)
+          
+          if(keyens.ge.4.and.keyens.le.7) then
+            
+            call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+            
+          endif
+          
+        endif
+        
+        if(lminnow)then
+          
+          call minimiser
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x      keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x      ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x      nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x      ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x      engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x      rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x      virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x      virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x      virtot,sigma,tolnce,engunit,engord,virord)
+        
+        elseif(loptim.or.keyshl.ne.2)then
+          
+          call molecular_dynamics
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x      newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x      idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x      kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x      nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x      ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x      ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x      enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x      engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x      virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+          
+        else
+          
+          call shell_relaxation
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,lzeql,newlst,ltad,lsolva,
+     x      lfree,lghost,idnode,imcon,keyfce,keyfld,keyshl,
+     x      kmax1,kmax2,kmax3,multt,mxnode,natms,nhko,nlatt,nneut,
+     x      nospl,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,
+     x      ntpmls,nsolva,isolva,alpha,delr,dlrpot,drewd,elrc,engang,
+     x      engbnd,engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp,
+     x      engtbp,engter,engtet,epsq,fmax,rctter,rcut,rcutfb,rcuttb,
+     x      rprim,rvdw,shlke,engcfg,temp,tstep,virang,virbnd,vircpe,
+     x      virdih,virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,rlxtol,pass0,
+     x      pass1,pass2,engord,virord)
+          
+        endif
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+c     switching option for excitation simulation
+        
+        if(llswitch)call copy_force(idnode,mxnode)
+        
+c     integrate equations of motion
+        
+        if(keyver.eq.0)then
+          
+c     integrate equations of motion by leapfrog verlet
+          
+          if(.not.(loptim.or.lminnow))call lf_integrate
+     x      (lcnb,lshmov,lnfic,idnode,mxnode,imcon,natms2,nstep,ngrp,
+     x      keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x      tstep,engke,engrot,tolnce,quattol,vircon,vircom,virtot,
+     x      temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,
+     x      elrc,virlrc,virpmf)
+          
+        else if(keyver.gt.0)then
+          
+c     integrate equations of motion by velocity verlet (stage 2)
+          
+          isw=2
+          if(.not.loptim)call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+          
+        endif
+        
+c     update the atomic positions for the ghost molecule
+        
+        if(lghost)call update_ghost(idnode,mxnode)
+        
+c     long range correction adjustment for free energy and solvation
+        
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+        if(lfree.or.lghost)
+     x    call lrcorrect_fre(lfree,volm,elrc,virlrc)
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+c     application of transition analysis procedures
+        
+        if(ltad.or.(lbpd.and.keybpd.eq.2))then
+          
+          engtke=engke+engrot
+          call hyper_driver
+     x      (seek,ltad,lbpd,recycle,lfcap,lneut,lnsq,loglnk,lzeql,
+     x      newlst,prechk,tadall,nebgo,nblock,ntrack,idnode,imcon,
+     x      keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x      mxnode,natms,ngrp,ntcons,nhko,nlatt,nneut,nospl,nscons,
+     x      nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,blkout,
+     x      alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x      tstep,volm,engcfg,catchrad,sprneb,deltad,tlow,engtke,
+     x      tolnce,hyp_units,ebias,vmin)
+          
+        endif
+        
+c     reset average boost factor in BPD during equilibration
+      
+      if(lbpd.and.keybpd.eq.1)then
+      
+        if(lzeql.and.nstep.le.nsteql)then
+          
+          numbpd=0
+          tboost=0.d0
+          
+        endif
+        
+      endif
+      
+c     calculate shell kinetic energy
+        
+        if(keyshl.eq.1)then
+          
+          call corshl(idnode,mxnode,ntshl,shlke)
+          
+        endif
+        
+c     scale t=0 tether reference positions (constant pressure only)
+        
+        if(keyver.eq.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+          
+        endif
+        
+c     apply temperature scaling
+        
+        if((ltscal.and.nstep.le.nsteql).and.
+     x    mod(nstep-nsteql,nstbts).eq.0)then
+          
+          chit=0.d0
+          chit_shl=0.d0
+          chip=0.d0
+          do i=1,9
+            eta(i)=0.d0
+          enddo
+          
+          if(keyshl.eq.1) then
+            
+            do k=1,4
+              
+              call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+              call shlqnch(idnode,mxnode,ntshl,temp)
+              
+            enddo
+            
+          else
+            
+            call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+            
+          endif
+          
+        endif
+        
+c     reset atom velocities at intervals if required
+        
+        if(newgau)then
+          
+          if(mod(nstep,numgau).eq.0)call regauss
+     x      (idnode,imcon,mxnode,natms2,ngrp,nscons,ntcons,
+     x      ntshl,keyshl,sigma,temp,tolnce)
+          
+        endif
+        
+c     calculate physical quantities
+        
+        if(nstep.gt.0)call static
+     x    (lbpd,lzeql,idnode,intsta,imcon,keyens,natms,nstack,
+     x    nstep,nsteql,ntpatm,numacc,mxnode,nblock,keybpd,numbpd,
+     x    consv,degfre,degrot,engang,engbnd,engcpe,engdih,enginv,
+     x    engke,engrot,engsrp,engunit,engcfg,stpeng,stpeth,stpprs,
+     x    stptmp,stpvir,stpvol,tstep,virbnd,engfbp,vircom,vircon,
+     x    vircpe,virsrp,engfld,virfld,engtbp,virtbp,virpmf,virshl,
+     x    engshl,engtet,virtet,degshl,shlke,virang,width,engmet,
+     x    virmet,engter,virter,boost,tboost)
+        
+c     z density calculation
+        
+        if(lzden.and.((.not.lzeql).or.(nstep.gt.nsteql))) then
+          
+          call zden0(idnode,natms,mxnode,nzden,zlen)
+          
+        endif
+        
+c     terminate program if boundary conditions violated
+        
+        if(imcon.gt.0.and.rcut.gt.width)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          call error(idnode,95)
+          
+        endif
+        
+c     line-printer output every nstbpo steps
+        
+        if(nstep.eq.1.or.(nstep.gt.1.and.mod(nstep,nstbpo).eq.0))then
+          
+          call timchk(0,timelp)
+          if(idnode.eq.0)then
+            
+            call get_prntime(hms,timelp,prntim)
+            call get_simtime(dec,nstep,tstep,simtim)
+            if(mod(lines,npage).eq.0)
+     x        write(nrite,"(1x,120('-'),
+     x        /,/,1x,'    step',5x,'eng_tot',4x,'temp_tot',5x,
+     x        'eng_cfg',5x,'eng_vdw',5x,'eng_cou',5x,'eng_bnd',
+     x        5x,'eng_ang',5x,'eng_dih',5x,'eng_tet',/,1x,
+     x        'time    ',5x,' eng_pv',4x,'temp_rot',5x,'vir_cfg',
+     x        5x,'vir_vdw',5x,'vir_cou',5x,'vir_bnd',5x,'vir_ang',
+     x        5x,'vir_con',5x,'vir_tet',/,1x,'cpu time',6x,
+     x        'volume',4x,'temp_shl',5x,'eng_shl',5x,'vir_shl',
+     x        7x,'alpha',8x,'beta',7x,'gamma',5x,'vir_pmf',
+     x        7x,'press',/,/,
+     x        1x,120('-'))")
+            write(nrite,"(1x,i8,1p,9e12.4,/,1x,0p,f7.3,a1,1p,9e12.4,
+     x        /,1x,0p,f7.3,a1,1p,9e12.4)")
+     x        nstep,(stpval(i),i=1,9),
+     x        simtim,dec,(stpval(i),i=10,18),
+     x        prntim,hms,(stpval(i),i=19,27)
+            write(nrite,"(/,1x,' rolling',1p,9e12.4,/,1x,'averages',
+     x        1p,9e12.4,/,9x,1p,9e12.4)") (ravval(i),i=1,27)
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+          lines=lines+1
+          
+        endif
+        
+c     report end of equilibration period
+        
+        if((.not.loptim).and.(.not.lzero).and.(nstep.ge.nsteql))then
+          
+          if((ltscal.and.idnode.eq.0).and.(nstep.eq.nsteql))
+     x      write(nrite,"(/,/,1x,'switching off temperature ',
+     x      'scaling at step ',i6,/,/,/,1x,120('-'))") nstep
+          ltscal=.false.
+          
+        endif
+        
+c     write trajectory data
+        
+        if(ltraj.and.nstep.ge.nstraj) then
+          if(idnode.eq.0.and.mod(nstep-nstraj,istraj).eq.0)then
+            
+            call traject
+     x        (ltraj,idnode,imcon,istraj,keytrj,natms,
+     x        nstraj,nstep,tstep)
+            
+          endif
+          
+        endif
+        
+c     write solvation energy file
+        
+        if(lsolva.and.nstep.ge.nsolva)then
+          
+          if(mod(nstep-nsolva,isolva).eq.0)then
+            
+            call solva_temp(idnode,mxnode,natms2,keyver)
+            call solvation_write(lexcite,lswitch,idnode,natms,
+     x        nstep,nsolva,isolva,tstep,engunit,elrc)
+            
+          endif
+          
+        endif
+        
+c     write free energy file
+        
+        if(lfree.and.nstep.ge.nfrn)then
+          
+          if(mod(nstep-nfrn,ifrn).eq.0)then
+            
+            call free_kinetic(lfrmas,idnode,mxnode,keyver)
+            call free_energy_write(idnode,nstep,engunit)
+          
+          endif
+          
+        endif
+        
+c     save restart data in event of system crash
+        
+        if(mod(nstep,ndump).eq.0.and.nstep.ne.nstrun)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          
+          if(ltad.or.lbpd)
+     x      call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+          
+        endif
+        
+c     cycle time check
+        
+        call timchk(0,timelp)
+        recycle=(recycle.and.timjob-timelp.gt.timcls)
+        
+      enddo
+      
+c***********************************************************************
+c     end of molecular dynamics calculations
+c***********************************************************************
+      
+c     last time check
+        
+      call timchk(0,timelp)
+      call get_prntime(hms,timjob,prntim)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'run terminating. elapsed cpu time = ',1p,e13.5,
+     x  ', job time = ',0p,f7.3,a1,', close time = ',f7.2,'s',/)")
+     x  timelp,prntim,hms,timcls
+      
+c     shell relaxation convergence statistics
+      
+      if(.not.loptim.and.keyshl.eq.2)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,/,1x,'shell relaxation statistics : average cycles = ',
+     x    f8.3,' maximum cycles = ',f8.3)")pass1,pass2
+      
+      endif
+
+c     produce summary of simulation
+      
+      levcfg=2
+      if(loptim)levcfg=0
+      if(.not.lneb)call result
+     x  (ltad,lbpd,lgofr,lpgr,lzden,idnode,imcon,keyens,mxnode,natms,
+     x  levcfg,nzden,nstep,ntpatm,numacc,numrdf,keybpd,chip,chit,
+     x  conint,rcut,tstep,engcfg,volm,virtot,vircom,zlen,tboost,
+     x  chit_shl)
+      
+c     write hyperdynamics restart file
+      
+      if(ltad.or.lbpd)
+     x  call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+      
+c     close output channels
+      
+      if(idnode.eq.0) then
+        
+        close (nrite)
+        close (nstats)
+        close (nhist)
+        close (nevnt)
+        
+      endif
+      
+c     terminate job
+      
+      call exitcomms()
+      
+      end
diff -urN dl_class_1.9.orig/srcmod/dlpoly.f.rej dl_class_1.9/srcmod/dlpoly.f.rej
--- dl_class_1.9.orig/srcmod/dlpoly.f.rej	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dlpoly.f.rej	2015-11-09 14:15:45.054258793 +0100
@@ -0,0 +1,20 @@
+--- dlpoly.f.preplumed
++++ dlpoly.f
+@@ -103,12 +103,17 @@
+       real(8) consv,engke,engrot,sigma,virtot,engcfg
+       real(8) stpeng,stpeth,stpprs,stptmp,stpvir,stpvol,width,zlen
+       real(8) timelp,engmet,virmet,pass0,pass1,pass2,rlxtol,opttol
+       real(8) catchrad,sprneb,deltad,tlow,engtke,ehit,xhit,yhit,zhit
+       real(8) ebias,vmin,boost,heinc,tboost,hyp_units,estar
++c PLUMED modifications
++      real(8) energyUnits,lengthUnits,timeUnits
++      integer(8) get_comms
++c PLUMED modifications
+       
+       real(8), allocatable :: tbuffer(:)
++      integer :: plumedavaiable
+       
+       data timelp/0.d0/,lminnow/.false./,ntrack/10/
+       data npage,lines/8,0/,recycle/.true./,boost/1.d0/
+       data pass0/0.d0/,pass1/0.d0/,pass2/0.d0/
+       data delr,epsq,press,quattol,rprim,rvdw/6*0.d0/
diff -urN dl_class_1.9.orig/srcmod/driver_module.f dl_class_1.9/srcmod/driver_module.f
--- dl_class_1.9.orig/srcmod/driver_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/driver_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,498 @@
+      module driver_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation driver routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use forces_module
+      use nlist_builders_module
+      use optimiser_module
+      use temp_scalers_module
+      
+      implicit none
+      
+      integer, parameter :: mxpass=250
+      
+      contains
+
+      subroutine molecular_dynamics
+     x  (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,newlst,
+     x  stropt,cycle,ltad,lsolva,lfree,lghost,idnode,imcon,
+     x  keyfce,keyfld,keyshl,keystr,keytol,kmax1,kmax2,kmax3,multt,
+     x  mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,
+     x  nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,
+     x  ntpter,ntpvdw,ntshl,ntteth,ntcons,numrdf,nsolva,isolva,
+     x  alpha,delr,dlrpot,drewd,elrc,engang,engbnd,engcpe,engdih,
+     x  engfbp,engfld,enginv,engshl,engsrp,engtbp,engter,engtet,
+     x  epsq,fmax,opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x  engcfg,temp,tstep,virang,virbnd,vircpe,virdih,virfbp,virfld,
+     x  virinv,virlrc,virmet,virshl,virsrp,virtbp,virter,virtet,volm,
+     x  engmet,virtot,engord,virord)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls in a standard
+c     molecular dynamics simulation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero
+      logical newlst,stropt,cycle,ltad,lsolva,lfree,lghost
+      
+      integer idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons
+      integer keystr,kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp
+      integer nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,nsolva
+      integer isolva
+      
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp
+      real(8) virtbp,virter,virtet,volm,engmet,virtot
+      real(8) engord,virord
+      
+c     construct verlet neighbour list
+      
+      call nlist_driver
+     x  (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x  nneut,keyfce,rcut,delr,tstep)
+      
+c     calculate atomic forces
+      
+      call force_manager
+     x  (newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x  lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x  ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x  keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x  isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x  vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x  rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x  virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x  virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x  engcfg,fmax,temp,engord,virord)
+      
+c     frozen atoms option
+      
+      call freeze(natms)
+      
+c     structure optimisation
+      
+      if(loptim.or.lzero)then
+        
+        call optimisation_selector
+     x    (loptim,stropt,lzero,idnode,mxnode,natms,imcon,ntcons,
+     x    nscons,ngrp,ntfree,keystr,keytol,engcfg,tstep,opttol)
+        
+        if(stropt.and.idnode.eq.0)
+     x    write(nrite,"(/,/,1x,'structure optimisation converged ',
+     x    'at step ',i6,/,/,/,1x,120('-'))") nstep
+        
+        cycle=(cycle.and.(.not.stropt))
+        
+      endif
+      
+c     total virial (excluding constraint virial and c.o.m virial)
+c     for npt routines     note: virsrp already includes virlrc
+      
+      virtot=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x  virang+virshl+virtet+virmet+virord
+      
+      return
+      end subroutine molecular_dynamics
+      
+      subroutine shell_relaxation
+     x  (lfcap,lgofr,lneut,lnsq,loglnk,lzeql,newlst,ltad,lsolva,
+     x  lfree,lghost,idnode,imcon,keyfce,keyfld,keyshl,
+     x  kmax1,kmax2,kmax3,multt,mxnode,natms,nhko,nlatt,nneut,
+     x  nospl,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntinv,
+     x  ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,
+     x  ntpmls,nsolva,isolva,alpha,delr,dlrpot,drewd,elrc,engang,
+     x  engbnd,engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp,
+     x  engtbp,engter,engtet,epsq,fmax,rctter,rcut,rcutfb,rcuttb,
+     x  rprim,rvdw,shlke,engcfg,temp,tstep,virang,virbnd,vircpe,
+     x  virdih,virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x  virtbp,virter,virtet,volm,engmet,virtot,rlxtol,pass0,
+     x  pass1,pass2,engord,virord)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls in a
+c     relaxed shell molecular dynamics simulation
+c
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical,save :: lfirst = .true.
+      logical lfcap,lgofr,lneut,lnsq,loglnk,lzeql,ltad
+      logical newlst,relaxed,shgofr,lsolva,lfree,lghost
+
+      integer idnode,imcon,keyfce,keyfld,keyshl
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms
+      integer nhko,nlatt,nneut,nospl,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf
+      integer keyrlx,ntpmls,pass,nsolva,isolva,ia,ib,ishl
+
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp
+      real(8) virtbp,virter,virtet,volm,engmet,virtot,rlxtol
+      real(8) pass0,pass1,pass2,engord,virord
+      
+      real(8),allocatable,dimension(:),save :: xdcs,ydcs,zdcs 
+
+      pass=0
+      keyrlx=0
+      shgofr=lgofr
+      relaxed=.false.
+ 
+      if(lfirst)then
+        
+        allocate(xdcs(1:ntshl))
+        allocate(ydcs(1:ntshl))
+        allocate(zdcs(1:ntshl))
+        lfirst = .false.
+        
+      else
+        
+        do ishl=1,ntshl
+          
+          ia=listshl(ishl,2)
+          ib=listshl(ishl,3)
+          xxx(ib)=xxx(ia)+xdcs(ishl)
+          yyy(ib)=yyy(ia)+ydcs(ishl)
+          zzz(ib)=zzz(ia)+zdcs(ishl)
+          
+        enddo
+        
+      endif
+      
+      do while(.not.relaxed.and.pass.le.mxpass)
+        
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,shgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     total virial (excluding constraint virial and c.o.m virial)
+c     for npt routines     note: virsrp already includes virlrc
+        
+        virtot=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x    virang+virshl+virtet+virmet+virord
+        
+c     relaxed shell option
+        
+        call relax_shells
+     x    (relaxed,keyrlx,idnode,mxnode,natms,ntpmls,tstep,
+     x    rlxtol)
+        
+        if(relaxed)then
+          
+          pass1=pass0*pass1
+          pass0=pass0+1.d0
+          pass1=pass1/pass0+pass/pass0
+          pass2=max(dble(pass),pass2)
+c$$$          write(104,'("Relaxed shells before step: ",I5)')pass+1          
+          
+        endif
+        
+        pass=pass+1
+        if(pass.gt.mxpass)call error(idnode,1950)
+        shgofr=.false.
+        
+c     end of shell relaxation
+        
+      enddo
+      
+c     store vector connecting the cores to the shells
+      
+      do ishl=1,ntshl
+        
+        ia=listshl(ishl,2)
+        ib=listshl(ishl,3)
+        xdcs(ishl)=xxx(ib)-xxx(ia)
+        ydcs(ishl)=yyy(ib)-yyy(ia)
+        zdcs(ishl)=zzz(ib)-zzz(ia)
+        
+      enddo
+      
+      call images(imcon,0,1,ntshl,cell,xdcs,ydcs,zdcs)
+      
+      return
+      end subroutine shell_relaxation
+
+      subroutine minimiser
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x  keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x  ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x  nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x  ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x  drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x  engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x  rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x  virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x  virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x  virtot,sigma,tolnce,engunit,engord,virord)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls in a
+c     minimisation simulation
+c
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2007
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lfcap,lneut,lnsq,loglnk,lzeql,newlst,stropt,shgofr
+      logical conopt,newjob,ltad,lsolva,lfree,lghost
+      
+      integer idnode,imcon,keyfce,keyfld,keyshl,keystr,pass,i
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,keytol
+      integer nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,ntcons
+      integer fail,nsolva,isolva
+
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,opttol,rctter,sigma
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp,tolnce
+      real(8) virtbp,virter,virtet,volm,engmet,virtot,engcon
+      real(8) cfgmin,engunit,hnorm,grad0,grad1,ff1,sgn
+      real(8) engord,virord
+      
+      real(8), allocatable :: sxx(:),syy(:),szz(:)
+      
+      save cfgmin,newjob
+      
+      data newjob/.true./
+      
+      pass=0
+      keystr=0
+      shgofr=.false.
+      stropt=.false.
+      
+c     dummy variables
+      
+      ltad=.false.
+      lsolva=.false.
+      lfree=.false.
+      lghost=.false.
+      nsolva=0
+      isolva=1
+      
+c$$$c     diagnostic printing (not usually active)
+c$$$
+c$$$      if(idnode.eq.0)then
+c$$$        
+c$$$        write(nrite,"(1x,120('-'),
+c$$$     x    /,/,1x,'    pass',5x,'eng_cfg',5x,'eng_vdw',5x,'eng_cou',
+c$$$     x    5x,'eng_bnd',5x,'eng_ang',5x,'eng_dih',5x,'eng_tet',
+c$$$     x    5x,'eng_met',/,1x,120('-'))")
+c$$$        
+c$$$      endif
+      
+      do while(.not.stropt.and.pass.lt.mxpass)
+        
+        pass=pass+1
+        
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,shgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     total virial (excluding constraint virial and c.o.m virial)
+c     for npt routines     note: virsrp already includes virlrc
+        
+        virtot=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x    virang+virshl+virtet+virmet+virord
+        
+c     conjugate gradient structure optimisation
+        
+        call strucopt
+     x    (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x    imcon,ngrp,ntfree,tstep,opttol,engcfg,hnorm,grad0,grad1,
+     x    ff1,sgn)
+        
+c$$$c     diagnostic printing (not usually active)
+c$$$
+c$$$        if(idnode.eq.0)then
+c$$$          
+c$$$          write(nrite,"(1x,i8,1p,8e12.4)")
+c$$$     x      pass,engcfg/engunit,engsrp/engunit,engcpe/engunit,
+c$$$     x      engbnd/engunit,engang/engunit,engdih/engunit,engtet/
+c$$$     x      engunit,engmet/engunit
+c$$$          write(nrite,"(1x,120('-'))")
+c$$$          
+c$$$        endif
+
+c     end of structure minimisation
+        
+      enddo
+      
+c     ensure constraints are satisfied
+      
+      if(stropt.and.ntcons.gt.0)then
+        
+        allocate(sxx(mxatms),syy(mxatms),szz(mxatms),stat=fail)
+        if(fail.ne.0)call error(idnode,9999)
+        
+c     store current forces
+        
+        do i=1,natms
+          
+          sxx(i)=fxx(i)
+          syy(i)=fyy(i)
+          szz(i)=fzz(i)
+          
+        enddo
+        
+        keystr=0
+        conopt=.false.
+        
+        do while(.not.conopt.and.pass.lt.mxpass)
+
+          pass=pass+1
+          engcon=0.d0
+          
+          do i=1,natms
+            
+            fxx(i)=0.d0
+            fyy(i)=0.d0
+            fzz(i)=0.d0
+            
+          enddo
+          
+c     conjugate gradient structure optimisation of constraint bonds
+          
+          call strucopt
+     x      (conopt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x      imcon,ngrp,ntfree,tstep,opttol,engcon,hnorm,grad0,grad1,
+     x      ff1,sgn)
+          
+        enddo
+        
+c     restore current forces
+        
+        do i=1,natms
+          
+          fxx(i)=sxx(i)
+          fyy(i)=syy(i)
+          fzz(i)=szz(i)
+          
+        enddo
+        
+        deallocate(sxx,syy,szz,stat=fail)
+        
+      endif
+      
+c     write data summary
+      
+      if(idnode.eq.0)then
+        
+        if(stropt)then
+          
+          write(nrite,'(1x,"minimisation converged after ",i6," cycles"
+     x      ," energy minimum: ",1pe12.4)')pass,engcfg/engunit
+          
+        else
+          
+          write(nrite,'(1x,"minimisation NOT converged after ",i6,
+     x      " cycles")')pass
+          
+        endif
+        
+        write(nrite,"(1x,120('-'))")
+        
+      endif
+      
+c     reset velocities after structure optimisation
+      
+      call regauss(idnode,imcon,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntshl,keyshl,sigma,temp,tolnce)
+      
+c     write out minimised structure if lowest obtained so far
+      
+      if(newjob.or.cfgmin.gt.engcfg)then
+        
+        if(idnode.eq.0)call config_write('CFGMIN',0,imcon,natms,engcfg)
+        cfgmin=engcfg
+        newjob=.false.
+        
+      endif
+      
+      return
+      end subroutine minimiser
+      
+      end module driver_module
diff -urN dl_class_1.9.orig/srcmod/ensemble_tools_module.f dl_class_1.9/srcmod/ensemble_tools_module.f
--- dl_class_1.9.orig/srcmod/ensemble_tools_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/ensemble_tools_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1934 @@
+      module ensemble_tools_module
+
+c***********************************************************************
+c     
+c     dl_poly module defining tools for ensemble simulations
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use core_shell_module
+      use property_module
+      use rigid_body_module
+      use utility_module
+      
+      contains
+      
+      function getmass(natms,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate total system mass
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) getmass
+      
+      iatm0 = (idnode*natms)/mxnode+1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+      getmass=0.d0
+
+      do i=iatm0,iatm1
+
+        getmass=getmass+weight(i)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=getmass
+        call gdsum(buffer(1),1,buffer(2))
+        getmass=buffer(1)
+        
+      endif
+      
+      return
+      end function getmass
+
+      subroutine getcom(natms,idnode,mxnode,totmas,com)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system centre of mass
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) totmas
+      
+      real(8) com(3)
+      
+      iatm0 = (idnode*natms)/mxnode+1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+      com(1)=0.d0
+      com(2)=0.d0
+      com(3)=0.d0
+      
+      do i=iatm0,iatm1
+        
+        com(1)=com(1)+weight(i)*xxx(i)
+        com(2)=com(2)+weight(i)*yyy(i)
+        com(3)=com(3)+weight(i)*zzz(i)
+
+      enddo
+
+      if(mxnode.gt.1) call gdsum(com,3,buffer)
+
+      com(1)=com(1)/totmas
+      com(2)=com(2)/totmas
+      com(3)=com(3)/totmas
+
+      return
+      end subroutine getcom
+
+      subroutine getvom(natms,idnode,mxnode,totmas,vom)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system centre of mass
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) totmas
+      
+      real(8) vom(3)
+      
+      iatm0 = (idnode*natms)/mxnode+1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+      vom(1)=0.d0
+      vom(2)=0.d0
+      vom(3)=0.d0
+      
+      do i=iatm0,iatm1
+        
+        vom(1)=vom(1)+weight(i)*vxx(i)
+        vom(2)=vom(2)+weight(i)*vyy(i)
+        vom(3)=vom(3)+weight(i)*vzz(i)
+
+      enddo
+
+      if(mxnode.gt.1) call gdsum(vom,3,buffer)
+
+      vom(1)=vom(1)/totmas
+      vom(2)=vom(2)/totmas
+      vom(3)=vom(3)/totmas
+
+      return
+      end subroutine getvom
+
+      subroutine nvtscale
+     x  (idnode,mxnode,natms,engke,sigma,tstep,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NVT thermostat
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm0,iatm1
+      real(8) engke,sigma,tstep,qmass,chit,conint,scale,taut
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+
+c     update chit to 1/2 step
+      
+      chit=chit+tstep*(engke-sigma)/qmass
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*qmass/taut**2
+
+c     update chit to full step
+      
+      chit=chit+tstep*(engke-sigma)/qmass
+      
+      return
+      end subroutine nvtscale
+
+      subroutine nptscale_t
+     x  (idnode,mxnode,natms,engke,temp,sigma,tstep,pmass,qmass,taut,
+     x  chip,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NPT thermostat
+c
+c     copyright daresbury laboratory
+c     author - w.smith july 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm0,iatm1
+      real(8) engke,temp,sigma,tstep,pmass,qmass,chip,chit,conint,scale
+      real(8) taut
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp)
+
+c     update chit to full step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+
+      return
+      end subroutine nptscale_t
+
+      subroutine nptscale_p
+     x  (idnode,mxnode,natms,engke,tstep,pmass,chip,chit,
+     x  volm,press,vircon,virtot)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT barostat
+c     
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm0,iatm1
+      real(8) engke,tstep,pmass,chip,press,vircon,virtot
+      real(8) volm,scale,chit
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     propagate chip to 1/2 step
+      
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+
+c     barostat the velocities
+      
+      scale=exp(-tstep*chip)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update volume parameter to full step
+      
+      volm=volm*exp(3.d0*tstep*chip)
+
+c     update chip to full step
+      
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+      
+      return
+      end subroutine nptscale_p
+
+      subroutine nvtqscl
+     x  (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x   tstep,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NVT thermostat
+c     to atomic, group and quaternion momenta
+c
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     calculate kinetic energy
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 step
+      
+      chit=chit+tstep*(engke-sigma)/qmass
+
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+
+c     thermostat free atoms
+
+      do j=ifre1,ifre2
+
+         i=lstfre(j)
+         vxx(i)=scale*vxx(i)
+         vyy(i)=scale*vyy(i)
+         vzz(i)=scale*vzz(i)
+        
+      enddo
+
+c     thermostat rigid body velocities
+
+      do ig=igrp1,igrp2
+         
+         omx(ig)=scale*omx(ig)
+         omy(ig)=scale*omy(ig)
+         omz(ig)=scale*omz(ig)
+         gvxx(ig)=scale*gvxx(ig)
+         gvyy(ig)=scale*gvyy(ig)
+         gvzz(ig)=scale*gvzz(ig)
+         
+      enddo
+
+c     scale kinetic energy
+
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*qmass/taut**2
+
+c     update chit to full step
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+tstep*(engke-sigma)/qmass
+
+      return
+      end subroutine nvtqscl
+
+      subroutine nptqscl_t
+     x  (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,sigma,
+     x  tstep,pmass,qmass,taut,chip,chit,conint)
+
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT thermostat
+c     to atomic, group and quaternion momenta
+c     
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c     
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale,chip,pmass,temp
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     calculate kinetic energy
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 tstep
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+      
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+      
+c     thermostat free atoms
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      
+c     thermostat rigid body velocities
+      
+      do ig=igrp1,igrp2
+        
+        omx(ig)=scale*omx(ig)
+        omy(ig)=scale*omy(ig)
+        omz(ig)=scale*omz(ig)
+        gvxx(ig)=scale*gvxx(ig)
+        gvyy(ig)=scale*gvyy(ig)
+        gvzz(ig)=scale*gvzz(ig)
+        
+      enddo
+      
+c     scale kinetic energy
+      
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+      
+c     update chi to full tstep
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp)
+      
+c     update chit to full tstep
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+      
+      return
+      end subroutine nptqscl_t
+
+      subroutine nptqscl_p
+     x  (idnode,mxnode,ntfree,ngrp,engfke,engtrn,tstep,pmass,
+     x  chip,chit,volm,press,vircon,virtot,vircom)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT barostat
+c     for system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,i,ngrp,ntfree,igrp1,igrp2,ifre1,ifre2
+      integer j,ig
+      real(8) engke,tstep,pmass,chip,press,vircon,virtot
+      real(8) vircom,volm,scale,engtrn,engfke,chit
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     propagate chip to 1/2 tstep
+      
+      engke=engfke+engtrn
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon-vircom)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+      
+c     barostat the free atom velocities
+      
+      scale=exp(-tstep*chip)
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      
+c     barostat the group translational velocities
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=scale*gvxx(ig)
+        gvyy(ig)=scale*gvyy(ig)
+        gvzz(ig)=scale*gvzz(ig)
+        
+      enddo
+      
+c     scale kinetic energy
+      
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      
+c     update volume parameter to full tstep
+      
+      volm=volm*exp(3.d0*tstep*chip)
+      
+c     update chip to full tstep
+      
+      engke=engfke+engtrn
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon-vircom)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+      
+      return
+      end subroutine nptqscl_p
+
+      subroutine nstscale_t
+     x  (idnode,mxnode,natms,mode,engke,temp,sigma,tstep,
+     x  pmass,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NST thermostat
+c
+c     copyright daresbury laboratory
+c     author - w.smith july 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,mode,i,iatm0,iatm1
+      real(8) engke,temp,sigma,tstep,pmass,qmass,chip2,chit,conint,scale
+      real(8) taut,fac(0:3)
+      data fac/9.d0,3.d0,2.d0,5.d0/
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic energy
+      
+      chip2=sdot0(9,eta,eta)
+      if(mode.eq.2)chip2=chip2-eta(1)**2
+      engke=getkin(natms,idnode,mxnode)
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit)
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp*fac(mode))
+
+c     update chit to full step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+      return
+      end subroutine nstscale_t
+
+      subroutine nstscale_p
+     x  (idnode,mxnode,natms,mode,tstep,pmass,chit,press,volm)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,natms,mode,i,iatm0,iatm1
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit
+      real(8) strkin(9),uni(9),celp(10)
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     propagate barostat momentum to 1/2 step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     barostat the velocities
+      
+      do i=iatm0,iatm1
+        
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+
+      enddo
+
+c     new cell vectors
+          
+      call cell_update(tstep,cell,eta)
+
+c     update volume to full time step
+
+      call dcell(cell,celp)
+      volm=celp(10)
+
+c     calculate kinetic energy and contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+      
+      return
+      end subroutine nstscale_p
+
+      subroutine nstqscl_t
+     x  (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x  sigma,tstep,pmass,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NPT thermostat
+c     to atomic, group and quaternion momenta
+c
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig,mode
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale,chip2,pmass,temp,fac(0:3)
+      data fac/9.d0,3.d0,2.d0,5.d0/
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     calculate kinetic energy
+      
+      chip2=sdot0(9,eta,eta)
+      if(mode.eq.2)chip2=chip2-eta(1)**2
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+
+c     thermostat free atoms
+
+      do j=ifre1,ifre2
+
+         i=lstfre(j)
+         vxx(i)=scale*vxx(i)
+         vyy(i)=scale*vyy(i)
+         vzz(i)=scale*vzz(i)
+        
+      enddo
+
+c     thermostat rigid body velocities
+
+      do ig=igrp1,igrp2
+         
+         omx(ig)=scale*omx(ig)
+         omy(ig)=scale*omy(ig)
+         omz(ig)=scale*omz(ig)
+         gvxx(ig)=scale*gvxx(ig)
+         gvyy(ig)=scale*gvyy(ig)
+         gvzz(ig)=scale*gvzz(ig)
+         
+      enddo
+
+c     scale kinetic energy
+
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp*fac(mode))
+
+c     update chit to full step
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+      return
+      end subroutine nstqscl_t
+
+      subroutine nstqscl_p
+     x  (idnode,mxnode,ntfree,ngrp,mode,tstep,pmass,chit,press,volm)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     for system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith may 2005
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,igrp1,igrp2,ifre1,ifre2,ig,j
+      integer mode
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit
+      real(8) strkin(9),strgrp(9),uni(9),celp(10)
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     propagate barostat momentum to 1/2 step
+      
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     subtract kinetic contribution from stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+      do i=1,9
+        stress(i)=stress(i)-strkin(i)-strgrp(i)
+      enddo
+      
+c     barostat the free atom velocities
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+
+      enddo
+
+c     barostat the group translational velocities
+
+      do ig=igrp1,igrp2
+         
+         txx=gvxx(ig)
+         tyy=gvyy(ig)
+         tzz=gvzz(ig)
+         gvxx(ig)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+         gvyy(ig)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+         gvzz(ig)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+         
+      enddo
+
+c     new cell vectors
+
+      call cell_update(tstep,cell,eta)
+      
+c     new system volume
+      
+      call dcell(cell,celp)
+      volm=celp(10)
+      
+c     add new kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)
+      enddo
+      
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+      return
+      end subroutine nstqscl_p
+
+      subroutine nstqscl_t2
+     x  (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x  sigma,tstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NPT thermostat
+c     to atomic, group and quaternion momenta
+c
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig,mode
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale,chip2,pmass,temp,fac(0:3)
+      real(8) strkin(9),strgrp(9)
+      data fac/9.d0,3.d0,2.d0,5.d0/
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     remove old kinetic term from stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)-strkin(i)-strgrp(i)
+      enddo
+
+c     calculate kinetic energy
+      
+      chip2=sdot0(9,eta,eta)
+      if(mode.eq.2)chip2=chip2-eta(1)**2
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+
+c     thermostat free atoms
+
+      do j=ifre1,ifre2
+
+         i=lstfre(j)
+         vxx(i)=scale*vxx(i)
+         vyy(i)=scale*vyy(i)
+         vzz(i)=scale*vzz(i)
+        
+      enddo
+
+c     thermostat rigid body velocities
+
+      do ig=igrp1,igrp2
+         
+         omx(ig)=scale*omx(ig)
+         omy(ig)=scale*omy(ig)
+         omz(ig)=scale*omz(ig)
+         gvxx(ig)=scale*gvxx(ig)
+         gvyy(ig)=scale*gvyy(ig)
+         gvzz(ig)=scale*gvzz(ig)
+         
+      enddo
+
+c     scale kinetic energy
+
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+
+c     scale kinetic energy tensors
+
+      do i=1,9
+
+        strkin(i)=strkin(i)*scale**2
+        strgrp(i)=strgrp(i)*scale**2
+
+      enddo
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp*fac(mode))
+
+c     update chit to full step
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     add new kinetic terms to stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)
+      enddo
+
+      return
+      end subroutine nstqscl_t2
+
+      subroutine nstqscl_p2
+     x  (idnode,mxnode,ntfree,ngrp,mode,tstep,pmass,chit,press,volm,
+     x  strkin,strgrp)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     for system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith may 2005
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,igrp1,igrp2,ifre1,ifre2,ig,j
+      integer mode
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit
+      real(8) strkin(9),strgrp(9),uni(9),celp(10)
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     propagate barostat momentum to 1/2 step
+      
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     subtract kinetic contribution from stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)-strkin(i)-strgrp(i)
+      enddo
+      
+c     barostat the free atom velocities
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+
+      enddo
+
+c     barostat the group translational velocities
+
+      do ig=igrp1,igrp2
+         
+         txx=gvxx(ig)
+         tyy=gvyy(ig)
+         tzz=gvzz(ig)
+         gvxx(ig)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+         gvyy(ig)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+         gvzz(ig)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+         
+      enddo
+
+c     new cell vectors
+
+      call cell_update(tstep,cell,eta)
+      
+c     new system volume
+      
+      call dcell(cell,celp)
+      volm=celp(10)
+      
+c     add new kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)
+      enddo
+      
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+      return
+      end subroutine nstqscl_p2
+
+      subroutine cell_update(tstep,cell,eta)
+
+c***********************************************************************
+c     
+c     dlpoly utility to update the cell vectors in the hoover 
+c     nst algorithms (velocity verlet version)
+c
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer i
+      real(8) tstep,cell(9),eta(9),ctmp(9),uni(9)
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      do i=1,9
+        ctmp(i)=uni(i)+tstep*eta(i)
+      enddo
+
+      call mat_mul(ctmp,cell,cell)
+      
+      return
+      end subroutine cell_update
+
+      subroutine cell_propagate(tstep,cell,eta)
+
+c***********************************************************************
+c     
+c     dlpoly utility to update the cell vectors in the hoover 
+c     nst algorithms (leapfrog version)
+c
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer i
+      real(8) tstep
+      real(8) cell(9),eta(9),aaa(9),bbb(9),uni(9)
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+
+      do i=1,9
+        aaa(i)=tstep*eta(i)
+      enddo
+      
+      call mat_mul(aaa,aaa,bbb)
+      
+      do i=1,9
+        bbb(i)=uni(i)+aaa(i)+0.5d0*bbb(i)
+      enddo
+      
+      call mat_mul(bbb,cell,cell)
+
+      return
+      end subroutine cell_propagate
+
+      subroutine nstqmtk_p
+     x  (idnode,mxnode,ntfree,ngrp,mode,tstep,pmass,chit,press,volm,
+     x  engfke,engtrn,engrot,temp,sigma)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     of martyna tobias and klein to atomic, group and quaternion 
+c     system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith may 2005
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,igrp1,igrp2,ifre1,ifre2,ig,j
+      integer mode
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit,temp,sigma,degfre
+      real(8) engtke,engfke,engtrn,engrot,trace
+      real(8) strkin(9),strgrp(9),uni(9),ctmp(9)
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      degfre=2.d0*sigma/(temp*boltz)
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     calculate kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     propagate barostat momentum to 1/2 step
+
+      call invert(cell,ctmp,volm)
+      volm=abs(volm)
+      engtke=2.d0*(engfke+engtrn+engrot)/degfre
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)+strgrp(i)+
+     x    (engtke-press*volm)*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     barostat the free atom velocities
+      
+      trace=(eta(1)+eta(5)+eta(9))/degfre
+
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz+trace)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz+trace)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz+trace)
+
+      enddo
+
+c     barostat the group translational velocities
+
+      do ig=igrp1,igrp2
+         
+         txx=gvxx(ig)
+         tyy=gvyy(ig)
+         tzz=gvzz(ig)
+         gvxx(ig)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz+trace)
+         gvyy(ig)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz+trace)
+         gvzz(ig)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz+trace)
+         
+      enddo
+
+c     update volume to full time step
+
+      volm=volm*exp(tstep*(eta(1)+eta(5)+eta(9)))
+
+c     calculate kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     calculate new kinetic energy
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engtke=2.d0*(engfke+engtrn+engrot)/degfre
+
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)+strgrp(i)+
+     x    (engtke-press*volm)*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+      return
+      end subroutine nstqmtk_p
+
+      subroutine kinstr(idnode,mxnode,natms,tstep)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to calculate the kinetic energy contribution to
+c     the stress tensor
+c     
+c     assumes velocities are half-timestep behind forces
+c     
+c     replicated data version / block data
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester may 1994
+c     amended t.forester dec 1994 : block data
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm1,iatm2
+      real(8) tstep,vxt,vyt,vzt
+      
+c     block indices
+
+      iatm1 = (idnode*natms)/mxnode + 1
+      iatm2 = ((idnode+1)*natms)/mxnode
+
+      do i = iatm1,iatm2
+
+        if(rmass(i).gt.0.d0) then
+
+          vxt = vxx(i)+fxx(i)*rmass(i)*tstep*0.5d0
+          vyt = vyy(i)+fyy(i)*rmass(i)*tstep*0.5d0
+          vzt = vzz(i)+fzz(i)*rmass(i)*tstep*0.5d0
+
+          stress(1)=stress(1)-weight(i)*vxt*vxt
+          stress(2)=stress(2)-weight(i)*vxt*vyt
+          stress(3)=stress(3)-weight(i)*vxt*vzt
+          stress(4)=stress(4)-weight(i)*vyt*vxt
+          stress(5)=stress(5)-weight(i)*vyt*vyt
+          stress(6)=stress(6)-weight(i)*vyt*vzt
+          stress(7)=stress(7)-weight(i)*vzt*vxt
+          stress(8)=stress(8)-weight(i)*vzt*vyt
+          stress(9)=stress(9)-weight(i)*vzt*vzt
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine kinstr
+      
+      function getkin(natms,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system kinetic energy
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w. smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) getkin,engke
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      engke=0.d0
+      
+      do i=iatm0,iatm1
+        engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engke
+        call gdsum(buffer(1),1,buffer(2))
+        engke=buffer(1)
+        
+      endif
+
+      getkin=0.5d0*engke
+
+      return
+      end function getkin
+
+      function getkinf(ntfree,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate kinetic energy of atoms not in
+c     rigid bodies
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w. smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ntfree,idnode,mxnode,i,j,ifre0,ifre1
+      real(8) getkinf,engke
+      
+      ifre0=(idnode*ntfree)/mxnode+1
+      ifre1=((idnode+1)*ntfree)/mxnode
+
+      engke=0.d0
+      
+      do j=ifre0,ifre1
+        
+        i=lstfre(j)
+        engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engke
+        call gdsum(buffer(1),1,buffer(2))
+        engke=buffer(1)
+        
+      endif
+
+      getkinf=0.5d0*engke
+
+      return
+      end function getkinf
+
+      subroutine getking(ngrp,idnode,mxnode,engtrn,engrot)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system kinetic energy
+c     for rigid groups only
+c
+c     copyright daresbury laboratory
+c     author - m.leslie february 2003
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) engtrn,engrot
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      engtrn=0.d0
+      engrot=0.d0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     group kinetic energy
+
+        engtrn=engtrn+
+     x    gmass(id)*(gvxx(ig)**2+gvyy(ig)**2+gvzz(ig)**2)
+
+c     rotational kinetic energy
+        
+        engrot=engrot+(rotinx(id,1)*omx(ig)**2
+     x    +rotiny(id,1)*omy(ig)**2
+     x    +rotinz(id,1)*omz(ig)**2)
+
+      enddo
+
+      if(mxnode.gt.1) then
+        
+        buffer(5)=engtrn
+        buffer(6)=engrot
+        call  gdsum(buffer(5),2,buffer(1))
+        engtrn=buffer(5)
+        engrot=buffer(6)
+        
+      endif
+
+      engtrn=0.5d0*engtrn
+      engrot=0.5d0*engrot
+
+      return
+      end subroutine getking
+
+      function getkint(ngrp,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate translational kinetic energy
+c     for rigid groups only
+c
+c     copyright daresbury laboratory
+c     author  - w.smith october 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) engtrn,getkint
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      engtrn=0.d0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     group kinetic energy
+
+        engtrn=engtrn+
+     x    gmass(id)*(gvxx(ig)**2+gvyy(ig)**2+gvzz(ig)**2)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engtrn
+        call gdsum(buffer(1),1,buffer(2))
+        engtrn=buffer(1)
+        
+      endif
+      
+      getkint=0.5d0*engtrn
+
+      return
+      end function getkint
+
+      function getkinr(ngrp,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate rotational kinetic energy
+c     for rigid groups only
+c
+c     copyright daresbury laboratory
+c     author  - w.smith october 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) engrot,getkinr
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      engrot=0.d0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     rotational kinetic energy
+        
+        engrot=engrot+(rotinx(id,1)*omx(ig)**2
+     x    +rotiny(id,1)*omy(ig)**2
+     x    +rotinz(id,1)*omz(ig)**2)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engrot
+        call gdsum(buffer(1),1,buffer(2))
+        engrot=buffer(1)
+        
+      endif
+      
+      getkinr=0.5d0*engrot
+      
+      return
+      end function getkinr
+
+      subroutine kinstress(natms,idnode,mxnode,stresh)
+
+c*********************************************************************
+c     
+c     dl_poly routine to calculate kinetic contribution to the 
+c     stress tensor
+c     
+c     copyright daresbury laboratory
+c     author - w.smith november 2002
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer natms,idnode,mxnode,iatm0,iatm1,i
+      real(8) stresh(9)
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     initialise stress tensor
+
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+
+c     kinetic contribution to stress tensor
+        
+      do i=iatm0,iatm1
+        
+        stresh(1)=stresh(1)+weight(i)*vxx(i)*vxx(i)
+        stresh(2)=stresh(2)+weight(i)*vxx(i)*vyy(i)
+        stresh(3)=stresh(3)+weight(i)*vxx(i)*vzz(i)
+        stresh(5)=stresh(5)+weight(i)*vyy(i)*vyy(i)
+        stresh(6)=stresh(6)+weight(i)*vyy(i)*vzz(i)
+        stresh(9)=stresh(9)+weight(i)*vzz(i)*vzz(i)
+        
+      enddo
+
+      stresh(4)=stresh(2)
+      stresh(7)=stresh(3)
+      stresh(8)=stresh(6)
+
+c     global sum of stress tensor
+      
+      if(mxnode.gt.1) call gdsum(stresh,9,buffer)
+        
+      return
+      end subroutine kinstress
+
+      subroutine kinstressg(ngrp,idnode,mxnode,stresh)
+
+c*********************************************************************
+c     
+c     dl_poly routine to calculate kinetic contribution to the 
+c     stress tensor
+c     
+c     copyright daresbury laboratory
+c     author - m.leslie february 2003
+c
+c*********************************************************************
+      
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) stresh(9)
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     initialise stress tensor
+
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+
+c     kinetic contribution to stress tensor
+      
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+        stresh(1)=stresh(1)+gmass(id)*gvxx(ig)*gvxx(ig)
+        stresh(2)=stresh(2)+gmass(id)*gvxx(ig)*gvyy(ig)
+        stresh(3)=stresh(3)+gmass(id)*gvxx(ig)*gvzz(ig)
+        stresh(5)=stresh(5)+gmass(id)*gvyy(ig)*gvyy(ig)
+        stresh(6)=stresh(6)+gmass(id)*gvyy(ig)*gvzz(ig)
+        stresh(9)=stresh(9)+gmass(id)*gvzz(ig)*gvzz(ig)
+        
+      enddo
+      
+      stresh(4)=stresh(2)
+      stresh(7)=stresh(3)
+      stresh(8)=stresh(6)
+
+c     global sum of stress tensor
+      
+      if(mxnode.gt.1) call gdsum(stresh,9,buffer)
+        
+      return
+      end subroutine kinstressg
+
+      subroutine getkins(natms,idnode,mxnode,getkin)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system kinetic energy
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005: f90 conversion
+c
+c*********************************************************************
+     
+      implicit none
+
+      integer natms,idnode,mxnode,iatm0,iatm1,i
+      real(8) getkin,engke
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      engke=0.d0
+      
+      do i=iatm0,iatm1
+        engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engke
+        call gdsum(buffer(1),1,buffer(2))
+        engke=buffer(1)
+        
+      endif
+
+      getkin=0.5d0*engke
+
+      return
+      end subroutine getkins
+
+      subroutine kinstressf(ntfree,idnode,mxnode,stresh)
+
+c*********************************************************************
+c     
+c     dl_poly routine to calculate kinetic contribution to the 
+c     stress tensor for unconstrained atoms
+c     
+c     copyright daresbury laboratory
+c     author - m.leslie february 2003
+c     amended - w.smith january 2005: f90 conversion
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer ntfree,idnode,mxnode,i,ifre1,ifre2,ifre
+      real(8) stresh(9)
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     initialise stress tensor
+
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+
+c     kinetic contribution to stress tensor
+        
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        stresh(1)=stresh(1)+weight(i)*vxx(i)*vxx(i)
+        stresh(2)=stresh(2)+weight(i)*vxx(i)*vyy(i)
+        stresh(3)=stresh(3)+weight(i)*vxx(i)*vzz(i)
+        stresh(5)=stresh(5)+weight(i)*vyy(i)*vyy(i)
+        stresh(6)=stresh(6)+weight(i)*vyy(i)*vzz(i)
+        stresh(9)=stresh(9)+weight(i)*vzz(i)*vzz(i)
+        
+      enddo
+
+      stresh(4)=stresh(2)
+      stresh(7)=stresh(3)
+      stresh(8)=stresh(6)
+
+c     global sum of stress tensor
+      
+      if(mxnode.gt.1) call gdsum(stresh,9,buffer)
+        
+      return
+      end subroutine kinstressf
+      
+      subroutine nvtscale_shl
+     x  (idnode,mxnode,ntshl,shlke,sigma_shl,tstep,qmass_shl,
+     x   taut,chit_shl,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NVT thermostat
+c     thermostats the core-shell relative motion
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c     adapted - d. quigley      2006 : core-shell motion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntshl,i,ishl1,ishl2,j,k,m
+      real(8) shlke,sigma_shl,tstep,qmass_shl,chit_shl,conint
+      real(8) dvx,dvy,dvz,tmx,tmy,tmz,rmu,scale,taut
+
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+
+c     calculate kinetic energy
+      
+      call corshl(idnode,mxnode,ntshl,shlke)
+
+c     update chit to 1/2 step
+      
+      chit_shl=chit_shl+tstep*(shlke-sigma_shl)/qmass_shl
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit_shl)
+
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+
+        rmu=(weight(i)*weight(j))/(weight(i)+weight(j))
+        
+        if(rmu.gt.0.d0)then
+          
+          dvx=vxx(j)-vxx(i)
+          dvy=vyy(j)-vyy(i)
+          dvz=vzz(j)-vzz(i)
+          
+          tmx=weight(i)*vxx(i)+weight(j)*vxx(j)
+          tmy=weight(i)*vyy(i)+weight(j)*vyy(j)
+          tmz=weight(i)*vzz(i)+weight(j)*vzz(j)
+          
+          vxx(i)=tmx/(weight(i)+weight(j))-scale*rmu*dvx/weight(i)
+          vxx(j)=tmx/(weight(i)+weight(j))+scale*rmu*dvx/weight(j)
+          vyy(i)=tmy/(weight(i)+weight(j))-scale*rmu*dvy/weight(i)
+          vyy(j)=tmy/(weight(i)+weight(j))+scale*rmu*dvy/weight(j)
+          vzz(i)=tmz/(weight(i)+weight(j))-scale*rmu*dvz/weight(i)
+          vzz(j)=tmz/(weight(i)+weight(j))+scale*rmu*dvz/weight(j)
+          
+        endif
+
+      enddo
+
+      shlke=shlke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit_shl*qmass_shl/taut**2
+
+c     update chit to full step
+      
+      chit_shl=chit_shl+tstep*(shlke-sigma_shl)/qmass_shl
+
+      if(mxnode.gt.1) call shlmerge(idnode,mxnode,ntshl)
+      
+      return
+      end subroutine nvtscale_shl
+
+      end module ensemble_tools_module
+
diff -urN dl_class_1.9.orig/srcmod/error_module.f dl_class_1.9/srcmod/error_module.f
--- dl_class_1.9.orig/srcmod/error_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/error_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1513 @@
+      module error_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining bond potentials
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use setup_module
+      
+      contains
+      
+      subroutine error(idnode,iode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing error messages and bringing
+c     about a controlled termination of the program
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     warning - this routine terminates the job. user must ensure
+c     that all nodes are informed of error condition before this
+c     subroutine is called. e.g. using subroutine gstate().
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      logical kill
+      integer idnode,iode,kode
+
+      kill=(iode.ge.0)
+      kode = abs(iode)
+      
+      if(idnode.eq.0)then
+        
+        if(kill)then
+          write(nrite,'(/,/,1x,a,i5)') 
+     x      'DL_POLY terminated due to error ', kode
+
+        else
+
+          write(nrite,'(/,/,1x,a,i5)') 
+     x      'DL_POLY will terminate due to error ', kode
+          
+        endif
+
+        if(kode.lt.50)then
+          
+          if(kode.eq. 0)then
+            
+c     dummy entry
+            
+          elseif(kode.eq. 3)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown directive found in CONTROL file'        
+          elseif(kode.eq. 4)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown directive found in FIELD file'
+          elseif(kode.eq. 5)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown energy unit requested'
+          elseif(kode.eq. 6)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - energy unit not specified'
+          elseif(kode.eq. 7)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - energy unit respecified'
+          elseif(kode.eq. 8)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - time step not specified'
+          elseif(kode.eq.10)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many molecule types specified'
+          elseif(kode.eq.11)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate molecule directive in FIELD file'
+          elseif(kode.eq.12)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown molecule directive in FIELD file'
+          elseif(kode.eq.13)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - molecular species not yet specified'
+          elseif(kode.eq.14)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many unique atom types specified'
+          elseif(kode.eq.15)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate pair potential specified'
+          elseif(kode.eq.16)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - strange exit from FIELD file processing'
+          elseif(kode.eq.17)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - strange exit from CONTROL file processing'
+          elseif(kode.eq.18)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate 3-body potential specified'
+          elseif(kode.eq.19)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate 4-body potential specified'
+          elseif(kode.eq.20)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many molecule sites specified'
+          elseif(kode.eq.21)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate tersoff potential specified'
+          elseif(kode.eq.22)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unsuitable radial increment in TABLE file'
+          elseif(kode.eq.23)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incompatible FIELD and TABLE file potentials'
+          elseif(kode.eq.24)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of file encountered in TABLE file'
+          elseif(kode.eq.25)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - wrong atom type found in CONFIG file'
+          elseif(kode.eq.26)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cutoff smaller than EAM potential range'
+          elseif(kode.eq.27)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incompatible FIELD and TABEAM file potentials'
+          elseif(kode.eq.28)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in mettab'
+          elseif(kode.eq.29)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of file encountered in TABEAM file'
+          elseif(kode.eq.30)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many chemical bonds specified'
+          elseif(kode.eq.31)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many chemical bonds in system'
+          elseif(kode.eq.32)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - integer array memory allocation failure'
+          elseif(kode.eq.33)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - real array memory allocation failure'
+          elseif(kode.eq.34)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - character array memory allocation failure'
+          elseif(kode.eq.35)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - logical array  memory allocation failure'
+          elseif(kode.eq.36)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed fmet array allocation in mettab'
+          elseif(kode.eq.40)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond constraints specified'
+          elseif(kode.eq.41)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond constraints in system'
+          elseif(kode.eq.42)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in merge1'
+          elseif(kode.eq.45)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many atoms in CONFIG file'
+          elseif(kode.eq.46)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - ewlbuf array too small in ewald1'
+          elseif(kode.eq.47)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in merge'
+          elseif(kode.eq.48)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in fortab'
+          elseif(kode.eq.49)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - frozen core-shell unit specified'
+          endif
+          
+        elseif(kode.lt.100)then
+          
+          if(kode.eq.50)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond angles specified'
+          elseif(kode.eq.51)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond angles in system'
+          elseif(kode.eq.52)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of FIELD file encountered'
+          elseif(kode.eq.53)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of CONTROL file encountered'
+          elseif(kode.eq.54)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - problem reading CONFIG file'
+          elseif(kode.eq.55)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of CONFIG file encountered'
+          elseif(kode.eq.57)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many core-shell units specified'
+          elseif(kode.eq.59)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many core-shell units in system'
+          elseif(kode.eq.60)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many dihedral angles specified'
+          elseif(kode.eq.61)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many dihedral angles in system'
+          elseif(kode.eq.62)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many tethered atoms specified'
+          elseif(kode.eq.63)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many tethered atoms in system'
+          elseif(kode.eq.65)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many excluded pairs specified'
+          elseif(kode.eq.66)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition for HK ewald'
+          elseif(kode.eq.67)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition in thbfrc'
+          elseif(kode.eq.69)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells required in thbfrc'
+          elseif(kode.eq.70)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - constraint bond quench failure'
+          elseif(kode.eq.71)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many metal potentials specified'
+          elseif(kode.eq.72)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - different metal potential types specified'
+          elseif(kode.eq.73)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many inversion potentials specified'
+          elseif(kode.eq.75)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many atoms in specified system'
+          elseif(kode.eq.77)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many inversion potentials in system'
+          elseif(kode.eq.79)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition in fbpfrc'
+          elseif(kode.eq.80)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many pair potentials specified'
+          elseif(kode.eq.81)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in pair potential list'
+          elseif(kode.eq.82)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated pair potential index too large'
+          elseif(kode.eq.83)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many three body potentials specified'
+          elseif(kode.eq.84)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in 3-body potential list'
+          elseif(kode.eq.85)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - required velocities not in CONFIG file'
+          elseif(kode.eq.86)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated 3-body potential index too large'
+          elseif(kode.eq.87)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells required in fbpfrc'
+          elseif(kode.eq.88)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many tersoff potentials specified'
+          elseif(kode.eq.89)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many four body potentials specified'
+          elseif(kode.eq.90)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - system total electric charge nonzero'
+          elseif(kode.eq.91)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in 4-body potential list'
+          elseif(kode.eq.92)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in tersoff potential list'
+          elseif(kode.eq.93)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot use shell model with rigid molecules'
+          elseif(kode.eq.95)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - potential cutoff exceeds half-cell width'
+          elseif(kode.eq.97)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot use shell model with neutral groups'
+          elseif(kode.eq.99)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot use shell model with constraints'
+          endif
+          
+        elseif(kode.lt.150)then
+          
+          if(kode.eq.100)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - forces working arrays too small'
+          elseif(kode.eq.101)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated 4-body potential index too large'
+          elseif(kode.eq.102)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxproc exceeded in shake arrays'
+          elseif(kode.eq.103)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxlshp exceeded in shake arrays'
+          elseif(kode.eq.105)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - shake algorithm failed to converge'
+          elseif(kode.eq.106)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlink '
+     x        //'subroutine'
+          elseif(kode.eq.107)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlinkneu '
+     x        //'subroutine'
+          elseif(kode.eq.108)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parneulst '
+     x        //'subroutine'
+          elseif(kode.eq.109)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlst_nsq '
+     x        //'subroutine'
+          elseif(kode.eq.110)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlst '
+     x        //'subroutine'
+          elseif(kode.eq.112)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - vertest array too small'
+          elseif(kode.eq.120)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - invalid determinant in matrix inversion'
+          elseif(kode.eq.130)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect octahedral boundary condition'
+          elseif(kode.eq.135)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect hexagonal prism boundary condition'
+          elseif(kode.eq.140)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect dodecahedral boundary condition'
+          elseif(kode.eq.141)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate metal potential specified'
+          elseif(kode.eq.142)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - interpolation outside range of metal '//
+     x        'potential attempted'
+          elseif(kode.eq.145)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - no van der waals potentials defined'
+          endif
+          
+        elseif(kode.lt.200)then
+          
+          if(kode.eq.150)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown van der waals potential selected'
+          elseif(kode.eq.151)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown metal potential selected'
+          elseif(kode.eq.153)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - metals not permitted with multiple timestep'
+          elseif(kode.eq.160)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unaccounted for atoms in exclude list '
+          elseif(kode.eq.170)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many variables for statistic array '
+          elseif(kode.eq.180)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald sum requested in non-periodic system'
+          elseif(kode.eq.185)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many reciprocal space vectors'
+          elseif(kode.eq.186)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer array too small in sysgen'
+          elseif(kode.eq.190)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - buffer array too small in splice'
+          endif
+          
+        elseif(kode.lt.250)then
+          
+          if(kode.eq.200)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - rdf buffer array too small in revive'
+          elseif(kode.eq.220)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many neutral groups in system'
+          elseif(kode.eq.225)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - multiple selection of optimisation options'
+          elseif(kode.eq.230)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neutral groups improperly arranged'
+          endif
+          
+        elseif(kode.lt.300)then
+          
+          if(kode.eq.250)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald sum requested with neutral groups'
+          elseif(kode.eq.260)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxexcl exceeded in excludeneu routine'
+          endif
+          
+        elseif(kode.lt.350)then
+          
+          if(kode.eq.300)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition in parlink'
+          elseif(kode.eq.301)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many rigid body types '
+          elseif(kode.eq.302)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many sites in rigid body '
+          elseif(kode.eq.303)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many rigid bodies specified'
+          elseif(kode.eq.304)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many rigid body sites in system '
+          elseif(kode.eq.305)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - box size too small for link cells'
+          elseif(kode.eq.306)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed to find principal axis system'
+          elseif(kode.eq.310)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - quaternion setup failed '
+          elseif(kode.eq.320)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - site in multiple rigid bodies'
+          elseif(kode.eq.321)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - quaternion integrator failed'
+          elseif(kode.eq.330)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxewld parameter incorrect'
+          elseif(kode.eq.331)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxhke parameter incorrect'
+          elseif(kode.eq.332)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxhko parameter too small'
+          elseif(kode.eq.340)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - invalid integration option requested'
+          endif
+          
+        elseif(kode.lt.400)then
+          
+          if(kode.eq.350)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too few degrees of freedom'
+          elseif(kode.eq.360)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - frozen atom found in rigid body'
+          elseif(kode.eq.380)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation temperature not specified'
+          elseif(kode.eq.381)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation timestep not specified'
+          elseif(kode.eq.382)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation cutoff not specified'
+          elseif(kode.eq.383)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation forces option not specified'
+          elseif(kode.eq.384)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - verlet strip width not specified'
+          elseif(kode.eq.385)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - primary cutoff not specified'
+          elseif(kode.eq.386)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - primary cutoff larger than rcut'
+          elseif(kode.eq.387)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - system pressure not specified'
+          elseif(kode.eq.388)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - npt incompatible with multiple timestep'
+          elseif(kode.eq.389)then
+            write(nrite,'(/,/,1x,a)')
+     x        'number of pimd beads not specified in field file'
+          elseif(kode.eq.390)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - npt ensemble requested in non-periodic system'
+          elseif(kode.eq.391)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect number of pimd beads in config file'
+          elseif(kode.eq.392)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells requested'
+          elseif(kode.eq.394)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - minimum image arrays exceeded'
+          elseif(kode.eq.396)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - interpolation array exceeded'
+          elseif(kode.eq.398)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cutoff too small for rprim and delr'
+          endif
+          
+        elseif(kode.lt.450)then
+          
+          if(kode.eq.400)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - rvdw greater than cutoff'
+          elseif(kode.eq.402)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - van der waals cutoff unset'
+          elseif(kode.eq.410)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cell not consistent with image convention'
+          elseif(kode.eq.412)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf parameter too small for shake routine'
+          elseif(kode.eq.414)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - conflicting ensemble options in CONTROL file'
+          elseif(kode.eq.416)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - conflicting force options in CONTROL file'
+          elseif(kode.eq.418)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in bndfrc'
+          elseif(kode.eq.419)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in angfrc'
+          elseif(kode.eq.420)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in tethfrc'
+          elseif(kode.eq.421)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in dihfrc'
+          elseif(kode.eq.422)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - all-pairs must use multiple timestep'
+          elseif(kode.eq.423)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in shlfrc'
+          elseif(kode.eq.424)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - electrostatics incorrect for all-pairs'
+          elseif(kode.eq.425)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer array too small in shlmerge'
+          elseif(kode.eq.426)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neutral groups not permitted with all-pairs'
+          elseif(kode.eq.427)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in invfrc'
+          elseif(kode.eq.430)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - integration routine not available'
+          elseif(kode.eq.432)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - intlist failed to assign constraints '
+          elseif(kode.eq.433)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - specify rcut before the Ewald sum precision'
+          elseif(kode.eq.434)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - illegal entry into STRESS related routine'
+          elseif(kode.eq.435)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - specify rcut before the coulomb precision'
+          elseif(kode.eq.436)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unrecognised ensemble '
+          elseif(kode.eq.438)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - PMF constraints failed to converge'
+          elseif(kode.eq.440)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined angular potential'
+          elseif(kode.eq.442)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined three body potential'
+          elseif(kode.eq.443)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined four body potential'
+          elseif(kode.eq.444)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined bond potential'
+          elseif(kode.eq.445)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined many body potential'
+          elseif(kode.eq.446)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined electrostatic key in dihfrc'
+          elseif(kode.eq.447)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - 1-4 separation exceeds cutoff range'
+          elseif(kode.eq.448)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined dihedral potential'
+          elseif(kode.eq.449)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined inversion potential'
+          endif
+          
+        elseif(kode.lt.500)then
+          
+          if(kode.eq.450)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined tethering potential'
+          elseif(kode.eq.451)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - three body potential cutoff undefined'
+          elseif(kode.eq.452)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined pair potential'
+          elseif(kode.eq.453)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - four body potential cutoff undefined'
+          elseif(kode.eq.454)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined external field'
+          elseif(kode.eq.456)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - core and shell in same rigid unit'
+          elseif(kode.eq.458)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many PMF constraints - param. mspmf too '
+     x        //'small'
+          elseif(kode.eq.460)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many PMF sites - parameter mxspmf too small'
+          elseif(kode.eq.461)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined metal potential'
+          elseif(kode.eq.462)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - PMF UNIT  record expected'
+          elseif(kode.eq.463)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in metal potential list'
+          elseif(kode.eq.464)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - thermostat time constant must be > 0.d0'
+          elseif(kode.eq.465)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated pair potential index too large'
+          elseif(kode.eq.466)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - barostat time constant must be > 0.d0'
+          elseif(kode.eq.468)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - r0 too large for snm potential with current '
+     x        //'cutoff'
+          elseif(kode.eq.470)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - n<m in definition of n-m potential'
+          elseif(kode.eq.474)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in parlst subroutine'
+          elseif(kode.eq.475)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in parlst_nsq subroutine'
+          elseif(kode.eq.476)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in parneulst subroutine'
+          elseif(kode.eq.477)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in prneulst subroutine'
+          elseif(kode.eq.478)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in forcesneu subroutine'
+          elseif(kode.eq.479)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in multipleneu subroutine'
+          elseif(kode.eq.484)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - only one potential of mean force permitted'
+          elseif(kode.eq.486)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HK real space screening function cutoff '
+     x        //'violation'
+          elseif(kode.eq.487)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HK recip space screening function cutoff '
+     x        //'violation'
+          elseif(kode.eq.488)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HK lattice control parameter set too large'
+          elseif(kode.eq.490)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - PMF parameter mxpmf too small in passpmf'
+          elseif(kode.eq.492)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxcons < number of PMF constraints'
+          elseif(kode.eq.494)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in csend: pvmfinitsend'
+          elseif(kode.eq.496)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in csend: pvmfpack'
+          elseif(kode.eq.498)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in csend: pvmfsend'
+          endif
+          
+        elseif(kode.lt.550)then
+          
+          if(kode.eq.500)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in crecv: pvmfrecv'
+          elseif(kode.eq.502)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in crecv: pvmfunpack'
+          elseif(kode.eq.504)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cutoff too large for TABLE file'
+          elseif(kode.eq.506)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - work arrays too small for quaternion integration'
+          elseif(kode.eq.508)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - rigid bodies not permitted with RESPA algorithm'
+          elseif(kode.eq.510)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - structure optimiser not permitted with RESPA'
+          elseif(kode.eq.513)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - SPME not available for given boundary conditions'
+          elseif(kode.eq.514)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - SPME routines have not been compiled in'
+          elseif(kode.eq.516)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - repeat of impact option specified'
+          endif
+          
+        elseif(kode.lt.650)then
+          
+          if(kode.eq.601)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald SPME incompatible with solvation'
+          elseif(kode.eq.602)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald HK incompatible with solvation'
+          endif
+          
+        elseif(kode.lt.1050)then
+          
+          if(kode.eq.1000)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of configuration arrays'
+          elseif(kode.eq.1010)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of angle arrays'
+          elseif(kode.eq.1011)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dihedral arrays'
+          elseif(kode.eq.1012)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of exclude arrays'
+          elseif(kode.eq.1013)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of rigid body arrays'
+          elseif(kode.eq.1014)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of vdw arrays'
+          elseif(kode.eq.1015)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of lr correction arrays'
+          elseif(kode.eq.1020)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of angle work arrays'
+          elseif(kode.eq.1030)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of bond arrays'
+          elseif(kode.eq.1040)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of bond work arrays'
+          endif
+          
+        elseif(kode.lt.1100)then
+          
+          if(kode.eq.1050)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dihedral arrays'
+          elseif(kode.eq.1060)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dihedral work arrays'
+          elseif(kode.eq.1070)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of constraint arrays'
+          elseif(kode.eq.1090)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of site arrays'
+          endif
+          
+        elseif(kode.lt.1050)then
+          
+          if(kode.eq.1100)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of core_shell arrays'
+          elseif(kode.eq.1115)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of hyperdynamics work arrays'
+          elseif(kode.eq.1120)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of inversion arrays'
+          elseif(kode.eq.1130)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of inversion work arrays' 
+          elseif(kode.eq.1140)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of four-body arrays'
+          endif
+          
+        elseif(kode.lt.1200)then
+          
+          if(kode.eq.1150)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of four-body work arrays'
+          elseif(kode.eq.1170)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of three-body arrays'
+          elseif(kode.eq.1180)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of three-body work arrays'
+          elseif(kode.eq.1200)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of external field arrays'
+          endif
+          
+        elseif(kode.lt.1250)then
+          
+          if(kode.eq.1210)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pmf arrays'
+          elseif(kode.eq.1220)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pmf_lf or pmf_vv '
+     x        //'work arrays'
+          elseif(kode.eq.1230)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pmf_shake work arrays'
+          elseif(kode.eq.1240)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of ewald arrays'
+          endif
+          
+        elseif(kode.lt.1300)then
+          
+          if(kode.eq.1250)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of excluded atom arrays'
+          elseif(kode.eq.1260)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tethering arrays'
+          elseif(kode.eq.1270)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tethering work arrays'
+          elseif(kode.eq.1280)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of metal arrays'
+          elseif(kode.eq.1290)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_h0.f'
+          endif
+          
+        elseif(kode.lt.1350)then
+          
+          if(kode.eq.1300)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in npt_b0.f'
+          elseif(kode.eq.1310)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_b0.f'
+          elseif(kode.eq.1320)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in npt_h0.f'
+          elseif(kode.eq.1330)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_h0.f'
+          elseif(kode.eq.1340)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in nst_b0.f'
+          endif
+          
+        elseif(kode.lt.1400)then
+          
+          if(kode.eq.1350)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_b0.f'
+          elseif(kode.eq.1360)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in nst_h0.f'
+          elseif(kode.eq.1370)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_h0.f'
+          elseif(kode.eq.1380)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nve_1.f'
+          elseif(kode.eq.1390)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_e1.f'
+          endif
+          
+        elseif(kode.lt.1450)then
+          
+          if(kode.eq.1400)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_b1.f'
+          elseif(kode.eq.1410)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_h1.f'
+          elseif(kode.eq.1420)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_b1.f'
+          elseif(kode.eq.1430)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in npt_b1.f'
+          elseif(kode.eq.1440)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_h1.f'
+          endif
+          
+        elseif(kode.lt.1500)then
+          
+          if(kode.eq.1450)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in npt_h1.f'
+          elseif(kode.eq.1460)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_b1.f'
+          elseif(kode.eq.1470)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nst_b1.f'
+          elseif(kode.eq.1480)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_h1.f'
+          elseif(kode.eq.1490)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nst_h1.f'
+          endif
+          
+        elseif(kode.lt.1550)then
+          
+          if(kode.eq.1500)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nveq_1.f'
+          elseif(kode.eq.1510)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_b1.f'
+          elseif(kode.eq.1520)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_h1.f'
+          elseif(kode.eq.1530)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_b1.f'
+          elseif(kode.eq.1540)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_b1.f'
+          endif
+          
+        elseif(kode.lt.1600)then
+          
+          if(kode.eq.1550)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_h1.f'
+          elseif(kode.eq.1560)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_h1.f'
+          elseif(kode.eq.1570)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_b1.f'
+          elseif(kode.eq.1580)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_b1.f'
+          elseif(kode.eq.1590)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_h1.f'
+          endif
+          
+        elseif(kode.lt.1650)then
+          
+          if(kode.eq.1600)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_h1.f'
+          elseif(kode.eq.1610)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in qshake.f'
+          elseif(kode.eq.1615)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in qrattle_q.f'
+          elseif(kode.eq.1620)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nveq_2.f'
+          elseif(kode.eq.1625)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in qrattle_v.f'
+          elseif(kode.eq.1630)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_b2.f'
+          elseif(kode.eq.1640)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_h2.f'
+          endif
+          
+        elseif(kode.lt.1700)then
+          
+          if(kode.eq.1650)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_b2.f'
+          elseif(kode.eq.1660)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_b2.f'
+          elseif(kode.eq.1670)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_h2.f'
+          elseif(kode.eq.1680)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_h2.f'
+          elseif(kode.eq.1690)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_b2.f'
+          endif
+          
+        elseif(kode.lt.1750)then
+          
+          if(kode.eq.1700)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_b2.f'
+          elseif(kode.eq.1710)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_h2.f'
+          elseif(kode.eq.1720)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_h2.f'
+          elseif(kode.eq.1730)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of HK Ewald arrays'
+          elseif(kode.eq.1740)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of property arrays'
+          endif
+          
+        elseif(kode.lt.1800)then
+          
+          if(kode.eq.1750)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of spme arrays'
+          elseif(kode.eq.1760)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of ewald_spme.f work arrays'
+          elseif(kode.eq.1770)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of quench.f work arrays'
+          elseif(kode.eq.1780)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of quatqnch.f work arrays'
+          elseif(kode.eq.1790)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of quatbook.f work arrays'
+          endif
+          
+        elseif(kode.lt.1850)then
+          
+          if(kode.eq.1800)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of intlist.f work arrays'
+          elseif(kode.eq.1810)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of forces.f work arrays'
+          elseif(kode.eq.1820)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of forcesneu.f work arrays'
+          elseif(kode.eq.1830)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of neutlst.f work arrays'
+          elseif(kode.eq.1840)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of multiple.f work arrays'
+          endif
+          
+        elseif(kode.lt.1900)then
+          
+          if(kode.eq.1850)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of multipleneu.f work arrays'
+          elseif(kode.eq.1860)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of multiple_nsq.f work arrays'
+          elseif(kode.eq.1870)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlst_nsq.f work arrays'
+          elseif(kode.eq.1880)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlst.f work arrays'
+          elseif(kode.eq.1890)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlink.f work arrays'
+          endif
+          
+        elseif(kode.lt.1950)then
+          
+          if(kode.eq.1900)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlinkneu.f work arrays'
+          elseif(kode.eq.1910)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parneulst.f work arrays'
+          elseif(kode.eq.1920)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of zero_kelvin.f work arrays'
+          elseif(kode.eq.1925)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of strucopt.f work arrays'
+          elseif(kode.eq.1930)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of vertest.f work arrays'
+          elseif(kode.eq.1940)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pair arrays'
+          elseif(kode.eq.1945)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tersoff arrays'
+          endif
+          
+        elseif(kode.lt.2000)then
+          
+          if(kode.eq.1950)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - shell relaxation cycle limit exceeded'
+          elseif(kode.eq.1951)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - no shell dynamics algorithm specified'
+          elseif(kode.eq.1953)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - tersoff radius of cutoff not defined'
+          elseif(kode.eq.1955)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tersoff work arrays'
+          elseif(kode.eq.1960)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - conflicting shell option in FIELD file'
+          elseif(kode.eq.1970)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of shell_relax work arrays'
+          elseif(kode.eq.1972)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown tersoff potential defined in FIELD file'
+          elseif(kode.eq.1974)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect period boundary in tersoff.f'
+          elseif(kode.eq.1976)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells required in tersoff.f'
+          elseif(kode.eq.1977)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - tersoff.f requires 3x3x3 link cells minimum'
+          elseif(kode.eq.1978)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined potential in tersoff.f'
+          elseif(kode.eq.1980)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvevv_1.f work arrays'
+          elseif(kode.eq.1990)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtvv_b1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2050)then
+          
+          if(kode.eq.2000)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtvv_e1.f work arrays'
+          elseif(kode.eq.2010)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtvv_h1.f work arrays'
+          elseif(kode.eq.2020)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_b1.f dens0 array'
+          elseif(kode.eq.2030)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_b1.f work arrays'
+          elseif(kode.eq.2040)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_h1.f dens0 array'
+          endif
+          
+        elseif(kode.lt.2100)then
+          
+          if(kode.eq.2050)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_h1.f work arrays'
+          elseif(kode.eq.2060)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_b1.f dens0 array'
+          elseif(kode.eq.2070)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_b1.f work arrays'
+          elseif(kode.eq.2080)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_h1.f dens0 array'
+          elseif(kode.eq.2090)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_b1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2150)then
+          
+          if(kode.eq.2100)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nveqvv_1.f work arrays'
+          elseif(kode.eq.2110)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nveqvv_2.f work arrays'
+          elseif(kode.eq.2120)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_b1.f work arrays'
+          elseif(kode.eq.2130)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_b2.f work arrays'
+          elseif(kode.eq.2140)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_h1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2200)then
+          
+          if(kode.eq.2150)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_h2.f work arrays'
+          elseif(kode.eq.2160)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b1.f dens0 array'
+          elseif(kode.eq.2170)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b1.f work arrays'
+          elseif(kode.eq.2180)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b2.f dens0 array'
+          elseif(kode.eq.2190)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b2.f work arrays'
+          endif
+          
+        elseif(kode.lt.2250)then
+          
+          if(kode.eq.2200)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h1.f dens0 array'
+          elseif(kode.eq.2210)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h1.f work arrays'
+          elseif(kode.eq.2220)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h2.f dens0 array'
+          elseif(kode.eq.2230)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h2.f work arrays'
+          elseif(kode.eq.2240)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b1.f dens0 array'
+          endif
+          
+        elseif(kode.lt.2300)then
+          
+          if(kode.eq.2250)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b1.f work arrays'
+          elseif(kode.eq.2260)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b2.f dens0 array'
+          elseif(kode.eq.2270)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b2.f work arrays'
+          elseif(kode.eq.2280)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h1.f dens0 array'
+          elseif(kode.eq.2290)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2350)then
+          
+          if(kode.eq.2300)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h2.f dens0 array'
+          elseif(kode.eq.2310)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h2.f work arrays'
+          elseif(kode.eq.2320)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - NEB convergence failure'
+          elseif(kode.eq.2330)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many basin files found - increase mxbsn'
+          elseif(kode.eq.2340)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - TAD diffs arrays exceeded '//
+     x        '- increase mxdiffs'
+          elseif(kode.eq.2341)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HYPOLD file not TAD compatible'
+          endif
+          
+        elseif(kode.lt.2400)then
+          
+          if(kode.eq.2350)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - kinks found in NEB chain during optimisation'
+            
+          elseif(kode.eq.2355)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot run both TAD and BPD together'
+            
+          elseif(kode.eq.2360)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - ensemble unavailable for metadynamics'
+            
+          endif
+          
+c     *****************important note********************
+c     error messages 2500 to 2550 reserved for metadynamics
+c     see subroutine mfrz_error in metafreeze_module
+
+        else
+          
+          write(nrite,'(/,/,1x,a)')
+     x      'error - undefined error code found'
+          
+        endif
+        
+      endif
+      
+      if(kill)then
+        
+c     close all i/o channels
+        
+        if(idnode.eq.0)then
+          close (nrite)
+          close (nhist)
+          close (nread)
+          close (nconf)
+          close (nstats)
+          close (nrest)
+          close (nfield)
+          close (ntable)
+          close (nevnt)
+        endif
+        
+        call gsync()
+        call exitcomms()
+        
+      endif
+      
+      return
+      end subroutine error
+      
+      subroutine warning(idnode,kode,a,b,c)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing warning messages and returning
+c     control back to the main program
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    april 1994
+c     
+c***********************************************************************
+      
+      use setup_module
+      
+      implicit none
+      
+      integer idnode,kode,ia,ib,ic
+      real(8) a,b,c
+      
+      if(idnode.eq.0)then
+        
+        if(kode.eq. 10)then
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - no pair forces in use ***'
+          
+        elseif(kode.eq. 20)then
+          
+          ia = nint(a)
+          ib = nint(b)
+          ic = nint(c)
+          write(nrite,'(/,1x,a50,i5,5x,a6,2i10)')
+     x      ' *** warning - : 1..4 scale factors reset for molecule ',
+     x      ia,'sites ',ib,ic
+          
+        elseif(kode.eq. 30)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - atomistic cutoff with electrostatics ***'
+          
+        elseif(kode.eq. 40)then
+          
+          write(nrite,'(/,1x,a,/,1x,a,f12.6)')
+     x      ' *** warning - radial cutoff reset ***',
+     x      'new potential cutoff radius    ',a
+          
+        elseif(kode.eq. 50)then
+          
+          write(nrite,'(/,1x,a,/,1x,a,f12.6)')
+     x      ' *** warning - short range cutoff reset ***',
+     x      'new cutoff radius (rvdw)       ',a
+          
+        elseif(kode.eq. 60)then
+          
+          write(nrite,'(/,1x,a,f12.6,a)')
+     x      ' *** warning - total system charge:',a,' ***'
+          
+        elseif(kode.eq. 70)then
+          
+          write(nrite,'(/,1x,a,f12.6,a)')
+     x      ' *** warning - switching length reset to: ',a,' ***'
+          
+        elseif(kode.eq. 80)then
+          
+          write(nrite,'(/,1x,a,f12.6,a)')
+     x      ' *** warning -  requested thermostat unavailable ***'
+          
+        elseif(kode.eq. 90)then
+          
+          ia=nint(a)
+          ib=nint(b)
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning -  cannot activate link cell option ***'
+          write(nrite,'(/,1x,a,i6,a,i6)')
+     x      ' *** you must change parameter mxcell from ',ib,' to ',ia
+          write(nrite,'(/,1x,a)')
+     x      ' *** using standard Brode-Ahlrichs list builder  ***'
+          
+        elseif(kode.eq.100)then
+          
+          write(nrite,'(/,1x,a,1p,e12.4,a)')
+     x      ' *** warning - HK real space screening function problem'
+     x      //' at cut off:',a,' ***'
+          
+        elseif(kode.eq.105)then
+          
+          write(nrite,'(/,1x,a,1p,e12.4,a)')
+     x      ' *** warning - HK recip space screening function problem'
+     x      //' at cut off:',a,' ***'
+          
+        elseif(kode.eq.110)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - undefined atom-atom interactions set to '
+     x      //'zero ***'
+          
+        elseif(kode.eq.120)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - RDF calculation cancelled - no pair forces'
+     x      //' defined ***'
+          
+        elseif(kode.eq.130)then
+          
+          ia=nint(a)
+          write(nrite,'(/,1x,a,i5,a)')
+     x      ' *** warning - RDF interval reset to',ia,' ***'
+          
+        elseif(kode.eq.140)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - RDF calculation cancelled - free energy'
+     x      //' option in use ***'
+          
+        else
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** unspecified warning encountered ***'
+        endif
+        
+      endif
+      
+      return
+      end subroutine warning
+      
+      end module error_module
diff -urN dl_class_1.9.orig/srcmod/ewald_module.f dl_class_1.9/srcmod/ewald_module.f
--- dl_class_1.9.orig/srcmod/ewald_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/ewald_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1992 @@
+      module ewald_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining ewald sum arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted for solvation, free energy and excitation
+c     - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use exclude_module
+      use metafreeze_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+      
+      implicit none
+      
+      real(8), allocatable :: ckc(:),cks(:),clm(:),slm(:)
+      real(8), allocatable :: elc(:,:),els(:,:)
+      real(8), allocatable :: emc(:,:),ems(:,:)
+      real(8), allocatable :: enc(:,:),ens(:,:)
+      real(8), allocatable :: ewlbuf(:),erc(:),fer(:)
+      
+      save ckc,cks,clm,slm,elc,emc,enc,els,ems,ens,erc,fer,ewlbuf
+      
+      contains
+      
+      subroutine alloc_ewald_arrays(idnode)
+      
+      implicit none
+      
+      integer, parameter :: nnn=6
+      
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (ckc(mxewld),cks(mxewld),stat=fail(1))
+      allocate (clm(mxewld),slm(mxewld),stat=fail(2))
+      allocate (elc(mxewld,0:1),els(mxewld,0:1),stat=fail(3))
+      allocate (emc(mxewld,0:kmaxb),ems(mxewld,0:kmaxb),stat=fail(4))
+      allocate (enc(mxewld,0:kmaxc),ens(mxewld,0:kmaxc),stat=fail(5))
+      allocate (ewlbuf(mxebuf),erc(mxegrd),fer(mxegrd),stat=fail(6))
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1240)
+      enddo
+      
+      end subroutine alloc_ewald_arrays
+      
+      subroutine erfcgen(alpha,drewd,rcut)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for generating interpolation tables for 
+c     erfc and its derivative - for use with ewald sum.
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester dec 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i
+      real(8) alpha,drewd,rcut,a1,a2,a3,a4,a5,pp,rrr,rsq,tt,exp1
+      
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      
+c     look-up tables for real space part of ewald sum
+      
+      drewd=rcut/dble(mxegrd-4)
+      
+      do i=1,mxegrd
+        
+        rrr=dble(i)*drewd
+        rsq=rrr*rrr
+        tt=1.d0/(1.d0+pp*alpha*rrr)
+        exp1=exp(-(alpha*rrr)**2)
+        erc(i)=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rrr
+        fer(i)=(erc(i)+2.d0*(alpha/sqrpi)*exp1)/rsq
+        
+      enddo
+      
+      return
+      end subroutine erfcgen
+      
+      subroutine ewald1
+     x  (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x  kmax1,kmax2,kmax3,engcpe,vircpe,alpha,volm,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     parallel replicated data version (part 1)
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith march 1992.
+c     modified  - t. forester april 1993: t3d adaptation
+c     modified  - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c     
+c     note - in loop over all k vectors k=2pi(ll/cl,mm/cl,nn/cl)
+c     the values of ll,mm and nn are selected so that the symmetry of
+c     reciprocal lattice is taken into account i.e. the following
+c     rules apply.
+c     
+c     ll ranges over the values 0 to kmax1 only.
+c     
+c     mm ranges over 0 to kmax2 when ll=0 and over
+c     -kmax2 to kmax2 otherwise.
+c     nn ranges over 1 to kmax3 when ll=mm=0 and over
+c     -kmax3 to kmax3 otherwise.
+c     
+c     hence the result of the summation must be doubled at the end.
+c     
+c     stress tensor added t.forester may 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newjob,lconsw,safe,leven,lsolva,llsolva,lfree,lghost
+      integer isol,jsol,ksol,iisol,jjsol,kksol,kstep
+      integer idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3
+      integer iatm0,iatm1,i,j,limit,l,npass,ipass,kkk,nmin
+      integer mmin,ll,m,mm,n,nn
+      real(8) engcpe,vircpe,alpha,volm,epsq,omg,qchg,qfix,qforce
+      real(8) twopi,rvolm,ralph,det,rcpcut,rcpct2,engsic,ssx
+      real(8) ssy,ssz,rkx1,rky1,rkz1,cs,rkx2,rky2,rkz2,eng1
+      real(8) rkx3,rky3,rkz3,rksq,ckcs,ckss,rrksq,akk,bkk,akv
+      real(8) scal1,scale,virprs,ckc1s,cks1s,ckc2s,cks2s,fkk
+      real(8) term1a,term2a,term1b,term2b
+      
+      dimension omg(9)
+      
+      save newjob,engsic,qchg
+      
+      data newjob/.true./,lconsw/.true./,safe/.true./,leven/.true./
+      
+      twopi=2.d0*pi
+      
+      kstep=2
+      if(lfree.or.lghost)kstep=6
+      
+      if(alpha.lt.1.d-6)return
+      if(mxewld.ne.msatms)call error(idnode,330)
+      
+c     set up atoms numbers for nodes
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise coulombic potential energy
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     initalize stress tensor working arrays
+      
+      do i=1,9
+        omg(i)=0.d0
+      enddo
+      
+c     set working parameters
+      
+      rvolm=twopi/volm
+      ralph=-0.25d0/alpha**2
+      
+c     set switch for TO, RD and HP boundary conditions
+      
+      if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)then
+        
+        lconsw=.false.
+        rvolm=0.5d0*rvolm
+        
+      endif
+      
+c     construct reciprocal lattice vectors and set k vector range
+      
+      call invert(cell,rcell,det)
+      if(abs(det).lt.1.d-6)call error(idnode,120)
+      call dcell(rcell,buffer)
+      
+      rcpcut=min(dble(kmax1)*buffer(7),dble(kmax2)*buffer(8),
+     x  dble(kmax3)*buffer(9))
+      rcpcut=rcpcut*1.05d0*twopi
+      rcpct2=rcpcut**2
+      
+      if(newjob)then
+        
+c     calculate self interaction correction (sic) and net system charge
+        
+        qchg=0.d0
+        qchg0=0.d0
+        qchg1=0.d0
+        qchg2=0.d0
+        engsic=0.d0
+        engsic0=0.d0
+        engsic2=0.d0
+        
+c     set solvation charge correction variables
+        
+        if(lsolva)then
+          
+          qfix_sol(:)=0.d0
+          cou_sol_sic(:)=0.d0
+          if(lghost)then
+            
+            qfix_exc(:)=0.d0
+            cou_exc_sic(:)=0.d0
+            
+          endif
+          
+        endif
+        
+        if(lghost)then
+          
+c     set excitation sic and charge correction variables
+          
+          do i=iatm0,iatm1
+            
+            if(atm_fre(i).ne.2)then
+              qchg0=qchg0+chge(i)
+              engsic0=engsic0+chge(i)**2
+            endif
+            if(atm_fre(i).ne.1)then
+              qchg2=qchg2+chge(i)
+              engsic2=engsic2+chge(i)**2
+            endif
+            
+          enddo
+          
+        elseif(lfree)then
+          
+c     set free energy sic and charge correction variables
+          
+          do i=iatm0,iatm1
+            
+            if(atm_fre(i).eq.0)then
+              qchg0=qchg0+chge(i)
+              engsic0=engsic0+chge(i)**2
+            elseif(atm_fre(i).eq.1)then
+              qchg1=qchg1+chge(i)
+              engsic0=engsic0+lambda1*chge(i)**2
+              engsic2=engsic2-chge(i)**2
+            elseif(atm_fre(i).eq.2)then
+              qchg2=qchg2+chge(i)
+              engsic0=engsic0+lambda2*chge(i)**2
+              engsic2=engsic2+chge(i)**2
+            endif
+            
+          enddo
+          
+        else
+          
+c     set normal sic and charge correction variables
+          
+          do i=iatm0,iatm1
+            
+            qchg=qchg+chge(i)
+            engsic=engsic+chge(i)**2
+            
+          enddo
+          
+        endif
+        
+        if(lsolva)then
+          
+          if(lghost)then
+            
+c     set excitation sic and charge correction arrays
+            
+            do i=iatm0,iatm1
+              
+              kkk=loc2(atmolt(i),atmolt(i))
+              if(atm_fre(i).ne.2)then
+                cou_sol_sic(kkk)=cou_sol_sic(kkk)+chge(i)**2
+                qfix_sol(atmolt(i))=qfix_sol(atmolt(i))+chge(i)
+              endif
+              if(atm_fre(i).ne.1)then
+                cou_exc_sic(kkk)=cou_exc_sic(kkk)+chge(i)**2
+                qfix_exc(atmolt(i))=qfix_exc(atmolt(i))+chge(i)
+              endif
+              
+            enddo
+            
+          else
+            
+c     set solvation sic and charge correction arrays
+            
+            do i=iatm0,iatm1
+              
+              kkk=loc2(atmolt(i),atmolt(i))
+              cou_sol_sic(kkk)=cou_sol_sic(kkk)+chge(i)**2
+              qfix_sol(atmolt(i))=qfix_sol(atmolt(i))+chge(i)
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+c     calculate global values for correction variables and arrays
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=qchg
+          buffer(2)=qchg0
+          buffer(3)=qchg1
+          buffer(4)=qchg2
+          call gdsum(buffer(1),4,buffer(5))
+          qchg=buffer(1)
+          qchg0=buffer(2)
+          qchg1=buffer(3)
+          qchg2=buffer(4)
+          if(lsolva)then
+            
+            call gdsum(qfix_sol(1),mxtmls,buffer(1))
+            if(lghost)call gdsum(qfix_exc(1),mxtmls,buffer(1))
+            
+          endif
+          
+        endif
+        
+c     store self interaction correction terms
+        
+        engsic=-r4pie0/epsq*alpha*engsic/sqrpi
+        engsic0=-r4pie0/epsq*alpha*engsic0/sqrpi
+        engsic2=-r4pie0/epsq*alpha*engsic2/sqrpi
+        
+        if(lsolva)then
+          
+          cou_sol_sic(:)=-r4pie0/epsq*alpha*cou_sol_sic(:)/sqrpi
+          if(lghost)cou_exc_sic(:)=-r4pie0/epsq*alpha*
+     x      cou_exc_sic(:)/sqrpi
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      if(lfree.or.lghost)then
+        
+        qchg=qchg0
+        engsic=engsic0
+        
+      endif
+      
+c     calculate and store exponential factors
+c     convert real to reciprocal space coordinates
+      
+      i=0
+      
+      do j=iatm0,iatm1
+        
+        i=i+1
+        elc(i,0)=1.d0
+        emc(i,0)=1.d0
+        enc(i,0)=1.d0
+        els(i,0)=0.d0
+        ems(i,0)=0.d0
+        ens(i,0)=0.d0
+        ssx=rcell(1)*xxx(j)+rcell(4)*yyy(j)+rcell(7)*zzz(j)
+        ssy=rcell(2)*xxx(j)+rcell(5)*yyy(j)+rcell(8)*zzz(j)
+        ssz=rcell(3)*xxx(j)+rcell(6)*yyy(j)+rcell(9)*zzz(j)
+        elc(i,1)=cos(twopi*ssx)
+        emc(i,1)=cos(twopi*ssy)
+        enc(i,1)=cos(twopi*ssz)
+        els(i,1)=sin(twopi*ssx)
+        ems(i,1)=sin(twopi*ssy)
+        ens(i,1)=sin(twopi*ssz)
+        
+      enddo
+      
+      limit=i
+      
+      do l=2,kmax2
+        
+        do i=1,limit
+          
+          emc(i,l)=emc(i,l-1)*emc(i,1)-ems(i,l-1)*ems(i,1)
+          ems(i,l)=ems(i,l-1)*emc(i,1)+emc(i,l-1)*ems(i,1)
+          
+        enddo
+        
+      enddo
+      
+      do l=2,kmax3
+        
+        do i=1,limit
+          
+          enc(i,l)=enc(i,l-1)*enc(i,1)-ens(i,l-1)*ens(i,1)
+          ens(i,l)=ens(i,l-1)*enc(i,1)+enc(i,l-1)*ens(i,1)
+          
+        enddo
+        
+      enddo
+      
+c     start of main loop over k vectors
+      
+      npass=1
+      if(mxnode.gt.16)npass=2
+      if((mxnode.gt.1).and.(mxebuf.gt.5000))npass=2
+      
+      do ipass=1,npass
+        
+        kkk=0
+        mmin=0
+        nmin=1
+        if(llsolva)kksol=0
+        
+        do ll=0,kmax1
+          
+          l=ll
+          rkx1=twopi*dble(ll)*rcell(1)
+          rky1=twopi*dble(ll)*rcell(4)
+          rkz1=twopi*dble(ll)*rcell(7)
+          
+c     put cos(i,L) terms into cos(i,0) array
+          
+          if(l.eq.1)then
+            
+            do i=1,limit
+              
+              elc(i,0)=elc(i,1)
+              els(i,0)=els(i,1)
+              
+            enddo
+            
+          elseif(l.gt.1)then
+            
+            do i=1,limit
+              
+              cs=elc(i,0)
+              elc(i,0)=cs*elc(i,1)-els(i,0)*els(i,1)
+              els(i,0)=els(i,0)*elc(i,1)+cs*els(i,1)
+              
+            enddo
+            
+          endif
+          
+          do mm=mmin,kmax2
+            
+            m=iabs(mm)
+            rkx2=rkx1+twopi*dble(mm)*rcell(2)
+            rky2=rky1+twopi*dble(mm)*rcell(5)
+            rkz2=rkz1+twopi*dble(mm)*rcell(8)
+            
+c     set temporary products of exponential terms
+            
+            if(mm.ge.0)then
+              
+              do i=1,limit
+                
+                clm(i)=elc(i,0)*emc(i,m)-els(i,0)*ems(i,m)
+                slm(i)=els(i,0)*emc(i,m)+ems(i,m)*elc(i,0)
+                
+              enddo
+              
+            else
+              
+              do i=1,limit
+                
+                clm(i)=elc(i,0)*emc(i,m)+els(i,0)*ems(i,m)
+                slm(i)=els(i,0)*emc(i,m)-ems(i,m)*elc(i,0)
+                
+              enddo
+              
+            endif
+            
+            do nn=nmin,kmax3
+              
+              n=iabs(nn)
+              
+              if(.not.lconsw)then
+                
+                if(imcon.eq.7)then
+                  
+                  leven=(mod(l+m,2).eq.0)
+                  
+                else
+                  
+                  leven=(mod(l+m+n,2).eq.0)
+                  
+                endif
+                
+              endif
+              
+              if(lconsw.or.leven)then
+                
+                rkx3=rkx2+twopi*dble(nn)*rcell(3)
+                rky3=rky2+twopi*dble(nn)*rcell(6)
+                rkz3=rkz2+twopi*dble(nn)*rcell(9)
+                
+c     test on magnitude of k vector
+                
+                rksq=rkx3*rkx3+rky3*rky3+rkz3*rkz3
+                
+                if(rksq.le.rcpct2)then
+                  
+c     calculate exp(ikr) terms and product with charges
+                  
+                  i=0
+                  
+                  if(nn.ge.0)then
+                    
+                    if(lfree.or.lghost)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.1)then
+                          ckc1(i)=chge(j)*(clm(i)*enc(i,n)-
+     x                      slm(i)*ens(i,n))
+                          cks1(i)=chge(j)*(slm(i)*enc(i,n)+
+     x                      clm(i)*ens(i,n))
+                        elseif(atm_fre(j).eq.2)then
+                          ckc2(i)=chge(j)*(clm(i)*enc(i,n)-
+     x                      slm(i)*ens(i,n))
+                          cks2(i)=chge(j)*(slm(i)*enc(i,n)+
+     x                      clm(i)*ens(i,n))
+                        else
+                          ckc(i)=chge(j)*(clm(i)*enc(i,n)-
+     x                      slm(i)*ens(i,n))
+                          cks(i)=chge(j)*(slm(i)*enc(i,n)+
+     x                      clm(i)*ens(i,n))
+                        endif
+                        
+                      enddo
+                      
+                    else
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        ckc(i)=chge(j)*(clm(i)*enc(i,n)-slm(i)*ens(i,n))
+                        cks(i)=chge(j)*(slm(i)*enc(i,n)+clm(i)*ens(i,n))
+                        
+                      enddo
+                      
+                    endif
+                    
+                  else
+                    
+                    if(lfree.or.lghost)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.1)then
+                          ckc1(i)=chge(j)*(clm(i)*enc(i,n)+
+     x                      slm(i)*ens(i,n))
+                          cks1(i)=chge(j)*(slm(i)*enc(i,n)-
+     x                      clm(i)*ens(i,n))
+                        elseif(atm_fre(j).eq.2)then
+                          ckc2(i)=chge(j)*(clm(i)*enc(i,n)+
+     x                      slm(i)*ens(i,n))
+                          cks2(i)=chge(j)*(slm(i)*enc(i,n)-
+     x                      clm(i)*ens(i,n))
+                        else
+                          ckc(i)=chge(j)*(clm(i)*enc(i,n)+
+     x                      slm(i)*ens(i,n))
+                          cks(i)=chge(j)*(slm(i)*enc(i,n)-
+     x                      clm(i)*ens(i,n))
+                        endif
+                        
+                      enddo
+                      
+                    else
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        ckc(i)=chge(j)*(clm(i)*enc(i,n)+slm(i)*ens(i,n))
+                        cks(i)=chge(j)*(slm(i)*enc(i,n)-clm(i)*ens(i,n))
+                        
+                      enddo
+                      
+                    endif
+                    
+                  endif
+                  
+                  if(ipass.eq.1)then
+                    
+c     calculate vector sums
+                    
+                    ckcs=0.d0
+                    ckss=0.d0
+                    
+                    if(lfree.or.lghost)then
+                      
+                      ckc1s=0.d0
+                      cks1s=0.d0
+                      ckc2s=0.d0
+                      cks2s=0.d0
+                      
+                    endif
+                    
+                    if(llsolva)then
+                      
+                      ckc_sol_sum(:)=0.d0
+                      cks_sol_sum(:)=0.d0
+                      
+                      if(lghost)then
+                        ckc_fre_sum(:)=0.d0
+                        cks_fre_sum(:)=0.d0
+                      endif
+                      
+                    endif
+                    
+                    if(lfree.or.lghost)then
+                      
+                      i=0
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.1)then
+                          ckc1s=ckc1s+ckc1(i)
+                          cks1s=cks1s+cks1(i)
+                        elseif(atm_fre(j).eq.2)then
+                          ckc2s=ckc2s+ckc2(i)
+                          cks2s=cks2s+cks2(i)
+                        else
+                          ckcs=ckcs+ckc(i)
+                          ckss=ckss+cks(i)
+                        endif
+                        
+                      enddo
+                      
+                    else
+                      
+                      do i=1,limit
+                        
+                        ckcs=ckcs+ckc(i)
+                        ckss=ckss+cks(i)
+                        
+                      enddo
+                      
+                    endif
+                    
+                    if(llsolva)then
+                      
+                      i=0
+                      if(lghost)then
+                        
+                        do j=iatm0,iatm1
+                          
+                          i=i+1
+                          if(atm_fre(j).eq.1)then
+                            ckc_sol_sum(atmolt(j))=
+     x                        ckc_sol_sum(atmolt(j))+ckc1(i)
+                            cks_sol_sum(atmolt(j))=
+     x                        cks_sol_sum(atmolt(j))+cks1(i)
+                          elseif(atm_fre(j).eq.2)then
+                            ckc_fre_sum(atmolt(j))=
+     x                        ckc_fre_sum(atmolt(j))+ckc2(i)
+                            cks_fre_sum(atmolt(j))=
+     x                        cks_fre_sum(atmolt(j))+cks2(i)
+                          else
+                            ckc_sol_sum(atmolt(j))=
+     x                        ckc_sol_sum(atmolt(j))+ckc(i)
+                            cks_sol_sum(atmolt(j))=
+     x                        cks_sol_sum(atmolt(j))+cks(i)
+                          endif
+                          
+                        enddo
+                        
+                      else
+                        
+                        do j=iatm0,iatm1
+                          
+                          i=i+1
+                          ckc_sol_sum(atmolt(j))=ckc_sol_sum(atmolt(j))+
+     x                      ckc(i)
+                          cks_sol_sum(atmolt(j))=cks_sol_sum(atmolt(j))+
+     x                      cks(i)
+                          
+                        enddo
+                        
+                      endif
+                      
+                    endif
+                    
+c     perform global summation of exp(ikr) terms or store if npass=2
+                    
+                    if(npass.eq.2)then
+                      
+                      if(kkk+kstep.le.mxebuf)then
+                        
+                        ewlbuf(kkk+1)=ckcs
+                        ewlbuf(kkk+2)=ckss
+                        
+                        if(lfree.or.lghost)then
+                          
+                          ewlbuf(kkk+3)=ckc1s
+                          ewlbuf(kkk+4)=cks1s
+                          ewlbuf(kkk+5)=ckc2s
+                          ewlbuf(kkk+6)=cks2s
+                          
+                        endif
+                        
+                        if(llsolva)then
+                          
+                          do isol=1,mxtmls
+                            
+                            ebuf_sol1(kksol+isol)=ckc_sol_sum(isol)
+                            ebuf_sol2(kksol+isol)=cks_sol_sum(isol)
+                            
+                            if(lghost)then
+                              
+                              ebuf_exc1(kksol+isol)=ckc_fre_sum(isol)
+                              ebuf_exc2(kksol+isol)=cks_fre_sum(isol)
+                              
+                            endif
+                            
+                          enddo
+                          
+                        endif
+                        
+                      else
+                        
+                        safe=.false.
+                        
+                      endif
+                      
+                    elseif(mxnode.gt.1)then
+                      
+                      buffer(1)=ckcs
+                      buffer(2)=ckss
+                      call gdsum(buffer(1),2,buffer(3))
+                      ckcs=buffer(1)
+                      ckss=buffer(2)
+                      
+                      if(lfree.or.lghost)then
+                        
+                        buffer(1)=ckc1s
+                        buffer(2)=cks1s
+                        buffer(3)=ckc2s
+                        buffer(4)=cks2s
+                        call gdsum(buffer(1),4,buffer(5))
+                        ckc1s=buffer(1)
+                        cks1s=buffer(2)
+                        ckc2s=buffer(3)
+                        cks2s=buffer(4)
+                        
+                      endif
+                      
+                      if(llsolva)then
+                        
+                        call gdsum(ckc_sol_sum(1),mxtmls,buffer(1))
+                        call gdsum(cks_sol_sum(1),mxtmls,buffer(1))
+                        
+                        if(lghost)then
+                          
+                          call gdsum(ckc_fre_sum(1),mxtmls,buffer(1))
+                          call gdsum(cks_fre_sum(1),mxtmls,buffer(1))
+                          
+                        endif
+                        
+                      endif
+                      
+                    endif
+                    
+                  endif
+                  
+                  if(ipass.eq.npass)then
+                    
+                    if(npass.eq.2)then
+                      
+                      ckcs=ewlbuf(kkk+1)
+                      ckss=ewlbuf(kkk+2)
+                      
+                      if(lfree.or.lghost)then
+                        
+                        ckc1s=ewlbuf(kkk+3)
+                        cks1s=ewlbuf(kkk+4)
+                        ckc2s=ewlbuf(kkk+5)
+                        cks2s=ewlbuf(kkk+6)
+                        
+                      endif
+                      
+                      if(llsolva)then
+                        
+                        do isol=1,mxtmls
+                          
+                          ckc_sol_sum(isol)=ebuf_sol1(kksol+isol)
+                          cks_sol_sum(isol)=ebuf_sol2(kksol+isol)
+                          
+                          if(lghost)then
+                            
+                            ckc_fre_sum(isol)=ebuf_exc1(kksol+isol)
+                            cks_fre_sum(isol)=ebuf_exc2(kksol+isol)
+                            
+                          endif
+                          
+                        enddo
+                        
+                      endif
+                      
+                    endif
+                    
+c     calculate akk coefficients
+                    
+                    rrksq=1.d0/rksq
+                    if(lconsw)then
+                      akk=exp(ralph*rksq)*rrksq
+                    else
+                      akk=4.0d0*exp(ralph*rksq)*rrksq
+                    endif
+                    bkk=akk
+                    akv=2.d0*akk*(rrksq-ralph)
+                    
+c     accumulate potential energy and virial terms
+                    
+                    if(lghost)then
+                      
+                      engcpe=engcpe+akk*((ckcs*ckcs+ckss*ckss)
+     x                  +(ckc1s*ckc1s+cks1s*cks1s)+2.d0*
+     x                  (ckc1s*ckcs+cks1s*ckss))
+                      virprs=akv*((ckcs*ckcs+ckss*ckss)
+     x                  +(ckc1s*ckc1s+cks1s*cks1s)+2.d0*
+     x                  (ckc1s*ckcs+cks1s*ckss))
+                      
+                    elseif(lfree)then
+                      
+                      term1a=(ckc1s*ckc1s+cks1s*cks1s)
+                      term1b=2.d0*(ckc1s*ckcs+cks1s*ckss)
+                      term2a=(ckc2s*ckc2s+cks2s*cks2s)
+                      term2b=2.d0*(ckc2s*ckcs+cks2s*ckss)
+                      
+                      engcpe=engcpe+akk*
+     x                  ((ckcs*ckcs+ckss*ckss)+
+     x                  lambda1*(term1a+term1b)+
+     x                  lambda2*(term2a+term2b))
+                      
+                      cou_fre=cou_fre+akk*
+     x                  ((term2a+term2b)-(term1a+term1b))
+                      
+                      virprs=akv*
+     x                  ((ckcs*ckcs+ckss*ckss)+
+     x                  lambda1*(term1a+term1b)+
+     x                  lambda2*(term2a+term2b))
+                      
+                      cou_vir=cou_vir+akv*rksq*
+     x                  ((term2a+term2b)-(term1a+term1b))
+                      
+                    else
+                      
+                      engcpe=engcpe+akk*(ckcs*ckcs+ckss*ckss)
+                      virprs=akv*(ckcs*ckcs+ckss*ckss)
+                      
+                    endif
+                    
+                    if(llsolva)then
+                      
+                      ksol=0
+                      do isol=1,mxtmls
+                        
+                        fkk=2.d0*akk
+                        do jsol=1,isol
+                          
+                          ksol=ksol+1
+                          if(isol.eq.jsol)fkk=akk
+                          
+                          cou_sol(ksol)=cou_sol(ksol)+
+     x                      fkk*(ckc_sol_sum(isol)*ckc_sol_sum(jsol)+
+     x                      cks_sol_sum(isol)*cks_sol_sum(jsol))
+                          
+                          if(lghost)then
+                            
+                            cou_exc(ksol)=cou_exc(ksol)+
+     x                        akk*(ckc_fre_sum(isol)*ckc_fre_sum(jsol)+
+     x                        cks_fre_sum(isol)*cks_fre_sum(jsol))
+                            
+                          endif
+                          
+                        enddo
+                        
+                      enddo
+                      
+                    endif
+                    
+c     contributions to stress tensor
+                    
+                    omg(1)=omg(1)-virprs*rkx3*rkx3
+                    omg(5)=omg(5)-virprs*rky3*rky3
+                    omg(9)=omg(9)-virprs*rkz3*rkz3
+                    omg(2)=omg(2)-virprs*rkx3*rky3
+                    omg(3)=omg(3)-virprs*rkx3*rkz3
+                    omg(6)=omg(6)-virprs*rky3*rkz3
+                    
+c     calculate force on each site
+                    
+                    i=0
+                    if(lghost)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.2)then
+                          qforce=bkk*(cks2(i)*(ckcs+ckc2s)-
+     x                      ckc2(i)*(ckss+cks2s))
+                        elseif(atm_fre(j).eq.1)then
+                          qforce=bkk*(cks1(i)*(ckcs+ckc1s)-
+     x                      ckc1(i)*(ckss+cks1s))
+                        else
+                          qforce=bkk*(cks(i)*(ckcs+ckc1s)-
+     x                      ckc(i)*(ckss+cks1s))
+                        endif
+                        
+                        fxx(j)=fxx(j)+rkx3*qforce
+                        fyy(j)=fyy(j)+rky3*qforce
+                        fzz(j)=fzz(j)+rkz3*qforce
+                        
+                      enddo
+                      
+                    elseif(lfree)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.0)then
+                          qforce=bkk*(cks(i)*(ckcs+lambda1*ckc1s+
+     x                      lambda2*ckc2s)-ckc(i)*(ckss+lambda1*
+     x                      cks1s+lambda2*cks2s))
+                        elseif(atm_fre(j).eq.1)then
+                          qforce=lambda1*bkk*(cks1(i)*(ckcs+ckc1s)
+     x                      -ckc1(i)*(ckss+cks1s))
+                        elseif(atm_fre(j).eq.2)then
+                          qforce=lambda2*bkk*(cks2(i)*(ckcs+ckc2s)
+     x                      -ckc2(i)*(ckss+cks2s))
+                        endif
+                        
+                        fxx(j)=fxx(j)+rkx3*qforce
+                        fyy(j)=fyy(j)+rky3*qforce
+                        fzz(j)=fzz(j)+rkz3*qforce
+                        
+                      enddo
+                      
+                    else
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        qforce=bkk*(cks(i)*ckcs-ckc(i)*ckss)
+                        fxx(j)=fxx(j)+rkx3*qforce
+                        fyy(j)=fyy(j)+rky3*qforce
+                        fzz(j)=fzz(j)+rkz3*qforce
+                        
+                      enddo
+                      
+                    endif
+                    
+c     end vector loop
+                    
+                  endif
+                  
+                  kkk=kkk+kstep
+                  
+                  if(llsolva)kksol=kksol+mxtmls
+                  
+                endif
+                
+              endif
+              
+            enddo
+            
+            nmin=-kmax3
+            
+          enddo
+          
+          mmin=-kmax2
+          
+        enddo
+        
+c     delayed global sum of exp(ikr) terms for npass=2 case
+        
+        if(ipass.eq.1.and.npass.eq.2)then
+          
+          if(safe)then
+            
+            call gdsum(ewlbuf,kkk,buffer)
+            
+            if(llsolva)then
+              
+              call gdsum(ebuf_sol1,kksol,buffer)
+              call gdsum(ebuf_sol2,kksol,buffer)
+              
+              if(lghost)then
+                
+                call gdsum(ebuf_exc1,kksol,buffer)
+                call gdsum(ebuf_exc2,kksol,buffer)
+                
+              endif
+              
+            endif
+            
+            do i=1,limit
+              
+              elc(i,0)=1.d0
+              els(i,0)=0.d0
+              
+            enddo
+            
+          else
+            
+            if(idnode.eq.0)then
+              
+              write(nrite,'(a,i10)')
+     x          'dimension of ewlbuf array required ',kkk
+              write(nrite,'(a,i10)')
+     x          'dimension of current  ewlbuf array ',mxebuf
+              
+            endif
+            
+            call error(idnode,46)
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     reduce sums by factor mxnode for global summation
+      
+      engcpe=engcpe/dble(mxnode)
+      
+      if(lfree)then
+        cou_fre=cou_fre/dble(mxnode)
+        cou_vir=cou_vir/dble(mxnode)
+      endif
+      
+      if(llsolva)then
+        cou_sol(:)=cou_sol(:)/dble(mxnode)
+        if(lghost)cou_exc(:)=cou_exc(:)/dble(mxnode)
+      endif
+      
+      do i=1,9
+        omg(i)=omg(i)/dble(mxnode)
+      enddo
+      
+c     correction for charged systems
+      
+      if(lfree)then
+        
+        qfix=-(0.5d0*pi*r4pie0/epsq)*(((qchg/alpha)**2+lambda1*
+     x    (qchg1/alpha)**2+lambda2*(qchg2/alpha)**2+2.d0*lambda1*
+     x    (qchg1/alpha)*(qchg/alpha)+2.d0*lambda2*(qchg2/alpha)*
+     x    (qchg/alpha))/volm)/dble(mxnode)
+        
+        qfix_fre=-(0.5d0*pi*r4pie0/epsq)*(((qchg2/alpha)**2-
+     x    (qchg1/alpha)**2+2.d0*(qchg2/alpha)*(qchg/alpha)
+     x    -2.d0*(qchg1/alpha)*(qchg/alpha))/volm)/dble(mxnode)
+        
+      else
+        
+        qfix=-(0.5d0*pi*r4pie0/epsq)*((qchg/alpha)**2/volm)/
+     x    dble(mxnode)
+        
+      endif
+      
+c     add self interaction correction to potential
+      
+      if(lconsw)then
+        
+        eng1=engcpe
+        engcpe=2.d0*rvolm*r4pie0*engcpe/epsq+engsic+qfix
+        
+        if(lfree)then
+          
+          cou_vir=2.d0*rvolm*r4pie0*(cou_vir-3.d0*cou_fre)/epsq-
+     x      3.d0*qfix_fre
+          cou_fre=2.d0*rvolm*r4pie0*cou_fre/epsq+qfix_fre+engsic2
+          
+        endif
+        
+        if(llsolva)then
+          
+          cou_sol(:)=2.d0*rvolm*r4pie0*cou_sol(:)/epsq+cou_sol_sic(:)
+          if(lghost)cou_exc(:)=2.d0*rvolm*r4pie0*cou_exc(:)/epsq+
+     x      cou_exc_sic(:)
+          
+        endif        
+        
+        scal1=2.d0*rvolm*r4pie0/epsq
+        scale=4.d0*rvolm*r4pie0/epsq
+        
+      else
+        
+        eng1=engcpe
+        engcpe=rvolm*r4pie0*engcpe/epsq+engsic+qfix
+        
+        if(lfree)then
+          
+          cou_vir=rvolm*r4pie0*(cou_vir-3.d0*cou_fre)/epsq-
+     x      3.d0*qfix_fre
+          cou_fre=rvolm*r4pie0*cou_fre/epsq+qfix_fre+engsic2
+          
+        endif
+        
+        if(llsolva)then
+          
+          cou_sol(:)=rvolm*r4pie0*cou_sol(:)/epsq+cou_sol_sic(:)
+          if(lghost)cou_exc(:)=rvolm*r4pie0*cou_exc(:)/epsq+
+     x      cou_exc_sic(:)
+          
+        endif        
+        
+        scal1=rvolm*r4pie0/epsq
+        scale=2.d0*rvolm*r4pie0/epsq
+        
+      endif
+      
+      if(llsolva)then
+        
+        ksol=0
+        do isol=1,mxtmls
+          
+          fkk=1.d0
+          do jsol=1,isol
+            
+            ksol=ksol+1
+            if(isol.eq.jsol)fkk=0.5d0
+            
+            cou_sol(ksol)=cou_sol(ksol)-
+     x        ((fkk*pi*r4pie0/epsq)*qfix_sol(isol)*
+     x        qfix_sol(jsol)/(alpha*alpha*volm*
+     x        dble(mxnode)))
+              
+            if(lghost)then
+              
+              cou_exc(ksol)=cou_exc(ksol)-
+     x          ((fkk*pi*r4pie0/epsq)*qfix_exc(isol)*
+     x          qfix_exc(jsol)/(alpha*alpha*volm*
+     x          dble(mxnode)))
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+c     calculate final forces
+      
+      do i=iatm0,iatm1
+        
+        fxx(i)=scale*fxx(i)
+        fyy(i)=scale*fyy(i)
+        fzz(i)=scale*fzz(i)
+        
+      enddo
+      
+c     calculate stress tensor (symmetrical)
+      
+      stress(1)=stress(1)+scal1*(omg(1)+eng1)+qfix
+      stress(2)=stress(2)+scal1*omg(2)
+      stress(3)=stress(3)+scal1*omg(3)
+      stress(4)=stress(4)+scal1*omg(2)
+      stress(5)=stress(5)+scal1*(omg(5)+eng1)+qfix
+      stress(6)=stress(6)+scal1*omg(6)
+      stress(7)=stress(7)+scal1*omg(3)
+      stress(8)=stress(8)+scal1*omg(6)
+      stress(9)=stress(9)+scal1*(omg(9)+eng1)+qfix
+      
+c     virial term
+      
+      vircpe=-scal1*(omg(1)+omg(5)+omg(9)+3.d0*eng1)-3.d0*qfix
+      
+      cou_fre=0.d0
+      cou_vir=0.d0
+      return
+      end subroutine ewald1
+      
+      subroutine ewald2
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,drewd,rcut,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     parallel replicated data version (part 2)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     T3d optimised. t.forester july 1994
+c     modified  - p.-a. cazade oct 2007: solvation, free energy etcc     
+c     part 2 - real space terms. 
+c     
+c     Tabulated potential in r space
+c     3pt interpolation
+c     
+c     t. forester March 1993
+c     {stress tensor : t.forester june 1994}
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer m,ik,iatm,jatm,ll,l1,l2,kkk
+      real(8) engcpe,vircpe,drewd,rcut,epsq
+      real(8) chgprd,rsq,rrr,ppp,vk0,vk1,vk2,t1,t2,erfcr,egamma
+      real(8) rcsq,rdrewd,chgea,fx,fy,fz,fi
+      real(8) strs(6),strs_loc(6)
+      
+      dimension fi(3)
+      
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      
+c     reciprocal of interpolation interval
+      
+      rdrewd=1.d0/drewd
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))          
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          
+c     Ignore interaction if product of charges is zero
+          
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)              
+              
+              ll=int(rrr*rdrewd)
+              l1=ll+1
+              l2=ll+2
+              ppp=rrr*rdrewd-dble(ll)
+              
+c     calculate interaction energy using 3-point interpolation
+              
+              vk0=erc(ll)
+              vk1=erc(l1)
+              vk2=erc(l2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              erfcr=(t1+(t2-t1)*ppp*0.5d0)*chgprd
+              
+c     calculate forces using 3pt interpolation
+              
+              vk0=fer(ll)
+              vk1=fer(l1)
+              vk2=fer(l2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              egamma=(t1+(t2-t1)*ppp*0.5d0)*chgprd
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+erfcr
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-erfcr
+                  cou_vir=cou_vir+egamma*rsq
+                  erfcr=lambda1*erfcr
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre+erfcr
+                  cou_vir=cou_vir-egamma*rsq
+                  erfcr=lambda2*erfcr
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+                
+                engcpe=engcpe+erfcr
+                vircpe=vircpe-egamma*rsq
+                
+c     calculate solvation energy
+                
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+erfcr
+                
+c     calculate forces
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+c     metadynamics local parameters
+              
+              if(lmetadyn.and.(idrive.or.jdrive))then
+                
+c     local energy and virial
+                
+                eng_loc=eng_loc+erfcr
+                vir_loc=vir_loc-egamma*rsq
+                
+c     local forces
+                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+                
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+      
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine ewald2
+      
+      subroutine ewald3
+     x  (lsolva,lfree,lghost,iatm,ilst,engcpe,vircpe,alpha,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     parallel replicated data version (part 3)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     modified  - p.-a. cazade oct 2007: solvation, free energy etcc     
+c     
+c     stress stensor added t.forester may 1994
+c     
+c***********************************************************************
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,jatm,ilst,m,kkk
+      real(8) engcpe,vircpe,alpha,epsq,a1,a2,a3
+      real(8) a4,a5,pp,rr3,r10,r42,r216,chgea,chgprd,rrr,rsq,alpr
+      real(8) alpr2,erfr,egamma,tt,exp1,fx,fy,fz
+      real(8) strs(6),strs_loc(6)
+      
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      data rr3/0.333333333333d0/,r10/0.1d0/,r42/0.02380952381d0/
+      data r216/4.62962962963d-3/
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     initialise stress accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      do m=1,nexatm(ilst)
+        
+c     atomic index and charge product
+        
+        jatm=lexatm(ilst,m)
+        if(lmetadyn)jdrive=driven(ltype(jatm))
+        
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq. 2)cycle
+        endif
+        
+        chgprd=chgea*chge(jatm)
+        
+c     calculate interatomic distance
+        
+        rsq=xdf(m)**2+ydf(m)**2+zdf(m)**2
+        
+        rrr=sqrt(rsq)
+        alpr=rrr*alpha
+        alpr2=alpr*alpr
+        
+c     calculate error function and derivative
+        
+        if(alpr.lt.1.d-2)then
+          
+          erfr=2.d0*chgprd*(alpha/sqrpi)*
+     x      (1.d0+alpr2*(-rr3+alpr2*(r10+alpr2*(-r42+alpr2*r216))))
+          
+          egamma=-4.d0*chgprd*(alpha**3/sqrpi)*
+     x      (rr3+alpr2*(-2.d0*r10+alpr2*(3.d0*r42-4.d0*alpr2*r216)))
+          
+        else
+          
+          tt=1.d0/(1.d0+pp*alpha*rrr)
+          exp1=exp(-(alpha*rrr)**2)
+          erfr=(1.d0-tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1)*
+     x      chgprd/rrr
+          egamma=-(erfr-2.d0*chgprd*(alpha/sqrpi)*exp1)/rsq
+          
+        endif
+        
+c     set selection control
+        
+        lselect=.true.
+        
+c     set double index
+        
+        if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+        
+        if(lghost)then
+          
+c     selected excitation option
+          
+          if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+            
+c     calculate solvation energy
+                  
+            if(lsolva)cou_exc(kkk)=cou_exc(kkk)-erfr
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+            
+c     set hamiltonian mixing parameter
+            
+            cou_fre=cou_fre+erfr
+            cou_vir=cou_vir+egamma*rsq
+            erfr=lambda1*erfr
+            egamma=lambda1*egamma
+            
+          elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+            
+c     set hamiltonian mixing parameter
+            
+            cou_fre=cou_fre-erfr
+            cou_vir=cou_vir-egamma*rsq
+            erfr=lambda2*erfr
+            egamma=lambda2*egamma
+            
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate potential energy and virial
+
+          engcpe=engcpe-erfr
+          vircpe=vircpe-egamma*rsq
+        
+c     calculate solvation energy
+          
+          if(lsolva)cou_sol(kkk)=cou_sol(kkk)-erfr
+            
+c     calculate forces
+          
+          fx=egamma*xdf(m)
+          fy=egamma*ydf(m)
+          fz=egamma*zdf(m)
+          
+          fxx(iatm)=fxx(iatm)+fx
+          fyy(iatm)=fyy(iatm)+fy
+          fzz(iatm)=fzz(iatm)+fz
+          
+          fxx(jatm)=fxx(jatm)-fx
+          fyy(jatm)=fyy(jatm)-fy
+          fzz(jatm)=fzz(jatm)-fz
+          
+c     calculate stress tensor
+          
+          strs(1)=strs(1)+xdf(m)*fx
+          strs(2)=strs(2)+xdf(m)*fy
+          strs(3)=strs(3)+xdf(m)*fz
+          strs(4)=strs(4)+ydf(m)*fy
+          strs(5)=strs(5)+ydf(m)*fz
+          strs(6)=strs(6)+zdf(m)*fz
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive))then
+          
+c     local energy and virial
+
+          eng_loc=eng_loc-erfr
+          vir_loc=vir_loc-egamma*rsq
+        
+c     local forces
+          
+          fxx_loc(iatm)=fxx_loc(iatm)+fx
+          fyy_loc(iatm)=fyy_loc(iatm)+fy
+          fzz_loc(iatm)=fzz_loc(iatm)+fz
+          
+          fxx_loc(jatm)=fxx_loc(jatm)-fx
+          fyy_loc(jatm)=fyy_loc(jatm)-fy
+          fzz_loc(jatm)=fzz_loc(jatm)-fz
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xdf(m)*fx
+          strs_loc(2)=strs_loc(2)+xdf(m)*fy
+          strs_loc(3)=strs_loc(3)+xdf(m)*fz
+          strs_loc(4)=strs_loc(4)+ydf(m)*fy
+          strs_loc(5)=strs_loc(5)+ydf(m)*fz
+          strs_loc(6)=strs_loc(6)+zdf(m)*fz
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine ewald3
+      
+      subroutine ewald4(lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,
+     x  engcpl,vircpl,drewd,rcut,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     modified to allow direct calculation of primary (short-range)
+c     interactions for multiple-time step corrections
+c      
+c     primary neighbours are taken out of the Ewald sum
+c     electrostatics are evaluated directly instead
+c     
+c     parallel replicated data version (part 2)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     modified  - t. forester february 1993
+c     
+c     part 2 - real space terms
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip
+      integer iatm,ik,m,jatm,ll,i,kkk
+      real(8) engcpe,vircpe,engcpl,vircpl,drewd,rcut,epsq,rrr
+      real(8) rcsq,rdrewd,strs,strl,chgea,fi,fli,rsq,chgprd,coul
+      real(8) vk0,vk1,vk2,t1,t2,erfcr,fcoul,egamma,fx,fy,fz,ppp
+      
+      dimension fi(3),fli(3),strs(6),strl(6)
+      
+CDIR$ CACHE_ALIGN fi
+CDIR$ CACHE_ALIGN fli
+      
+      lskip=(lfree.or.lghost)
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      
+c     reciprocal of interpolation interval
+      
+      rdrewd=1.d0/drewd
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      engcpl=0.d0
+      vircpl=0.d0
+      
+c     initialise stress tensor accumulators
+      
+      do i=1,6
+        
+        strs(i)=0.d0
+        strl(i)=0.d0
+        
+      enddo
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      if(abs(chgea).gt.1.d-10)then
+        
+c     temporary arrays for cache aligning
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        fli(1)=flx(iatm)
+        fli(2)=fly(iatm)
+        fli(3)=flz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+            if(rcsq.gt.rsq)then
+              
+c     coulombic energy and coulombic force
+              
+              rrr=sqrt(rsq)
+              coul=chgprd/rrr
+              fcoul=coul/rsq
+              
+c     calculate Ewald term using 3-point interpolation
+              
+              ll=int(rrr*rdrewd)
+              ppp=rrr*rdrewd-dble(ll)
+              
+              vk0=erc(ll)
+              vk1=erc(ll+1)
+              vk2=erc(ll+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              erfcr=(t1+(t2-t1)*ppp*0.5d0)*chgprd              
+              
+c     calculate Ewald forces using 3pt interpolation
+              
+              vk0=fer(ll)
+              vk1=fer(ll+1)
+              vk2=fer(ll+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              egamma=(t1+(t2-t1)*ppp*0.5d0)*chgprd
+              egamma=egamma-fcoul
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)then
+                    cou_exc(kkk)=cou_exc(kkk)+coul
+                    cou_exc_lng(kkk)=cou_exc_lng(kkk)+erfcr-coul
+                  endif
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+fcoul*rsq
+                  coul=lambda1*coul
+                  erfcr=lambda1*erfcr
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-fcoul*rsq
+                  coul=lambda2*coul
+                  erfcr=lambda2*erfcr
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+                
+                engcpe=engcpe+coul
+                engcpl=engcpl+erfcr-coul
+                vircpe=vircpe-fcoul*rsq
+                vircpl=vircpl-egamma*rsq
+                
+c     calculate solvation energy
+                
+                if(lsolva)then
+                  cou_sol(kkk)=cou_sol(kkk)+coul
+                  cou_sol_lng(kkk)=cou_sol_lng(kkk)+erfcr-coul
+                endif
+                
+c     add in contributions to the long-range force
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fli(1)=fli(1)+fx
+                fli(2)=fli(2)+fy
+                fli(3)=fli(3)+fz
+                
+                flx(jatm)=flx(jatm)-fx
+                fly(jatm)=fly(jatm)-fy
+                flz(jatm)=flz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strl(1)=strl(1)+xdf(m)*fx
+                strl(2)=strl(2)+xdf(m)*fy
+                strl(3)=strl(3)+xdf(m)*fz
+                strl(4)=strl(4)+ydf(m)*fy
+                strl(5)=strl(5)+ydf(m)*fz
+                strl(6)=strl(6)+zdf(m)*fz
+              
+c     add in contributions to instantaneous force
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     copy back temporaries
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+        flx(iatm)=fli(1)
+        fly(iatm)=fli(2)
+        flz(iatm)=fli(3)
+        
+c     complete stress tensorS
+        
+        stresl(1)=stresl(1)+strl(1)
+        stresl(2)=stresl(2)+strl(2)
+        stresl(3)=stresl(3)+strl(3)
+        stresl(4)=stresl(4)+strl(2)
+        stresl(5)=stresl(5)+strl(4)
+        stresl(6)=stresl(6)+strl(5)
+        stresl(7)=stresl(7)+strl(3)
+        stresl(8)=stresl(8)+strl(5)
+        stresl(9)=stresl(9)+strl(6)
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+        
+      endif
+      
+      return
+      end subroutine ewald4
+      
+      end module ewald_module
diff -urN dl_class_1.9.orig/srcmod/exclude_module.f dl_class_1.9/srcmod/exclude_module.f
--- dl_class_1.9.orig/srcmod/exclude_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/exclude_module.f	2012-04-24 18:30:31.000000000 +0200
@@ -0,0 +1,1368 @@
+      module exclude_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining excluded atom arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use dihedral_module
+      use error_module
+      use inversion_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+
+      implicit none
+
+      integer, allocatable :: lexatm(:,:)
+      integer, allocatable :: nexatm(:),noxatm(:)
+
+      save lexatm,nexatm,noxatm
+
+      contains
+      
+      subroutine alloc_exc_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for allocating excluded atom arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=3
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (lexatm(msatms,mxexcl),stat=fail(1))
+      allocate (nexatm(msatms),stat=fail(2))
+      allocate (noxatm(msatms),stat=fail(3))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1012)
+      enddo
+
+      end subroutine alloc_exc_arrays
+
+      subroutine exclude(idnode,mxnode,natms,ntpmls)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     
+c     keybnd < 0 distance restraint so not excluded
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        june 1992
+c     
+c     rigid body exclusions added : t.forester nov 1993
+c     check on 1..4 scale factors : t.forester feb 1994
+c     inversion terms added       : w.smith    jul 1996
+c
+c***********************************************************************
+      
+      implicit none
+
+      logical newjob,check,safe,lchk
+      integer idnode,mxnode,natms,ntpmls,nsatms,ibig,i,ibonds
+      integer iangle,iconst,idihdr,invers,igrp,isite,ishels,ia,ib,k
+      integer ic,id,jz,j,jj,ia1,ib1,kk,jk,ntpsit,nlast,lexsav,itmols
+      real(8) a1,a2,a3
+      
+      save newjob
+      
+      data newjob/.true./
+      
+      if(newjob)then
+
+c     check on array allocations
+        
+        nsatms=(natms+mxnode-1)/mxnode
+        if(nsatms.gt.msatms)then
+          
+          if(idnode.eq.0)write(nrite,*)'make msatms >= ',nsatms
+          call error(idnode,100)
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+c     variables for array bound checking
+
+      ibig=0
+      safe=.true.
+
+c     initialise excluded atom arrays
+      
+      do i=1,mxsite
+        
+        nexsit(i)=0
+        
+      enddo
+      
+      do i=1,msatms
+        
+        nexatm(i)=0
+        
+      enddo
+
+      do j=1,mxexcl
+        
+        do i=1,mxsite
+          
+          lexsit(i,j)=0
+          
+        enddo
+        
+        do i=1,msatms
+          
+          lexatm(i,j)=0
+          
+        enddo
+        
+      enddo
+      
+
+c     loop over molecules in system
+      
+      ibonds=0
+      iangle=0
+      iconst=0
+      idihdr=0
+      invers=0
+      igrp  =0
+      isite =0
+      ishels=0
+      
+      do itmols=1,ntpmls
+        
+c     exclude sites on basis of chemical bonds
+        
+        do i=1,numbonds(itmols)
+          
+          ibonds=ibonds+1
+          
+          if(keybnd(ibonds).gt.0)then
+            
+            ia=lstbnd(ibonds,1)+isite
+            ib=lstbnd(ibonds,2)+isite
+
+c     check interaction not already included
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=ib-isite
+                lexsit(ib,nexsit(ib))=ia-isite
+              endif
+            endif
+            
+          endif
+          
+        enddo
+        
+c     exclude sites on basis of bond constraints
+        
+        do i=1,numcon(itmols)
+          
+          iconst=iconst+1
+          ia=lstcon(iconst,1)+isite
+          ib=lstcon(iconst,2)+isite
+
+c     check interaction not already included
+
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+          
+        enddo
+        
+c     exclude sites on basis of bond angles
+        
+        do i=1,numang(itmols)
+          
+          iangle=iangle+1
+          if(keyang(iangle).gt.0)then
+            ia=lstang(iangle,1)+isite
+            ib=lstang(iangle,2)+isite
+            ic=lstang(iangle,3)+isite
+
+c     check if already added to lists ..
+c     ia - ib interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=ib-isite
+                lexsit(ib,nexsit(ib))=ia-isite
+              endif
+            endif
+
+c     ib - ic interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ib),mxexcl)
+              if(lexsit(ib,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ib)=nexsit(ib)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(ib),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ib),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(ib,nexsit(ib))=ic-isite
+                lexsit(ic,nexsit(ic))=ib-isite
+              endif
+            endif
+
+c     ia - ic interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(ia),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=ic-isite
+                lexsit(ic,nexsit(ic))=ia-isite
+              endif
+            endif
+
+          endif
+          
+        enddo
+        
+c     exclude on basis of rigid groups
+        
+        do i=1,numgrp(itmols)
+          
+          igrp=igrp+1
+          id=listyp(igrp)
+          
+          do jj=1,numgsit(id)-1
+            
+            ia=lstgst(igrp,jj)+isite
+            
+            do jk=jj+1,numgsit(id)
+              
+              ib=lstgst(igrp,jk)+isite
+              
+c     check interaction not already included
+
+              lchk=.true.
+              do jz=1,min(nexsit(ia),mxexcl)
+                if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+              enddo
+              
+              if(lchk)then
+                nexsit(ia)=nexsit(ia)+1
+                nexsit(ib)=nexsit(ib)+1
+                if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia),nexsit(ib))
+                  safe=.false.
+                else
+                  lexsit(ia,nexsit(ia))=ib-isite
+                  lexsit(ib,nexsit(ib))=ia-isite
+                endif
+              endif
+              
+            enddo
+            
+          enddo
+          
+        enddo
+        
+c     exclude sites on basis of 1-4 dihedral angles
+        
+        do i=1,numdih(itmols)
+          
+          idihdr=idihdr+1
+          ia=lstdih(idihdr,1)+isite
+          ib=lstdih(idihdr,2)+isite
+          ic=lstdih(idihdr,3)+isite
+          id=lstdih(idihdr,4)+isite
+          
+c     check if already added to lists ..
+c     ia - ib interaction
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+          
+c     ib - ic interaction
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ib),mxexcl)
+            if(lexsit(ib,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ib)=nexsit(ib)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ib),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ib),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ib,nexsit(ib))=ic-isite
+              lexsit(ic,nexsit(ic))=ib-isite
+            endif
+          endif
+          
+c     ia - ic interaction
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ia),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ic-isite
+              lexsit(ic,nexsit(ic))=ia-isite
+            endif
+          endif
+          
+c     id - ib interaction
+          
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(id),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ib-isite
+                lexsit(ib,nexsit(ib))=id-isite
+              endif
+            endif
+            
+c     id - ic interaction
+            
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(id),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ic-isite
+                lexsit(ic,nexsit(ic))=id-isite
+              endif
+            endif
+            
+c     ia - id interaction: may need to reset vdw and elec scale factors
+            
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.id-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(id)=nexsit(id)+1
+              if(max(nexsit(ia),nexsit(id)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(id))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=id-isite
+                lexsit(id,nexsit(id))=ia-isite
+              endif
+              
+            elseif(keydih(idihdr).ne.7)then
+              
+c     if already excluded reset 1..4 vdw and coulombic scale factors
+              
+              check=((abs(prmdih(idihdr,4)).gt.1.d-10).or.
+     x          (abs(prmdih(idihdr,5)).gt.1.d-10))
+            
+              if(check)then
+                
+                a1=dble(itmols)
+                a2=dble(ia)
+                a3=dble(id)
+                call warning(idnode,20,a1,a2,a3)
+                
+                prmdih(idihdr,4)=0.d0
+                prmdih(idihdr,5)=0.d0
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+c     exclude sites on basis of inversion potentials
+        
+        do i=1,numinv(itmols)
+          
+          invers=invers+1
+          ia=lstinv(invers,1)+isite
+          ib=lstinv(invers,2)+isite
+          ic=lstinv(invers,3)+isite
+          id=lstinv(invers,4)+isite
+
+c     check if already added to lists ..
+c     ia - ib interaction
+
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+
+c     ib - ic interaction
+
+          lchk=.true.
+          do jz=1,min(nexsit(ib),mxexcl)
+            if(lexsit(ib,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ib)=nexsit(ib)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ib),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ib),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ib,nexsit(ib))=ic-isite
+              lexsit(ic,nexsit(ic))=ib-isite
+            endif
+          endif
+
+c     ia - ic interaction
+
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ia),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ic-isite
+              lexsit(ic,nexsit(ic))=ia-isite
+            endif
+          endif
+
+c     id - ib interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(id),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ib-isite
+                lexsit(ib,nexsit(ib))=id-isite
+              endif
+            endif
+
+c     id - ic interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(id),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ic-isite
+                lexsit(ic,nexsit(ic))=id-isite
+              endif
+            endif
+
+c     ia - id interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.id-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(id)=nexsit(id)+1
+              if(max(nexsit(ia),nexsit(id)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(id))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=id-isite
+                lexsit(id,nexsit(id))=ia-isite
+              endif
+
+          endif
+          
+        enddo
+        
+c     exclude sites on basis of core-shell units
+        
+        do i=1,numshl(itmols)
+          
+          ishels=ishels+1
+          
+          ia=lstshl(ishels,1)+isite
+          ib=lstshl(ishels,2)+isite
+
+c     check interaction not already included
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+          
+c     exclude sites on basis of bonds to core-shell units
+
+          ibonds=ibonds-numbonds(itmols)
+          do kk=1,numbonds(itmols)
+            
+            ibonds=ibonds+1
+            
+            if(keybnd(ibonds).gt.0)then
+              
+              ia1=lstbnd(ibonds,1)+isite
+              ib1=lstbnd(ibonds,2)+isite
+
+              if(ia.eq.ia1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ib1),mxexcl)
+                  if(lexsit(ib1,jz).eq.ib-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ib1)=nexsit(ib1)+1
+                  nexsit(ib)=nexsit(ib)+1
+                  if(max(nexsit(ib1),nexsit(ib)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ib1),nexsit(ib))
+                    safe=.false.
+                  else
+                    lexsit(ib1,nexsit(ib1))=ib-isite
+                    lexsit(ib,nexsit(ib))=ib1-isite
+                  endif
+                endif
+
+              endif
+
+              if(ia.eq.ib1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ia1),mxexcl)
+                  if(lexsit(ia1,jz).eq.ib-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ia1)=nexsit(ia1)+1
+                  nexsit(ib)=nexsit(ib)+1
+                  if(max(nexsit(ia1),nexsit(ib)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ia1),nexsit(ib))
+                    safe=.false.
+                  else
+                    lexsit(ia1,nexsit(ia1))=ib-isite
+                    lexsit(ib,nexsit(ib))=ia1-isite
+                  endif
+                endif
+
+              endif
+
+              if(ib.eq.ia1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ia),mxexcl)
+                  if(lexsit(ia,jz).eq.ib1-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ia)=nexsit(ia)+1
+                  nexsit(ib1)=nexsit(ib1)+1
+                  if(max(nexsit(ia),nexsit(ib1)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ia),nexsit(ib1))
+                    safe=.false.
+                  else
+                    lexsit(ia,nexsit(ia))=ib1-isite
+                    lexsit(ib1,nexsit(ib1))=ia-isite
+                  endif
+                endif
+
+              endif
+              if(ib.eq.ib1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ia),mxexcl)
+                  if(lexsit(ia,jz).eq.ia1-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ia)=nexsit(ia)+1
+                  nexsit(ia1)=nexsit(ia1)+1
+                  if(max(nexsit(ia),nexsit(ia1)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ia),nexsit(ia1))
+                    safe=.false.
+                  else
+                    lexsit(ia,nexsit(ia))=ia1-isite
+                    lexsit(ia1,nexsit(ia1))=ia-isite
+                  endif
+                endif
+
+              endif
+
+            endif
+
+          enddo
+          
+c     exclude sites on basis of constraint bonds to core-shell units
+          
+          iconst=iconst-numcon(itmols)
+          do kk=1,numcon(itmols)
+            
+            iconst=iconst+1
+            
+            ia1=lstcon(iconst,1)+isite
+            ib1=lstcon(iconst,2)+isite
+
+            if(ia.eq.ia1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ib1),mxexcl)
+                if(lexsit(ib1,jz).eq.ib-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ib1)=nexsit(ib1)+1
+                nexsit(ib)=nexsit(ib)+1
+                if(max(nexsit(ib1),nexsit(ib)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ib1),nexsit(ib))
+                  safe=.false.
+                else
+                  lexsit(ib1,nexsit(ib1))=ib-isite
+                  lexsit(ib,nexsit(ib))=ib1-isite
+                endif
+              endif
+
+            endif
+
+            if(ia.eq.ib1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ia1),mxexcl)
+                if(lexsit(ia1,jz).eq.ib-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ia1)=nexsit(ia1)+1
+                nexsit(ib)=nexsit(ib)+1
+                if(max(nexsit(ia1),nexsit(ib)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia1),nexsit(ib))
+                  safe=.false.
+                else
+                  lexsit(ia1,nexsit(ia1))=ib-isite
+                  lexsit(ib,nexsit(ib))=ia1-isite
+                endif
+              endif
+
+            endif
+
+            if(ib.eq.ia1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ia),mxexcl)
+                if(lexsit(ia,jz).eq.ib1-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ia)=nexsit(ia)+1
+                nexsit(ib1)=nexsit(ib1)+1
+                if(max(nexsit(ia),nexsit(ib1)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia),nexsit(ib1))
+                  safe=.false.
+                else
+                  lexsit(ia,nexsit(ia))=ib1-isite
+                  lexsit(ib1,nexsit(ib1))=ia-isite
+                endif
+              endif
+
+            endif
+            if(ib.eq.ib1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ia),mxexcl)
+                if(lexsit(ia,jz).eq.ia1-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ia)=nexsit(ia)+1
+                nexsit(ia1)=nexsit(ia1)+1
+                if(max(nexsit(ia),nexsit(ia1)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia),nexsit(ia1))
+                  safe=.false.
+                else
+                  lexsit(ia,nexsit(ia))=ia1-isite
+                  lexsit(ia1,nexsit(ia1))=ia-isite
+                endif
+              endif
+
+            endif
+
+          enddo
+          
+c     exclude sites on basis of rigid units involving  core or shell
+          
+          igrp=igrp-numgrp(itmols)
+          do kk=1,numgrp(itmols)
+          
+            igrp=igrp+1
+          
+            id=listyp(igrp)
+          
+            do jj=1,numgsit(id)
+            
+              ia1=lstgst(igrp,jj)+isite
+              if(ia1.eq.ia)then
+
+                do jk=1,numgsit(id)
+            
+                  if(jk.ne.jj)then
+                    ib1=lstgst(igrp,jk)+isite
+
+c     check interaction not already included
+          
+                    lchk=.true.
+                    do jz=1,min(nexsit(ib1),mxexcl)
+                      if(lexsit(ib1,jz).eq.ib-isite)lchk=.false.
+                    enddo
+                    if(lchk)then
+                      nexsit(ib1)=nexsit(ib1)+1
+                      nexsit(ib)=nexsit(ib)+1
+                      if(max(nexsit(ib1),nexsit(ib)).gt.mxexcl)then
+                        ibig=max(ibig,nexsit(ib1),nexsit(ib))
+                        safe=.false.
+                      else
+                        lexsit(ib1,nexsit(ib1))=ib-isite
+                        lexsit(ib,nexsit(ib))=ib1-isite
+                      endif
+                    endif
+
+                  endif
+
+                enddo
+                
+              endif
+
+              if(ia1.eq.ib)then
+
+                do jk=1,numgsit(id)
+            
+                  if(jk.ne.jj)then
+                    ib1=lstgst(igrp,jk)+isite
+
+c     check interaction not already included
+          
+                    lchk=.true.
+                    do jz=1,min(nexsit(ia),mxexcl)
+                      if(lexsit(ia,jz).eq.ib1-isite)lchk=.false.
+                    enddo
+                    if(lchk)then
+                      nexsit(ia)=nexsit(ia)+1
+                      nexsit(ib1)=nexsit(ib1)+1
+                      if(max(nexsit(ia),nexsit(ib1)).gt.mxexcl)then
+                        ibig=max(ibig,nexsit(ia),nexsit(ib1))
+                        safe=.false.
+                      else
+                        lexsit(ia,nexsit(ia))=ib1-isite
+                        lexsit(ib1,nexsit(ib1))=ia-isite
+                      endif
+
+                    endif
+
+                  endif
+
+                enddo
+                
+              endif
+
+            enddo
+
+          enddo
+
+        enddo
+
+        isite=isite+numsit(itmols)
+        
+      enddo
+      
+      ntpsit=isite
+
+c     check for exceeded array bounds
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)then
+        if(mxnode.gt.1)call gimax(ibig,1,jj)
+        if(idnode.eq.0)write(nrite,*)'mxexcl must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxexcl is currently     ',mxexcl
+        call error(idnode,65)
+      endif
+
+c     remove redundant entries from exclusion list
+c     (there shouldn't be any!)
+      
+      do i=1,ntpsit
+        
+        nlast=nexsit(i)
+        do j=1,nexsit(i)-1
+          
+          if(j.lt.nlast)then
+            
+            kk=j
+            do k=j+1,nexsit(i)
+              
+              if(lexsit(i,j).eq.lexsit(i,k))then
+                
+                nlast=nlast-1
+                lexsit(i,k)=0
+                
+              else if(lexsit(i,k).gt.0)then
+                
+                kk=kk+1
+                lexsav=lexsit(i,k)
+                lexsit(i,k)=0
+                lexsit(i,kk)=lexsav
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+        enddo
+        
+        nexsit(i)=nlast
+        
+      enddo
+
+      
+      return
+      end subroutine exclude
+
+      subroutine excludeneu(idnode,mxnode,nneut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     part 2 - neutral group implementation
+c     
+c     copyright - daresbury laboratory     1994
+c     author    - t. forester        march 1994
+c     
+c***********************************************************************
+      implicit none
+
+      logical lchk
+      integer idnode,mxnode,nneut,ibig,iatom,jatom,last,mpm2
+      integer npm2,m,ii,im,itmols,inoff,isoff,isit,iolsit,jm,jtmols
+      integer jnoff,jsoff,jsit,jolsit,jn1,jno1,jsite,jsite0,in1,ino1
+      integer jj0,isite,ij,idum,it
+      
+c     construct excluded pair list for verlet neighbour correction
+
+      ibig=0
+      iatom=0
+      jatom=0
+
+c     generate all atomic pairs and check for exclusions 
+c     with Brode Ahlrichs ordering of groups
+      
+      last=nneut
+      lchk=.true.
+      mpm2=nneut/2+1
+      npm2=(nneut-1)/2+1
+      
+c     outer loop over groups
+      
+      do m=1,mpm2
+        
+        if(m.gt.npm2)last=mpm2-1
+        
+c     inner loop over groups - include intragroup interactions
+        
+        ii=0
+        
+        do im=idnode+1,last,mxnode
+          
+          ii=ii+1
+
+c     first site in neutral group
+          
+          itmols=1
+          inoff=0
+          isoff=0
+          isit=numsit(itmols)*nummols(itmols)
+          iolsit=numsit(itmols)
+          
+c     calculate j group indices
+          
+          jm=im+m-1
+          if(jm.gt.nneut)jm=jm-nneut
+          
+c     inner loop over neutral groups
+          
+          jtmols=1
+          jnoff=0
+          jsoff=0
+          jsit=numsit(jtmols)*nummols(jtmols)
+          jolsit=numsit(jtmols)
+          
+c     test first sites in neutral group
+          
+          jatom=neulst(jm)        
+
+c     establish pointer to sets
+          
+          do while(jatom.gt.jsit)
+            
+            jtmols=jtmols+1
+            jnoff=jsit
+            jsoff=jsoff+jolsit
+            jsit=jsit+nummols(jtmols)*numsit(jtmols)
+            jolsit=numsit(jtmols)
+            
+          enddo
+          
+          jn1=jatom-jnoff
+          jno1=(jn1/jolsit)*jolsit
+          jsite=jn1-jno1
+          if(jsite.eq.0)then 
+            jsite=jolsit
+            jno1=jno1-jolsit
+          endif
+          jsite=jsite+jsoff
+          jsite0=jsite-1
+          
+          do iatom=neulst(im),neulst(im+1)-1
+            
+c     establish pointer to sets
+            
+            do while(iatom.gt.isit)
+              
+              itmols=itmols+1
+              inoff=isit
+              isoff=isoff+iolsit
+              isit=isit+nummols(itmols)*numsit(itmols)
+              iolsit=numsit(itmols)
+              
+            enddo
+            
+            in1=iatom-inoff
+            ino1=(in1/iolsit)*iolsit
+            isite=in1-ino1
+            if(isite.eq.0)then 
+              isite=iolsit
+              ino1=ino1-iolsit
+            endif
+            isite=isite+isoff
+            
+c     test im and jm are neutral groups on same molecule
+            
+            if((jnoff.eq.inoff).and.(ino1.eq.jno1))then
+            if(abs(im-jm).lt.iolsit)then
+              
+              jj0=neulst(jm)
+              jsite=jsite0
+              
+c     special case for im=jm (ie. same group)
+              
+              if(im.eq.jm)then 
+                
+                jj0=iatom+1
+                jsite=isite
+                
+              endif
+
+c     test for excluded interaction
+              
+              do jatom=jj0,neulst(jm+1)-1
+                
+                jsite=jsite+1
+                
+                do ij=1,nexsit(isite)
+                  
+                  if(lexsit(isite,ij).eq.jsite-jsoff)then
+                    
+                    it=nexatm(ii)
+                    
+                    if(it+2.gt.mxexcl)then
+                      
+                      ibig=max(it+2,ibig)
+                      nexatm(ii)=it+2
+                      lchk=.false.
+                      
+                    else
+                      
+                      lexatm(ii,it+1)=iatom
+                      lexatm(ii,it+2)=jatom
+                      nexatm(ii)=nexatm(ii)+2
+                      
+                    endif
+
+                  endif
+                  
+                enddo
+                
+              enddo
+              
+            endif
+            endif
+            
+          enddo
+          
+        enddo
+        
+      enddo
+
+c     global check
+      
+      call gstate(lchk)
+      if(.not.lchk)then
+        
+        if(mxnode.gt.1)call gimax(ibig,1,idum)
+        if(idnode.eq.0)write(nrite,*)'mxexcl must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxexcl is currently     ',mxexcl
+        call error(idnode,260)
+
+      endif
+      
+      return
+      end subroutine excludeneu
+
+      subroutine exclude_link(idnode,mxnode,ntpmls)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     
+c     part 2 - link cell implementation
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        june 1992
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntpmls,iatom,jatom,lsite,ksite
+      integer itmols,imols,isite,kk,newatm,k
+
+c     construct excluded pair list for verlet neighbour correction
+      
+      iatom=0
+      jatom=0
+      lsite=0
+      ksite=0
+      
+      do itmols=1,ntpmls
+        
+        do imols=1,nummols(itmols)
+          
+          do isite=1,numsit(itmols)
+            
+            iatom=iatom+1
+            
+            if(mod(iatom-1,mxnode).eq.idnode)then
+              
+              kk=0
+              jatom=jatom+1
+              
+              do k=1,nexsit(ksite+isite)
+                
+                newatm=lexsit(ksite+isite,k)+lsite
+                
+                kk=kk+1
+                lexatm(jatom,kk)=newatm
+                
+              enddo
+              
+              nexatm(jatom)=kk
+              
+            endif
+            
+          enddo
+          
+          lsite=lsite+numsit(itmols)
+          
+        enddo
+        
+        ksite=ksite+numsit(itmols)
+        
+      enddo
+      
+      return
+      end subroutine exclude_link
+
+      subroutine exclude_atom(idnode,mxnode,natms,ntpmls)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     part 2 
+c
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        june 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,ntpmls,iatom,jatom,lsite
+      integer ksite,itmols,isite,imols,k,kk,newatm,j,latom,i,ii
+
+c     construct excluded pair list for verlet neighbour correction
+      
+      iatom=0
+      jatom=0
+      lsite=0
+      ksite=0
+      
+      do itmols=1,ntpmls
+        
+        do imols=1,nummols(itmols)
+          
+          do isite=1,numsit(itmols)
+            
+            iatom=iatom+1
+            
+            if(mod(iatom-1,mxnode).eq.idnode)then
+              
+              kk=0
+              jatom=jatom+1
+              
+              do k=1,nexsit(ksite+isite)
+                
+                newatm=lexsit(ksite+isite,k)+lsite
+
+c     keep only brode-ahlrichs combinations of indices
+                
+                if(((newatm.gt.iatom).and.
+     x            (newatm-iatom.le.natms/2)).or.
+     x            ((newatm.lt.iatom).and.
+     x            (newatm+natms-iatom.le.(natms-1)/2)))then
+                  
+                  kk=kk+1
+                  lexatm(jatom,kk)=newatm
+                  
+                  if(kk.gt.1)then
+                    
+c     sort the excluded atom list in ascending indices
+
+                    do j=kk,2,-1
+                      
+                      if(lexatm(jatom,j).lt.lexatm(jatom,j-1))
+     x                  then
+                        latom=lexatm(jatom,j)
+                        lexatm(jatom,j)=lexatm(jatom,j-1)
+                        lexatm(jatom,j-1)=latom
+                      endif
+                      
+                    enddo
+                    
+                  endif
+                  
+                endif
+                
+              enddo
+              
+              nexatm(jatom)=kk
+              
+            endif
+            
+          enddo
+          
+          lsite=lsite+numsit(itmols)
+          
+        enddo
+        
+        ksite=ksite+numsit(itmols)
+        
+      enddo
+      
+c     final sort into brode-ahlrichs ordering
+      
+      ii=0
+      do i=1+idnode,natms,mxnode
+        
+        ii=ii+1
+        do j=1,nexatm(ii)
+          
+          if(lexatm(ii,1).lt.i)then
+            
+            latom=lexatm(ii,1)
+            
+            do k=1,nexatm(ii)-1
+              
+              lexatm(ii,k)=lexatm(ii,k+1)
+              
+            enddo
+            
+            lexatm(ii,nexatm(ii))=latom
+            
+          endif
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine exclude_atom
+
+      subroutine exclude_copy_mtd(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for copying excluded atom arrays into 
+c     the metadynamics module for use in computing order parameters
+c
+c     author    - d. quigley    April 2012
+c     
+c***********************************************************************
+      use metafreeze_module, only : mtd_lexatm,mtd_nexatm
+      implicit none
+      integer, parameter :: nnn=2
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     data needed by metadynamics module
+      allocate (mtd_lexatm(msatms,mxexcl),stat=fail(1))
+      allocate (mtd_nexatm(msatms)       ,stat=fail(2))
+
+      do i=1,nnn
+        if(fail(i).gt.0) call error(idnode,1012)
+      enddo
+
+
+c     copy exclude list into metafreeze module
+      mtd_nexatm = nexatm
+      mtd_lexatm = lexatm
+
+      return
+      end subroutine exclude_copy_mtd
+      
+      end module exclude_module
+
diff -urN dl_class_1.9.orig/srcmod/external_field_module.f dl_class_1.9/srcmod/external_field_module.f
--- dl_class_1.9.orig/srcmod/external_field_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/external_field_module.f	2014-02-27 13:49:34.000000000 +0100
@@ -0,0 +1,347 @@
+      module external_field_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining external field potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use utility_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmfld(:)
+      
+      save prmfld
+      
+      contains
+      
+      subroutine alloc_fld_arrays(idnode)
+      
+      implicit none
+      
+      integer fail,idnode
+      
+      data fail/0/
+      
+      allocate (prmfld(mxfld),stat=fail)
+      if(fail.ne.0)call error(idnode,1200)
+      
+      end subroutine alloc_fld_arrays
+      
+      subroutine define_external_field
+     x  (safe,lunits,idnode,keyfld,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to define external fields
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     amended   - p.-l. chau  jun 2009 z-restraint option
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lunits
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,keyfld,nfld,i,k,idum
+      real(8) engunit
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)return
+      
+      call strip(record,lenrec)
+      call lowcase(record,lenrec)
+      call copystring(record,message,80)
+      call getword(keyword,record,4,lenrec)
+      
+      if(keyword(1:4).eq.'elec') then
+        keyfld=1 
+      elseif(keyword(1:4).eq.'oshr') then
+        keyfld=2
+      elseif(keyword(1:4).eq.'shrx') then
+        keyfld=3
+      elseif(keyword(1:4).eq.'grav') then
+        keyfld=4
+      elseif(keyword(1:4).eq.'magn') then
+        keyfld=5
+      elseif(keyword(1:4).eq.'sphr') then
+        keyfld=6
+      elseif(keyword(1:4).eq.'zbnd') then
+        keyfld=7
+      elseif(keyword(1:4).eq.'zres') then
+        keyfld=9
+      else
+        if(idnode.eq.0) write(nrite,*) message
+        call error(idnode,454)
+      endif
+      
+      do i=1,mxfld
+        prmfld(i)=0.d0
+      enddo
+      
+      nfld=intstr(record,lenrec,idum)
+      if(nfld.eq.0)nfld=5
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)return
+      do k=1,nfld
+        
+        prmfld(k)=dblstr(record,lenrec,idum)
+        if(idum.gt.lenrec.and.k.lt.nfld)then
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)return
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'external field key ',13x,a4,
+     x    /,/,30x,'external field parameters')") keyword(1:4)
+        write(nrite,"(2(/,1x,1p,5e15.5))") prmfld
+        
+      endif      
+      
+c     convert to internal units
+      
+      if(keyfld.eq.1.or.keyfld.eq.4.or.keyfld.eq.5) then
+        
+        if(.not.lunits)call error(idnode,6)
+        
+        do i=1,3
+          prmfld(i)=prmfld(i)*engunit
+        enddo
+        
+      elseif(keyfld.eq.2.or.keyfld.eq.6.or.keyfld.eq.7) then
+        
+        prmfld(1)=prmfld(1)*engunit
+        
+      elseif(keyfld.eq.9) then
+        
+        prmfld(3)=prmfld(3)*engunit
+        
+      endif
+      
+      return
+      end subroutine define_external_field
+      
+      subroutine extnfld
+     x  (idnode,imcon,keyfld,mxnode,natms,engfld,virfld)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for application of an external field
+c     
+c     replicated data version / block data
+c     
+c     copyright daresbury laboratory 1993
+c     author  -    t.forester october 1993
+c     amended -    t.forester dec 1994
+c     amended -    p.-l. chau jun 2009 z-restraint option
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,imcon,keyfld,mxnode,natms,iatm1,iatm2,i,j
+      integer istart,ifinish,numresat
+      real(8) engfld,virfld,rz,rrr,gamma,zdif,totwgt
+      real(8) com(3)
+      
+c     energy and virial accumulators 
+      
+      engfld=0.d0
+      virfld=0.d0
+      
+c     block indices
+      
+      iatm1=(idnode*natms)/mxnode+1
+      iatm2=((idnode+1)*natms)/mxnode
+      
+      if(keyfld.eq.1) then
+        
+c     electric field: prmfld(1-3) are field components
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+chge(i)*prmfld(1)
+          fyy(i)=fyy(i)+chge(i)*prmfld(2)
+          fzz(i)=fzz(i)+chge(i)*prmfld(3)
+          
+        enddo
+        
+      elseif(keyfld.eq.2) then
+        
+c     oscillating shear: orthorhombic box:  Fx=a*cos(b.2.pi.z/L)
+        
+        rz=2.d0*pi/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+prmfld(1)*cos(prmfld(2)*zzz(i)*rz)
+          
+        enddo
+        
+      elseif(keyfld.eq.3.and.imcon.eq.6) then
+        
+c     continuous shear of walls : 2D periodic box (imcon=6)
+c     shear rate=prmfld(1) angstrom per ps for atoms at
+c     abs(z) > prmfld(2)
+        
+        do i=iatm1,iatm2
+          
+          if(abs(zzz(i)).gt.prmfld(2)) then
+            
+            vxx(i)=0.5d0*sign(prmfld(1),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      elseif(keyfld.eq.4) then
+        
+c     gravitational field: field components given by prmfld(1-3)
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+prmfld(1)*weight(i)
+          fyy(i)=fyy(i)+prmfld(2)*weight(i)
+          fzz(i)=fzz(i)+prmfld(3)*weight(i)
+          
+        enddo
+        
+      elseif(keyfld.eq.5) then
+        
+c     magnetic field: field components given by prmfld(1-3)
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+(vyy(i)*prmfld(3)-vzz(i)*prmfld(2))
+     x      *chge(i)
+          fyy(i)=fyy(i)+(vzz(i)*prmfld(1)-vxx(i)*prmfld(3))
+     x      *chge(i)
+          fzz(i)=fzz(i)+(vxx(i)*prmfld(2)-vyy(i)*prmfld(1))
+     x      *chge(i)
+          
+        enddo
+        
+      elseif(keyfld.eq.6) then
+        
+c     containing sphere : r^(-n) potential
+        
+        do i=iatm1,iatm2
+          
+          rrr=sqrt(xxx(i)**2+yyy(i)**2+zzz(i)**2)
+          if(rrr.gt.prmfld(4)) then
+            rrr=prmfld(2)-rrr
+            if(rrr.lt.0.d0) rrr=0.1d0
+            
+            gamma =prmfld(1)*rrr**(-prmfld(3))
+            engfld=engfld+gamma
+            
+            gamma=-prmfld(3)*gamma/((prmfld(2)-rrr)*rrr)
+            
+            fxx(i)=fxx(i)+gamma*xxx(i)
+            fyy(i)=fyy(i)+gamma*yyy(i)
+            fzz(i)=fzz(i)+gamma*zzz(i)
+            
+          endif
+          
+        enddo
+        
+      elseif(keyfld.eq.7) then
+        
+c     repulsive wall (harmonic) starting at z0
+        
+        do i=iatm1,iatm2
+          
+          if(prmfld(3)*zzz(i).gt.prmfld(3)*prmfld(2)) then
+            
+            zdif=zzz(i)-prmfld(2)
+            gamma=-prmfld(1)*zdif
+            
+            fzz(i)=fzz(i)+gamma
+            engfld=engfld-gamma*zdif/2.
+            
+          endif
+          
+        enddo
+        
+      elseif(keyfld.eq.9) then
+        
+c     keyfld=9. restrain molecule z-position
+c     prmfld(1) is number of first atom of restrained molecule
+c     prmfld(2) is number of last atom of restrained molecule
+c     prmfld(3) is the restraining constant
+c     prmfld(4) is z-min
+c     prmfld(5) is z-max
+        
+        istart=nint(prmfld(1))
+        ifinish=nint(prmfld(2))
+        numresat=ifinish-istart+1
+        
+c     calculate the centre of mass of the molecule
+        
+        call getcom_mol(istart,ifinish,imcon,idnode,mxnode,totwgt,com)
+        
+c     apply restraint force according to location
+        
+        if(com(3).lt.prmfld(4))then
+          
+c     if centre of mass is below z-min, activate restraining force
+          
+          do i=istart,ifinish
+            
+            fzz(i)=fzz(i)-prmfld(3)*(weight(i)/totwgt)*
+     x        (com(3)-prmfld(4))/mxnode
+            
+          enddo
+          
+        elseif(com(3).gt.prmfld(5))then
+          
+c     if centre of mass if above z-max, activate restraining force
+          
+          do i=istart,ifinish
+            
+            fzz(i)=fzz(i)-prmfld(3)*(weight(i)/totwgt)*
+     x        (com(3)-prmfld(5))/mxnode
+            
+          enddo
+          
+        endif
+        
+      else
+        
+c     unidentified field potential error exit
+        
+        call error(idnode,454)
+        
+      endif
+      
+c     global sum of external field potential and virial
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engfld
+        buffer(2)=virfld
+        call gdsum(buffer(1),2,buffer(3))
+        engfld=buffer(1)
+        virfld=buffer(2)
+        
+      endif
+      
+      return
+      end subroutine extnfld
+      
+      end module external_field_module
diff -urN dl_class_1.9.orig/srcmod/forces_module.f dl_class_1.9/srcmod/forces_module.f
--- dl_class_1.9.orig/srcmod/forces_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/forces_module.f	2015-11-09 14:15:45.064258843 +0100
@@ -0,0 +1,2970 @@
+      module forces_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for calculation of atomic forces
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - d. quigley : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use coulomb_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use metafreeze_module
+      use metal_module
+      use neu_coul_module
+      use nlist_builders_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+      use spme_module
+      use tersoff_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      contains
+      
+      subroutine force_manager
+     x  (newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x  lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x  ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x  keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x  isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x  vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x  rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x  virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x  virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x  engcfg,fmax,temp,engord,virord)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine to manage the calculation of the atomic forces
+c     from all force field terms.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva
+      logical lfree,lghost,llsolva
+      
+      integer idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,numrdf
+      integer keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ntpmet
+      integer i,nospl,multt,nneut,ntbond,ntangl,ntdihd,nsolva,isolva
+      integer ntinv,ntteth,ntshl,ntptbp,ntpfbp,ntpter,keyshl,keyfld
+      
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang,engdih
+      real(8) virdih,enginv,virinv,engtet,virtet,engshl,virshl,engfld
+      real(8) virfld,fmax,temp,shlke,engcfg,tmpeng,tmpvir,engord,virord
+      
+      llsolva=.false.
+      
+c     initialize energy and virial accumulators
+      
+      engbnd=0.d0
+      virbnd=0.d0
+      engang=0.d0
+      virang=0.d0
+      engdih=0.d0
+      virdih=0.d0
+      enginv=0.d0
+      virinv=0.d0
+      engtbp=0.d0
+      virtbp=0.d0
+      engter=0.d0
+      virter=0.d0
+      engfbp=0.d0
+      virfbp=0.d0
+      engsrp=0.d0
+      virsrp=0.d0
+      engcpe=0.d0
+      vircpe=0.d0
+      engfld=0.d0
+      virfld=0.d0
+      engshl=0.d0
+      virshl=0.d0
+      shlke =0.d0
+      engtet=0.d0
+      virtet=0.d0
+      engmet=0.d0
+      virmet=0.d0
+      virord=0.0d0
+      engord=0.0d0
+      
+      if(lmetadyn)then
+        
+        eng_loc=0.0d0
+        vir_loc=0.0d0
+        fxx_loc(:)=0.0d0
+        fyy_loc(:)=0.0d0
+        fzz_loc(:)=0.0d0
+        stress_loc(:)=0.0d0
+        
+      endif
+      
+c     initialise free energy accumulators
+      
+      if(lfree)then
+        
+        ang_fre=0.d0
+        bnd_fre=0.d0
+        dih_fre=0.d0
+        inv_fre=0.d0
+        tbp_fre=0.d0
+        fbp_fre=0.d0
+        cou_fre=0.d0
+        vdw_fre=0.d0
+        shl_fre=0.d0
+        ang_vir=0.d0
+        bnd_vir=0.d0
+        dih_vir=0.d0
+        inv_vir=0.d0
+        tbp_vir=0.d0
+        fbp_vir=0.d0
+        cou_vir=0.d0
+        vdw_vir=0.d0
+        shl_vir=0.d0
+        eng_cfg_fre=0.d0
+        vir_cfg_fre=0.d0
+        
+      endif
+      
+c     initialise solvation and excitation arrays
+      
+      if(lsolva)then
+        
+        if(keyfce/2.gt.0)lcomp(6)=.true.
+        if(mod(keyfce,2).eq.1)lcomp(7)=.true.
+        if(mod(nstep-nsolva,isolva).eq.0)then
+          
+          llsolva=.true.
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     initialise the force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress tensor
+      
+      if(nstep.gt.0)then
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+      endif
+      
+      if(keyfce.gt.0)then
+        
+c     calculate pair forces, including coulombic forces
+        
+        if(lnsq)then
+          
+c     multiple timestep - all-pairs
+          
+          call multiple_nsq
+     x      (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x      imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x      numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x      rcut,rprim,rvdw,vircpe,virsrp)
+          
+        elseif(.not.lneut)then         
+          
+c     single timestep
+          
+          if(multt.eq.1)then
+            
+            call forces
+     x        (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,
+     x        ntpmet,natms,nstbgr,nstep,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,
+     x        vircpe,virsrp,volm,engmet,virmet)
+            
+          else
+            
+            call multiple
+     x        (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x        imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x        mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x        rvdw,vircpe,virsrp,volm)
+            
+          endif
+          
+        elseif(lneut)then
+          
+c     neutral groups
+          
+          if(multt.eq.1)then
+            
+            call forces_neu
+     x        (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x        mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x        isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x        vircpe,virsrp)
+            
+          else
+            
+            call multiple_neu
+     x        (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x        numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x        rprim,rcut,rvdw,alpha,vircpe,virsrp)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add in long range corrections to energy and pressure
+      
+      engsrp=engsrp+elrc
+      virsrp=virsrp+virlrc
+      engmet=engmet+elrcm(0)
+      virmet=virmet+vlrcm(0)
+      if(lfree)then
+        vdw_fre=vdw_fre+elrc_fre
+        vdw_vir=vdw_vir+vlrc_fre
+      endif
+      
+c     calculate three body forces
+      
+      if(ntptbp.gt.0)call thbfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcuttb,
+     x  engtbp,virtbp)
+      
+c     calculate four body forces
+      
+      if(ntpfbp.gt.0)call fbpfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcutfb,
+     x  engfbp,virfbp)
+      
+c     calculate tersoff potential forces
+      
+      if(ntpter.gt.0)call tersoff
+     x  (idnode,mxnode,natms,imcon,rctter,engter,virter)
+      
+c     calculate bond forces
+      
+      if(ntbond.gt.0)call bndfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntbond,epsq,
+     x  engbnd,virbnd)
+      
+c     calculate valence angle forces
+      
+      if(ntangl.gt.0)call angfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntangl,engang,virang)
+      
+c     calculate dihedral forces
+      
+      if(ntdihd.gt.0)call dihfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntdihd,keyfce,dlrpot,
+     x  epsq,engcpe,engdih,engsrp,rcut,rvdw,alpha,vircpe,virdih,virsrp)
+      
+c     calculate inversion forces
+      
+      if(ntinv.gt.0)call invfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntinv,enginv,virinv)
+      
+c     calculate tethered atom forces
+      
+      if(ntteth.gt.0)call tethfrc
+     x  (idnode,mxnode,imcon,natms,nstep,ntteth,engtet,virtet)
+      
+c     calculate shell model forces
+      
+      if(keyshl.gt.0)call shlfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntshl,engshl,virshl)
+      
+c     external field
+      
+      if(keyfld.gt.0)call extnfld
+     x  (idnode,imcon,keyfld,mxnode,natms,engfld,virfld)
+      
+c     metadynamics option : use potential energy as order parameter
+      
+      if(lmetadyn)then
+        
+        tmpeng=engsrp+engcpe+engbnd+engang+engdih+engfld+
+     x         engtbp+engfbp+engshl+enginv+engter+engmet
+        
+        tmpvir=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x         virang+virshl+virtet+virmet
+        
+        call metafreeze_driver
+     x    (imcon,natms,temp,nstep,tmpeng,tmpvir,engord,virord)
+        
+      endif
+      
+c     global summation of force arrays (basic replicated data strategy)
+      
+      call global_sum_forces(natms,mxnode,fxx,fyy,fzz)
+      
+c     global sum of stress arrays
+      
+      if(mxnode.gt.1)call gdsum(stress,9,buffer)
+      
+c     add long range correction to diagonal terms of stress tensor
+      
+      stress(1)=stress(1)-(virlrc+vlrcm(0))/3.d0
+      stress(5)=stress(5)-(virlrc+vlrcm(0))/3.d0
+      stress(9)=stress(9)-(virlrc+vlrcm(0))/3.d0
+      
+c     cap forces in equilibration mode
+      
+      if(nstep.le.nsteql.and.lfcap)
+     x  call fcap(lfcap,natms,fmax,temp)
+      
+c     total configuration energy
+      
+      engcfg=engsrp+engcpe+engbnd+engang+engdih+engfld+engtbp+
+     x  engfbp+engshl+enginv+engter+engmet
+
+c     PLUMED modifications
+      if(lplumed)then
+         call plumed_f_gcmd("setStep"//char(0),nstep)
+         call plumed_f_gcmd("setMasses"//char(0),weight)
+         call plumed_f_gcmd("setCharges"//char(0),chge)
+         call plumed_f_gcmd("setPositionsX"//char(0),xxx)
+         call plumed_f_gcmd("setPositionsY"//char(0),yyy)
+         call plumed_f_gcmd("setPositionsZ"//char(0),zzz)
+         call plumed_f_gcmd("setBox"//char(0),cell) 
+         call plumed_f_gcmd("setEnergy"//char(0),engcfg)
+         call plumed_f_gcmd("setForcesX"//char(0),fxx)
+         call plumed_f_gcmd("setForcesY"//char(0),fyy)
+         call plumed_f_gcmd("setForcesZ"//char(0),fzz)
+         call plumed_f_gcmd("setVirial"//char(0),stress)
+         call plumed_f_gcmd("calc"//char(0) )
+      endif
+c     PLUMED modifications
+      
+c     total derivative of the configurational free energy
+      
+      if(lfree)then
+        
+        eng_cfg_fre=dlambda*(ang_fre+bnd_fre+dih_fre+inv_fre+
+     x    tbp_fre+fbp_fre+cou_fre+vdw_fre+shl_fre)
+        vir_cfg_fre=dlambda*(ang_vir+bnd_vir+dih_vir+inv_vir+
+     x    tbp_vir+fbp_vir+cou_vir+vdw_vir+shl_vir)
+        
+      endif
+      
+c     sum solvation and excitation energies for pair forces
+      
+      if(mxnode.gt.1)then
+        
+        if(llsolva)then
+          
+          call gdsum(vdw_sol,mxtmls_sol2,buffer)
+          call gdsum(cou_sol,mxtmls_sol2,buffer)
+          
+          if(lghost)then
+            
+            call gdsum(vdw_exc,mxtmls_exc2,buffer)
+            call gdsum(cou_exc,mxtmls_exc2,buffer)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add long range corrections to solvation terms
+      
+      if(lsolva)then
+        
+        vdw_sol(:)=vdw_sol(:)+elrc_sol(:)
+        if(lghost)vdw_exc(:)=vdw_exc(:)+elrc_exc(:)
+        
+      endif
+      
+      return
+      end subroutine force_manager
+      
+      subroutine forces
+     x  (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,ntpmet,natms,
+     x  nstbgr,nstep,nsteql,numrdf,nospl,nsolva,isolva,alpha,dlrpot,
+     x  drewd,engcpe,engsrp,epsq,rcut,rvdw,vircpe,virsrp,volm,engmet,
+     x  virmet)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     amended  - t. forester sept 1994
+c     amended  - w. smith june 1995 for metal potentials
+c     
+c     key:
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,loglnk,lewald,lspme,lhke,newjob,lcshft,safe
+      logical lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,kmax1,kmax2,kmax3,nhko,nlatt
+      integer mxnode,ntpvdw,natms,nstbgr,nstep,nsteql,numrdf
+      integer ntpmet,nospl,nsolva,isolva,i,j,k,ii
+      
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,eps
+      real(8) vircpe,virsrp,volm,engacc,engac1,viracc,engmet,virmet
+      
+      save newjob
+      
+      data newjob/.true./
+      
+      safe=.true.
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lhke)then
+          
+          call hkgen(idnode,nhko,nlatt,alpha,drewd,rcut)
+          
+        else if(lewald.or.lspme.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+c     initialise force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     calculate local density in metals
+      
+      if(ntpmet.gt.0)then
+        
+        call metdens
+     x    (idnode,imcon,mxnode,natms,engmet,virmet)
+        
+        stress(1)=stress(1)-virmet/3.d0
+        stress(5)=stress(5)-virmet/3.d0
+        stress(9)=stress(9)-virmet/3.d0
+        
+      endif
+      
+c     fourier contribution to coulombic forces in Ewald sum
+      
+      if(lewald)then
+        
+        call ewald1
+     x    (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x    kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     hautman-klein-ewald method
+      
+      if(lhke)then
+        
+c     fourier terms of hk-ewald
+        
+        call hkewald1
+     x    (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x    engacc,viracc,alpha,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+c     real space terms of hk-ewald
+        
+        call hkewald2
+     x    (idnode,mxnode,nhko,nlatt,imcon,natms,engacc,viracc,
+     x    drewd,rcut,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     smoothed particle mesh ewald
+      
+      if(lspme)then
+        
+        call ewald_spme
+     x    (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x    engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     outer loop over atoms
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        do k=1,lentry(ii)
+          
+          j=list(ii,k)
+          ilist(k)=j
+          
+          xdf(k)=xxx(i)-xxx(j)
+          ydf(k)=yyy(i)-yyy(j)
+          zdf(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     square of distances
+        
+        do k=1,lentry(ii)
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     calculate metal forces and potential
+        
+        if(ntpmet.gt.0)then
+          
+          call metfrc(safe,i,lentry(ii),engacc,viracc)
+          
+          engmet=engmet+engacc
+          virmet=virmet+viracc
+          
+        endif
+        
+c     calculate short range force and potential terms
+        
+        if(ntpvdw.gt.0.and.mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,
+     x      rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme)then
+          
+          call ewald2(llsolva,lfree,lghost,i,lentry(ii),engacc,
+     x      viracc,drewd,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+          
+          if(mod(nstep,nstbgr).eq.0)then
+            
+            call rdf0(i,lentry(ii),rcut)
+            
+          endif
+          
+        endif
+        
+      enddo      
+      
+c     check metal interpolation is safe
+      
+      if(ntpmet.gt.0)then
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,142)
+        
+      endif
+      
+c     calculate corrections for intramolecular coulomb terms in
+c     Ewald sum
+      
+      if(lewald.or.lspme.or.lhke)then
+        
+        eps=epsq
+        if(loglnk)eps=eps*2.0d0
+        
+c     outer loop over atoms
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          do k=1,nexatm(ii)
+            
+            j=lexatm(ii,k)
+            jlist(k)=j
+            
+            xdf(k)=xxx(i)-xxx(j)
+            ydf(k)=yyy(i)-yyy(j)
+            zdf(k)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     periodic boundary condition
+          
+          call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+          
+c     calculate correction terms
+          
+          if(lhke)then
+            
+            call hkewald3(i,ii,engacc,viracc,eps)
+            
+          else
+            
+            call ewald3
+     x        (llsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+            
+          endif
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        enddo
+        
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+        
+        if(mod(nstep,nstbgr).eq.0)then
+          
+          numrdf=numrdf+1
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=engmet
+        buffer(6)=virmet
+        buffer(7)=vdw_fre
+        buffer(8)=cou_fre
+        buffer(9)=vdw_vir
+        buffer(10)=cou_vir
+        call gdsum(buffer(1),10,buffer(11))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        engmet=buffer(5)
+        virmet=buffer(6)
+        vdw_fre=buffer(7)
+        cou_fre=buffer(8)
+        vdw_vir=buffer(9)
+        cou_vir=buffer(10)
+        
+      endif
+      
+      return
+      end subroutine forces
+      
+      subroutine forces_neu
+     x  (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x  isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x  vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     modified  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,newlst,lchk,lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,i,fail,jneu,jj0,jj1,j
+      integer ibig,ia,ineu,isn,ik,nsolva,isolva
+      real(8) dlrpot,engcpe,engsrp,epsq,rcut,rvdw,vircpe
+      real(8) virsrp,engacc,viracc,anorm,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension fail(2)
+      
+      data fail/0,0/
+      
+c     allocate working arrays
+      
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      do i=1,2
+        if(fail(i).ne.0)call error(idnode,1820)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      
+c     initialise force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     initialise energy and virial accumulators
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     outer loop over neutral groups
+      
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        newlst=.true.
+        
+        isn=1
+        call neutlst
+     x    (newlst,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x    mod(nstep,nstbgr).eq.0)then
+          
+          call rdf0neu(ik,rcut)
+          
+        endif
+        
+      enddo
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,478)
+      endif
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     counter for rdf statistics outside loop structure
+      
+      if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x  mod(nstep,nstbgr).eq.0)numrdf=numrdf+1
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,stat=fail(2))
+      
+      return
+      end subroutine forces_neu
+      
+      subroutine multiple
+     x  (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x  mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x  isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x  rvdw,vircpe,virsrp,volm)
+c***************************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm
+c     reciprocal space calculated on long time steps.
+c     
+c     copyright daresbury laboratory
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3,4
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3,4]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3,4
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+
+      logical newplst,newlst,lgofr,lzeql,lgr,loglnk,lewald,lspme
+      logical lhke,newjob,lcshft,lsolva,lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt
+      integer mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,fail
+      integer numlsts,i,nstep0,nsolva,isolva,ii,k,j,ik
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,volm,stresp,engcpl,engacc,viracc,engac1
+      real(8) vircpl,eps,ann,engsr1,viracl,engsrl,virsrl,virac2,engcp1
+      real(8) vircp1,engacl,engac2,virsr1
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz,newjob
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      if(newlst)nstep0=nstep
+      newplst=(newlst).or.(mod(nstep-nstep0,multt).eq.0)
+      
+c     allocate working arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1840)
+        enddo
+        
+      endif
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lspme.or.lewald.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+      endif
+      
+      newjob=.false.
+      
+c     divide neighbour list into primary and secondary neighbours
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call primlst(idnode,mxnode,natms,imcon,rprim)
+        
+      endif
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     zero force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS******************
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+        
+c     zero accumulators
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        llsolva=lsolva
+        if(lsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate fourier contribution to secondary coulombic forces
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(lewald)then
+            
+            call ewald1
+     x        (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x        kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+            
+c     hautman-klein-ewald method
+            
+          elseif(lhke)then
+            
+            call hkewald1
+     x        (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x        engac1,viracc,alpha,epsq)
+            
+c     real space terms of hk-ewald
+            
+            call hkewald2
+     x        (idnode,mxnode,nhko,nlatt,imcon,natms,engac2,
+     x        virac2,drewd,rcut,epsq)
+            
+            engac1=engac1+engac2
+            viracc=viracc+virac2
+            
+          elseif(lspme)then
+            
+c     smoothed particle mesh ewald
+            
+            call ewald_spme
+     x        (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x        engac1,viracc,alpha,volm,epsq)
+            
+          endif
+          
+          engcpl=engcpl+engac1
+          vircpl=vircpl+viracc
+          
+c     calculate corrections for intramolecular coulomb terms in 
+c     Ewald sum
+c     note: if using link cells - have double counted excluded 
+c     interactions use temporary adjustment to relative dielectric
+c     constant
+          
+          eps=epsq
+          if(loglnk)eps=epsq*2.0d0
+          
+c     calculate self interaction corrections for fourier contributions
+          
+          ii=0
+          
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic distances
+            
+            do k=1,nexatm(ii)
+              
+              j=lexatm(ii,k)
+              jlist(k)=j
+              
+              xdf(k)=xxx(i)-xxx(j)
+              ydf(k)=yyy(i)-yyy(j)
+              zdf(k)=zzz(i)-zzz(j)
+              
+            enddo
+            
+c     periodic boundary condition
+            
+            call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+            
+c     calculate correction terms
+            
+            if(lhke)then
+              
+              call hkewald3(i,ii,engacc,viracc,eps)
+              
+            else
+              
+              call ewald3
+     x          (lsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+              
+            endif
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          enddo
+          
+        endif
+        
+c     calculate pair contributions to secondary neighbour forces
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of distance
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+          
+          if(lewald.or.lspme)then
+            
+            call ewald2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,drewd,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.2)then
+            
+            call coul2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call coul4
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     calculate pair force contributions
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        ik=0
+        
+        do k=1,lentry(ii)
+          
+          j=-list(ii,k)
+          
+          if(j.gt.0)then
+            
+            ik=ik+1
+            ilist(ik)=j
+            xdf(ik)=xxx(i)-xxx(j)
+            ydf(ik)=yyy(i)-yyy(j)
+            zdf(ik)=zzz(i)-zzz(j)
+            
+          endif
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+        
+c     square of distance
+        
+        do k=1,ik
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     accumulate radial distribution functions
+        
+        if(lgr)call rdf0(i,ik,rcut)
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(newplst.or.
+     x      (mod(nstep-nstep0,multt).le.1))then
+            
+            if(lhke)then
+              
+              call hkewald4(i,ik,engacc,viracc,engacl,viracl,rcut,epsq)
+              
+            else
+              
+              call ewald4
+     x          (llsolva,lfree,lghost,i,ik,engacc,viracc,engacl,viracl,
+     x          drewd,rcut,epsq)
+              
+            endif
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            engcpl=engcpl+engacl
+            vircpl=vircpl+viracl
+            
+          else
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          endif
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+      enddo
+      
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresp(i)+stresl(i)*ann
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+      return
+      end subroutine multiple
+      
+      subroutine multiple_neu
+     x  (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x  keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rprim,rcut,rvdw,alpha,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     multiple timestep option
+c     
+c     parallel replicated data version
+c     
+c     fpx,fpy,fpz : forces from electrostatics fron rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory april 1994
+c     author  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     = 10,11 ----- reaction field                    : coul3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=7
+
+      logical lgofr,lzeql,newlst,newplst,lgr,lchk,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,fail,i,numlsts,jneu,jj0,j
+      integer jj1,ineu,ia,isn,ibig,ik,nstep0,nsolva,isolva
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rprim,rcut,rvdw,vircpe
+      real(8) virsrp,engcpl,vircpl,engsrl,virsrl,anorm,ann,stresp
+      real(8) engacc,viracc,engsr1,virsr1,engcp1,vircp1,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension fail(nnn),stresp(9)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      if(newjob)then
+        
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(3))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(4))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(5))
+          
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(6))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(7))
+          endif
+          
+        endif
+        newjob=.false.
+        
+      endif
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1850)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+
+c     error if ewald sum requested
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     create list of primary and secondary neighbours
+      
+      if(newlst)nstep0=nstep
+      newplst=(mod(nstep-nstep0,multt).eq.0)
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call prneulst(newlst,imcon,idnode,mxnode,nneut,rprim)
+        
+      endif
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     zero force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress arrays
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+      
+c     zero accumulators for secondary neighbour energies and virial
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        
+c     initialise solvation and excitation  arrays
+
+        if(lsolva)then
+          
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     outer loop over neutral groups
+        
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+c     calculate interatomic distances
+          
+          isn=-1
+          call neutlst
+     x      (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x      txx,tyy,tzz,uxx,uyy,uzz)
+          
+c     trap possible array bound exception 
+          
+          ibig=max(ibig,ik)
+          if(ik.gt.mxxdf)ik=0
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1.and.(rvdw.gt.rprim-delr))then
+            
+            call srfrceneu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.2)then
+            
+            call coul2neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,250)
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          else
+            
+            call error(idnode,250)
+            
+          endif
+          
+c     accumulate radial distribution functions out to rcut
+          
+          if(lgr)then
+            call rdf0neu(ik,rcut)
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+          
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+      ia=0
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        isn=1        
+        call neutlst
+     x    (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions out to rcut
+        
+        if(lgr)then
+          call rdf0neu(ik,rcut)
+        endif
+        
+      enddo
+      
+c     ******************END OF PRIMARY NEIGHBOUR PROCESSING*************
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,479)
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresl(i)*ann+stresp(i)
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,uxx,uyy,uzz,stat=fail(1))
+      
+      return
+      end subroutine multiple_neu
+      
+      subroutine multiple_nsq
+     x  (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rcut,rprim,rvdw,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm 
+c     to be used with all-pairs option
+c     
+c     flx,fly,flz : forces from electrostatics from r > rcut
+c     fpx,fpy,fpz : forces from electrostatics from rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     Ewald sum --- not used
+c     = 4,5  ------ Distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     truncated and shifted coulombic -- not used
+c     reaction field - not used
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+      logical newplst,newlst,lgofr,lzeql,lgr,lnsq,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nstep,nstbgr
+      integer nsteql,numrdf,fail,nstep0,ii,ik,k,numlsts,nsolva
+      integer isolva,i,j
+      real(8) delr,dlrpot,engcpe,engsrp,engcp3,epsq,rcut
+      real(8) rprim,rvdw,vircpe,virsrp,vircp3,rcut1,engcp2,vircp2
+      real(8) engsr2,virsr2,stresp,engacc,viracc
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engsr2,virsr2,engcp2,vircp2,nstep0,numlsts,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+
+      data numlsts/-1/
+      data newjob/.true./
+      
+c     allocate work arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1860)
+        enddo
+        newjob=.false.
+        
+      endif
+      
+      if(lnsq)then
+        
+        llsolva=.false.
+        if(lsolva)then
+          llsolva=(mod(nstep-nsolva,isolva).eq.0)
+        endif
+        
+c     divide neighbour list into primary and secondary neighbours
+        
+        if(newplst)then        
+          
+          numlsts=numlsts+1
+          call primlst(idnode,mxnode,natms,imcon,rprim)
+          
+        endif
+        
+c     flag for accumulating rdfs
+        
+        lgr=(lgofr.and.(.not.lzeql.or.(nstep-nsteql.gt.0)))
+        lgr=(lgr.and.newplst.and.(mod(numlsts,nstbgr).eq.0))
+        
+c     set extended cutoff for electrostatics - secondary shell
+        
+        rcut1=rcut+delr
+        
+        if(newlst)nstep0=nstep
+        newplst=(newlst.or.mod(nstep-nstep0,multt).eq.0)
+        
+c     ********************PROCESS TERTIARY NEIGHBOURS*********************
+        
+        if(newplst)then
+          
+          call coul_nsq
+     x      (lsolva,lfree,lghost,idnode,mxnode,natms,imcon,epsq,rcut,
+     x      engcp3,vircp3)
+          
+        endif
+        
+c     ****************END OF TERTIARY NEIGHBOUR PROCESSING**************
+        
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+        if(newplst)then
+          
+c     zero accumulators for secondary neighbour energies and virial
+          
+          engcp2=0.d0
+          vircp2=0.d0
+          engsr2=0.d0
+          virsr2=0.d0
+          
+c     zero secondary forces
+          
+          do i=1,natms
+            
+            fxx(i)=0.d0
+            fyy(i)=0.d0
+            fzz(i)=0.d0
+            
+          enddo
+          
+c     zero solvation and excitation arrays
+        
+          if(lsolva)then
+            
+            vdw_sol(:)=0.d0
+            cou_sol(:)=0.d0
+            
+            if(lghost)then
+              
+              vdw_exc(:)=0.d0
+              cou_exc(:)=0.d0
+              
+            endif
+            
+          endif
+
+c     zero stress tensor
+          
+          do i=1,9
+            stress(i)=0.d0
+          enddo
+          
+          ii=0
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic vectors
+            
+            ik=0
+            do k=1,lentry(ii)
+              
+              j=list(ii,k)
+              
+              if(j.gt.0)then
+                
+                ik=ik+1
+                ilist(ik)=j
+                xdf(ik)=xxx(i)-xxx(j)
+                ydf(ik)=yyy(i)-yyy(j)
+                zdf(ik)=zzz(i)-zzz(j)
+                
+              endif
+              
+            enddo
+            
+c     periodic boundary condition only for interactions > rprim
+            
+            call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+            
+c     square of interatomic distances
+            
+            do k=1,ik
+              
+              rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+              
+            enddo
+            
+c     short range forces for secondary shell
+            
+            if((mod(keyfce,2).eq.1).and.(rvdw.gt.rprim-delr))then
+              
+              call srfrce
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+              
+              engsr2=engsr2+engacc
+              virsr2=virsr2+viracc
+              
+            endif
+            
+c     calculate coulombic force and potential terms
+            
+            if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+              
+              call error(idnode,424)
+              
+            elseif(keyfce/2.eq.2)then
+              
+c     distance dependent dielectric
+              
+              call coul2
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.3)then
+              
+c     coulombic potential
+              
+              call coul0
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.4)then
+              
+c     truncated shifted coulombic potential
+              
+              call error(idnode,424)
+              
+            endif
+            
+c     accumulate radial distribution functions : out to rcut
+            
+            if(lgr)call rdf0(i,ik,rcut)
+            
+          enddo
+          
+c     store secondary forces and stress tensor
+          
+          do i=1,natms
+            
+            fpx(i)=fxx(i)
+            fpy(i)=fyy(i)
+            fpz(i)=fzz(i)
+            
+          enddo
+          
+          do i=1,9
+            stresp(i)=stress(i)
+          enddo
+          
+c     store solvation and excitation arrays
+          
+          if(lsolva)then
+            
+            vdw_sol_put(:)=vdw_sol(:)
+            cou_sol_put(:)=cou_sol(:)
+            
+            if(lghost)then
+              
+              vdw_exc_put(:)=vdw_exc(:)
+              cou_exc_put(:)=cou_exc(:)
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+        
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+        
+c     zero accumulators for total energies and virials
+        
+        engcpe=0.d0
+        engsrp=0.d0
+        vircpe=0.d0
+        virsrp=0.d0
+        
+c     zero primary forces
+        
+        do i=1,natms
+          
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+c     zero stress tensor
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+c     zero solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate primary pair force contributions
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=-list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of interatomic distances
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions : out to rcut
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrp=engsrp+engacc
+            virsrp=virsrp+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+            
+            call error(idnode,424)
+            
+          elseif(keyfce/2.eq.2)then
+            
+c     distance dependent dielectric
+            
+            call coul2
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+c     coulombic potential
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,424)
+            
+          endif
+          
+        enddo
+        
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+        
+c     counter for rdf statistics outside loop structure
+        
+        if(lgr)numrdf=numrdf+1
+        
+c     add in secondary and tertiary neighbour contributions to 
+c     force, energy etc
+        
+        do i=1,natms
+          
+          fxx(i)=fxx(i)+fpx(i)+flx(i)
+          fyy(i)=fyy(i)+fpy(i)+fly(i)
+          fzz(i)=fzz(i)+fpz(i)+flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stress(i)=stress(i)+stresp(i)
+        enddo
+        
+        engsrp=engsrp+engsr2
+        virsrp=virsrp+virsr2
+        
+        engcpe=engcpe+engcp2+engcp3 
+        vircpe=vircpe+vircp2+vircp3
+        
+c     calculate solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=vdw_sol(:)+vdw_sol_put(:)+vdw_sol_lng(:)
+          cou_sol(:)=cou_sol(:)+cou_sol_put(:)+cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc(:)=vdw_exc(:)+vdw_exc_put(:)+vdw_exc_lng(:)
+            cou_exc(:)=cou_exc(:)+cou_exc_put(:)+cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+c     sum up contributions to short range and coulombic potential
+        
+        if(mxnode.gt.1)then 
+          
+          buffer(1)=engsrp
+          buffer(2)=virsrp
+          buffer(3)=engcpe
+          buffer(4)=vircpe
+          buffer(5)=vdw_fre
+          buffer(6)=cou_fre
+          buffer(7)=vdw_vir
+          buffer(8)=cou_vir
+          call gdsum(buffer(1),8,buffer(9))
+          engsrp=buffer(1)
+          virsrp=buffer(2)
+          engcpe=buffer(3)
+          vircpe=buffer(4)
+          vdw_fre=buffer(5)
+          cou_fre=buffer(6)
+          vdw_vir=buffer(7)
+          cou_vir=buffer(8)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine multiple_nsq
+      
+      subroutine neutlst
+     x  (newlst,lchk,isn,imcon,idnode,ineu,ia,ll,
+     x  txx,tyy,tzz,uxx,uyy,uzz)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to create pair lists for neutral group
+c     implementations.
+c     loops over group ineu
+c     
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester march 1994
+c     
+c     isn = -1 => secondary neighbours
+c     isn =  1 => primary neighbours - must contain excld interactions
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lchk,lexc
+      integer isn,imcon,idnode,ineu,ia,ll,i,jj,jj0,jj1
+      integer fail,ibig,keyexc,lenia,j,jneu,in0,in1
+      real(8) txx,tyy,tzz,uxx,uyy,uzz
+      
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1830)
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     set cutoff radius
+        
+        ll=0
+        
+c     number of excludes found
+        
+        if(isn.lt.0)then
+          keyexc=nexatm(ia)+2
+        else
+          keyexc=1
+        endif
+        
+c     do centre - centre distances
+        
+        lenia=lentry(ia)
+        
+        do j=1,lenia
+          
+          jneu=abs(list(ia,j))
+          xxt(j)=uxx(ineu)-uxx(jneu)
+          yyt(j)=uyy(ineu)-uyy(jneu)
+          zzt(j)=uzz(ineu)-uzz(jneu)
+          
+        enddo
+        
+        call images(imcon,0,1,lenia,cell,xxt,yyt,zzt)
+        
+c     working intragroup vectors of central group 
+c     - for periodic boundaries
+        
+        in0=neulst(ineu)
+        in1=neulst(ineu+1)-1
+        
+c     loop over neutral groups sites of a  
+        
+        
+c     loop over groups in list
+        
+        do jj=1,lentry(ia)
+          
+          jneu=list(ia,jj)*isn
+          
+          if(jneu.gt.0)then
+            
+            do i=in0,in1
+              
+              jj0=neulst(jneu)
+              jj1=neulst(jneu+1)-1
+              
+              if(ineu.eq.jneu)jj0=i+1
+              
+c     loop over jneu sites
+              
+              do j=jj0,jj1
+                
+c     reject atoms in excluded pair list
+                
+                lexc=.false.     
+                
+                if(keyexc.lt.nexatm(ia))then
+                  
+                  if(lexatm(ia,keyexc).eq.i)then
+                    if(lexatm(ia,keyexc+1).eq.j)then
+                      lexc=.true.
+                      keyexc=keyexc+2
+                    endif
+                  endif   
+                  
+                endif
+                
+c     reject frozen atom pairs
+                
+                if(lstfrz(i).ne.0)then
+                  if(lstfrz(j).ne.0)lexc=.true.
+                endif
+                
+                if(.not.lexc)then
+                  
+                  ll=ll+1
+                  if(ll.le.mxxdf)then
+                    
+                    xdf(ll)=txx(i)+xxt(jj)-txx(j)
+                    ydf(ll)=tyy(i)+yyt(jj)-tyy(j)
+                    zdf(ll)=tzz(i)+zzt(jj)-tzz(j)
+                    rsqdf(ll)=xdf(ll)**2+ydf(ll)**2+zdf(ll)**2
+                    ilist(ll)=i
+                    jlist(ll)=j
+                    
+                  else
+                    
+                    lchk=.false.
+                    ibig=max(ibig,ll)
+                    
+                  endif
+                  
+                endif
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine neutlst
+      
+      end module forces_module
+      
diff -urN dl_class_1.9.orig/srcmod/forces_module.f.preplumed dl_class_1.9/srcmod/forces_module.f.preplumed
--- dl_class_1.9.orig/srcmod/forces_module.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/forces_module.f.preplumed	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,2952 @@
+      module forces_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for calculation of atomic forces
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - d. quigley : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use coulomb_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use metafreeze_module
+      use metal_module
+      use neu_coul_module
+      use nlist_builders_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+      use spme_module
+      use tersoff_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      contains
+      
+      subroutine force_manager
+     x  (newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x  lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x  ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x  keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x  isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x  vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x  rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x  virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x  virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x  engcfg,fmax,temp,engord,virord)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine to manage the calculation of the atomic forces
+c     from all force field terms.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva
+      logical lfree,lghost,llsolva
+      
+      integer idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,numrdf
+      integer keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ntpmet
+      integer i,nospl,multt,nneut,ntbond,ntangl,ntdihd,nsolva,isolva
+      integer ntinv,ntteth,ntshl,ntptbp,ntpfbp,ntpter,keyshl,keyfld
+      
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang,engdih
+      real(8) virdih,enginv,virinv,engtet,virtet,engshl,virshl,engfld
+      real(8) virfld,fmax,temp,shlke,engcfg,tmpeng,tmpvir,engord,virord
+      
+      llsolva=.false.
+      
+c     initialize energy and virial accumulators
+      
+      engbnd=0.d0
+      virbnd=0.d0
+      engang=0.d0
+      virang=0.d0
+      engdih=0.d0
+      virdih=0.d0
+      enginv=0.d0
+      virinv=0.d0
+      engtbp=0.d0
+      virtbp=0.d0
+      engter=0.d0
+      virter=0.d0
+      engfbp=0.d0
+      virfbp=0.d0
+      engsrp=0.d0
+      virsrp=0.d0
+      engcpe=0.d0
+      vircpe=0.d0
+      engfld=0.d0
+      virfld=0.d0
+      engshl=0.d0
+      virshl=0.d0
+      shlke =0.d0
+      engtet=0.d0
+      virtet=0.d0
+      engmet=0.d0
+      virmet=0.d0
+      virord=0.0d0
+      engord=0.0d0
+      
+      if(lmetadyn)then
+        
+        eng_loc=0.0d0
+        vir_loc=0.0d0
+        fxx_loc(:)=0.0d0
+        fyy_loc(:)=0.0d0
+        fzz_loc(:)=0.0d0
+        stress_loc(:)=0.0d0
+        
+      endif
+      
+c     initialise free energy accumulators
+      
+      if(lfree)then
+        
+        ang_fre=0.d0
+        bnd_fre=0.d0
+        dih_fre=0.d0
+        inv_fre=0.d0
+        tbp_fre=0.d0
+        fbp_fre=0.d0
+        cou_fre=0.d0
+        vdw_fre=0.d0
+        shl_fre=0.d0
+        ang_vir=0.d0
+        bnd_vir=0.d0
+        dih_vir=0.d0
+        inv_vir=0.d0
+        tbp_vir=0.d0
+        fbp_vir=0.d0
+        cou_vir=0.d0
+        vdw_vir=0.d0
+        shl_vir=0.d0
+        eng_cfg_fre=0.d0
+        vir_cfg_fre=0.d0
+        
+      endif
+      
+c     initialise solvation and excitation arrays
+      
+      if(lsolva)then
+        
+        if(keyfce/2.gt.0)lcomp(6)=.true.
+        if(mod(keyfce,2).eq.1)lcomp(7)=.true.
+        if(mod(nstep-nsolva,isolva).eq.0)then
+          
+          llsolva=.true.
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     initialise the force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress tensor
+      
+      if(nstep.gt.0)then
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+      endif
+      
+      if(keyfce.gt.0)then
+        
+c     calculate pair forces, including coulombic forces
+        
+        if(lnsq)then
+          
+c     multiple timestep - all-pairs
+          
+          call multiple_nsq
+     x      (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x      imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x      numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x      rcut,rprim,rvdw,vircpe,virsrp)
+          
+        elseif(.not.lneut)then         
+          
+c     single timestep
+          
+          if(multt.eq.1)then
+            
+            call forces
+     x        (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,
+     x        ntpmet,natms,nstbgr,nstep,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,
+     x        vircpe,virsrp,volm,engmet,virmet)
+            
+          else
+            
+            call multiple
+     x        (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x        imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x        mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x        rvdw,vircpe,virsrp,volm)
+            
+          endif
+          
+        elseif(lneut)then
+          
+c     neutral groups
+          
+          if(multt.eq.1)then
+            
+            call forces_neu
+     x        (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x        mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x        isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x        vircpe,virsrp)
+            
+          else
+            
+            call multiple_neu
+     x        (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x        numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x        rprim,rcut,rvdw,alpha,vircpe,virsrp)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add in long range corrections to energy and pressure
+      
+      engsrp=engsrp+elrc
+      virsrp=virsrp+virlrc
+      engmet=engmet+elrcm(0)
+      virmet=virmet+vlrcm(0)
+      if(lfree)then
+        vdw_fre=vdw_fre+elrc_fre
+        vdw_vir=vdw_vir+vlrc_fre
+      endif
+      
+c     calculate three body forces
+      
+      if(ntptbp.gt.0)call thbfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcuttb,
+     x  engtbp,virtbp)
+      
+c     calculate four body forces
+      
+      if(ntpfbp.gt.0)call fbpfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcutfb,
+     x  engfbp,virfbp)
+      
+c     calculate tersoff potential forces
+      
+      if(ntpter.gt.0)call tersoff
+     x  (idnode,mxnode,natms,imcon,rctter,engter,virter)
+      
+c     calculate bond forces
+      
+      if(ntbond.gt.0)call bndfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntbond,epsq,
+     x  engbnd,virbnd)
+      
+c     calculate valence angle forces
+      
+      if(ntangl.gt.0)call angfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntangl,engang,virang)
+      
+c     calculate dihedral forces
+      
+      if(ntdihd.gt.0)call dihfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntdihd,keyfce,dlrpot,
+     x  epsq,engcpe,engdih,engsrp,rcut,rvdw,alpha,vircpe,virdih,virsrp)
+      
+c     calculate inversion forces
+      
+      if(ntinv.gt.0)call invfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntinv,enginv,virinv)
+      
+c     calculate tethered atom forces
+      
+      if(ntteth.gt.0)call tethfrc
+     x  (idnode,mxnode,imcon,natms,nstep,ntteth,engtet,virtet)
+      
+c     calculate shell model forces
+      
+      if(keyshl.gt.0)call shlfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntshl,engshl,virshl)
+      
+c     external field
+      
+      if(keyfld.gt.0)call extnfld
+     x  (idnode,imcon,keyfld,mxnode,natms,engfld,virfld)
+      
+c     metadynamics option : use potential energy as order parameter
+      
+      if(lmetadyn)then
+        
+        tmpeng=engsrp+engcpe+engbnd+engang+engdih+engfld+
+     x         engtbp+engfbp+engshl+enginv+engter+engmet
+        
+        tmpvir=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x         virang+virshl+virtet+virmet
+        
+        call metafreeze_driver
+     x    (imcon,natms,temp,nstep,tmpeng,tmpvir,engord,virord)
+        
+      endif
+      
+c     global summation of force arrays (basic replicated data strategy)
+      
+      call global_sum_forces(natms,mxnode,fxx,fyy,fzz)
+      
+c     global sum of stress arrays
+      
+      if(mxnode.gt.1)call gdsum(stress,9,buffer)
+      
+c     add long range correction to diagonal terms of stress tensor
+      
+      stress(1)=stress(1)-(virlrc+vlrcm(0))/3.d0
+      stress(5)=stress(5)-(virlrc+vlrcm(0))/3.d0
+      stress(9)=stress(9)-(virlrc+vlrcm(0))/3.d0
+      
+c     cap forces in equilibration mode
+      
+      if(nstep.le.nsteql.and.lfcap)
+     x  call fcap(lfcap,natms,fmax,temp)
+      
+c     total configuration energy
+      
+      engcfg=engsrp+engcpe+engbnd+engang+engdih+engfld+engtbp+
+     x  engfbp+engshl+enginv+engter+engmet
+      
+c     total derivative of the configurational free energy
+      
+      if(lfree)then
+        
+        eng_cfg_fre=dlambda*(ang_fre+bnd_fre+dih_fre+inv_fre+
+     x    tbp_fre+fbp_fre+cou_fre+vdw_fre+shl_fre)
+        vir_cfg_fre=dlambda*(ang_vir+bnd_vir+dih_vir+inv_vir+
+     x    tbp_vir+fbp_vir+cou_vir+vdw_vir+shl_vir)
+        
+      endif
+      
+c     sum solvation and excitation energies for pair forces
+      
+      if(mxnode.gt.1)then
+        
+        if(llsolva)then
+          
+          call gdsum(vdw_sol,mxtmls_sol2,buffer)
+          call gdsum(cou_sol,mxtmls_sol2,buffer)
+          
+          if(lghost)then
+            
+            call gdsum(vdw_exc,mxtmls_exc2,buffer)
+            call gdsum(cou_exc,mxtmls_exc2,buffer)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add long range corrections to solvation terms
+      
+      if(lsolva)then
+        
+        vdw_sol(:)=vdw_sol(:)+elrc_sol(:)
+        if(lghost)vdw_exc(:)=vdw_exc(:)+elrc_exc(:)
+        
+      endif
+      
+      return
+      end subroutine force_manager
+      
+      subroutine forces
+     x  (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,ntpmet,natms,
+     x  nstbgr,nstep,nsteql,numrdf,nospl,nsolva,isolva,alpha,dlrpot,
+     x  drewd,engcpe,engsrp,epsq,rcut,rvdw,vircpe,virsrp,volm,engmet,
+     x  virmet)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     amended  - t. forester sept 1994
+c     amended  - w. smith june 1995 for metal potentials
+c     
+c     key:
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,loglnk,lewald,lspme,lhke,newjob,lcshft,safe
+      logical lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,kmax1,kmax2,kmax3,nhko,nlatt
+      integer mxnode,ntpvdw,natms,nstbgr,nstep,nsteql,numrdf
+      integer ntpmet,nospl,nsolva,isolva,i,j,k,ii
+      
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,eps
+      real(8) vircpe,virsrp,volm,engacc,engac1,viracc,engmet,virmet
+      
+      save newjob
+      
+      data newjob/.true./
+      
+      safe=.true.
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lhke)then
+          
+          call hkgen(idnode,nhko,nlatt,alpha,drewd,rcut)
+          
+        else if(lewald.or.lspme.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+c     initialise force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     calculate local density in metals
+      
+      if(ntpmet.gt.0)then
+        
+        call metdens
+     x    (idnode,imcon,mxnode,natms,engmet,virmet)
+        
+        stress(1)=stress(1)-virmet/3.d0
+        stress(5)=stress(5)-virmet/3.d0
+        stress(9)=stress(9)-virmet/3.d0
+        
+      endif
+      
+c     fourier contribution to coulombic forces in Ewald sum
+      
+      if(lewald)then
+        
+        call ewald1
+     x    (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x    kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     hautman-klein-ewald method
+      
+      if(lhke)then
+        
+c     fourier terms of hk-ewald
+        
+        call hkewald1
+     x    (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x    engacc,viracc,alpha,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+c     real space terms of hk-ewald
+        
+        call hkewald2
+     x    (idnode,mxnode,nhko,nlatt,imcon,natms,engacc,viracc,
+     x    drewd,rcut,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     smoothed particle mesh ewald
+      
+      if(lspme)then
+        
+        call ewald_spme
+     x    (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x    engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     outer loop over atoms
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        do k=1,lentry(ii)
+          
+          j=list(ii,k)
+          ilist(k)=j
+          
+          xdf(k)=xxx(i)-xxx(j)
+          ydf(k)=yyy(i)-yyy(j)
+          zdf(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     square of distances
+        
+        do k=1,lentry(ii)
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     calculate metal forces and potential
+        
+        if(ntpmet.gt.0)then
+          
+          call metfrc(safe,i,lentry(ii),engacc,viracc)
+          
+          engmet=engmet+engacc
+          virmet=virmet+viracc
+          
+        endif
+        
+c     calculate short range force and potential terms
+        
+        if(ntpvdw.gt.0.and.mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,
+     x      rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme)then
+          
+          call ewald2(llsolva,lfree,lghost,i,lentry(ii),engacc,
+     x      viracc,drewd,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+          
+          if(mod(nstep,nstbgr).eq.0)then
+            
+            call rdf0(i,lentry(ii),rcut)
+            
+          endif
+          
+        endif
+        
+      enddo      
+      
+c     check metal interpolation is safe
+      
+      if(ntpmet.gt.0)then
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,142)
+        
+      endif
+      
+c     calculate corrections for intramolecular coulomb terms in
+c     Ewald sum
+      
+      if(lewald.or.lspme.or.lhke)then
+        
+        eps=epsq
+        if(loglnk)eps=eps*2.0d0
+        
+c     outer loop over atoms
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          do k=1,nexatm(ii)
+            
+            j=lexatm(ii,k)
+            jlist(k)=j
+            
+            xdf(k)=xxx(i)-xxx(j)
+            ydf(k)=yyy(i)-yyy(j)
+            zdf(k)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     periodic boundary condition
+          
+          call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+          
+c     calculate correction terms
+          
+          if(lhke)then
+            
+            call hkewald3(i,ii,engacc,viracc,eps)
+            
+          else
+            
+            call ewald3
+     x        (llsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+            
+          endif
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        enddo
+        
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+        
+        if(mod(nstep,nstbgr).eq.0)then
+          
+          numrdf=numrdf+1
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=engmet
+        buffer(6)=virmet
+        buffer(7)=vdw_fre
+        buffer(8)=cou_fre
+        buffer(9)=vdw_vir
+        buffer(10)=cou_vir
+        call gdsum(buffer(1),10,buffer(11))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        engmet=buffer(5)
+        virmet=buffer(6)
+        vdw_fre=buffer(7)
+        cou_fre=buffer(8)
+        vdw_vir=buffer(9)
+        cou_vir=buffer(10)
+        
+      endif
+      
+      return
+      end subroutine forces
+      
+      subroutine forces_neu
+     x  (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x  isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x  vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     modified  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,newlst,lchk,lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,i,fail,jneu,jj0,jj1,j
+      integer ibig,ia,ineu,isn,ik,nsolva,isolva
+      real(8) dlrpot,engcpe,engsrp,epsq,rcut,rvdw,vircpe
+      real(8) virsrp,engacc,viracc,anorm,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension fail(2)
+      
+      data fail/0,0/
+      
+c     allocate working arrays
+      
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      do i=1,2
+        if(fail(i).ne.0)call error(idnode,1820)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      
+c     initialise force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     initialise energy and virial accumulators
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     outer loop over neutral groups
+      
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        newlst=.true.
+        
+        isn=1
+        call neutlst
+     x    (newlst,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x    mod(nstep,nstbgr).eq.0)then
+          
+          call rdf0neu(ik,rcut)
+          
+        endif
+        
+      enddo
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,478)
+      endif
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     counter for rdf statistics outside loop structure
+      
+      if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x  mod(nstep,nstbgr).eq.0)numrdf=numrdf+1
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,stat=fail(2))
+      
+      return
+      end subroutine forces_neu
+      
+      subroutine multiple
+     x  (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x  mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x  isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x  rvdw,vircpe,virsrp,volm)
+c***************************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm
+c     reciprocal space calculated on long time steps.
+c     
+c     copyright daresbury laboratory
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3,4
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3,4]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3,4
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+
+      logical newplst,newlst,lgofr,lzeql,lgr,loglnk,lewald,lspme
+      logical lhke,newjob,lcshft,lsolva,lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt
+      integer mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,fail
+      integer numlsts,i,nstep0,nsolva,isolva,ii,k,j,ik
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,volm,stresp,engcpl,engacc,viracc,engac1
+      real(8) vircpl,eps,ann,engsr1,viracl,engsrl,virsrl,virac2,engcp1
+      real(8) vircp1,engacl,engac2,virsr1
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz,newjob
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      if(newlst)nstep0=nstep
+      newplst=(newlst).or.(mod(nstep-nstep0,multt).eq.0)
+      
+c     allocate working arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1840)
+        enddo
+        
+      endif
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lspme.or.lewald.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+      endif
+      
+      newjob=.false.
+      
+c     divide neighbour list into primary and secondary neighbours
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call primlst(idnode,mxnode,natms,imcon,rprim)
+        
+      endif
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     zero force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS******************
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+        
+c     zero accumulators
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        llsolva=lsolva
+        if(lsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate fourier contribution to secondary coulombic forces
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(lewald)then
+            
+            call ewald1
+     x        (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x        kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+            
+c     hautman-klein-ewald method
+            
+          elseif(lhke)then
+            
+            call hkewald1
+     x        (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x        engac1,viracc,alpha,epsq)
+            
+c     real space terms of hk-ewald
+            
+            call hkewald2
+     x        (idnode,mxnode,nhko,nlatt,imcon,natms,engac2,
+     x        virac2,drewd,rcut,epsq)
+            
+            engac1=engac1+engac2
+            viracc=viracc+virac2
+            
+          elseif(lspme)then
+            
+c     smoothed particle mesh ewald
+            
+            call ewald_spme
+     x        (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x        engac1,viracc,alpha,volm,epsq)
+            
+          endif
+          
+          engcpl=engcpl+engac1
+          vircpl=vircpl+viracc
+          
+c     calculate corrections for intramolecular coulomb terms in 
+c     Ewald sum
+c     note: if using link cells - have double counted excluded 
+c     interactions use temporary adjustment to relative dielectric
+c     constant
+          
+          eps=epsq
+          if(loglnk)eps=epsq*2.0d0
+          
+c     calculate self interaction corrections for fourier contributions
+          
+          ii=0
+          
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic distances
+            
+            do k=1,nexatm(ii)
+              
+              j=lexatm(ii,k)
+              jlist(k)=j
+              
+              xdf(k)=xxx(i)-xxx(j)
+              ydf(k)=yyy(i)-yyy(j)
+              zdf(k)=zzz(i)-zzz(j)
+              
+            enddo
+            
+c     periodic boundary condition
+            
+            call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+            
+c     calculate correction terms
+            
+            if(lhke)then
+              
+              call hkewald3(i,ii,engacc,viracc,eps)
+              
+            else
+              
+              call ewald3
+     x          (lsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+              
+            endif
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          enddo
+          
+        endif
+        
+c     calculate pair contributions to secondary neighbour forces
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of distance
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+          
+          if(lewald.or.lspme)then
+            
+            call ewald2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,drewd,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.2)then
+            
+            call coul2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call coul4
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     calculate pair force contributions
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        ik=0
+        
+        do k=1,lentry(ii)
+          
+          j=-list(ii,k)
+          
+          if(j.gt.0)then
+            
+            ik=ik+1
+            ilist(ik)=j
+            xdf(ik)=xxx(i)-xxx(j)
+            ydf(ik)=yyy(i)-yyy(j)
+            zdf(ik)=zzz(i)-zzz(j)
+            
+          endif
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+        
+c     square of distance
+        
+        do k=1,ik
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     accumulate radial distribution functions
+        
+        if(lgr)call rdf0(i,ik,rcut)
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(newplst.or.
+     x      (mod(nstep-nstep0,multt).le.1))then
+            
+            if(lhke)then
+              
+              call hkewald4(i,ik,engacc,viracc,engacl,viracl,rcut,epsq)
+              
+            else
+              
+              call ewald4
+     x          (llsolva,lfree,lghost,i,ik,engacc,viracc,engacl,viracl,
+     x          drewd,rcut,epsq)
+              
+            endif
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            engcpl=engcpl+engacl
+            vircpl=vircpl+viracl
+            
+          else
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          endif
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+      enddo
+      
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresp(i)+stresl(i)*ann
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+      return
+      end subroutine multiple
+      
+      subroutine multiple_neu
+     x  (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x  keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rprim,rcut,rvdw,alpha,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     multiple timestep option
+c     
+c     parallel replicated data version
+c     
+c     fpx,fpy,fpz : forces from electrostatics fron rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory april 1994
+c     author  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     = 10,11 ----- reaction field                    : coul3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=7
+
+      logical lgofr,lzeql,newlst,newplst,lgr,lchk,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,fail,i,numlsts,jneu,jj0,j
+      integer jj1,ineu,ia,isn,ibig,ik,nstep0,nsolva,isolva
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rprim,rcut,rvdw,vircpe
+      real(8) virsrp,engcpl,vircpl,engsrl,virsrl,anorm,ann,stresp
+      real(8) engacc,viracc,engsr1,virsr1,engcp1,vircp1,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension fail(nnn),stresp(9)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      if(newjob)then
+        
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(3))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(4))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(5))
+          
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(6))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(7))
+          endif
+          
+        endif
+        newjob=.false.
+        
+      endif
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1850)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+
+c     error if ewald sum requested
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     create list of primary and secondary neighbours
+      
+      if(newlst)nstep0=nstep
+      newplst=(mod(nstep-nstep0,multt).eq.0)
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call prneulst(newlst,imcon,idnode,mxnode,nneut,rprim)
+        
+      endif
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     zero force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress arrays
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+      
+c     zero accumulators for secondary neighbour energies and virial
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        
+c     initialise solvation and excitation  arrays
+
+        if(lsolva)then
+          
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     outer loop over neutral groups
+        
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+c     calculate interatomic distances
+          
+          isn=-1
+          call neutlst
+     x      (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x      txx,tyy,tzz,uxx,uyy,uzz)
+          
+c     trap possible array bound exception 
+          
+          ibig=max(ibig,ik)
+          if(ik.gt.mxxdf)ik=0
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1.and.(rvdw.gt.rprim-delr))then
+            
+            call srfrceneu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.2)then
+            
+            call coul2neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,250)
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          else
+            
+            call error(idnode,250)
+            
+          endif
+          
+c     accumulate radial distribution functions out to rcut
+          
+          if(lgr)then
+            call rdf0neu(ik,rcut)
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+          
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+      ia=0
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        isn=1        
+        call neutlst
+     x    (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions out to rcut
+        
+        if(lgr)then
+          call rdf0neu(ik,rcut)
+        endif
+        
+      enddo
+      
+c     ******************END OF PRIMARY NEIGHBOUR PROCESSING*************
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,479)
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresl(i)*ann+stresp(i)
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,uxx,uyy,uzz,stat=fail(1))
+      
+      return
+      end subroutine multiple_neu
+      
+      subroutine multiple_nsq
+     x  (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rcut,rprim,rvdw,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm 
+c     to be used with all-pairs option
+c     
+c     flx,fly,flz : forces from electrostatics from r > rcut
+c     fpx,fpy,fpz : forces from electrostatics from rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     Ewald sum --- not used
+c     = 4,5  ------ Distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     truncated and shifted coulombic -- not used
+c     reaction field - not used
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+      logical newplst,newlst,lgofr,lzeql,lgr,lnsq,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nstep,nstbgr
+      integer nsteql,numrdf,fail,nstep0,ii,ik,k,numlsts,nsolva
+      integer isolva,i,j
+      real(8) delr,dlrpot,engcpe,engsrp,engcp3,epsq,rcut
+      real(8) rprim,rvdw,vircpe,virsrp,vircp3,rcut1,engcp2,vircp2
+      real(8) engsr2,virsr2,stresp,engacc,viracc
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engsr2,virsr2,engcp2,vircp2,nstep0,numlsts,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+
+      data numlsts/-1/
+      data newjob/.true./
+      
+c     allocate work arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1860)
+        enddo
+        newjob=.false.
+        
+      endif
+      
+      if(lnsq)then
+        
+        llsolva=.false.
+        if(lsolva)then
+          llsolva=(mod(nstep-nsolva,isolva).eq.0)
+        endif
+        
+c     divide neighbour list into primary and secondary neighbours
+        
+        if(newplst)then        
+          
+          numlsts=numlsts+1
+          call primlst(idnode,mxnode,natms,imcon,rprim)
+          
+        endif
+        
+c     flag for accumulating rdfs
+        
+        lgr=(lgofr.and.(.not.lzeql.or.(nstep-nsteql.gt.0)))
+        lgr=(lgr.and.newplst.and.(mod(numlsts,nstbgr).eq.0))
+        
+c     set extended cutoff for electrostatics - secondary shell
+        
+        rcut1=rcut+delr
+        
+        if(newlst)nstep0=nstep
+        newplst=(newlst.or.mod(nstep-nstep0,multt).eq.0)
+        
+c     ********************PROCESS TERTIARY NEIGHBOURS*********************
+        
+        if(newplst)then
+          
+          call coul_nsq
+     x      (lsolva,lfree,lghost,idnode,mxnode,natms,imcon,epsq,rcut,
+     x      engcp3,vircp3)
+          
+        endif
+        
+c     ****************END OF TERTIARY NEIGHBOUR PROCESSING**************
+        
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+        if(newplst)then
+          
+c     zero accumulators for secondary neighbour energies and virial
+          
+          engcp2=0.d0
+          vircp2=0.d0
+          engsr2=0.d0
+          virsr2=0.d0
+          
+c     zero secondary forces
+          
+          do i=1,natms
+            
+            fxx(i)=0.d0
+            fyy(i)=0.d0
+            fzz(i)=0.d0
+            
+          enddo
+          
+c     zero solvation and excitation arrays
+        
+          if(lsolva)then
+            
+            vdw_sol(:)=0.d0
+            cou_sol(:)=0.d0
+            
+            if(lghost)then
+              
+              vdw_exc(:)=0.d0
+              cou_exc(:)=0.d0
+              
+            endif
+            
+          endif
+
+c     zero stress tensor
+          
+          do i=1,9
+            stress(i)=0.d0
+          enddo
+          
+          ii=0
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic vectors
+            
+            ik=0
+            do k=1,lentry(ii)
+              
+              j=list(ii,k)
+              
+              if(j.gt.0)then
+                
+                ik=ik+1
+                ilist(ik)=j
+                xdf(ik)=xxx(i)-xxx(j)
+                ydf(ik)=yyy(i)-yyy(j)
+                zdf(ik)=zzz(i)-zzz(j)
+                
+              endif
+              
+            enddo
+            
+c     periodic boundary condition only for interactions > rprim
+            
+            call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+            
+c     square of interatomic distances
+            
+            do k=1,ik
+              
+              rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+              
+            enddo
+            
+c     short range forces for secondary shell
+            
+            if((mod(keyfce,2).eq.1).and.(rvdw.gt.rprim-delr))then
+              
+              call srfrce
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+              
+              engsr2=engsr2+engacc
+              virsr2=virsr2+viracc
+              
+            endif
+            
+c     calculate coulombic force and potential terms
+            
+            if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+              
+              call error(idnode,424)
+              
+            elseif(keyfce/2.eq.2)then
+              
+c     distance dependent dielectric
+              
+              call coul2
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.3)then
+              
+c     coulombic potential
+              
+              call coul0
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.4)then
+              
+c     truncated shifted coulombic potential
+              
+              call error(idnode,424)
+              
+            endif
+            
+c     accumulate radial distribution functions : out to rcut
+            
+            if(lgr)call rdf0(i,ik,rcut)
+            
+          enddo
+          
+c     store secondary forces and stress tensor
+          
+          do i=1,natms
+            
+            fpx(i)=fxx(i)
+            fpy(i)=fyy(i)
+            fpz(i)=fzz(i)
+            
+          enddo
+          
+          do i=1,9
+            stresp(i)=stress(i)
+          enddo
+          
+c     store solvation and excitation arrays
+          
+          if(lsolva)then
+            
+            vdw_sol_put(:)=vdw_sol(:)
+            cou_sol_put(:)=cou_sol(:)
+            
+            if(lghost)then
+              
+              vdw_exc_put(:)=vdw_exc(:)
+              cou_exc_put(:)=cou_exc(:)
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+        
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+        
+c     zero accumulators for total energies and virials
+        
+        engcpe=0.d0
+        engsrp=0.d0
+        vircpe=0.d0
+        virsrp=0.d0
+        
+c     zero primary forces
+        
+        do i=1,natms
+          
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+c     zero stress tensor
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+c     zero solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate primary pair force contributions
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=-list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of interatomic distances
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions : out to rcut
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrp=engsrp+engacc
+            virsrp=virsrp+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+            
+            call error(idnode,424)
+            
+          elseif(keyfce/2.eq.2)then
+            
+c     distance dependent dielectric
+            
+            call coul2
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+c     coulombic potential
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,424)
+            
+          endif
+          
+        enddo
+        
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+        
+c     counter for rdf statistics outside loop structure
+        
+        if(lgr)numrdf=numrdf+1
+        
+c     add in secondary and tertiary neighbour contributions to 
+c     force, energy etc
+        
+        do i=1,natms
+          
+          fxx(i)=fxx(i)+fpx(i)+flx(i)
+          fyy(i)=fyy(i)+fpy(i)+fly(i)
+          fzz(i)=fzz(i)+fpz(i)+flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stress(i)=stress(i)+stresp(i)
+        enddo
+        
+        engsrp=engsrp+engsr2
+        virsrp=virsrp+virsr2
+        
+        engcpe=engcpe+engcp2+engcp3 
+        vircpe=vircpe+vircp2+vircp3
+        
+c     calculate solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=vdw_sol(:)+vdw_sol_put(:)+vdw_sol_lng(:)
+          cou_sol(:)=cou_sol(:)+cou_sol_put(:)+cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc(:)=vdw_exc(:)+vdw_exc_put(:)+vdw_exc_lng(:)
+            cou_exc(:)=cou_exc(:)+cou_exc_put(:)+cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+c     sum up contributions to short range and coulombic potential
+        
+        if(mxnode.gt.1)then 
+          
+          buffer(1)=engsrp
+          buffer(2)=virsrp
+          buffer(3)=engcpe
+          buffer(4)=vircpe
+          buffer(5)=vdw_fre
+          buffer(6)=cou_fre
+          buffer(7)=vdw_vir
+          buffer(8)=cou_vir
+          call gdsum(buffer(1),8,buffer(9))
+          engsrp=buffer(1)
+          virsrp=buffer(2)
+          engcpe=buffer(3)
+          vircpe=buffer(4)
+          vdw_fre=buffer(5)
+          cou_fre=buffer(6)
+          vdw_vir=buffer(7)
+          cou_vir=buffer(8)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine multiple_nsq
+      
+      subroutine neutlst
+     x  (newlst,lchk,isn,imcon,idnode,ineu,ia,ll,
+     x  txx,tyy,tzz,uxx,uyy,uzz)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to create pair lists for neutral group
+c     implementations.
+c     loops over group ineu
+c     
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester march 1994
+c     
+c     isn = -1 => secondary neighbours
+c     isn =  1 => primary neighbours - must contain excld interactions
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lchk,lexc
+      integer isn,imcon,idnode,ineu,ia,ll,i,jj,jj0,jj1
+      integer fail,ibig,keyexc,lenia,j,jneu,in0,in1
+      real(8) txx,tyy,tzz,uxx,uyy,uzz
+      
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1830)
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     set cutoff radius
+        
+        ll=0
+        
+c     number of excludes found
+        
+        if(isn.lt.0)then
+          keyexc=nexatm(ia)+2
+        else
+          keyexc=1
+        endif
+        
+c     do centre - centre distances
+        
+        lenia=lentry(ia)
+        
+        do j=1,lenia
+          
+          jneu=abs(list(ia,j))
+          xxt(j)=uxx(ineu)-uxx(jneu)
+          yyt(j)=uyy(ineu)-uyy(jneu)
+          zzt(j)=uzz(ineu)-uzz(jneu)
+          
+        enddo
+        
+        call images(imcon,0,1,lenia,cell,xxt,yyt,zzt)
+        
+c     working intragroup vectors of central group 
+c     - for periodic boundaries
+        
+        in0=neulst(ineu)
+        in1=neulst(ineu+1)-1
+        
+c     loop over neutral groups sites of a  
+        
+        
+c     loop over groups in list
+        
+        do jj=1,lentry(ia)
+          
+          jneu=list(ia,jj)*isn
+          
+          if(jneu.gt.0)then
+            
+            do i=in0,in1
+              
+              jj0=neulst(jneu)
+              jj1=neulst(jneu+1)-1
+              
+              if(ineu.eq.jneu)jj0=i+1
+              
+c     loop over jneu sites
+              
+              do j=jj0,jj1
+                
+c     reject atoms in excluded pair list
+                
+                lexc=.false.     
+                
+                if(keyexc.lt.nexatm(ia))then
+                  
+                  if(lexatm(ia,keyexc).eq.i)then
+                    if(lexatm(ia,keyexc+1).eq.j)then
+                      lexc=.true.
+                      keyexc=keyexc+2
+                    endif
+                  endif   
+                  
+                endif
+                
+c     reject frozen atom pairs
+                
+                if(lstfrz(i).ne.0)then
+                  if(lstfrz(j).ne.0)lexc=.true.
+                endif
+                
+                if(.not.lexc)then
+                  
+                  ll=ll+1
+                  if(ll.le.mxxdf)then
+                    
+                    xdf(ll)=txx(i)+xxt(jj)-txx(j)
+                    ydf(ll)=tyy(i)+yyt(jj)-tyy(j)
+                    zdf(ll)=tzz(i)+zzt(jj)-tzz(j)
+                    rsqdf(ll)=xdf(ll)**2+ydf(ll)**2+zdf(ll)**2
+                    ilist(ll)=i
+                    jlist(ll)=j
+                    
+                  else
+                    
+                    lchk=.false.
+                    ibig=max(ibig,ll)
+                    
+                  endif
+                  
+                endif
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine neutlst
+      
+      end module forces_module
+      
diff -urN dl_class_1.9.orig/srcmod/four_body_module.f dl_class_1.9/srcmod/four_body_module.f
--- dl_class_1.9.orig/srcmod/four_body_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/four_body_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,979 @@
+      module four_body_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining four-body potential arrays
+c     copyright - daresbury laboratory
+c     author  - w. smith  sep 2003
+c     adapted - w. smith  aug 2008 : solvation, free energy, excitation 
+c     adapted - w. smith  jan 2011 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      logical, allocatable :: filter(:)
+      real(8), allocatable :: prmfbp(:,:),rcut4b(:)
+      integer, allocatable :: lstfbp(:),ltpfbp(:),latfbp(:)
+
+      save prmfbp,rcut4b,lstfbp,ltpfbp,latfbp,filter
+
+      contains
+      
+      subroutine alloc_fbp_arrays(idnode)
+
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(6)
+
+      do i=1,6
+        fail(i)=0
+      enddo
+
+      allocate (prmfbp(mxfbp,mxpfbp),stat=fail(1))
+      allocate (rcut4b(mxfbp),stat=fail(2))
+      allocate (lstfbp(mxfbp),stat=fail(3))
+      allocate (ltpfbp(mxfbp),stat=fail(4))
+      allocate (latfbp(mxatms),stat=fail(5))
+      allocate (filter(mxsite),stat=fail(6))
+
+      do i=1,6
+        if(fail(i).gt.0)call error(idnode,1140)
+      enddo
+
+      end subroutine alloc_fbp_arrays
+
+      subroutine define_four_body
+     x  (safe,lunits,lmols,idnode,ntpfbp,ntpatm,
+     x  rcutfb,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining four body potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom0,atom1,atom2,atom3
+      character*1 message(80)
+      integer idnode,ntpfbp,ntpatm,ifbp,itpfbp,keypot,katm0
+      integer i,katm1,katm2,katm3,jtpatm,ka1,ka2,ka3,keyfbp,kfbp
+      integer j,fail,idum
+      real(8) rcutfb,engunit
+      real(8), allocatable :: parpot(:)
+
+      data fail/0/
+
+      allocate (parpot(mxpfbp),stat=fail)
+      if(fail.ne.0)call error(idnode,1150)
+
+      ntpfbp=intstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified four ',
+     x    'body potentials',i10)") ntpfbp
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ','atom 3  ',
+     x    'atom 4  ',3x,' key',30x,'parameters'/,/)")
+        
+      endif      
+      if(ntpfbp.gt.mxfbp) call error(idnode,89)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do i=1,mxsite
+        filter(i)=.false.
+      enddo
+
+      do ifbp=1,mxfbp
+        lstfbp(ifbp)=0
+      enddo
+      
+      do ifbp=1,mxfbp,mx3fbp
+        lstfbp(ifbp)=-1
+      enddo
+      
+      rcutfb=0.d0
+      
+      do itpfbp=1,ntpfbp
+        
+        do i=1,mxpfbp
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+c     Note the order!! atom0 is the central atom
+
+        call copystring(record,message,80)
+        call getword(atom0,record,8,lenrec)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call getword(atom3,record,8,lenrec)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+
+        if(keyword(1:4).eq.'harm') then
+          keypot=1
+        elseif(keyword(1:4).eq.'hcos') then
+          keypot=2
+        elseif(keyword(1:4).eq.'plan') then
+          keypot=3
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,443)
+        endif
+
+        parpot(1)=dblstr(record,lenrec,idum)
+        parpot(2)=dblstr(record,lenrec,idum)
+        parpot(3)=dblstr(record,lenrec,idum)
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(16x,4a8,4x,a4,1x,1p,9e13.5)") 
+     x    atom0,atom1,atom2,atom3,keyword(1:4),(parpot(j),j=1,mxpfbp)
+        
+        katm0=0
+        katm1=0
+        katm2=0
+        katm3=0
+        
+        do jtpatm=1,ntpatm
+          
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          if(atom3.eq.unqatm(jtpatm))katm3=jtpatm
+          
+        enddo
+        
+        if(katm0.eq.0.or.katm1.eq.0.or.katm2.eq.0.or.
+     x    katm3.eq.0) call error(idnode,91)
+        
+        filter(katm0)=.true.
+        filter(katm1)=.true.
+        filter(katm2)=.true.
+        filter(katm3)=.true.
+        
+        ka1=max(katm1,katm2,katm3)
+        ka3=min(katm1,katm2,katm3)
+        ka2=katm1+katm2+katm3-ka1-ka3
+        keyfbp=ka3+(ka2*(ka2-1))/2+(ka1*(ka1**2-1))/6+
+     x    (katm0-1)*mx3fbp
+
+        if(keyfbp.gt.mxfbp) call error(idnode,101)
+
+c     convert parameters to internal units
+        
+        parpot(1)=parpot(1)*engunit
+        parpot(2)=parpot(2)*(pi/180.d0)
+
+        if(keypot.eq.2)then
+
+          parpot(2)=cos(parpot(2))
+
+        endif
+
+        if(lstfbp(keyfbp).gt.0) call error(idnode,19)
+        lstfbp(keyfbp)=itpfbp
+        ltpfbp(itpfbp)=keypot
+        kfbp=mx3fbp*((keyfbp-1)/mx3fbp)+1
+        if(lstfbp(kfbp).lt.0)lstfbp(kfbp)=0
+
+c     calculate max four body cutoff
+        
+        rcutfb=max(rcutfb,parpot(3))
+        rcut4b(itpfbp)=parpot(3)
+
+c     store four body potential parameters
+        
+        do i=1,mxpfbp
+          prmfbp(itpfbp,i)=parpot(i)
+        enddo
+
+      enddo
+
+      if(rcutfb.lt.1.d-6)call error(idnode,453)
+      
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_four_body
+
+      subroutine fbpfrc
+     x  (lsolva,lfree,lexcite,idnode,mxnode,natms,imcon,rcutfb,
+     x  engfbp,virfbp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating four body inversion forces
+c     arising from the inversion angle between three atoms around a
+c     nominated central atom
+c     
+c     Note: the subroutine converts coordinates to reduced units
+c     to avoid a call to images.f. The link cell algorithm used
+c     here necessitates a parallelepiped cell geometry
+c     
+c     copyright - daresbury laboratory 1996
+c     author   - w.smith july 1996
+c     adapted   - w.smith aug 2008 solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect,lskip
+      logical idrive,jdrive,kdrive,ldrive
+      integer idnode,mxnode,natms,imcon,nix,niy,niz
+      integer i,j,k,nbx,nby,nbz,ncells,ix,iy,iz,icell,jx,jy
+      integer jz,jj,kk,ia,ib,ifbp,jfbp,kfbp,jklbd,kkfbp,ktyp,ii
+      integer ic,ll,id,lfbp,l,limit,jcell,kkk
+      real(8) rcutfb,engfbp,virfbp,vbn,vcn,pterm,xm,ym,zm
+      real(8) strs,cprp,det,xdc,ydc,zdc,sxx,syy,szz,sxab,strs_loc
+      real(8) syab,szab,xab,yab,zab,rab2,sxac,syac,szac,xac,yac
+      real(8) zac,rac2,sxad,syad,szad,xad,yad,zad,rad2,rrab,rrac
+      real(8) rrad,rbc,rcd,rdb,ubx,uby,ubz,ubn,rub,vbx,vby,vbz
+      real(8) rvb,wwb,ucx,ucy,ucz,ucn,ruc,vcx,vcy,vcz,rvc,wwc
+      real(8) udx,udy,udz,udn,rud,vdx,vdy,vdz,vdn,rvd,wwd,cosb
+      real(8) cosc,cosd,thb,thc,thd,gamb,gamc,gamd,rubc,rubd
+      real(8) rucd,rucb,rudb,rudc,rvbc,rvbd,rvcd,rvcb,rvdb,rvdc
+      real(8) fax,fay,faz,fbx,fby,fbz,fcx,fcy,fcz,fdx,fdy,fdz
+      dimension cprp(10),strs(6),nix(27),niy(27),niz(27),strs_loc(6)
+      
+      data nix/ 0,-1,-1,-1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 1,
+     x  1, 1, 1, 0, 0, 1,-1, 1, 0,-1, 1, 0,-1/
+      data niy/ 0, 0,-1, 1, 1, 0, 0, 0,-1,-1,-1, 1, 1, 1,
+     x  0, 1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1/
+      data niz/ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     x  0, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1/
+      
+      lskip=(lfree.or.lexcite)
+      
+c     flag for undefined potentials
+      
+      safe=.true.
+      
+c     initialise accumulators
+      
+      engfbp=0.d0
+      virfbp=0.d0
+      fbp_fre=0.d0
+      fbp_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+      if(lsolva)then
+        
+        lcomp(9)=.true.
+        en4_sol(:)=0.d0
+        if(lexcite)en4_exc(:)=0.d0
+        
+      endif
+      
+c     create mock cell vectors for non-periodic system
+      
+      if(imcon.eq.0) then
+        
+        xm=0.d0
+        ym=0.d0
+        zm=0.d0
+        do i=1,natms
+          xm=max(xm,abs(xxx(i)))
+          ym=max(ym,abs(yyy(i)))
+          zm=max(zm,abs(zzz(i)))
+        enddo
+        
+        cell(1)=2.d0*xm+rcutfb
+        cell(2)=0.d0
+        cell(3)=0.d0
+        cell(4)=0.d0
+        cell(5)=2.d0*ym+rcutfb
+        cell(6)=0.d0
+        cell(7)=0.d0
+        cell(8)=0.d0
+        cell(9)=2.d0*zm+rcutfb
+      
+      endif
+      
+c     check for appropriate boundary conditions
+      
+      if(imcon.gt.3)call error(idnode,79)
+      call invert(cell,rcell,det)
+      call dcell(cell,cprp)
+      
+c     calculate link cell numbers
+      
+      nbx=int(cprp(7)/(rcutfb+1.d-6))
+      nby=int(cprp(8)/(rcutfb+1.d-6))
+      nbz=int(cprp(9)/(rcutfb+1.d-6))
+      ncells=nbx*nby*nbz
+      if(ncells.gt.mxcell) then
+        
+        if(idnode.eq.0) write(nrite,'(a,i6)')
+     x    'number of required link cells in routine fbpfrc is ',ncells
+        write(nrite,'(a,i6)')
+     x    'number of default link cells in routine fbpfrc is ',mxcell
+        call error(idnode,87)
+        
+      endif
+      
+c     transform atomic coordinates and construct link cells
+      
+      do l=1,ncells
+        
+        lct(l)=0
+        lst(l)=0
+        
+      enddo
+      
+      xdc=dble(nbx)
+      ydc=dble(nby)
+      zdc=dble(nbz)
+      
+      do i=1,natms
+        
+        if(filter(ltype(i)))then
+          
+          sxx=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          syy=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          szz=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+          xxx(i)=sxx
+          yyy(i)=syy
+          zzz(i)=szz
+          
+          ix=min(int(xdc*(sxx+0.5d0)),nbx-1)
+          iy=min(int(ydc*(syy+0.5d0)),nby-1)
+          iz=min(int(zdc*(szz+0.5d0)),nbz-1)
+          k=1+ix+nbx*(iy+nby*iz)
+          lst(k)=lst(k)+1
+          link(i)=lct(k)
+          lct(k)=i
+          
+        endif
+        
+      enddo
+      
+c     loop over central atoms of inversion
+      
+      ix=0
+      iy=1
+      iz=1
+      do icell=1,ncells
+        
+        ix=ix+1
+        if(ix.gt.nbx)then
+          ix=1
+          iy=iy+1
+          if(iy.gt.nby)then
+            iy=1
+            iz=iz+1
+          endif
+        endif
+        
+        k=0
+        do kk=1,27
+          
+          jx=ix+nix(kk)
+          jy=iy+niy(kk)
+          jz=iz+niz(kk)
+          
+          if(jx.gt.nbx)jx=1
+          if(jy.gt.nby)jy=1
+          if(jz.gt.nbz)jz=1
+          if(jx.lt.1)jx=jx+nbx
+          if(jy.lt.1)jy=jy+nby
+          if(jz.lt.1)jz=jz+nbz
+          
+          jcell=jx+nbx*(jy-1+nby*(jz-1))
+          j=lct(jcell)
+          
+          do ii=1,lst(jcell)
+            
+            k=k+1
+            latfbp(k)=j
+            j=link(j)
+            
+          enddo
+          
+        enddo
+        
+        limit=k
+        
+        do ii=1,lst(icell)
+          
+          ia=latfbp(ii)
+          if(lmetadyn)idrive=driven(ltype(ia))
+          ifbp=mx3fbp*(ltype(ia)-1)
+          if(mod(ia,mxnode).eq.idnode.and.lstfbp(ifbp+1).ge.0)then
+            
+          do jj=1,limit-2
+          
+          ib=latfbp(jj)
+          if(lmetadyn)jdrive=driven(ltype(ib))
+          
+          do kk=jj+1,limit-1
+          
+          ic=latfbp(kk)
+          if(lmetadyn)kdrive=driven(ltype(ic))
+                
+          do ll=kk+1,limit
+          
+          id=latfbp(ll)
+          if(lmetadyn)ldrive=driven(ltype(id))
+                  
+          if(lskip)then
+            
+            if((atm_fre(ia).eq.1.or.atm_fre(ib).eq.1.or.
+     x        atm_fre(ic).eq.1.or.atm_fre(id).eq.1).and.
+     x        (atm_fre(ia).eq.2.or.atm_fre(ib).eq.2.or.
+     x        atm_fre(ic).eq.2.or.atm_fre(id).eq.2))cycle
+            
+          endif
+          
+          jfbp=max(ltype(ib),ltype(ic),ltype(id))
+          lfbp=min(ltype(ib),ltype(ic),ltype(id))
+          kfbp=ltype(ib)+ltype(ic)+ltype(id)-jfbp-lfbp
+          jklbd=ifbp+lfbp+(kfbp*(kfbp-1))/2+(jfbp*(jfbp**2-1))/6
+          kkfbp=lstfbp(jklbd)
+          if(kkfbp.gt.0)then
+                    
+          sxab=xxx(ib)-xxx(ia)
+          sxab=sxab-nint(sxab)
+          syab=yyy(ib)-yyy(ia)
+          syab=syab-nint(syab)
+          szab=zzz(ib)-zzz(ia)
+          szab=szab-nint(szab)
+          
+          xab=cell(1)*sxab+cell(4)*syab+cell(7)*szab
+          if(abs(xab).lt.rcutfb)then
+          
+          yab=cell(2)*sxab+cell(5)*syab+cell(8)*szab
+          if(abs(yab).lt.rcutfb)then
+          
+          zab=cell(3)*sxab+cell(6)*syab+cell(9)*szab
+          if(abs(zab).lt.rcutfb)then
+          
+          rab2=xab*xab+yab*yab+zab*zab
+          
+          sxac=xxx(ic)-xxx(ia)
+          sxac=sxac-nint(sxac)
+          syac=yyy(ic)-yyy(ia)
+          syac=syac-nint(syac)
+          szac=zzz(ic)-zzz(ia)
+          szac=szac-nint(szac)
+          
+          xac=cell(1)*sxac+cell(4)*syac+cell(7)*szac
+          if(abs(xac).lt.rcutfb)then
+                            
+          yac=cell(2)*sxac+cell(5)*syac+cell(8)*szac
+          if(abs(yac).lt.rcutfb)then
+          
+          zac=cell(3)*sxac+cell(6)*syac+cell(9)*szac
+          if(abs(zac).lt.rcutfb)then
+          
+          rac2=xac*xac+yac*yac+zac*zac
+          
+          sxad=xxx(id)-xxx(ia)
+          sxad=sxad-nint(sxad)
+          syad=yyy(id)-yyy(ia)
+          syad=syad-nint(syad)
+          szad=zzz(id)-zzz(ia)
+          szad=szad-nint(szad)
+          
+          xad=cell(1)*sxad+cell(4)*syad+cell(7)*szad
+          if(abs(xad).lt.rcutfb)then
+          
+          yad=cell(2)*sxad+cell(5)*syad+cell(8)*szad
+          if(abs(yad).lt.rcutfb)then
+          
+          zad=cell(3)*sxad+cell(6)*syad+cell(9)*szad
+          if(abs(zad).lt.rcutfb)then
+          
+          rad2=xad*xad+yad*yad+zad*zad
+          
+          if(rcut4b(kkfbp)**2.ge.max(rab2,rac2,rad2))then
+          
+          rrab=1.d0/sqrt(rab2)
+          rrac=1.d0/sqrt(rac2)
+          rrad=1.d0/sqrt(rad2)
+          
+          rbc=xab*xac+yab*yac+zab*zac
+          rcd=xac*xad+yac*yad+zac*zad
+          rdb=xad*xab+yad*yab+zad*zab
+          
+c     calculate bond-angle-plane vectors
+          
+          ubx=xac*rrac+xad*rrad
+          uby=yac*rrac+yad*rrad
+          ubz=zac*rrac+zad*rrad
+          ubn=1.d0/sqrt(ubx**2+uby**2+ubz**2)
+          ubx=ubn*ubx
+          uby=ubn*uby
+          ubz=ubn*ubz
+          rub=xab*ubx+yab*uby+zab*ubz
+          
+          vbx=xac*rrac-xad*rrad
+          vby=yac*rrac-yad*rrad
+          vbz=zac*rrac-zad*rrad
+          vbn=1.d0/sqrt(vbx**2+vby**2+vbz**2)
+          vbx=vbn*vbx
+          vby=vbn*vby
+          vbz=vbn*vbz
+          rvb=xab*vbx+yab*vby+zab*vbz
+          wwb=sqrt(rub**2+rvb**2)
+          
+          ucx=xad*rrad+xab*rrab
+          ucy=yad*rrad+yab*rrab
+          ucz=zad*rrad+zab*rrab
+          ucn=1.d0/sqrt(ucx**2+ucy**2+ucz**2)
+          ucx=ucn*ucx
+          ucy=ucn*ucy
+          ucz=ucn*ucz
+          ruc=xac*ucx+yac*ucy+zac*ucz
+          
+          vcx=xad*rrad-xab*rrab
+          vcy=yad*rrad-yab*rrab
+          vcz=zad*rrad-zab*rrab
+          vcn=1.d0/sqrt(vcx**2+vcy**2+vcz**2)
+          vcx=vcn*vcx
+          vcy=vcn*vcy
+          vcz=vcn*vcz
+          rvc=xac*vcx+yac*vcy+zac*vcz
+          wwc=sqrt(ruc**2+rvc**2)
+          
+          udx=xab*rrab+xac*rrac
+          udy=yab*rrab+yac*rrac
+          udz=zab*rrab+zac*rrac
+          udn=1.d0/sqrt(udx**2+udy**2+udz**2)
+          udx=udn*udx
+          udy=udn*udy
+          udz=udn*udz
+          rud=xad*udx+yad*udy+zad*udz
+          
+          vdx=xab*rrab-xac*rrac
+          vdy=yab*rrab-yac*rrac
+          vdz=zab*rrab-zac*rrac
+          vdn=1.d0/sqrt(vdx**2+vdy**2+vdz**2)
+          vdx=vdn*vdx
+          vdy=vdn*vdy
+          vdz=vdn*vdz
+          rvd=xad*vdx+yad*vdy+zad*vdz
+          wwd=sqrt(rud**2+rvd**2)
+          
+c     calculate inversion angle cosines
+          
+          cosb=wwb*rrab
+          cosc=wwc*rrac
+          cosd=wwd*rrad
+          if(abs(cosb).gt.1.d0)cosb=sign(1.d0,cosb)
+          if(abs(cosc).gt.1.d0)cosc=sign(1.d0,cosc)
+          if(abs(cosd).gt.1.d0)cosd=sign(1.d0,cosd)
+          
+c     select potential energy function type
+          
+          ktyp=ltpfbp(kkfbp)
+          
+c     calculate potential energy and scalar force term
+          
+          if(ktyp.eq.1)then
+            
+c     key=1 for harmonic potential
+            
+            thb=acos(cosb)
+            thc=acos(cosc)
+            thd=acos(cosd)
+            
+            pterm=0.5d0*prmfbp(kkfbp,1)*
+     x        ((thb-prmfbp(kkfbp,2))**2+
+     x        (thc-prmfbp(kkfbp,2))**2+
+     x        (thd-prmfbp(kkfbp,2))**2)/3.d0
+            
+            gamb=0.d0
+            if(abs(thb).gt.1.d-12)gamb=prmfbp(kkfbp,1)*
+     x        (thb-prmfbp(kkfbp,2))/(3.d0*sin(thb))
+            gamc=0.d0
+            if(abs(thc).gt.1.d-12)gamc=prmfbp(kkfbp,1)*
+     x        (thc-prmfbp(kkfbp,2))/(3.d0*sin(thc))
+            gamd=0.d0
+            if(abs(thd).gt.1.d-12)gamd=prmfbp(kkfbp,1)*
+     x        (thd-prmfbp(kkfbp,2))/(3.d0*sin(thd))
+            
+          else if(ktyp.eq.2)then
+            
+c     key=2 for harmonic cosine inversion potential
+            
+            pterm=0.5d0*prmfbp(kkfbp,1)*
+     x        ((cosb-prmfbp(kkfbp,2))**2+
+     x        (cosc-prmfbp(kkfbp,2))**2+
+     x        (cosd-prmfbp(kkfbp,2))**2)/3.d0
+            
+            gamb=-prmfbp(kkfbp,1)*(cosb-prmfbp(kkfbp,2))/3.d0
+            gamc=-prmfbp(kkfbp,1)*(cosc-prmfbp(kkfbp,2))/3.d0
+            gamd=-prmfbp(kkfbp,1)*(cosd-prmfbp(kkfbp,2))/3.d0
+            
+          else if(ktyp.eq.3)then
+            
+c     key=3 for planar inversion potentials
+            
+            pterm=prmfbp(kkfbp,1)*
+     x        (3.d0-cosb-cosc-cosd)/3.d0
+            
+            gamb=-prmfbp(kkfbp,1)/3.d0
+            gamc=-prmfbp(kkfbp,1)/3.d0
+            gamd=-prmfbp(kkfbp,1)/3.d0
+            
+          else
+            
+c     undefined potential
+            
+            safe=.false.
+            pterm=0.d0
+            gamb=0.d0
+            gamc=0.d0
+            gamd=0.d0
+            
+          endif
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set quadruple index
+          
+          if(lsolva)
+     x      kkk=loc4(atmolt(ia),atmolt(ib),atmolt(ic),atmolt(id))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x        (atm_fre(ic).ne.1).and.(atm_fre(id).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic)+
+     x          atm_fre(id).eq.0)
+              
+              if(lsolva)en4_exc(kkk)=en4_exc(kkk)+pterm
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x        (atm_fre(ic).eq.1).or.(atm_fre(id).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              fbp_fre=fbp_fre-pterm
+              pterm=lambda1*pterm
+              gamb=lambda1*gamb
+              gamc=lambda1*gamc
+              gamd=lambda1*gamd
+              
+            elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x          (atm_fre(ic).eq.2).or.(atm_fre(id).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              fbp_fre=fbp_fre+pterm
+              pterm=lambda2*pterm
+              gamb=lambda2*gamb
+              gamc=lambda2*gamc
+              gamd=lambda2*gamd
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential
+            
+            engfbp=engfbp+pterm
+            
+            if(lsolva)en4_sol(kkk)=en4_sol(kkk)+pterm
+            
+c     calculate bond and u,v scalar products
+            
+            rubc=xab*ucx+yab*ucy+zab*ucz
+            rubd=xab*udx+yab*udy+zab*udz
+            rucd=xac*udx+yac*udy+zac*udz
+            rucb=xac*ubx+yac*uby+zac*ubz
+            rudb=xad*ubx+yad*uby+zad*ubz
+            rudc=xad*ucx+yad*ucy+zad*ucz
+            
+            rvbc=xab*vcx+yab*vcy+zab*vcz
+            rvbd=xab*vdx+yab*vdy+zab*vdz
+            rvcd=xac*vdx+yac*vdy+zac*vdz
+            rvcb=xac*vbx+yac*vby+zac*vbz
+            rvdb=xad*vbx+yad*vby+zad*vbz
+            rvdc=xad*vcx+yad*vcy+zad*vcz
+            
+c     calculate atomic forces
+            
+            fbx=gamb*(-cosb*xab*rrab**2+rrab*(rub*ubx+rvb*vbx)/wwb)
+     x        +(ruc*ucn*rrab*(xac-ruc*ucx-(rbc-ruc*rubc)*xab*rrab**2)
+     x        - rvc*vcn*rrab*(xac-rvc*vcx-(rbc-rvc*rvbc)*xab*rrab**2))
+     x        * gamc*rrac/wwc
+     x        +(rud*udn*rrab*(xad-rud*udx-(rdb-rud*rubd)*xab*rrab**2)
+     x        + rvd*vdn*rrab*(xad-rvd*vdx-(rdb-rvd*rvbd)*xab*rrab**2))
+     x        * gamd*rrad/wwd
+            
+            fby=gamb*(-cosb*yab*rrab**2+rrab*(rub*uby+rvb*vby)/wwb)
+     x        +(ruc*ucn*rrab*(yac-ruc*ucy-(rbc-ruc*rubc)*yab*rrab**2)
+     x        - rvc*vcn*rrab*(yac-rvc*vcy-(rbc-rvc*rvbc)*yab*rrab**2))
+     x        * gamc*rrac/wwc
+     x        +(rud*udn*rrab*(yad-rud*udy-(rdb-rud*rubd)*yab*rrab**2)
+     x        + rvd*vdn*rrab*(yad-rvd*vdy-(rdb-rvd*rvbd)*yab*rrab**2))
+     x        * gamd*rrad/wwd
+            
+            fbz=gamb*(-cosb*zab*rrab**2+rrab*(rub*ubz+rvb*vbz)/wwb)
+     x        +(ruc*ucn*rrab*(zac-ruc*ucz-(rbc-ruc*rubc)*zab*rrab**2)
+     x        - rvc*vcn*rrab*(zac-rvc*vcz-(rbc-rvc*rvbc)*zab*rrab**2))
+     x        * gamc*rrac/wwc
+     x        +(rud*udn*rrab*(zad-rud*udz-(rdb-rud*rubd)*zab*rrab**2)
+     x        + rvd*vdn*rrab*(zad-rvd*vdz-(rdb-rvd*rvbd)*zab*rrab**2))
+     x        * gamd*rrad/wwd
+            
+            fcx=gamc*(-cosc*xac*rrac**2+rrac*(ruc*ucx+rvc*vcx)/wwc)
+     x        +(rud*udn*rrac*(xad-rud*udx-(rcd-rud*rucd)*xac*rrac**2)
+     x        - rvd*vdn*rrac*(xad-rvd*vdx-(rcd-rvd*rvcd)*xac*rrac**2))
+     x        * gamd*rrad/wwd
+     x        +(rub*ubn*rrac*(xab-rub*ubx-(rbc-rub*rucb)*xac*rrac**2)
+     x        + rvb*vbn*rrac*(xab-rvb*vbx-(rbc-rvb*rvcb)*xac*rrac**2))
+     x        * gamb*rrab/wwb
+            
+            fcy=gamc*(-cosc*yac*rrac**2+rrac*(ruc*ucy+rvc*vcy)/wwc)
+     x        +(rud*udn*rrac*(yad-rud*udy-(rcd-rud*rucd)*yac*rrac**2)
+     x        - rvd*vdn*rrac*(yad-rvd*vdy-(rcd-rvd*rvcd)*yac*rrac**2))
+     x        * gamd*rrad/wwd
+     x        +(rub*ubn*rrac*(yab-rub*uby-(rbc-rub*rucb)*yac*rrac**2)
+     x        + rvb*vbn*rrac*(yab-rvb*vby-(rbc-rvb*rvcb)*yac*rrac**2))
+     x        * gamb*rrab/wwb
+            
+            fcz=gamc*(-cosc*zac*rrac**2+rrac*(ruc*ucz+rvc*vcz)/wwc)
+     x        +(rud*udn*rrac*(zad-rud*udz-(rcd-rud*rucd)*zac*rrac**2)
+     x        - rvd*vdn*rrac*(zad-rvd*vdz-(rcd-rvd*rvcd)*zac*rrac**2))
+     x        * gamd*rrad/wwd
+     x        +(rub*ubn*rrac*(zab-rub*ubz-(rbc-rub*rucb)*zac*rrac**2)
+     x        + rvb*vbn*rrac*(zab-rvb*vbz-(rbc-rvb*rvcb)*zac*rrac**2))
+     x        * gamb*rrab/wwb
+            
+            fdx=gamd*(-cosd*xad*rrad**2+rrad*(rud*udx+rvd*vdx)/wwd)
+     x        +(rub*ubn*rrad*(xab-rub*ubx-(rdb-rub*rudb)*xad*rrad**2)
+     x        - rvb*vbn*rrad*(xab-rvb*vbx-(rdb-rvb*rvdb)*xad*rrad**2))
+     x        * gamb*rrab/wwb
+     x        +(ruc*ucn*rrad*(xac-ruc*ucx-(rcd-ruc*rudc)*xad*rrad**2)
+     x        + rvc*vcn*rrad*(xac-rvc*vcx-(rcd-rvc*rvdc)*xad*rrad**2))
+     x        * gamc*rrac/wwc
+            
+            fdy=gamd*(-cosd*yad*rrad**2+rrad*(rud*udy+rvd*vdy)/wwd)
+     x        +(rub*ubn*rrad*(yab-rub*uby-(rdb-rub*rudb)*yad*rrad**2)
+     x        - rvb*vbn*rrad*(yab-rvb*vby-(rdb-rvb*rvdb)*yad*rrad**2))
+     x        * gamb*rrab/wwb
+     x        +(ruc*ucn*rrad*(yac-ruc*ucy-(rcd-ruc*rudc)*yad*rrad**2)
+     x        + rvc*vcn*rrad*(yac-rvc*vcy-(rcd-rvc*rvdc)*yad*rrad**2))
+     x        * gamc*rrac/wwc
+            
+            fdz=gamd*(-cosd*zad*rrad**2+rrad*(rud*udz+rvd*vdz)/wwd)
+     x        +(rub*ubn*rrad*(zab-rub*ubz-(rdb-rub*rudb)*zad*rrad**2)
+     x        - rvb*vbn*rrad*(zab-rvb*vbz-(rdb-rvb*rvdb)*zad*rrad**2))
+     x        * gamb*rrab/wwb
+     x        +(ruc*ucn*rrad*(zac-ruc*ucz-(rcd-ruc*rudc)*zad*rrad**2)
+     x        + rvc*vcn*rrad*(zac-rvc*vcz-(rcd-rvc*rvdc)*zad*rrad**2))
+     x        * gamc*rrac/wwc
+            
+            fax=-(fbx+fcx+fdx)
+            fay=-(fby+fcy+fdy)
+            faz=-(fbz+fcz+fdz)
+            
+            fxx(ia)=fxx(ia)+fax
+            fyy(ia)=fyy(ia)+fay
+            fzz(ia)=fzz(ia)+faz
+            
+            fxx(ib)=fxx(ib)+fbx
+            fyy(ib)=fyy(ib)+fby
+            fzz(ib)=fzz(ib)+fbz
+            
+            fxx(ic)=fxx(ic)+fcx
+            fyy(ic)=fyy(ic)+fcy
+            fzz(ic)=fzz(ic)+fcz
+            
+            fxx(id)=fxx(id)+fdx
+            fyy(id)=fyy(id)+fdy
+            fzz(id)=fzz(id)+fdz
+            
+c     stress tensor calculation for inversion terms
+            
+            strs(1)=strs(1)+xab*fbx+xac*fcx+xad*fdx 
+            strs(2)=strs(2)+yab*fbx+yac*fcx+yad*fdx 
+            strs(3)=strs(3)+zab*fbx+zac*fcx+zad*fdx 
+            strs(4)=strs(4)+yab*fby+yac*fcy+yad*fdy 
+            strs(5)=strs(5)+yab*fbz+yac*fcz+yad*fdz 
+            strs(6)=strs(6)+zab*fbz+zac*fcz+zad*fdz 
+          
+          endif
+          
+c     metadynamics local parameters
+          
+          if(lmetadyn.and.(idrive.or.jdrive.or.kdrive.or.ldrive))then
+            
+c     local energy (no virial)
+
+            eng_loc=eng_loc+pterm
+
+c     local forces
+            
+            fxx_loc(ia)=fxx_loc(ia)+fax
+            fyy_loc(ia)=fyy_loc(ia)+fay
+            fzz_loc(ia)=fzz_loc(ia)+faz
+            
+            fxx_loc(ib)=fxx_loc(ib)+fbx
+            fyy_loc(ib)=fyy_loc(ib)+fby
+            fzz_loc(ib)=fzz_loc(ib)+fbz
+            
+            fxx_loc(ic)=fxx_loc(ic)+fcx
+            fyy_loc(ic)=fyy_loc(ic)+fcy
+            fzz_loc(ic)=fzz_loc(ic)+fcz
+            
+            fxx_loc(id)=fxx_loc(id)+fdx
+            fyy_loc(id)=fyy_loc(id)+fdy
+            fzz_loc(id)=fzz_loc(id)+fdz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xab*fbx+xac*fcx+xad*fdx 
+            strs_loc(2)=strs_loc(2)+yab*fbx+yac*fcx+yad*fdx 
+            strs_loc(3)=strs_loc(3)+zab*fbx+zac*fcx+zad*fdx 
+            strs_loc(4)=strs_loc(4)+yab*fby+yac*fcy+yad*fdy 
+            strs_loc(5)=strs_loc(5)+yab*fbz+yac*fcz+yad*fdz 
+            strs_loc(6)=strs_loc(6)+zab*fbz+zac*fcz+zad*fdz 
+
+          endif
+          
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+
+          enddo
+          enddo
+          enddo
+          
+          endif
+
+        enddo
+
+      enddo
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,443)
+
+c     global sum of four body potential and virial
+
+      buffer(1)=engfbp
+      buffer(2)=virfbp
+      buffer(3)=fbp_fre
+      buffer(4)=fbp_vir
+      call gdsum(buffer(1),4,buffer(5))
+      engfbp=buffer(1)
+      virfbp=buffer(2)
+      fbp_fre=buffer(3)
+      fbp_vir=buffer(4)
+
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(en4_sol,mxtmls_sol4,buffer(1))
+          if(lexcite)call gdsum(en4_exc,mxtmls_exc4,buffer(1))
+          
+        endif
+        
+c     restore coordinate array to original representation
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=xxx(i)
+          syy=yyy(i)
+          szz=zzz(i)
+          
+          xxx(i)=cell(1)*sxx+cell(4)*syy+cell(7)*szz
+          yyy(i)=cell(2)*sxx+cell(5)*syy+cell(8)*szz
+          zzz(i)=cell(3)*sxx+cell(6)*syy+cell(9)*szz
+          
+        endif
+        
+      enddo
+
+c     restore cell vector
+
+      if(imcon.eq.0) then
+        cell(1)=0.d0
+        cell(5)=0.d0
+        cell(9)=0.d0
+      endif
+
+c     complete stress tensor
+        
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine fbpfrc
+      
+      end module four_body_module
diff -urN dl_class_1.9.orig/srcmod/hkewald_module.f dl_class_1.9/srcmod/hkewald_module.f
--- dl_class_1.9.orig/srcmod/hkewald_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/hkewald_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1292 @@
+      module hkewald_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining hautman-klein ewald sum arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use exclude_module
+      use error_module
+      use pair_module
+      use property_module
+      use setup_module
+
+      implicit none
+
+      real(8), allocatable :: ahk(:),crn(:,:)
+      real(8), allocatable :: elc(:,:),els(:,:)
+      real(8), allocatable :: emc(:,:),ems(:,:)
+      real(8), allocatable :: zzn(:),zzd(:)
+      real(8), allocatable :: hon(:,:),znp(:,:)
+      real(8), allocatable :: dhn(:,:),zgs(:)
+      real(8), allocatable :: fon(:,:),zgc(:)
+      real(8), allocatable :: ckc(:),cks(:)
+      real(8), allocatable :: pp(:),sss(:)
+
+      save ahk,crn,elc,els,emc,ems,zzn,zzd,hon,znp,dhn,zgs
+      save fon,zgc,ckc,cks,pp,sss
+
+      contains
+      
+      subroutine alloc_hke_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=9
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (ahk(0:mxhko),crn(0:mxhko,0:mxhko),stat=fail(1))
+      allocate (elc(mxewld,0:1),els(mxewld,0:1),stat=fail(2))
+      allocate (emc(mxewld,0:kmaxb),ems(mxewld,0:kmaxb),stat=fail(3))
+      allocate (zzn(mxxdf),zzd(mxxdf),stat=fail(4))
+      allocate (hon(mxgrid,0:mxhko),znp(mxhke,0:2*mxhko),stat=fail(5))
+      allocate (dhn(mxgrid,0:mxhko),zgs(0:2*mxhko),stat=fail(6))
+      allocate (fon(mxegrd,0:7),zgc(0:2*mxhko),stat=fail(7))
+      allocate (ckc(mxewld),cks(mxewld),stat=fail(8))
+      allocate (pp(2*mxhko),sss(mxxdf),stat=fail(9))
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1730)
+      enddo
+
+      end subroutine alloc_hke_arrays
+
+      subroutine hkgen(idnode,nhko,nlatt,alpha,drewd,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating convergence function
+c     arrays for hautman klein ewald method (up to order 3 only)
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith february 2000
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,idnode,nhko,nlatt,k
+      real(8) alpha,drewd,rcut,ecut,den,fac,ss1,aaa,ss2
+
+      if(nhko.gt.mxhko)call error(idnode,332)
+
+c     define effective cutoff
+
+      ecut=rcut*dble(2*nlatt+1)
+
+c     define grid resolution for potential arrays
+      
+      drewd=ecut/dble(mxegrd-4)
+
+c     calculate HKE coefficients
+
+      ahk(0)=1.d0
+
+      do i=1,nhko
+
+        ahk(i)=-0.25d0*ahk(i-1)*dble(2*i*(2*i-1))/dble(i*i)
+
+      enddo
+
+c     generate convergence function arrays
+
+      do i=1,mxegrd
+
+        hon(i,0)=0.d0
+        hon(i,1)=dble(i-1)*drewd
+        hon(i,2)=(2.d0*alpha/sqrpi)*exp(-(alpha*hon(i,1))**2)
+
+      enddo
+
+c     generate error function and derivatives by recursion
+
+      do k=100,1,-1
+
+        den=1.d0/dble(2*k-1)
+        fac=(2.d0*alpha**2)**(k-1)
+
+        do i=1,mxegrd
+
+          hon(i,0)=den*(hon(i,0)*hon(i,1)**2+fac*hon(i,2))
+
+        enddo
+
+        if(k.le.2*nhko+2)then
+
+          do i=1,mxegrd
+
+            fon(i,k-1)=hon(i,0)
+
+          enddo
+
+        endif
+
+      enddo
+        
+c     zeroth order function
+c     note: hon(1,0)=2.d0*alpha/sqrpi
+
+      do i=1,mxegrd
+
+        hon(i,0)= fon(i,0)
+        dhn(i,0)=-fon(i,1)
+
+      enddo
+
+      if(nhko.eq.0)then
+
+        ss1=dble(mxegrd-1)*drewd
+        aaa=abs(1.d0-hon(mxegrd,nhko)*ss1)
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+
+      endif
+
+c     first order function
+c     note: hon(1,1)=8.d0*alpha**3/(3.d0*sqrpi)
+
+      do i=1,mxegrd
+        
+        ss2=(dble(i-1)*drewd)**2
+        
+        hon(i,1)=-(2.d0*fon(i,1)-fon(i,2)*ss2)
+        dhn(i,1)= (4.d0*fon(i,2)-fon(i,3)*ss2)
+          
+      enddo
+        
+      if(nhko.eq.1)then
+
+        aaa=abs(1.d0-hon(mxegrd,nhko)*sqrt(ss2)**(2*nhko+1))
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+
+      endif
+
+c     second order function
+c     note: hon(1,2)=64.d0*alpha**5/(45.d0*sqrpi)
+
+      do i=1,mxegrd
+        
+        ss2=(dble(i-1)*drewd)**2
+        
+        hon(i,2)=(8.d0*fon(i,2)+ss2*(-8.d0*fon(i,3)+ss2*fon(i,4)))/9.d0
+        dhn(i,2)=(-24.d0*fon(i,3)+ss2*(12.d0*fon(i,4)-ss2*fon(i,5)))
+     x          /9.d0
+
+      enddo
+
+      if(nhko.eq.2)then
+
+        aaa=abs(1.d0-hon(mxegrd,nhko)*sqrt(ss2)**(2*nhko+1))
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+        
+      endif
+
+c     third order function (enough for anyone!)
+c     note: hon(1,3)=768.d0*alpha**7/(14175.d0*sqrpi)
+
+      do i=1,mxegrd
+        
+        ss2=(dble(i-1)*drewd)**2
+        
+        hon(i,3)=-(48.d0*fon(i,3)+ss2*(-72.d0*fon(i,4)+ss2*(
+     x    18.d0*fon(i,5)-ss2*fon(i,6))))/225.d0
+        dhn(i,3)= (192.d0*fon(i,4)+ss2*(-144.d0*fon(i,5)+ss2*(
+     x    24.d0*fon(i,6)-ss2*fon(i,7))))/225.d0
+        
+      enddo
+
+      if(nhko.eq.3)then
+
+        aaa=abs(1.d0-hon(mxegrd,nhko)*sqrt(ss2)**(2*nhko+1))
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+        
+      endif
+
+      return
+      end subroutine hkgen
+
+      subroutine hkewald1
+     x  (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x  engcpe,vircpe,alpha,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using Hautman Klein Ewald method
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith february 2000
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c     
+c     note - in loop over all k vectors k=2pi(ll/cl,mm/cl)
+c     the values of ll and mm are selected so that the symmetry of
+c     reciprocal lattice is taken into account i.e. the following
+c     rules apply.
+c     
+c     ll ranges over the values 0 to kmax1 only.
+c     
+c     mm ranges over 1 to kmax2 when ll=0 and over
+c     -kmax2 to kmax2 otherwise.
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical newjob
+      integer idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,i
+      integer iatm0,iatm1,j,k,limit,mmin,l,ll,m,mm,n
+      real(8) engcpe,vircpe,alpha,epsq,twopi,ralph,area,rarea
+      real(8) det,rcpcut,rcpct2,aaa,engsic,pm1,pm2,term,ssx,ssy
+      real(8) tmp,rkx1,rky1,rkx2,rky2,rksq,rkk,fac,eterm,fng,fn0,gaus
+      real(8) bkk,force0,forcez,pterm,scale,cprop,omg,cs
+c$$$      real(8) erfc
+
+      dimension cprop(10),omg(9)
+
+      save newjob,engsic
+
+      data newjob/.true./
+
+c     initialise coulombic potential energy
+
+      engcpe=0.d0
+      vircpe=0.d0
+      if(alpha.lt.1.d-8)return
+
+c     set working parameters
+
+      twopi=2.d0*pi
+      ralph=0.5d0/alpha
+      call dcell(cell,cprop)
+      area=cprop(1)*cprop(2)*sqrt(1.d0-cprop(4)**2)
+      rarea=pi/area
+
+c     set up atoms numbers for nodes
+
+      iatm0 = (idnode*natms)/mxnode + 1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+c     initalize stress tensor working arrays
+
+      do i = 1,9
+
+        omg(i) = 0.d0
+
+      enddo
+
+c     construct reciprocal lattice vectors and set k vector range
+
+      call invert(cell,rcell,det)
+      if(abs(det).lt.1.d-6)call error(idnode,120)
+      call dcell(rcell,cprop)
+      rcpcut=min(dble(kmax1)*cprop(7),dble(kmax2)*cprop(8))*
+     x  1.05d0*twopi
+      rcpct2=rcpcut**2
+
+c     compute quantities for first entry
+
+      if(newjob)then
+
+        newjob=.false.
+
+c     pbc check and array bound checks
+
+        if(imcon.ne.6)call error(idnode,66)
+        if(mxhke.ne.msatms) call error(idnode,331)
+        if(mxewld.ne.msatms) call error(idnode,330)
+
+c     check hk screening function at cutoff
+
+        aaa=cerfr(ralph,rcpcut)
+c$$$        aaa=erfc(ralph*rcpcut)/rcpcut
+
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,105,aaa,0.d0,0.d0)
+c          call error(idnode,487)
+          
+        endif
+
+c     calculate self interaction correction
+        
+        engsic=0.d0
+        
+        do i=iatm0,iatm1
+          
+          engsic=engsic+chge(i)**2
+          
+        enddo
+
+        engsic=-r4pie0*alpha*engsic/(sqrpi*epsq)
+
+c     binomial coefficients
+
+        k=0
+        crn(0,0)=0.5d0
+        do i=1,2*nhko
+
+          pp(i)=1.d0
+          pm1=pp(1)
+
+          do j=2,i
+
+            pm2=pp(j)
+            pp(j)=pm2+pm1
+            pm1=pm2
+
+          enddo
+
+          if(mod(i,2).eq.0)then
+
+            k=k+1
+            do j=0,k
+
+              term=pp(j+1)*(-1.d0)**j
+              crn(j,k)=term
+              crn(k,j)=term
+
+            enddo
+
+            crn(k,k)=0.5d0*crn(k,k)
+
+          endif
+
+        enddo
+
+      endif
+
+c     calculate and store powers of z_i
+      
+      i=0
+
+      do j=iatm0,iatm1
+
+        i=i+1
+        znp(i,0)=1.d0
+        znp(i,1)=zzz(j)
+
+      enddo
+
+      limit=i
+
+      do k=2,2*nhko
+
+        do i=1,limit
+
+          znp(i,k)=znp(i,k-1)*znp(i,1)
+
+        enddo
+
+      enddo
+
+c     calculate and store exponential factors
+
+      i=0
+
+      do j=iatm0,iatm1
+        
+        i=i+1
+        elc(i,0)=1.d0
+        emc(i,0)=1.d0
+        els(i,0)=0.d0
+        ems(i,0)=0.d0
+        ssx=rcell(1)*xxx(j)+rcell(4)*yyy(j)
+        ssy=rcell(2)*xxx(j)+rcell(5)*yyy(j)
+        elc(i,1)=cos(twopi*ssx)
+        emc(i,1)=cos(twopi*ssy)
+        els(i,1)=sin(twopi*ssx)
+        ems(i,1)=sin(twopi*ssy)
+        
+      enddo
+
+      do l=2,kmax2
+        
+        do i=1,limit
+          
+          emc(i,l)=emc(i,l-1)*emc(i,1)-ems(i,l-1)*ems(i,1)
+          ems(i,l)=ems(i,l-1)*emc(i,1)+emc(i,l-1)*ems(i,1)
+          
+        enddo
+        
+      enddo
+
+c     start of main loop over k vectors
+
+      mmin=1
+      
+      do ll=0,kmax1
+        
+        l=ll
+        tmp = twopi*dble(ll)
+        rkx1=tmp*rcell(1)
+        rky1=tmp*rcell(4)
+
+c     put cos(i,L) terms into cos(i,0) array
+
+        if(l.eq.1) then
+          
+          do i=1,limit
+
+            elc(i,0)=elc(i,1)
+            els(i,0)=els(i,1)
+            
+          enddo
+
+        elseif(l.gt.1) then
+
+          do i=1,limit
+
+            cs=elc(i,0)
+            elc(i,0)=cs*elc(i,1)-els(i,0)*els(i,1)
+            els(i,0)=els(i,0)*elc(i,1)+cs*els(i,1)
+            
+          enddo
+          
+        endif
+
+        do mm=mmin,kmax2
+          
+          m=iabs(mm)
+          tmp = twopi*dble(mm)
+          rkx2=rkx1+tmp*rcell(2)
+          rky2=rky1+tmp*rcell(5)
+
+c     test on magnitude of k vector
+          
+          rksq=rkx2*rkx2+rky2*rky2
+
+          if(rksq.le.rcpct2)then
+
+c     calculate exp(ikr) terms and product with charges
+            
+            i=0
+
+            if(mm.ge.0)then
+              
+              do j=iatm0,iatm1
+                
+                i=i+1
+                ckc(i)=chge(j)*(elc(i,0)*emc(i,m)-els(i,0)*ems(i,m))
+                cks(i)=chge(j)*(els(i,0)*emc(i,m)+ems(i,m)*elc(i,0))
+                
+              enddo
+              
+            else
+              
+              do j=iatm0,iatm1
+                
+                i=i+1
+                
+                ckc(i)=chge(j)*(elc(i,0)*emc(i,m)+els(i,0)*ems(i,m))
+                cks(i)=chge(j)*(els(i,0)*emc(i,m)-ems(i,m)*elc(i,0))
+                
+              enddo
+              
+            endif
+
+c     calculate sum of products of powers of z_i and q_i exp(ik.s_i)
+            
+            do k=0,2*nhko
+              
+              zgc(k)=0.d0
+              zgs(k)=0.d0
+
+              do i=1,limit
+
+                zgc(k)=zgc(k)+ckc(i)*znp(i,k)
+                zgs(k)=zgs(k)+cks(i)*znp(i,k)
+
+              enddo
+
+            enddo
+
+c     perform global summation of zgc and zgs arrays
+            
+            if(mxnode.gt.1)then
+              
+              call gdsum(zgc(0),2*nhko+1,buffer)
+              call gdsum(zgs(0),2*nhko+1,buffer)
+              
+            endif
+
+c     calculate 0th order screening function
+
+            rkk=sqrt(rksq)
+            fn0=cerfr(ralph,rkk)
+c$$$            fn0=erfc(ralph*rkk)/rkk
+            gaus=exp(-(ralph*rkk)**2)/(alpha*sqrpi)
+
+c     sum terms for orders of the screening function
+
+            fac=1.d0
+
+            do k=0,nhko
+
+c     sum over z_i binomial contributions
+
+              eterm=0.d0
+              fng=fac*fn0
+              do m=0,k
+
+                n=2*k-m
+
+c     sum energy terms
+
+                eterm=eterm+crn(m,k)*(zgc(m)*zgc(n)+zgs(m)*zgs(n))
+
+c     calculate force contribution to each site
+                
+                i=0
+                bkk=-fng*crn(m,k)
+
+                do j=iatm0,iatm1
+                  
+                  i=i+1
+                  force0=bkk*(znp(i,n)*(zgs(m)*ckc(i)-zgc(m)*cks(i))+
+     x              znp(i,m)*(zgs(n)*ckc(i)-zgc(n)*cks(i)))
+                  fxx(j)=fxx(j)+rkx2*force0
+                  fyy(j)=fyy(j)+rky2*force0
+
+                  omg(3)=omg(3)+rkx2*force0*zzz(j)
+                  omg(6)=omg(6)+rky2*force0*zzz(j)
+
+                  if(k.gt.0)then
+
+                    if(m.eq.0)then
+                      
+                      forcez=bkk*dble(n)*znp(i,n-1)*(zgc(m)*ckc(i)+
+     x                  zgs(m)*cks(i))
+                      
+                    else
+                      
+                      forcez=bkk*(dble(m)*znp(i,m-1)*(zgc(n)*ckc(i)+
+     x                  zgs(n)*cks(i))+dble(n)*znp(i,n-1)*(zgc(m)*
+     x                  ckc(i)+zgs(m)*cks(i)))
+                    
+                    endif
+                    
+                    omg(9)=omg(9)+forcez*zzz(j)
+                    fzz(j)=fzz(j)+forcez
+
+                  endif
+
+                enddo
+
+              enddo
+
+c     accumulate potential energy and stress tensor
+              
+              engcpe=engcpe+fng*eterm
+              pterm=(dble(2*k-1)*fng-fac*gaus)/rksq
+              omg(1)=omg(1)+eterm*(fng+pterm*rkx2*rkx2)
+              omg(5)=omg(5)+eterm*(fng+pterm*rky2*rky2)
+              omg(2)=omg(2)+eterm*pterm*rky2*rkx2
+              fac=fac*rksq/(dble(2*(k+1))*dble(2*k+1))
+
+c     end of loop over orders of screening function
+
+            enddo
+
+c     end of if-block for  rksq <  rcpct2
+
+          endif
+
+c     end of inner loop over reciprocal lattice vectors
+
+        enddo
+        
+        mmin=-kmax2
+
+c     end of outer loop over reciprocal lattice vectors
+
+      enddo
+      
+      engcpe=engcpe/dble(mxnode)
+      do i = 1,9
+
+        omg(i) = omg(i)/dble(mxnode)
+
+      enddo
+
+c     add self interaction correction to potential
+
+      scale=4.d0*rarea*r4pie0/epsq
+      engcpe=scale*engcpe+engsic
+
+c     virial term
+
+      vircpe=vircpe-scale*(omg(1)+omg(5)+omg(9))
+
+c     calculate final forces
+
+      do i=iatm0,iatm1
+
+        fxx(i)=scale*fxx(i)
+        fyy(i)=scale*fyy(i)
+        fzz(i)=scale*fzz(i)
+
+      enddo
+
+c     calculate stress tensor (symmetrical)
+
+      stress(1) = stress(1)+scale*omg(1)
+      stress(2) = stress(2)+scale*omg(2)
+      stress(3) = stress(3)+scale*omg(3)
+      stress(4) = stress(4)+scale*omg(2)
+      stress(5) = stress(5)+scale*omg(5)
+      stress(6) = stress(6)+scale*omg(6)
+      stress(7) = stress(7)+scale*omg(3)
+      stress(8) = stress(8)+scale*omg(6)
+      stress(9) = stress(9)+scale*omg(9)
+      
+      return
+      end subroutine hkewald1
+
+      subroutine hkewald2
+     x  (idnode,mxnode,nhko,nlatt,imcon,natms,engcpe,
+     x  vircpe,drewd,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating real-space contributions to
+c     the hautman-klein-ewald electrostatic method
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith  may 2000
+c     
+c***********************************************************************
+            
+      implicit none
+
+      integer idnode,mxnode,nhko,nlatt,imcon,natms,nix,niy
+      integer nboxes,i,j,k,n,m,ma,mpm2,npm2,ii,l0,l1,l2,last
+      real(8) engcpe,vircpe,drewd,rcut,epsq
+      real(8) step,rcsq,rdrewd,strs1,strs2,strs3
+      real(8) strs5,strs6,strs9,dcx,dcy,udx,udy,fac,chgea,chgprd
+      real(8) ddx,ddy,ssx,ssy,ssq,coul,fcoul,rrr,ppp,vk0,vk1,vk2
+      real(8) eterm,t1,t2,egamma,fx,fy,fz,det
+
+      dimension nix(25),niy(25)
+
+      data nix/ 0, 1, 1, 0,-1,-1,-1, 0, 1, 2, 2,
+     x  2, 1, 0,-1,-2,-2,-2,-2,-2,-1, 0, 1, 2, 2/
+      data niy/ 0, 0, 1, 1, 1, 0,-1,-1,-1, 0, 1,
+     x  2, 2, 2, 2, 2, 1, 0,-1,-2,-2,-2,-2,-2,-1/
+
+CDIR$ CACHE_ALIGN fi
+      
+c     check boundary condition
+
+      if(imcon.ne.6)call error(idnode,66)
+
+c     number of neighbouring real space cells
+
+      if(nlatt.gt.2)call error(idnode,488)
+      step=dble(2*nlatt+1)
+      nboxes=(2*nlatt+1)**2
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+
+c     set cutoff condition for pair forces
+      
+      rcsq=(step*rcut)**2
+
+c     reciprocal of interpolation interval
+      
+      rdrewd = 1.d0/drewd
+
+c     reciprocal cell
+
+      call invert(cell,rcell,det)
+      do i=1,9
+
+        rcell(i)=rcell(i)/step
+
+      enddo
+
+c     initialise stress tensor accumulators
+      strs3 = 0.d0
+      strs6 = 0.d0
+      strs9 = 0.d0
+      strs1 = 0.d0
+      strs2 = 0.d0
+      strs5 = 0.d0
+
+c     loop over image cells, starting with central cell
+
+      ma=1
+      mpm2=natms/2
+      npm2=(natms-1)/2
+
+      do k=1,nboxes
+
+        last=natms
+        dcx=dble(nix(k))
+        dcy=dble(niy(k))
+        udx=cell(1)*dcx+cell(4)*dcy
+        udy=cell(2)*dcx+cell(5)*dcy
+
+c     outer loop over atoms
+
+        do m=ma,mpm2
+
+          fac=r4pie0/epsq
+          if(m.eq.0)fac=fac*0.5d0
+          if(m.gt.npm2)last=mpm2
+
+c     set initial array values
+
+          ii=0
+          do i=idnode+1,last,mxnode
+            
+            ii=ii+1
+            chgea=fac*chge(i)
+            
+            if(abs(chgea).gt.1.d-10)then
+              
+              j=i+m
+              if(j.gt.natms)j=j-natms
+              
+              chgprd=chgea*chge(j)
+              
+              if(abs(chgprd).gt.1.d-10)then
+
+                zzn(ii)=1.d0
+                zzd(ii)=0.d0
+
+c     calculate interatomic separation
+                
+                ddx=xxx(i)-xxx(j)+udx
+                ddy=yyy(i)-yyy(j)+udy
+                ssx=rcell(1)*ddx+rcell(4)*ddy
+                ssy=rcell(2)*ddx+rcell(5)*ddy
+                ssx=ssx-nint(ssx)
+                ssy=ssy-nint(ssy)
+                xdf(ii)=step*(ssx*cell(1)+ssy*cell(4))
+                ydf(ii)=step*(ssx*cell(2)+ssy*cell(5))
+                zdf(ii)=zzz(i)-zzz(j)
+                rsqdf(ii)=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                
+              endif
+
+            endif
+
+          enddo
+
+c     loop over HK orders
+
+          do n=0,nhko
+
+c     inner loop over atoms
+
+            ii=0
+            do i=idnode+1,last,mxnode
+
+              ii=ii+1
+              chgea = fac*chge(i)
+
+              if(abs(chgea).gt.1.d-10)then
+                
+                j=i+m
+                if(j.gt.natms)j=j-natms
+
+                chgprd=chgea*chge(j)
+                
+                if(abs(chgprd).gt.1.d-10)then
+
+c     apply truncation of potential
+                  
+                  ssq=rsqdf(ii)-zdf(ii)*zdf(ii)
+
+                  if(rcsq.gt.ssq)then
+
+c     calculate potential energy and virial
+                    
+                    coul=0.d0
+                    fcoul=0.d0
+                    rrr = sqrt(rsqdf(ii))
+                    sss(ii)=sqrt(ssq)
+
+                    if(n.eq.0)then
+
+                      coul = chgprd/rrr
+                      fcoul = coul/rsqdf(ii)
+
+                    endif
+
+c     interpolation parameters
+
+                    l0=int(sss(ii)*rdrewd)
+                    ppp=sss(ii)*rdrewd-dble(l0)
+                    l0=l0+1
+                    l1=l0+1
+                    l2=l0+2
+
+c     calculate interaction energy using 3-point interpolation
+                    
+                    vk0 = hon(l0,n)
+                    vk1 = hon(l1,n)
+                    vk2 = hon(l2,n)
+                    t1 = vk0 + (vk1 - vk0)*ppp
+                    t2 = vk1 + (vk2 - vk1)*(ppp - 1.0d0)
+                    
+                    eterm=(t1+(t2-t1)*ppp*0.5d0)*ahk(n)*chgprd
+                    engcpe=engcpe+coul-eterm*zzn(ii)
+
+c     calculate forces using 3pt interpolation
+                    
+                    vk0 = dhn(l0,n)
+                    vk1 = dhn(l1,n)
+                    vk2 = dhn(l2,n)
+                    
+                    t1 = vk0 + (vk1 - vk0)*ppp
+                    t2 = vk1 + (vk2 - vk1)*(ppp - 1.0d0)
+
+c     calculate in-plane forces
+                    
+                    egamma=fcoul+
+     x                (t1+(t2-t1)*ppp*0.5d0)*chgprd*zzn(ii)*ahk(n)
+                    fx=egamma*xdf(ii)
+                    fy=egamma*ydf(ii)
+
+c     calculate perpendicular forces
+                    
+                    fz=fcoul*zdf(ii)+2.d0*dble(n)*eterm*zzd(ii)
+
+c     add to force accumulators
+
+                    fxx(i)=fxx(i)+fx
+                    fyy(i)=fyy(i)+fy
+                    fzz(i)=fzz(i)+fz
+
+                    fxx(j)=fxx(j)-fx
+                    fyy(j)=fyy(j)-fy
+                    fzz(j)=fzz(j)-fz
+
+c     reset zzn array for next order of convergence function
+              
+                    zzd(ii)=zzn(ii)*zdf(ii)
+                    zzn(ii)=zzd(ii)*zdf(ii)
+              
+c     calculate stress tensor
+                    
+                    strs1 = strs1 + xdf(ii)*fx
+                    strs2 = strs2 + xdf(ii)*fy
+                    strs3 = strs3 + xdf(ii)*fz
+                    strs5 = strs5 + ydf(ii)*fy
+                    strs6 = strs6 + ydf(ii)*fz
+                    strs9 = strs9 + zdf(ii)*fz
+
+                  endif
+                  
+                endif
+                
+              endif
+
+            enddo
+
+          enddo
+
+        enddo
+
+        ma=0
+
+      enddo
+
+c     calculate virial
+
+      vircpe=vircpe-(strs1+strs5+strs9)
+
+c     complete stress tensor
+      
+      stress(1) = stress(1) + strs1
+      stress(2) = stress(2) + strs2
+      stress(3) = stress(3) + strs3
+      stress(4) = stress(4) + strs2
+      stress(5) = stress(5) + strs5
+      stress(6) = stress(6) + strs6
+      stress(7) = stress(7) + strs3
+      stress(8) = stress(8) + strs6
+      stress(9) = stress(9) + strs9
+      
+      return
+      end subroutine hkewald2
+
+      subroutine hkewald3(iatm,ik,engcpe,vircpe,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating exclusion corrections to
+c     the hautman-klein-ewald electrostatic method
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith  may 2000
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,ik,m,jatm
+      real(8) engcpe,vircpe,epsq,fx,fy,fz,strs1,strs2,strs3
+      real(8) strs5,strs6,strs9,chgea,chgprd,rrr,rsq,coul,fcoul
+
+CDIR$ CACHE_ALIGN fi
+      
+c     initialise stress tensor accumulators
+
+      strs1 = 0.d0
+      strs2 = 0.d0
+      strs3 = 0.d0
+      strs5 = 0.d0
+      strs6 = 0.d0
+      strs9 = 0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0     
+
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        do m=1,nexatm(ik)
+
+c     atomic index and charge product
+          
+          jatm=lexatm(ik,m)
+          chgprd=chgea*chge(jatm)
+          
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=xdf(m)**2+ydf(m)**2+zdf(m)**2
+            rrr = sqrt(rsq)
+
+c     calculate potential energy and virial
+            
+            coul = chgprd/rrr
+            engcpe = engcpe - coul
+            
+c     calculate forces
+            
+            fcoul = coul/rsq
+            fx = fcoul*xdf(m)
+            fy = fcoul*ydf(m)
+            fz = fcoul*zdf(m)
+            
+            fxx(iatm) = fxx(iatm) - fx
+            fyy(iatm) = fyy(iatm) - fy
+            fzz(iatm) = fzz(iatm) - fz
+
+            fxx(jatm) = fxx(jatm) + fx
+            fyy(jatm) = fyy(jatm) + fy
+            fzz(jatm) = fzz(jatm) + fz
+
+c     calculate stress tensor
+            
+            strs1 = strs1 - xdf(m)*fx
+            strs2 = strs2 - xdf(m)*fy
+            strs3 = strs3 - xdf(m)*fz
+            strs5 = strs5 - ydf(m)*fy
+            strs6 = strs6 - ydf(m)*fz
+            strs9 = strs9 - zdf(m)*fz
+            
+          endif
+          
+        enddo
+
+c     virial
+        
+        vircpe=vircpe-engcpe
+
+c     complete stress tensor
+        
+        stress(1) = stress(1) + strs1
+        stress(2) = stress(2) + strs2
+        stress(3) = stress(3) + strs3
+        stress(4) = stress(4) + strs2
+        stress(5) = stress(5) + strs5
+        stress(6) = stress(6) + strs6
+        stress(7) = stress(7) + strs3
+        stress(8) = stress(8) + strs6
+        stress(9) = stress(9) + strs9
+
+      endif
+      
+      return
+      end subroutine hkewald3
+
+      subroutine hkewald4(iatm,ik,engcpe,vircpe,engcpl,vircpl,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using the hautman-klein-ewald method
+c     
+c     modified to allow direct calculation of primary (short-range)
+c     interactions for multiple-time step corrections
+      
+c     primary neighbours are taken out of the Ewald sum
+c     electrostatics are evaluated directly instead
+c     
+c     parallel replicated data version - real space terms
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith july 2000
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,ik,m,jatm
+      real(8) engcpe,vircpe,engcpl,vircpl,rcut,epsq
+      real(8) fi,fli,rcsq,strs1,strs2,strs3,strs5,strs6
+      real(8) strs9,strl1,strl2,strl3,strl5,strl6,strl9,chgea,chgprd
+      real(8) rsq,rrr,coul,egamma,fx,fy,fz
+
+      dimension fi(3),fli(3)
+
+CDIR$ CACHE_ALIGN fi
+CDIR$ CACHE_ALIGN fli
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      engcpl=0.d0
+      vircpl=0.d0
+
+c     initialise stress tensor accumulators
+
+      strs1 = 0.d0
+      strs2 = 0.d0
+      strs3 = 0.d0
+      strs5 = 0.d0
+      strs6 = 0.d0
+      strs9 = 0.d0
+      strl1 = 0.d0
+      strl2 = 0.d0
+      strl3 = 0.d0
+      strl5 = 0.d0
+      strl6 = 0.d0
+      strl9 = 0.d0
+
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      if(abs(chgea).gt.1.d-10)then
+
+c     temporary arrays for cache aligning
+        
+        fi(1) = fxx(iatm)
+        fi(2) = fyy(iatm)
+        fi(3) = fzz(iatm)
+        
+        fli(1) = flx(iatm)
+        fli(2) = fly(iatm)
+        fli(3) = flz(iatm)
+
+        do m=1,ik
+
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          chgprd=chgea*chge(jatm)
+          
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+            if(rcsq.gt.rsq)then
+
+c     coulombic energy
+              
+              rrr = sqrt(rsq)
+              coul = chgprd/rrr
+
+c     sum contributions to the totals 
+              
+              engcpe = engcpe + coul
+              engcpl = engcpl - coul
+              vircpe = vircpe - coul
+              vircpl = vircpl + coul
+
+c     calculate coulombic forces
+              
+              egamma = coul/rsq
+
+              fx = egamma*xdf(m)
+              fy = egamma*ydf(m)
+              fz = egamma*zdf(m)
+
+c     add in contributions to instantaneous force
+              
+              fi(1) = fi(1) + fx
+              fi(2) = fi(2) + fy
+              fi(3) = fi(3) + fz
+              
+              fxx(jatm) = fxx(jatm) - fx
+              fyy(jatm) = fyy(jatm) - fy
+              fzz(jatm) = fzz(jatm) - fz
+
+c     add in contributions to the long-range force
+
+              fli(1) = fli(1) - fx
+              fli(2) = fli(2) - fy
+              fli(3) = fli(3) - fz
+              
+              flx(jatm) = flx(jatm) + fx
+              fly(jatm) = fly(jatm) + fy
+              flz(jatm) = flz(jatm) + fz
+
+c     calculate long and short range stress tensors
+              
+              strs1 = strs1 + xdf(m)*fx
+              strl1 = strl1 - xdf(m)*fx
+              strs2 = strs2 + xdf(m)*fy
+              strl2 = strl2 - xdf(m)*fy
+              strs3 = strs3 + xdf(m)*fz
+              strl3 = strl3 - xdf(m)*fz
+              strs5 = strs5 + ydf(m)*fy
+              strl5 = strl5 - ydf(m)*fy
+              strs6 = strs6 + ydf(m)*fz
+              strl6 = strl6 - ydf(m)*fz
+              strs9 = strs9 + zdf(m)*fz
+              strl9 = strl9 - zdf(m)*fz
+
+            endif
+
+          endif
+          
+        enddo
+
+c     copy back temporaries
+
+        fxx(iatm) = fi(1)
+        fyy(iatm) = fi(2)
+        fzz(iatm) = fi(3)
+
+        flx(iatm) = fli(1)
+        fly(iatm) = fli(2)
+        flz(iatm) = fli(3)
+
+c     complete stress tensor
+        
+        stresl(1) = stresl(1) + strl1
+        stresl(2) = stresl(2) + strl2
+        stresl(3) = stresl(3) + strl3
+        stresl(4) = stresl(4) + strl2
+        stresl(5) = stresl(5) + strl5
+        stresl(6) = stresl(6) + strl6
+        stresl(7) = stresl(7) + strl3
+        stresl(8) = stresl(8) + strl6
+        stresl(9) = stresl(9) + strl9
+        
+        stress(1) = stress(1) + strs1
+        stress(2) = stress(2) + strs2
+        stress(3) = stress(3) + strs3
+        stress(4) = stress(4) + strs2
+        stress(5) = stress(5) + strs5
+        stress(6) = stress(6) + strs6
+        stress(7) = stress(7) + strs3
+        stress(8) = stress(8) + strs6
+        stress(9) = stress(9) + strs9
+
+      endif
+      
+      return
+      end subroutine hkewald4
+
+      function cerfr(alpha,rrr)
+
+c***********************************************************************
+c     
+c     dl_poly function for generating complementary error function
+c     divided by r
+c     
+c     copyright - daresbury laboratory 2001
+c     author    - w. smith february 2001
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer k
+      real(8) cerfr,sqrpi,h0,h1,alpha,rrr,rr2,fac
+
+      sqrpi=1.7724538509055159d0
+
+c     starting values
+
+      h0=0.d0
+      h1=(2.d0*alpha/sqrpi)*exp(-(alpha*rrr)**2)
+
+c     generate function by recursion
+
+      rr2=rrr*rrr
+      do k=100,1,-1
+
+        fac=(2.d0*alpha**2)**(k-1)
+        h0=(h0*rr2+fac*h1)/dble(2*k-1)
+
+      enddo
+        
+      cerfr=1.d0/rrr-h0
+
+      return
+      end function cerfr
+      
+      end module hkewald_module
+
diff -urN dl_class_1.9.orig/srcmod/hyper_dynamics_module.f dl_class_1.9/srcmod/hyper_dynamics_module.f
--- dl_class_1.9.orig/srcmod/hyper_dynamics_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/hyper_dynamics_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,2821 @@
+      module hyper_dynamics_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining hyperdynamics routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use forces_module
+      use nlist_builders_module
+      use optimiser_module
+      use property_module
+      use setup_module
+      use shake_module
+      use temp_scalers_module
+      use vv_motion_module
+      
+      implicit none
+      
+      integer, parameter :: mxtrn=10
+      integer, parameter :: mxbsn=1000
+      integer, parameter :: mxneb=8
+      integer, parameter :: mxdiffs=300
+      integer, parameter :: hyper_tag=35000      
+      
+      integer numbsn,numpro,numtrk,ndiff,maxtrk,numdark,home_bsn,numbpd
+      integer nbsa(mxbsn),nbsb(mxbsn),ktrn(mxtrn)
+      real(8) xtrn(mxtrn),ytrn(mxtrn)
+      real(8) tstop,tkeres,timhyp,timres,tboost,boost,vbase
+      
+      integer, allocatable :: idabsn(:),keymin(:)
+      real(8), allocatable :: xbas(:),ybas(:),zbas(:)
+      real(8), allocatable :: xchk(:),ychk(:),zchk(:)
+      real(8), allocatable :: xres(:),yres(:),zres(:)
+      real(8), allocatable :: vxrs(:),vyrs(:),vzrs(:)
+      real(8), allocatable :: fxrs(:),fyrs(:),fzrs(:)
+      real(8), allocatable :: xhyp(:),yhyp(:),zhyp(:)
+      real(8), allocatable :: vxhp(:),vyhp(:),vzhp(:)
+      real(8), allocatable :: fxhp(:),fyhp(:),fzhp(:)
+      real(8), allocatable :: xdiffs(:),ydiffs(:),zdiffs(:)
+      real(8), allocatable :: celneb(:,:),path(:),optk(:,:)
+      real(8), allocatable :: xneb(:),yneb(:),zneb(:),engneb(:)
+      real(8), allocatable :: fxneb(:),fyneb(:),fzneb(:)
+      real(8), allocatable :: hxneb(:),hyneb(:),hzneb(:)
+      real(8), allocatable :: taux(:),tauy(:),tauz(:)
+      real(8), allocatable :: track(:)
+
+      integer bsn_1(maxneb),bsn_2(maxneb)
+      real(8) strhyp(9),strres(9),engbsn(2)
+      real(8) celbas(9),celhyp(9),celchk(9),celres(9)
+
+      save numbsn,numtrk,numpro,ndiff,numdark,timres
+      save xbas,ybas,zbas,xchk,ychk,zchk,timhyp,vbase
+      save xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs
+      save xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp
+      save celbas,celhyp,celres,celchk,strhyp,strres
+      save idabsn,nbsa,nbsb,xdiffs,ydiffs,zdiffs,tkeres
+      save xneb,yneb,zneb,engneb,taux,tauy,tauz,keymin
+      save fxneb,fyneb,fzneb,hxneb,hyneb,hzneb,path
+      save optk,tstop,tboost,boost,numbpd
+      
+      contains
+      
+      subroutine alloc_hyper_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining hyperdynamics arrays and
+c     initialising control variables
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      
+      integer i,fail,idnode,nebmax
+      dimension fail(nnn)
+      
+      nebmax=msatms*(mxneb+1)
+      
+c     initialise control variables
+      
+      numbpd=0
+      numtrk=0
+      numbsn=0
+      numpro=0
+      ndiff=0
+      numdark=0
+      home_bsn=0
+      tkeres=0.d0
+      tstop=1.d30
+      timhyp=0.d0
+      timres=0.d0
+      boost=1.d0
+      tboost=0.d0
+      vbase=-huge(1.d0)
+      do i=1,maxneb
+        bsn_1(i)=0
+        bsn_2(i)=0
+      enddo
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (xbas(msatms),ybas(msatms),zbas(msatms),stat=fail(1))
+      allocate (xchk(msatms),ychk(msatms),zchk(msatms),stat=fail(2))
+      allocate (xres(msatms),yres(msatms),zres(msatms),stat=fail(3))
+      allocate (vxrs(msatms),vyrs(msatms),vzrs(msatms),stat=fail(4))
+      allocate (fxrs(msatms),fyrs(msatms),fzrs(msatms),stat=fail(5))
+      allocate (xhyp(msatms),yhyp(msatms),zhyp(msatms),stat=fail(6))
+      allocate (vxhp(msatms),vyhp(msatms),vzhp(msatms),stat=fail(7))
+      allocate (fxhp(msatms),fyhp(msatms),fzhp(msatms),stat=fail(8))
+      allocate (xdiffs(mxdiffs),ydiffs(mxdiffs),zdiffs(mxdiffs),
+     x  stat=fail(9))
+      allocate (idabsn(mxdiffs),keymin(0:mxneb),stat=fail(10))
+      allocate (xneb(nebmax),yneb(nebmax),zneb(nebmax),stat=fail(11))
+      allocate (fxneb(nebmax),fyneb(nebmax),fzneb(nebmax),stat=fail(12))
+      allocate (taux(msatms),tauy(msatms),tauz(msatms),stat=fail(13))
+      allocate (engneb(0:mxneb),celneb(9,0:mxneb),path(0:mxneb),
+     x  stat=fail(14))
+      allocate (hxneb(nebmax),hyneb(nebmax),hzneb(nebmax),stat=fail(15))
+      allocate (optk(5,0:mxneb),stat=fail(16))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)then
+          if(idnode.eq.0)write(nrite,'(10i5)')fail
+          call error(idnode,1115)
+        endif
+      enddo
+      
+      end subroutine alloc_hyper_arrays
+      
+      subroutine hyper_start
+     x  (ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x  imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x  mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,
+     x  nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,
+     x  ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,ntcons,ntrack,alpha,
+     x  delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol,rctter,
+     x  rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,sigma,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for starting a hyperdynamics simulation
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,savflg
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,i,j
+      integer ntpvdw,ntshl,ntteth,numblock,iatm0,iatm1,ntcons
+      integer ktol,pass,fail,ntrack
+      real(8) alpha,delr,dlrpot,drewd,elrc,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,engcfg
+      real(8) virlrc,cvgerr,dum,otol,cgerr,sigma,hyp_units
+      
+c     allocate track array for BPD
+
+      if(lbpd)then
+        allocate (track(0:nblock/ntrack),stat=fail)
+      endif
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     current block number
+      
+      numblock=nstep/nblock
+      
+c     open hyperdynamics journal file
+      
+      if(idnode.eq.0)
+     x  open(nevnt,file="EVENTS",form='formatted',position='append')
+      
+c     set up hyperdynamics for simulation start
+      
+      if(nstep.eq.0)then
+        
+c     initialise bias potential boost factor
+      
+        numbpd=0
+        boost=1.d0
+        tboost=0.d0
+      
+c     set basin difference markers
+        
+        do i=1,mxbsn
+          
+          nbsa(i)=0
+          nbsb(i)=0
+          
+        enddo
+         
+c     store the starting configuration
+        
+        savflg=.true.
+        tkeres=sigma
+        call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x    xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+        
+c     minimise starting structure
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,engcfg,cvgerr)
+        
+c     define zero energy for BPD dynamics mode
+        
+        vbase=engcfg
+        
+c     write events entry for minimisation
+        
+        if(idnode.eq.0)then
+          
+          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      engcfg/hyp_units,cvgerr/hyp_units
+          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      engcfg/hyp_units,cvgerr/hyp_units
+          write(nrite,"(1x,120('-'))")
+          
+        endif
+      
+c     save minimised starting structure as basin file
+        
+        call write_reference_config
+     x    ('CFGBSN','BASINS',nbsn,numbsn,natms,imcon,idnode,engcfg)
+        
+c     save details of starting home basin
+        
+        engbsn(1)=engcfg
+        
+        do i=1,9
+          celbas(i)=cell(i)
+        enddo
+        
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xbas(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ybas(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zbas(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+c     restore the starting configuration
+        
+        savflg=.false.
+        call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x    xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+        
+      else
+        
+c     restore previous data from hyperdynamics backup file
+      
+        call hyper_open(ltad,idnode,mxnode,natms,nsteql)
+                
+c     reset home basin for hyperdynamics (home basin is 0 for TAD)
+        
+        if(lbpd)home_bsn=numbsn-1
+        
+c     store the current configuration
+        
+        savflg=.true.
+        call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x    xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+        
+c     read minimised starting structure from home basin file
+      
+        call read_reference_config
+     x    ('CFGBSN','BASINS',nbsn,home_bsn,natms,imcon,idnode,engcfg)
+        
+c     save details of current home basin
+        
+        engbsn(1)=engcfg
+        
+        do i=1,9
+          celbas(i)=cell(i)
+        enddo
+        
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xbas(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ybas(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zbas(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+c     restore the current configuration
+        
+        savflg=.false.
+        call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x    xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+        
+      endif
+      
+      return
+      end subroutine hyper_start
+      
+      subroutine hyper_driver
+     x  (seek,ltad,lbpd,recycle,lfcap,lneut,lnsq,loglnk,lzeql,
+     x  newlst,prechk,tadall,nebgo,nblock,ntrack,idnode,imcon,
+     x  keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x  mxnode,natms,ngrp,ntcons,nhko,nlatt,nneut,nospl,nscons,
+     x  nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x  ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,blkout,
+     x  alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x  opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x  tstep,volm,engcfg,catchrad,sprneb,deltad,tlow,engtke,
+     x  tolnce,hyp_units,ebias,vmin)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for implementing a hyperdynamics simulation
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+
+      character*8 seek
+      logical lbpd,ltad,lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb
+      logical lrefmin,same,savflg,recycle,scan,prechk,tadall,nebgo
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol,ntrack
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw
+      integer ntshl,ntteth,blkout,numblock,bsn1,bsn2,itrack
+      integer nturn,ntcons,mdiff,newbsn,iatm0,iatm1,pass,i,j,itrk
+      real(8) alpha,delr,dlrpot,drewd,elrc,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,catchrad
+      real(8) cvgerr,estar,engcfg,cfgtmp,engcpe,engsrp,catch
+      real(8) vircpe,engmet,virmet,virlrc,engtbp,virtbp,dum
+      real(8) engfbp,virfbp,engter,virter,engbnd,virbnd,engang
+      real(8) virang,engdih,virdih,enginv,virinv,engtet,virtet
+      real(8) engshl,shlke,virshl,engfld,virfld,virsrp,sprneb
+      real(8) deltad,deltal,tlow,timhop,timlow,engtke,tolnce,hyp_units
+      real(8) ebias,vmin
+      
+      data bsn1,bsn2/0,0/
+      
+c     control variables
+      
+      lneb=.false.
+      numblock=nstep/nblock
+      maxtrk=nblock/ntrack
+      if(numdark.eq.0)numdark=nsteql
+      lrefmin=(mod(nstep,nblock).eq.0)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     BPD/TAD simulation time
+      
+      timhyp=timhyp+tstep
+      
+c     track the tboost value
+      
+      if(mod(nstep,ntrack).eq.0)track(mod(numtrk,maxtrk))=tboost
+      
+c     provisional check for transition - compare current config with 
+c     the reference state (not in dark period)
+      
+      same=.true.
+      scan=.false.
+      if(prechk.and.(mod(nstep,ntrack).eq.0).and.
+     x  (lbpd.or.(ltad.and.(nstep.gt.numdark))))then
+        
+        catch=0.65d0*catchrad
+        call check_for_transition
+     x    (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x    catch)
+        
+        if(.not.same.and.idnode.eq.0)then
+          
+          write(nevnt,'("PRE",i10)')nstep
+          write(nrite,'(1x,"PRE",i10)')nstep
+          write(nrite,"(1x,120('-'))")
+        
+        endif
+        
+      endif
+      
+      if(.not.same.or.lrefmin)then
+        
+c     store the current configuration
+        
+        savflg=.true.
+        call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x    xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+        
+c     minimise current structure
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr)
+        
+c     write events entry for minimisation
+      
+        if(idnode.eq.0)then
+          
+          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,"(1x,120('-'))")
+          
+        endif
+        
+c     confirm any transition
+        
+        if(ltad)scan=.true.
+        call check_for_transition
+     x    (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x    catchrad)
+        
+c     transition detected - proceed with transition analysis
+        
+        if(.not.same)then
+          
+c     store new basin energy
+          
+          engbsn(2)=cfgtmp
+          
+c     save new minimised state (bias potential dynamics only)
+          
+          if(lbpd)then
+            
+            do i=1,9
+              celres(i)=cell(i)
+            enddo
+            
+            j=0
+            do i=iatm0,iatm1
+              
+              j=j+1
+              xres(j)=xxx(i)
+              yres(j)=yyy(i)
+              zres(j)=zzz(i)
+              
+            enddo
+
+          endif
+          
+c     record transition (for TAD only if outside blackout period)
+          
+          if(lbpd.or.nstep.gt.numdark)then
+            
+c     check if transition results in unique new basin (TAD only)
+            
+            if(ltad)call check_basins(newbsn,mdiff,mxnode)
+            
+c     analysis of new basin
+            
+            if(lbpd.or.tadall.or.newbsn.eq.numbsn)then
+              
+c     set difference counters and pointers (TAD only)
+              
+              if(ltad)then
+                
+                if(numbsn.gt.mxbsn)call error(idnode,2330)
+              
+                ndiff=mdiff
+                
+                if(numbsn.gt.1)then
+                  nbsa(numbsn)=nbsb(numbsn-1)+1
+                else
+                  nbsa(numbsn)=1
+                endif
+                
+                nbsb(numbsn)=mdiff
+                
+              endif
+              
+c     save the basin file and store basin energy
+              
+              call write_reference_config
+     x          ('CFGBSN','BASINS',nbsn,numbsn,natms,imcon,idnode,
+     x          cfgtmp)
+              
+c     determine minimum (reaction) path and activation energy
+              
+              if(nebgo)call neb_driver
+     x          (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn1,
+     x          bsn2,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x          keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x          ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x          keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x          ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x          rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x          engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x          engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x          engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x          virtet,engshl,shlke,virshl,engfld,virfld,cfgtmp,fmax,
+     x          temp,tstep,opttol,sprneb,hyp_units)
+              
+c     analyse the transition - determine e-star and destination state
+              
+              if(nebgo)call transition_properties
+     x          (seek,ltad,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,
+     x          idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x          kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x          nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x          ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x          ntpvdw,ntshl,ntteth,nturn,numbsn,alpha,delr,dlrpot,
+     x          drewd,elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x          rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr,estar,
+     x          catchrad,hyp_units)
+              
+c     estimate time of transition from past trajectory
+              
+              call transition_time
+     x          (seek,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,
+     x          idnode,imcon,keyfce,keyfld,keyshl,keytol,kmax1,
+     x          kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x          nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,
+     x          ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,
+     x          ntpter,ntrack,ntpvdw,ntshl,ntteth,ntcons,itrk,
+     x          alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x          opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x          tstep,volm,cfgtmp,cvgerr,catchrad,timhop,hyp_units)
+              
+c     update TAD control variables
+              
+              if(ltad)then
+                
+c     update blackout period
+                
+                numdark=nblock*((nstep+blkout)/nblock+1)
+                
+c     calculate stopping time
+                
+                timlow=timhop*exp(-(estar/temp-estar/tlow)/boltz)
+                tstop=min(tstop,deltad*(timlow/deltad)**(tlow/temp))
+                
+c     write transition data for TAD only
+                
+                if(idnode.eq.0)then
+                  
+                  write(nevnt,'("TRA",i10,3i6,1p,4e14.5)')
+     x              nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x              timhop,timlow,tstop
+                  write(nevnt,'("BLK",2i10)')nstep,numdark
+                  write(nrite,'(1x,"TRA",i10,3i6,1p,4e14.5)')
+     x              nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x              timhop,timlow,tstop
+                  write(nrite,'(1x,"BLK",2i10)')nstep,numdark
+                  write(nrite,"(1x,120('-'))")
+                  
+                endif
+                
+              elseif(nebgo.and.idnode.eq.0)then
+                
+c     write transition data for bias potential dynamics with NEB
+                
+                write(nevnt,'("TRA",i10,3i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,'(1x,"TRA",i10,3i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,"(1x,120('-'))")
+                
+                numbpd=0
+                tboost=0.0
+                
+              elseif(idnode.eq.0)then
+                
+c     write transition data for bias potential dynamics without NEB
+                
+                write(nevnt,'("TRA",i10,2i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,ebias/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,'(1x,"TRA",i10,2i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,ebias/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,"(1x,120('-'))")
+                
+                numbpd=0
+                tboost=0.0
+                
+              endif
+              
+            else
+              
+c     update blackout period when transition not unique (TAD only)
+              
+              numdark=nblock*((nstep+blkout)/nblock+1)
+              
+              if(idnode.eq.0)then
+                
+                write(nevnt,'("TRR",i10,3i6)')nstep,home_bsn,newbsn
+                write(nevnt,'("BLK",2i10)')nstep,numdark
+                write(nrite,'(1x,"TRR",i10,3i6)')nstep,home_bsn,newbsn
+                write(nrite,'(1x,"BLK",2i10)')nstep,numdark
+                write(nrite,"(1x,120('-'))")
+                
+              endif
+              
+            endif
+            
+c     actions when new basin has been visited before (TAD only)
+            
+          elseif(ltad)then
+            
+c     ignore dark transition and extend blackout period (TAD only)
+            
+            if(idnode.eq.0)then
+              
+              write(nevnt,'("TRI",i10)')nstep
+              write(nrite,'(1x,"TRI",i10)')nstep
+              write(nrite,"(1x,120('-'))")
+              
+            endif
+            
+            if(nstep.le.nsteql)then
+              
+              nsteql=nsteql+blkout
+              numdark=nsteql+blkout
+              if(idnode.eq.0)then
+                
+                write(nevnt,'("EQL",2i10)')nstep,nsteql
+                write(nrite,'(1x,"EQL",2i10)')nstep,nsteql
+                write(nrite,"(1x,120('-'))")
+                
+              endif
+              
+            else
+              
+              numdark=nblock*((nstep+blkout)/nblock+1)
+              if(idnode.eq.0)then
+                
+                write(nevnt,'("BLK",3i10)')nstep,numdark
+                write(nrite,'(1x,"BLK",3i10)')nstep,numdark
+                write(nrite,"(1x,120('-'))")
+                
+              endif
+              
+            endif
+            
+          endif
+          
+          if(ltad)then
+            
+c     return to the block starting state after transition (TAD only)
+            
+            timhyp=timres
+            savflg=.false.
+            call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x        xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+            
+c     scramble the velocities (and conserve system energy)
+            
+            call regauss(idnode,imcon,mxnode,natms,ngrp,nscons,ntcons,
+     x        ntshl,keyshl,tkeres,temp,tolnce)
+          
+          elseif(lbpd)then
+            
+c     reset reference state to new basin (bias potential dynamics only)
+            
+            home_bsn=home_bsn+1
+            engbsn(1)=engbsn(2)
+      
+            do i=1,9
+              celbas(i)=celres(i)
+            enddo
+            
+            call invert(celbas,rcell,dum)
+            
+            do i=1,iatm1-iatm0+1
+              
+              xbas(i)=rcell(1)*xres(i)+rcell(4)*yres(i)+rcell(7)*zres(i)
+              ybas(i)=rcell(2)*xres(i)+rcell(5)*yres(i)+rcell(8)*zres(i)
+              zbas(i)=rcell(3)*xres(i)+rcell(6)*yres(i)+rcell(9)*zres(i)
+              
+            enddo
+            
+c     restore current hyperdynamics configuration
+            
+            savflg=.false.
+            call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x        xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+            
+c     reset boost factor
+            
+            numbpd=0
+            tboost=0.d0
+            
+          endif
+          
+c     no transition detected so restore current trajectory
+          
+        else
+          
+c     restore the current configuration
+          
+          savflg=.false.
+          call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x      xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+          
+c     save the block configuration as reset state (TAD only)
+          
+          if(ltad.and.lrefmin)then
+            
+            savflg=.true.
+            tkeres=engtke
+            timres=timhyp
+            call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x        xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     close down if TAD stopping time reached
+      
+      if(ltad.and.tstop.lt.timhyp)recycle=.false.
+            
+c     write a tracking file
+      
+      if(mod(nstep,ntrack).eq.0)then
+        
+        itrack=mod(numtrk,maxtrk)
+        call write_reference_config
+     x    ('CFGTRK','TRACKS',ntrk,itrack,natms,imcon,idnode,engcfg)
+
+        numtrk=numtrk+1
+        
+      endif
+      
+      return
+      end subroutine hyper_driver
+      
+      subroutine define_minimum_state
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x  idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x  kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x  nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x  ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x  ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x  elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x  rcuttb,rprim,rvdw,temp,tstep,volm,engcfg,cvgerr)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls for a
+c     structural minimisation to define a minimum state for
+c     hyperdynamics simulations
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lfcap,nogofr,lneut,lnsq,loglnk,stropt,lzeql
+      logical newlst,ltad,lsolva,lfree,lexcite
+
+      integer idnode,imcon,keyfce,keyfld,keyshl,keytol
+      integer keystr,kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp
+      integer nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf
+      integer nblock,pass,mxpass,mstep,ntcons,nsolva,isolva
+
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp
+      real(8) virtbp,virter,virtet,volm,engmet,cfgold,cvgerr
+      real(8) hnorm,grad0,grad1,ff1,sgn,engord,virord
+      
+      data mxpass/1000/
+      
+c     control variables
+      
+      pass=0
+      keystr=0
+      numrdf=0
+      ltad=.true.
+      engcfg=1.d30
+      stropt=.false.
+      nogofr=.false.
+      
+c     dummy variables
+      
+      lsolva=.false.
+      lfree=.false.
+      lexcite=.false.
+      nsolva=0
+      isolva=1
+      engord=0.d0
+      virord=0.d0
+      
+c     relax the current structure
+      
+      do while(.not.stropt.and.pass.lt.mxpass)
+        
+        pass=pass+1
+        cfgold=engcfg
+        mstep=nstep+pass
+
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,nogofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lexcite,idnode,mxnode,natms,imcon,mstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     structure optimisation
+        
+        call strucopt
+     x    (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x    imcon,ngrp,ntfree,tstep,opttol,engcfg,hnorm,grad0,grad1,
+     x    ff1,sgn)
+        
+        cvgerr=abs(engcfg-cfgold)
+        
+      enddo
+            
+      return
+      end subroutine define_minimum_state
+      
+      subroutine write_reference_config
+     x  (fnam,direct,nfil,nnn,natms,imcon,idnode,engcfg)
+      
+c***********************************************************************
+c     
+c     dlpoly utility to write a minimum structure file in CONFIG
+c     format
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  june 2006
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      character*6 fnam
+      character*4 tail
+      character*6 direct
+      integer nfil,nnn,i,natms,imcon,idnode,levcfg
+      real(8) engcfg
+      
+      levcfg=0
+      
+c     node zero handles i/o
+      
+      if(idnode.eq.0)then
+        
+c     write configuration data to new configuration file
+        
+        write(tail,'(i4.4)')nnn
+        open(nfil,file=direct//'/'//fnam//tail,form='formatted')
+        
+        write(nfil,'(a10)')fnam//tail
+        write(nfil,'(3i10,g20.12)') levcfg,imcon,natms,engcfg
+
+        if(imcon.gt.0) write(nfil,'(3f20.12)') cell
+        
+        do i=1,natms
+          
+          write(nfil,'(a8,i10)') atmnam(i),i
+          write(nfil,'(3g20.10)') xxx(i),yyy(i),zzz(i)
+          
+        enddo
+        
+        close (nfil)
+        
+      endif
+      
+      nnn=nnn+1
+      
+      return
+      end subroutine write_reference_config
+      
+      subroutine read_reference_config
+     x  (fnam,direct,nfil,nnn,natms,imcon,idnode,engcfg)
+      
+c***********************************************************************
+c     
+c     dlpoly utility to read a reference structure file in CONFIG
+c     format
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  february 2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      character*6 fnam
+      character*4 tail
+      character*6 direct
+      integer nfil,nnn,i,natms,imcon,idnode,levcfg
+      real(8) engcfg
+      
+c     node zero handles i/o
+      
+      if(idnode.eq.0)then
+        
+c     read configuration data from configuration file on proc 0
+        
+        write(tail,'(i4.4)')nnn
+        open(nfil,file=direct//'/'//fnam//tail,form='formatted')
+        
+        read(nfil,*)
+        read(nfil,'(3i10,g20.12)')levcfg,imcon,natms,engcfg
+        buffer(1)=dble(levcfg)
+        buffer(2)=dble(imcon)
+        buffer(3)=dble(natms)
+        buffer(4)=engcfg
+        if(imcon.gt.0) read(nfil,'(3f20.12)') cell
+        do i=1,9
+          buffer(i+4)=cell(i)
+        enddo
+        call gdsum(buffer(1),13,buffer(14))
+        
+        do i=1,natms
+          
+          read(nfil,'(a8)') atmnam(i)
+          read(nfil,'(3g20.10)') xxx(i),yyy(i),zzz(i)
+          
+        enddo
+        
+        close (nfil)
+        
+      else
+        
+c     gather data from configuration file on procs > 0
+        
+        do i=1,13
+          buffer(i)=0.d0
+        enddo
+        call gdsum(buffer(1),13,buffer(14))
+
+        levcfg=nint(buffer(1))
+        imcon=nint(buffer(2))
+        natms=nint(buffer(3))
+        engcfg=buffer(4)
+        do i=1,9
+          cell(i)=buffer(i+4)
+        enddo
+        do i=1,natms
+          xxx(i)=0.d0
+          yyy(i)=0.d0
+          zzz(i)=0.d0
+        enddo
+        
+      endif
+      
+c     global gather of atomic coordinates
+      
+      call gdsum(xxx,natms,buffer)
+      call gdsum(yyy,natms,buffer)
+      call gdsum(zzz,natms,buffer)
+      
+      return
+      end subroutine read_reference_config
+      
+      subroutine store_config(lsave,idnode,mxnode,natms,strold,celold,
+     x  xold,yold,zold,vxold,vyold,vzold,fxold,fyold,fzold)
+
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for storing the current 
+c     configuration
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  sep  2006
+c     
+c**********************************************************************
+      
+      implicit none
+
+      logical lsave
+      integer idnode,mxnode,natms,iatm0,iatm1,i,j
+      
+      real(8) strold(9),celold(9)
+      real(8) xold(msatms),yold(msatms),zold(msatms)
+      real(8) vxold(msatms),vyold(msatms),vzold(msatms)
+      real(8) fxold(msatms),fyold(msatms),fzold(msatms)
+      
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+      if(lsave)then
+        
+c     save cell and stress tensors
+        
+        do i=1,9
+          
+          celold(i)=cell(i)
+          strold(i)=stress(i)
+          
+        enddo
+        
+c     save configuration
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xold(j)=xxx(i)
+          yold(j)=yyy(i)
+          zold(j)=zzz(i)
+          vxold(j)=vxx(i)
+          vyold(j)=vyy(i)
+          vzold(j)=vzz(i)
+          fxold(j)=fxx(i)
+          fyold(j)=fyy(i)
+          fzold(j)=fzz(i)
+          
+        enddo
+        
+      else
+        
+c     restore cell and stress tensors
+        
+        do i=1,9
+          
+          cell(i)=celold(i)
+          stress(i)=strold(i)
+          
+        enddo
+        
+c     restore configuration
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xxx(i)=xold(j)
+          yyy(i)=yold(j)
+          zzz(i)=zold(j)
+          vxx(i)=vxold(j)
+          vyy(i)=vyold(j)
+          vzz(i)=vzold(j)
+          fxx(i)=fxold(j)
+          fyy(i)=fyold(j)
+          fzz(i)=fzold(j)
+          
+        enddo
+        
+c     replication of full configuration data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call merge(idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine store_config
+      
+      subroutine check_for_transition
+     x  (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x  catchrad)
+      
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for checking when a transition
+c     has occured in a configuration
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  sep  2006
+c     
+c**********************************************************************
+      
+      implicit none
+
+      character*8 seek
+      logical same,safe,scan,all
+      integer idnode,mxnode,natms,imcon,nblock,mdiff
+      integer iatm0,iatm1,i,j
+      real(8) catchrad,catch2,rr2,dum,sxx,syy,szz,txx,tyy,tzz,pp2
+      
+      all=(seek.eq.'all     ')
+      
+c     flag for comparing structures
+      
+      same=.true.
+      
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise search parameters
+      
+      catch2=catchrad**2
+      
+c     construct coordinate check arrays
+
+      do i=1,9
+        celchk(i)=cell(i)
+      enddo
+
+c     store structure in reduced coordinates (target atoms only)
+      
+      call invert(cell,rcell,dum)
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        
+        if(all.or.atmnam(i).eq.seek)then
+          
+          xchk(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ychk(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zchk(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        endif
+        
+      enddo
+      
+c     compare current structure with reference basin
+      
+      j=0
+      pp2=0.d0
+      safe=.true.
+      mdiff=ndiff
+      do i=iatm0,iatm1
+        
+        j=j+1
+        
+        if(all.or.atmnam(i).eq.seek)then
+          
+c     calculate separations in reduced units
+          
+          sxx=xchk(j)-xbas(j)
+          syy=ychk(j)-ybas(j)
+          szz=zchk(j)-zbas(j)
+          
+c     calculate minimum image separations
+          
+          sxx=sxx-nint(sxx)
+          syy=syy-nint(syy)
+          szz=szz-nint(szz)
+          
+c     set trial structure at minimum displacements from reference
+          
+          xchk(j)=xbas(j)+sxx
+          ychk(j)=ybas(j)+syy
+          zchk(j)=zbas(j)+szz
+          
+c     calculate atomic separations in real coordinates
+          
+          txx=(celchk(1)*xchk(j)+celchk(4)*ychk(j)+celchk(7)*zchk(j))
+     x      -(celbas(1)*xbas(j)+celbas(4)*ybas(j)+celbas(7)*zbas(j))
+          tyy=(celchk(2)*xchk(j)+celchk(5)*ychk(j)+celchk(8)*zchk(j))
+     x      -(celbas(2)*xbas(j)+celbas(5)*ybas(j)+celbas(8)*zbas(j))
+          tzz=(celchk(3)*xchk(j)+celchk(6)*ychk(j)+celchk(9)*zchk(j))
+     x      -(celbas(3)*xbas(j)+celbas(6)*ybas(j)+celbas(9)*zbas(j))
+          
+c     calculate total structural difference
+          
+          rr2=txx**2+tyy**2+tzz**2
+          pp2=max(pp2,rr2)
+          
+c     identify and store the displaced atoms
+          
+          if(scan.and.rr2.ge.catch2)then
+            
+            mdiff=mdiff+1
+            
+            if(mdiff.le.mxdiffs)then
+              
+              idabsn(mdiff)=i
+              xdiffs(mdiff)=txx
+              ydiffs(mdiff)=tyy
+              zdiffs(mdiff)=tzz
+              
+            else
+              
+              safe=.false.
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     global check on diffs arrays
+      
+      if(scan)then
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'number of current diffs',i10)")mdiff
+          call error(idnode,2340)
+          
+        endif
+        
+      endif
+      
+c     global transition check
+      
+      same=(pp2.lt.catch2)
+      if(mxnode.gt.1)call gstate(same)
+      
+      return
+      end subroutine check_for_transition
+      
+      subroutine check_basins(newbsn,mdiff,mxnode)
+      
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for checking that a new basin is not
+c     one already known
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  jan  2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      logical same
+      integer newbsn,ia,ib,ic,id,ibsn,i,j,k,mxnode,mdiff
+      
+      ibsn=1
+      newbsn=0
+      ib=mdiff
+      ia=ndiff+1
+      same=.false.
+      do while(.not.same.and.ibsn.lt.numbsn)
+        
+        ic=nbsa(ibsn)
+        id=nbsb(ibsn)
+        
+        if(ib-ia.eq.id-ic)then
+          
+          same=.true.
+          
+          do k=0,ib-ia
+            
+            i=ia+k
+            j=ic+k
+            
+            if(.not.((idabsn(i).eq.idabsn(j)).and.
+     x        (abs(xdiffs(i)-xdiffs(j)).lt.0.1d0).and.
+     x        (abs(ydiffs(i)-ydiffs(j)).lt.0.1d0).and.
+     x        (abs(zdiffs(i)-zdiffs(j)).lt.0.1d0)))same=.false.
+            
+          enddo
+          
+        endif
+        
+c     check if same on all processors
+        
+        if(mxnode.gt.1)call gstate(same)
+        if(same)newbsn=ibsn
+        
+        ibsn=ibsn+1
+        
+      enddo
+      
+c     if not same - must be new basin!
+      
+      if(.not.same)newbsn=numbsn
+      
+      return
+      end subroutine check_basins
+      
+      subroutine neb_driver
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn1,
+     x  bsn2,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x  ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x  keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x  ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x  rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x  engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x  engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x  engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x  virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x  temp,tstep,opttol,sprneb,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling a nudged elastic band 
+c     calculation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lneb,newlst,lneut,lnsq,stropt
+      logical lzeql,loglnk,lfcap
+      integer idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,mstep
+      integer keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw
+      integer ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl
+      integer keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nscons
+      integer ngrp,keytol,ntfree,iatm0,iatm1,iatm2,ntcons
+      integer i,j,k,n,pass,mxpass,nkinks,bsn1,bsn2,itrk
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtet,virtet,engshl
+      real(8) shlke,virshl,engfld,virfld,engcfg,fmax,temp,tstep
+      real(8) sprneb,opttol,hyp_units,fac,xxn,yyn,zzn,tol,cvg,dum
+      
+      data mxpass/100/
+      
+c     control variables
+      
+      stropt=.false.
+      do n=0,mxneb
+        
+        keymin(n)=0
+        do i=1,5
+          optk(i,n)=0.d0
+        enddo
+        
+      enddo
+      if(lneb)numpro=-(100*bsn1+bsn2)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     read in the required start and end point configurations
+      
+      if(lneb)then
+        
+c     read data for first reference structure
+        
+        call read_reference_config
+     x    ('CFGBSN','BASINS',nbsn,bsn1,natms,imcon,idnode,engcfg)
+
+        engbsn(1)=engcfg
+        
+        do i=1,9
+          celbas(i)=cell(i)
+        enddo
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xbas(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ybas(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zbas(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+c     read data for second reference structure
+        
+        call read_reference_config
+     x    ('CFGBSN','BASINS',nbsn,bsn2,natms,imcon,idnode,engcfg)
+
+        engbsn(2)=engcfg
+        
+        do i=1,9
+          celchk(i)=cell(i)
+        enddo
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xchk(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ychk(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zchk(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+      endif
+      
+c     construct initial `bead' configurations in chain
+      
+      k=0
+      do n=0,mxneb
+        
+        j=0
+        fac=dble(n)/dble(mxneb)
+        
+c     construct linear mix of cell vectors
+        
+        do i=1,9
+          celneb(i,n)=(1.d0-fac)*celbas(i)+fac*celchk(i)
+        enddo
+        
+c     construct beads by linear interpolation
+        
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+
+          xxn=xbas(j)+fac*((xchk(j)-xbas(j))-nint(xchk(j)-xbas(j)))
+          yyn=ybas(j)+fac*((ychk(j)-ybas(j))-nint(ychk(j)-ybas(j)))
+          zzn=zbas(j)+fac*((zchk(j)-zbas(j))-nint(zchk(j)-zbas(j)))
+          xneb(k)=celneb(1,n)*xxn+celneb(4,n)*yyn+celneb(7,n)*zzn
+          yneb(k)=celneb(2,n)*xxn+celneb(5,n)*yyn+celneb(8,n)*zzn
+          zneb(k)=celneb(3,n)*xxn+celneb(6,n)*yyn+celneb(9,n)*zzn
+  
+        enddo
+        
+      enddo
+      
+c     start of NEB optimisation
+      
+      pass=0
+      safe=.false.
+      do while(.not.safe.and.pass.lt.mxpass)
+        
+        pass=pass+1
+        safe=.true.
+        mstep=nstep+pass
+        
+c     calculate system forces on all beads
+        
+        call neb_system_forces
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,mxnode,
+     x    natms,mstep,imcon,nstbgr,nsteql,keyfce,kmax1,kmax2,
+     x    kmax3,nhko,nlatt,ntpvdw,ntpmet,nospl,multt,nneut,ntptbp,
+     x    ntpfbp,ntpter,keyshl,keyfld,ntbond,ntangl,ntdihd,ntinv,
+     x    ntteth,ntshl,delr,dlrpot,engcpe,engsrp,epsq,
+     x    rcut,rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x    engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x    engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x    engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x    virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x    temp,tstep)
+        
+c     calculate spring forces on all beads
+        
+        call neb_spring_forces(idnode,mxnode,natms,nkinks,sprneb)
+        
+c     energy minimisation of each bead
+        
+        do n=0,mxneb
+          
+c     construct cell vectors for nth bead
+          
+          do i=1,9
+            cell(i)=celneb(i,n)
+          enddo
+          
+c     construct coordinate and force arrays for nth bead
+          
+          k=n*iatm2
+          do i=iatm0,iatm1
+            
+            k=k+1
+            xxx(i)=xneb(k)
+            yyy(i)=yneb(k)
+            zzz(i)=zneb(k)
+            fxx(i)=fxneb(k)
+            fyy(i)=fyneb(k)
+            fzz(i)=fzneb(k)
+            
+          enddo
+          
+c     restore search direction vector if keymin > 0
+          
+          if(keymin(n).gt.0)then
+            
+            k=n*iatm2
+            do i=iatm0,iatm1
+              
+              k=k+1
+              hhx(i)=hxneb(k)
+              hhy(i)=hyneb(k)
+              hhz(i)=hzneb(k)
+              
+            enddo
+            
+          endif
+          
+c     form complete global arrays
+          
+          if(mxnode.gt.1)then
+            
+            call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+            call merge(idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+            if(keymin(n).gt.0)
+     x        call merge(idnode,mxnode,natms,mxbuff,hhx,hhy,hhz,buffer)
+            
+          endif
+          
+c     structure optimisation
+          
+          call strucopt
+     x      (stropt,keymin(n),keytol,idnode,mxnode,natms,ntcons,nscons,
+     x      imcon,ngrp,ntfree,tstep,10.d0*opttol,engneb(n),optk(1,n),
+     x      optk(2,n),optk(3,n),optk(4,n),optk(5,n))
+          safe=safe.and.stropt
+          stropt=.false.
+          
+c     update coordinate arrays for nth bead
+          
+          k=n*iatm2
+          do i=iatm0,iatm1
+            
+            k=k+1
+            xneb(k)=xxx(i)
+            yneb(k)=yyy(i)
+            zneb(k)=zzz(i)
+            hxneb(k)=hhx(i)
+            hyneb(k)=hhy(i)
+            hzneb(k)=hhz(i)
+            
+          enddo
+          
+        enddo
+        
+      enddo
+      
+c     convergence check
+      
+c$$$      if(.not.safe)then
+c$$$        
+c$$$        call error(idnode,2320)
+c$$$        
+c$$$      else
+      
+c     save neb profile
+        
+        call write_profile(idnode,mxnode,natms,hyp_units)
+        
+c     write neb summary
+        
+        if(idnode.eq.0)then
+          
+          if(lneb)then
+            
+            write(nrite,'(/,1x,"summary of NEB calculation",/)')
+            write(nrite,'(1x,"path and energy for state",i4,
+     x        " ---> state",i4," transition")')bsn1,bsn2
+            write(nrite,'(1x,"convergence status :",l4)')safe
+            write(nrite,'(1x,"obtained after ",i4," iterations",/)')pass
+             
+            do n=0,mxneb
+              write(nrite,'(6x,1p,2e14.6)')path(n),engneb(n)/hyp_units
+            enddo
+           
+          else
+            
+            write(nevnt,'("NEB",i10,3i6,1p,2e14.5)')
+     x        nstep,pass,mxpass,mxneb+1,engbsn(1)/hyp_units,
+     x        engbsn(2)/hyp_units
+            write(nrite,'(1x,"NEB",i10,3i6,1p,2e14.5)')
+     x        nstep,pass,mxpass,mxneb+1,engbsn(1)/hyp_units,
+     x        engbsn(2)/hyp_units
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+        endif
+        
+c$$$      endif
+      
+c     end of NEB optimisation
+      
+      return
+      end subroutine neb_driver
+      
+      subroutine neb_system_forces
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,mxnode,
+     x  natms,mstep,imcon,nstbgr,nsteql,keyfce,kmax1,kmax2,
+     x  kmax3,nhko,nlatt,ntpvdw,ntpmet,nospl,multt,nneut,ntptbp,
+     x  ntpfbp,ntpter,keyshl,keyfld,ntbond,ntangl,ntdihd,ntinv,
+     x  ntteth,ntshl,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rcut,rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x  engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x  engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x  engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x  virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x  temp,tstep)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating system forces in a nudged 
+c     elastic band calculation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,nogofr,lzeql,loglnk,lfcap,ltad
+      logical lsolva,lfree,lexcite
+      integer idnode,mxnode,natms,imcon,nstbgr,nsteql,mstep
+      integer numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw
+      integer ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl
+      integer keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl
+      integer iatm0,iatm1,iatm2,i,k,n,nsolva,isolva
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtet,virtet,engshl
+      real(8) shlke,virshl,engfld,virfld,engcfg,fmax,temp,tstep
+      real(8) engord,virord
+      
+      numrdf=0
+      ltad=.true.
+      nogofr=.false.
+      
+c     dummy variables
+      
+      lsolva=.false.
+      lfree=.false.
+      lexcite=.false.
+      nsolva=0
+      isolva=1
+      engord=0.d0
+      virord=0.d0
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     calculate system forces for all beads
+      
+      do n=0,mxneb
+        
+c     construct cell vectors for one bead
+        
+        do i=1,9
+          cell(i)=celneb(i,n)
+        enddo
+        
+c     construct coordinate array for one bead
+        
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          k=k+1
+          xxx(i)=xneb(k)
+          yyy(i)=yneb(k)
+          zzz(i)=zneb(k)
+          
+        enddo
+        
+c     form complete global arrays
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces for one bead
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,nogofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lexcite,idnode,mxnode,natms,imcon,mstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     store configuration energy of bead
+        
+        engneb(n)=engcfg
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     allocate forces to bead atoms
+        
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          k=k+1
+          fxneb(k)=fxx(i)
+          fyneb(k)=fyy(i)
+          fzneb(k)=fzz(i)
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine neb_system_forces
+      
+      subroutine neb_spring_forces(idnode,mxnode,natms,nkinks,sprneb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating spring forces in a nudged 
+c     elastic band calculation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,k,n,kp,km,idnode,mxnode,natms,iatm0,iatm1,iatm2
+      integer nkinks
+      real(8) rp2,rm2,tau2,fpar,vv0,vp1,vm1,aaa,bbb,txx,tyy,tzz
+      real(8) uxx,uyy,uzz,wxx,wyy,wzz,sxx,syy,szz,rxx,ryy,rzz
+      real(8) sprneb,fac,kink,det
+      real(8) rcella(9),rcellb(9),rcellc(9),cella(9),cellb(9),cellc(9)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     energies of first and last basins
+      
+      engneb(0)=engbsn(1)
+      engneb(mxneb)=engbsn(2)
+      
+c     calculate spring tangents for all beads
+      
+      nkinks=0
+      do n=1,mxneb-1
+        
+        rp2=0.d0
+        rm2=0.d0
+        tau2=0.d0
+        fpar=0.d0
+        kink=0.d0
+        vv0=engneb(n)
+        vp1=engneb(n+1)
+        vm1=engneb(n-1)
+        
+c     calculate tangent vector and scalar product with system force
+        
+        if(vp1.gt.vv0.and.vv0.gt.vm1)then
+          
+          aaa=1.d0
+          bbb=0.d0
+          
+        else if(vp1.lt.vv0.and.vv0.lt.vm1)then
+          
+          aaa=0.d0
+          bbb=1.d0
+          
+        else if(vp1.gt.vm1)then
+          
+          aaa=max(abs(vp1-vv0),abs(vv0-vm1))
+          bbb=min(abs(vp1-vv0),abs(vv0-vm1))
+          
+        else
+          
+          aaa=min(abs(vp1-vv0),abs(vv0-vm1))
+          bbb=max(abs(vp1-vv0),abs(vv0-vm1))
+          
+        endif
+        
+c     invert cell matrices
+        
+        do i=1,9
+          cella(i)=celneb(i,n-1)
+          cellb(i)=celneb(i,n)
+          cellc(i)=celneb(i,n+1)
+        enddo
+        call invert(cella,rcella,det)
+        call invert(cellb,rcellb,det)
+        call invert(cellc,rcellc,det)
+
+        j=0
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+          km=k-iatm2
+
+c     calculate first spring vector (pbc corrected)
+
+          sxx=rcellb(1)*xneb(k)+rcellb(4)*yneb(k)+rcellb(7)*zneb(k)
+          syy=rcellb(2)*xneb(k)+rcellb(5)*yneb(k)+rcellb(8)*zneb(k)
+          szz=rcellb(3)*xneb(k)+rcellb(6)*yneb(k)+rcellb(9)*zneb(k)
+          rxx=rcella(1)*xneb(km)+rcella(4)*yneb(km)+rcella(7)*zneb(km)
+          ryy=rcella(2)*xneb(km)+rcella(5)*yneb(km)+rcella(8)*zneb(km)
+          rzz=rcella(3)*xneb(km)+rcella(6)*yneb(km)+rcella(9)*zneb(km)
+          rxx=rxx-nint(rxx-sxx)
+          ryy=ryy-nint(ryy-syy)
+          rzz=rzz-nint(rzz-szz)
+          txx=xneb(k)-
+     x      (rxx*celneb(1,n-1)+ryy*celneb(4,n-1)+rzz*celneb(7,n-1))
+          tyy=yneb(k)-
+     x      (rxx*celneb(2,n-1)+ryy*celneb(5,n-1)+rzz*celneb(8,n-1))
+          tzz=zneb(k)-
+     x      (rxx*celneb(3,n-1)+ryy*celneb(6,n-1)+rzz*celneb(9,n-1))
+
+c     calculate second spring vector (pbc corrected)
+
+          kp=k+iatm2
+          rxx=rcellc(1)*xneb(kp)+rcellc(4)*yneb(kp)+rcellc(7)*zneb(kp)
+          ryy=rcellc(2)*xneb(kp)+rcellc(5)*yneb(kp)+rcellc(8)*zneb(kp)
+          rzz=rcellc(3)*xneb(kp)+rcellc(6)*yneb(kp)+rcellc(9)*zneb(kp)
+          rxx=rxx-nint(rxx-sxx)
+          ryy=ryy-nint(ryy-syy)
+          rzz=rzz-nint(rzz-szz)
+          uxx=-xneb(k)+
+     x      rxx*celneb(1,n+1)+ryy*celneb(4,n+1)+rzz*celneb(7,n+1)
+          uyy=-yneb(k)+
+     x      rxx*celneb(2,n+1)+ryy*celneb(5,n+1)+rzz*celneb(8,n+1)
+          uzz=-zneb(k)+
+     x      rxx*celneb(3,n+1)+ryy*celneb(6,n+1)+rzz*celneb(9,n+1)
+
+          rp2=rp2+uxx*uxx+uyy*uyy+uzz*uzz
+          rm2=rm2+txx*txx+tyy*tyy+tzz*tzz
+          wxx=aaa*uxx+bbb*txx
+          wyy=aaa*uyy+bbb*tyy
+          wzz=aaa*uzz+bbb*tzz
+          taux(j)=wxx
+          tauy(j)=wyy
+          tauz(j)=wzz
+          tau2=tau2+wxx*wxx+wyy*wyy+wzz*wzz
+          fpar=fpar+wxx*fxneb(k)+wyy*fyneb(k)+wzz*fzneb(k)
+          kink=kink+txx*uxx+tyy*uyy+tzz*uzz
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=rp2
+          buffer(2)=rm2
+          buffer(3)=tau2
+          buffer(4)=fpar
+          buffer(5)=kink
+          call gdsum(buffer(1),5,buffer(6))
+          rp2=buffer(1)
+          rm2=buffer(2)
+          tau2=buffer(3)
+          fpar=buffer(4)
+          kink=buffer(5)
+          
+        endif
+        
+c     check for kinking of NEB
+        
+        kink=cos(kink/sqrt(rp2*rm2))
+        if(kink.lt.0.5d0)nkinks=nkinks+1
+        
+c     calculate final forces
+        
+        j=0
+        k=n*iatm2
+        tau2=sqrt(tau2)
+        fac=(sprneb*(sqrt(rp2)-sqrt(rm2))-fpar/tau2)/tau2
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+          fxneb(k)=fxneb(k)+fac*taux(j)
+          fyneb(k)=fyneb(k)+fac*tauy(j)
+          fzneb(k)=fzneb(k)+fac*tauz(j)
+          
+        enddo
+        
+      enddo
+      
+c     abort if kinks detected
+      
+      if(nkinks.gt.0)then
+        
+        if(idnode.eq.0)
+     x    write(nrite,'(1x,"number of kinks detected ",i6)')nkinks
+        call error(idnode,2350)
+        
+      endif
+      
+      return
+      end subroutine neb_spring_forces
+      
+      subroutine transition_properties
+     x  (seek,ltad,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,
+     x  idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,kmax1,
+     x  kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,
+     x  nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,
+     x  ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,
+     x  nturn,numbsn,alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,
+     x  fmax,opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x  tstep,volm,cfgtmp,cvgerr,estar,catchrad,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for analysing the NEB path and determining
+c     the destination state (if not end of chain).
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 seek
+      logical lfcap,lneut,lnsq,loglnk,lzeql,newlst,ltad,scan,same
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,pass
+      integer ntpvdw,ntshl,ntteth,nturn,i,k,n,iatm0,iatm1,iatm2
+      integer numblock,numbsn,mdiff
+      real(8) alpha,delr,dlrpot,drewd,elrc,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp
+      real(8) virlrc,cvgerr,estar,catchrad,hyp_units
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     analyse neb profile
+      
+      call scan_profile(nturn,estar)
+      
+c     determine true new state from first maximum
+      
+      if(nturn.gt.1)then
+        
+        i=1
+        do while(ktrn(i).ge.0)
+          i=i+1
+        enddo
+        n=-ktrn(i)
+        
+c     construct cell vectors for nth bead
+        
+        do i=1,9
+          cell(i)=celneb(i,n)
+        enddo
+        
+c     construct coordinate force arrays for nth bead
+        
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          k=k+1
+          xxx(i)=xneb(k)
+          yyy(i)=yneb(k)
+          zzz(i)=zneb(k)
+          
+        enddo
+        
+c     now minimise structure - this is correct new state
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr)
+        
+c     write events entry  for minimisation
+        
+        numblock=nstep/nblock
+        
+        if(idnode.eq.0)then
+          
+          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,"(1x,120('-'))")
+          
+        endif
+        
+        if(ltad)then
+          
+c     determine differences for new state (TAD only)
+        
+          scan=.true.
+          call check_for_transition
+     x      (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x      catchrad)
+          
+c     set difference counters and pointers
+          
+          if(numbsn.gt.mxbsn)call error(idnode,2330)
+          
+          ndiff=mdiff
+          
+          if(numbsn.gt.1)then
+            nbsa(numbsn)=nbsb(numbsn-1)+1
+          else
+            nbsa(numbsn)=1
+          endif
+          
+          nbsb(numbsn)=mdiff
+          
+c     save minimised starting structure as basin file
+          
+          call write_reference_config
+     x      ('CFGBSN','BASINS',nbsn,numbsn,natms,imcon,idnode,cfgtmp)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine transition_properties
+      
+      subroutine write_profile(idnode,mxnode,natms,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing profile file for NEB path
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      character*4 tail
+      integer idnode,mxnode,natms,i,j,k,n,iatm0,iatm1,iatm2
+      real(8) hyp_units
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+      if(idnode.eq.0)then
+        
+c     open profile data file
+      
+        if(numpro.lt.0)then
+
+          write(tail,'(i4.4)')iabs(numpro)
+          open(npro,file='PROFILES'//'/'//'PRX'//tail//'.XY',
+     x      form='formatted')
+          
+        else
+          
+          write(tail,'(i4.4)')numpro
+          open(npro,file='PROFILES'//'/'//'PRO'//tail//'.XY',
+     x      form='formatted')
+          
+        endif
+        
+      endif
+      
+c     calculate path
+      
+      path(0)=0.d0
+      if(idnode.eq.0)write(npro,'(1p,2e14.6)')path(0),
+     x  engneb(0)/hyp_units
+      
+      do n=1,mxneb
+        
+        path(n)=0.d0
+        k=n*iatm2
+        j=(n-1)*iatm2
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+          path(n)=(xneb(k)-xneb(j))**2+(yneb(k)-yneb(j))**2+
+     x      (zneb(k)-zneb(j))**2+path(n)
+          
+        enddo
+        
+        if(mxnode.gt.1)call gdsum(path(n),1,buffer(1))
+        
+        path(n)=sqrt(path(n))+path(n-1)
+        if(idnode.eq.0)write(npro,'(1p,2e14.6)')path(n),
+     x    engneb(n)/hyp_units
+        
+      enddo
+      
+      numpro=numpro+1
+      
+      if(idnode.eq.0)close(npro)
+      
+      return
+      end subroutine write_profile
+      
+      subroutine scan_profile(nturn,estar)
+      
+c*********************************************************************
+c     
+c     dl_poly  routine for analysing neb energy profile
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith january 2007
+c     
+c*********************************************************************
+
+      implicit none
+      
+      integer, parameter :: nscan=100
+
+      integer i,np,n1,n2,npnts,fail,nturn
+      real(8) di,dj,rpd,uu,vv,v0,ss,estar
+      real(8), allocatable :: aa(:),dd(:),gg(:),zz(:)
+      
+c     allocate working arrays
+      
+      allocate (aa(0:mxneb),dd(0:mxneb),gg(0:mxneb),zz(0:mxneb),
+     x  stat=fail)
+      
+      npnts=mxneb+1
+      n1=npnts-1
+      n2=npnts-2
+      
+c     calculate spline coefficients
+      
+      gg(0)=0.d0
+      dd(0)=path(1)-path(0)
+      
+      do i=1,n1-1
+        
+        dd(i)=path(i+1)-path(i)
+        gg(i)=2.d0*(path(i+1)-path(i-1))
+        zz(i)=6.d0*((engneb(i+1)-engneb(i))/dd(i)-
+     x    (engneb(i)-engneb(i-1))/dd(i-1))
+        
+      enddo
+      
+      gg(n1)=0.d0
+      dd(n1)=0.d0
+      aa(0)=0.d0
+      aa(1)=dd(1)/gg(1)
+      
+      do i=2,n2-1
+        
+        gg(i)=gg(i)-dd(i-1)*aa(i-1)
+        aa(i)=dd(i)/gg(i)
+        
+      enddo
+      
+      gg(n1-1)=gg(n1-1)-dd(n2-1)*aa(n2-1)
+      gg(1)=zz(1)/gg(1)
+      
+      do i=2,n1-1
+        gg(i)=(zz(i)-dd(i-1)*gg(i-1))/gg(i)
+      enddo
+      
+      do i=1,n2-1
+        gg(n1-i)=gg(n1-i)-aa(n1-i)*gg(npnts-i)
+      enddo
+      
+c     now scan across the profile locating maxima and minima
+            
+      np=1
+      nturn=0
+      ss=1.d0
+      v0=engneb(0)
+      rpd=(path(npnts-1)-path(0))/dble(nscan)
+      
+      do i=2,nscan-1
+        
+        uu=rpd*dble(i)+path(0)
+        
+        do while(np.lt.npnts.and.uu.gt.path(np))
+          np=np+1
+        enddo
+
+        di=uu-path(np-1)
+        dj=path(np)-uu
+        vv=(di*engneb(np)+dj*engneb(np-1)-di*dj*
+     x    ((dd(np-1)+dj)*gg(np-1)+(dd(np-1)+di)*gg(np))/6.d0)/dd(np-1)
+        
+        if(ss.gt.0.d0.and.vv.le.v0)then
+          
+          nturn=nturn+1
+          xtrn(nturn)=uu
+          ytrn(nturn)=vv
+          ktrn(nturn)=np
+          
+        else if(ss.lt.0.d0.and.vv.gt.v0)then
+          
+          nturn=nturn+1
+          xtrn(nturn)=uu
+          ytrn(nturn)=vv
+          ktrn(nturn)=-np
+          
+        endif
+        
+        ss=sign(1.d0,vv-v0)
+        v0=vv
+        
+      enddo
+      
+c     estimated activation energy
+      
+      i=1
+      do while(ktrn(i).lt.0)
+        i=i+1
+      enddo
+      estar=ytrn(i)-engbsn(1)
+      
+c     deallocate working arrays
+      
+      deallocate (aa,dd,gg,zz,stat=fail)
+      
+      return
+      end subroutine scan_profile
+      
+      subroutine transition_time
+     x  (seek,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x  imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,
+     x  multt,mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,
+     x  nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x  ntpfbp,ntpmet,ntptbp,ntpter,ntrack,ntpvdw,ntshl,ntteth,
+     x  ntcons,itrk,alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,
+     x  fmax,opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x  tstep,volm,cfgtmp,cvgerr,catchrad,timhop,hyp_units)
+
+c*********************************************************************
+c     
+c     dl_poly  routine for estimating the time of a transition
+c     from a backlog of previous configurations
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith february 2007
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      character*8 seek
+      logical same,minflg,lfcap,lneut,lnsq,loglnk,scan
+      logical lzeql,newlst
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter
+      integer ntpvdw,ntshl,ntteth,ntcons,ntrack,itrk,mdiff,pass
+      integer nback,ntry,numblock
+      real(8) alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol
+      real(8) rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep
+      real(8) volm,cfgtmp,cvgerr,eng,tol,catchrad,timhop,hyp_units
+      
+c     determine starting tracking file
+      
+      nback=min(numtrk,maxtrk)
+      
+c     search track files for transition
+        
+      itrk=0
+      same=.false.
+      
+      do while(.not.same.and.itrk.le.nback)
+        
+        itrk=itrk+1
+        ntry=mod(numtrk-itrk,maxtrk)
+        
+        call read_reference_config
+     x    ('CFGTRK','TRACKS',ntrk,ntry,natms,imcon,idnode,eng)
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr)
+        
+c     write events entry for minimisation (normally deactivated)
+        
+c$$$        if(idnode.eq.0)then
+c$$$          
+c$$$          numblock=nstep/nblock
+c$$$          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+c$$$     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+c$$$     x      cfgtmp/hyp_units,cvgerr/hyp_units
+c$$$          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+c$$$     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+c$$$     x      cfgtmp/hyp_units,cvgerr/hyp_units
+c$$$          write(nrite,"(1x,120('-'))")
+c$$$          
+c$$$        endif
+        
+c     check if still in base state
+        
+        scan=.false.
+        call check_for_transition
+     x    (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x    catchrad)
+        
+      enddo
+      
+      timhop=timhyp-tstep*dble(ntrack)*(dble(itrk)-0.5d0)
+      tboost=track(ntry)
+      
+      return
+      end subroutine transition_time
+
+      subroutine scramble_velocities(idnode,natms)
+      
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for randomising velocities after a 
+c     transition has occured (use with identical species only)
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  jan  2007
+c     
+c**********************************************************************
+            
+      implicit none
+
+      integer idnode,natms,i,j,k,m,n
+      real(8) vvv
+
+      do j=1,10
+        
+        do i=1,natms
+          
+          k=int(natms*duni())+1
+          vvv=vxx(i)
+          vxx(i)=vxx(k)
+          vxx(k)=vvv
+          m=int(natms*duni())+1
+          vvv=vyy(i)
+          vyy(i)=vyy(m)
+          vyy(m)=vvv
+          n=int(natms*duni())+1
+          vvv=vzz(i)
+          vzz(i)=vzz(n)
+          vzz(n)=vvv
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine scramble_velocities
+      
+      subroutine hyper_close(ltad,idnode,mxnode,natms,nsteql)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for saving hyperdynamics restart data
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  dec  2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      logical ltad
+      integer idnode,mxnode,natms,nsteql
+      integer iatm0,iatm1,i,j,k,n,last,ierr,netdif
+      real(8) buff(2)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     total number of atomic differences
+      
+      buff(1)=dble(ndiff)
+      call gdsum(buff(1),1,buff(2))
+      netdif=nint(buff(1))
+      
+      if(idnode.eq.0)then
+        
+c     open hyperdynamics restart file
+      
+        open(nhrs,file="HYPREV",form="unformatted")
+      
+c     write control variables
+        
+        write(nhrs)ltad,dble(numbsn),dble(numtrk),dble(numpro),
+     x    dble(netdif),dble(numdark),dble(nsteql),dble(numbpd),
+     x    timhyp,timres,tstop,tkeres,tboost,vbase,strres,celres
+        write(nhrs)track
+      endif
+      
+      if(ltad.and.numbsn.gt.1)then
+        
+c     load basin difference data
+        
+        n=0
+        do i=1,numbsn-1
+          
+          do j=nbsa(i),nbsb(i)
+            
+            buffer(n+1)=dble(idabsn(j))
+            buffer(n+2)=dble(i)
+            buffer(n+3)=xdiffs(j)
+            buffer(n+4)=ydiffs(j)
+            buffer(n+5)=zdiffs(j)
+            n=n+5
+            
+          enddo
+          
+        enddo
+        last=n
+        
+c     write basin difference data
+        
+        do k=1,mxnode-1
+          
+          if(idnode.eq.0)then
+            
+            
+            call csend(hyper_tag+k,buff,1,k,ierr)
+            call crecv(2*hyper_tag+k,buff,1)
+            call crecv(3*hyper_tag+k,buffer(last+1),nint(buff(1)))
+            last=nint(buff(1))+last
+            
+          elseif(k.eq.idnode)then
+            
+            call crecv(hyper_tag+k,buff,1)
+            buff(1)=dble(last)
+            call csend(2*hyper_tag+k,buff,1,0,ierr)
+            call csend(3*hyper_tag+k,buffer,last,0,ierr)
+            
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0)write(nhrs)(buffer(i),i=1,last)
+        call gsync()
+        
+      endif
+      
+c     load reference block configuration data
+        
+      j=0
+      k=1
+      do i=iatm0,iatm1
+        
+        buffer(j+1)=xres(k)
+        buffer(j+2)=yres(k)
+        buffer(j+3)=zres(k)
+        j=j+3
+        k=k+1
+        
+      enddo
+      last=j
+      
+c     write reference block configuration data
+      
+      do k=1,mxnode-1
+        
+        if(idnode.eq.0)then
+          
+          call csend(hyper_tag+k,buff,1,k,ierr)
+          call crecv(2*hyper_tag+k,buff,1)
+          call crecv(3*hyper_tag+k,buffer(last+1),nint(buff(1)))
+          last=nint(buff(1))+last
+          
+        elseif(k.eq.idnode)then
+          
+          call crecv(hyper_tag+k,buff,1)
+          buff(1)=dble(last)
+          call csend(2*hyper_tag+k,buff,1,0,ierr)
+          call csend(3*hyper_tag+k,buffer,last,0,ierr)
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nhrs)(buffer(i),i=1,last)
+        close(nhrs)
+        
+      endif
+      call gsync()
+      
+      return
+      end subroutine hyper_close
+      
+      subroutine hyper_open(ltad,idnode,mxnode,natms,nsteql)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for reading hyperdynamics restart data
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  dec  2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      logical ltad,mtad
+      integer idnode,mxnode,natms,nsteql
+      integer iatm0,iatm1,i,j,k,n,last,netdif,ierr
+      real(8) buff(1)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     restore control variables
+      
+      mtad=.true.
+      if(idnode.eq.0)then
+        
+c     open hyperdynamics restart file
+      
+        open(nhrs,file="HYPOLD",form="unformatted")
+      
+        read(nhrs)mtad,(buffer(i),i=1,30)
+        read(nhrs)track
+        
+      else
+        
+        do i=1,30
+          buffer(i)=0.d0
+        enddo
+        track(:)=0.d0
+        
+      endif
+      
+c     check restart file is tad compatible
+      
+      call gstate(mtad)
+      if(ltad.and.(.not.mtad))call error(idnode,2341)
+
+      call gdsum(buffer(1),31,buffer(32))
+      
+      numbsn=nint(buffer(1))
+      numtrk=nint(buffer(2))
+      numpro=nint(buffer(3))
+      netdif=nint(buffer(4))
+      numdark=nint(buffer(5))
+      nsteql=nint(buffer(6))
+      numbpd=nint(buffer(7))
+      timhyp=buffer(8)
+      timres=buffer(9)
+      tstop=buffer(10)
+      tkeres=buffer(11)
+      tboost=buffer(12)
+      vbase=buffer(13)
+      do i=1,9
+        
+        strres(i)=buffer(i+13)
+        celres(i)=buffer(i+22)
+
+      enddo
+      last=size(track)
+      call gdsum(track,last,buffer)
+
+      if(ltad.and.numbsn.gt.1)then
+        
+c     restore basin difference data
+        
+        last=5*netdif
+        if(idnode.eq.0)read(nhrs)(buffer(i),i=1,last)
+        
+        do k=1,mxnode-1
+          
+          if(idnode.eq.0)then
+            
+            call csend(hyper_tag+k,buffer,last,k,ierr)
+            
+          elseif(k.eq.idnode)then
+            
+            call crecv(hyper_tag+k,buffer,last)
+            
+          endif
+          
+        enddo
+        
+c     reject nonlocal basin difference data
+        
+        j=0
+        do i=1,last,5
+          
+          n=nint(buffer(i))
+          if(n.ge.iatm0.and.n.le.iatm1)then
+            
+            buffer(j+1)=buffer(i)
+            buffer(j+2)=buffer(i+1)
+            buffer(j+3)=buffer(i+2)
+            buffer(j+4)=buffer(i+3)
+            buffer(j+5)=buffer(i+4)
+            j=j+5
+            
+          endif
+          
+        enddo
+        last=j
+        
+c     unload basin difference data
+        
+        n=0
+        nbsa(1)=1
+        do i=1,numbsn-1
+          
+          if(i.gt.1)nbsa(i)=n+1
+          
+          do j=1,last,5
+            
+            if(nint(buffer(j+1)).eq.i)then
+              
+              n=n+1
+              idabsn(n)=nint(buffer(j))
+              xdiffs(n)=buffer(j+2)
+              ydiffs(n)=buffer(j+3)
+              zdiffs(n)=buffer(j+4)
+              
+            endif
+            
+          enddo
+          
+          nbsb(i)=n
+          
+        enddo
+        ndiff=n
+        call gsync()
+        
+      endif
+      
+c     retrieve reference block configuration data
+
+      last=3*natms
+      if(idnode.eq.0)read(nhrs)(buffer(i),i=1,last)
+      
+      do k=1,mxnode-1
+        
+c     read reference block configuration data
+        
+        if(idnode.eq.0)then
+          
+          call csend(hyper_tag+k,buffer,last,k,ierr)
+          
+        elseif(k.eq.idnode)then
+          
+          call crecv(hyper_tag+k,buffer,last)
+          
+        endif
+        
+      enddo
+      
+c     unload reference block configuration data
+        
+      n=1
+      j=3*(iatm0-1)
+      do i=iatm0,iatm1
+        
+        xres(n)=buffer(j+1)
+        yres(n)=buffer(j+2)
+        zres(n)=buffer(j+3)
+        j=j+3
+        n=n+1
+        
+      enddo
+      
+      if(idnode.eq.0)close(nhrs)
+      call gsync()
+      
+      return
+      end subroutine hyper_open
+      
+      subroutine bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for scaling forces in a bias potential dynamics 
+c     simulation using hamelberg, mongan and mccammon factor
+c     J. Chem. Phys. 120 (2004) 11919
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2008
+c     
+c***********************************************************************
+      
+      integer i,natms,mynode,keybpd
+      real(8) alpha,vmin,ebias,beta,temp,engcfg,eboost,hscale
+      real(8) engtmp
+      
+      boost=1.d0
+      numbpd=numbpd+1
+      
+c     reset potential energy wrt base level
+      
+      if(keybpd.eq.1)then
+        engtmp=engcfg-vbase
+      else
+        engtmp=engcfg-engbsn(1)
+      endif
+
+      if(ebias.gt.engtmp)then
+        
+c     bias potental boost
+        
+        alpha=ebias*(ebias-vmin)/vmin
+        beta=1.d0/(boltz*temp*dble(natms))
+        eboost=(ebias-engtmp)**2/(alpha+ebias-engtmp)
+        boost=exp(beta*eboost)
+        
+c     bias potential forces scaling factor
+        
+        hscale=(alpha/(alpha+ebias-engtmp))**2
+        
+c     scale forces
+        
+        do i=1,natms
+          
+          fxx(i)=fxx(i)*hscale
+          fyy(i)=fyy(i)*hscale
+          fzz(i)=fzz(i)*hscale
+          
+        enddo
+        
+      endif
+      
+c     accumulative average of boost factor
+      
+      tboost=boost/dble(numbpd)+dble(numbpd-1)*tboost/dble(numbpd)
+      
+      return
+      end subroutine bpd_forces
+
+      end module hyper_dynamics_module
diff -urN dl_class_1.9.orig/srcmod/integrator_module.f dl_class_1.9/srcmod/integrator_module.f
--- dl_class_1.9.orig/srcmod/integrator_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/integrator_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,624 @@
+      module integrator_module
+
+c***********************************************************************
+c     
+c     dl_poly module for selecting verlet integration schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use error_module
+      use lf_motion_module
+      use lf_rotation1_module
+      use lf_rotation2_module
+      use pmf_module
+      use temp_scalers_module
+      use vv_motion_module
+      use vv_rotation1_module
+      use vv_rotation2_module
+      
+      contains
+      
+      subroutine lf_integrate
+     x  (lcnb,lshmov,lnfic,idnode,mxnode,imcon,natms,nstep,ngrp,
+     x  keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x  tstep,engke,engrot,tolnce,quattol,vircon,vircom,virtot,
+     x  temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,
+     x  elrc,virlrc,virpmf)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the integration algorithm
+c     to solve the the equations of motion. based on the leapfrog
+c     verlet algorithm
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith december 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,safep,safeq,lcnb,lshmov,lnfic
+      integer idnode,mxnode,imcon,natms,ngrp,keyens,nscons,nofic
+      integer ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nstep
+      real(8) tstep,engke,engrot,tolnce,quattol,vircon,vircom
+      real(8) virtot,temp,press,volm,sigma,taut,taup,chit,chip
+      real(8) consv,conint,elrc,virlrc,virpmf
+      
+      safe=.true.
+      safeq=.true.
+      safep=.true.
+      
+      if(ngrp.eq.0) then
+        
+        if(keyens.eq.0) then
+
+c     verlet leapfrog 
+
+          call nve_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      engke,tolnce,tstep,vircon)
+          
+        else if(keyens.eq.1) then
+
+c     Evans Gaussian Temperature constraints
+          
+          call nvt_e1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      engke,tolnce,tstep,vircon)
+          
+        else if(keyens.eq.2) then
+
+c     Berendsen thermostat
+          
+          call nvt_b1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      engke,taut,sigma,tolnce,tstep,vircon)
+          
+        else if(keyens.eq.3) then
+
+c     Nose-Hoover thermostat
+          
+          call nvt_h1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      chit,consv,conint,engke,taut,sigma,tolnce,tstep,vircon)
+          
+        elseif(keyens.eq.4) then
+
+c     Berendsen thermostat and isotropic barostat
+
+          call npt_b1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,elrc,engke,virlrc,press,taup,taut,sigma,tolnce,
+     x      tstep,virtot,vircon,volm)
+
+        else if(keyens.eq.5) then
+
+c     Nose-Hoover thermostat and isotropic barostat 
+
+          call npt_h1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,chip,chit,conint,consv,elrc,engke,virlrc,press,
+     x      taup,taut,sigma,temp,tolnce,tstep,virtot,vircon,volm)
+
+        else if(keyens.eq.6) then
+
+c     Berendsen thermostat and barostat (cell shape varying)
+
+          call nst_b1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,mode,elrc,engke,virlrc,press,taup,taut,sigma,
+     x      tolnce,tstep,vircon,volm)
+
+        else if(keyens.eq.7) then
+
+c     Nose-Hoover thermostat and barostat (cell shape varying)
+          
+          call nst_h1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,mode,chit,conint,consv,elrc,engke,virlrc,press,
+     x      taup,taut,sigma,temp,tolnce,tstep,vircon,volm)
+
+        elseif(keyens.eq.8) then
+
+c     Potential of mean force in NVE
+
+            call pmflf
+     x        (safe,safep,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+
+        endif
+
+      elseif(ngrp.gt.0) then
+
+c     apply rigid body equations of motion
+        
+        if(keyens.eq.0) then
+          
+          if(.not.lcnb) then
+
+            call nveq_1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x        vircon)
+
+          else
+
+            call nveq_2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x        vircon)
+
+          endif
+
+        elseif(keyens.eq.1) then
+
+c     invalid option
+
+          call error(idnode,430)
+          
+        elseif(keyens.eq.2) then
+          
+          if(.not.lcnb) then
+
+            call nvtq_b1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x        tstep,vircom,vircon)
+
+          else
+
+            call nvtq_b2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x        tstep,vircom,vircon)
+          
+          endif
+
+        elseif(keyens.eq.3) then
+          
+          if(.not.lcnb) then 
+
+            call nvtq_h1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,chit,consv,conint,engke,engrot,quattol,
+     x        sigma,taut,tolnce,tstep,vircom,vircon)
+
+          else
+
+            call nvtq_h2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,conint,consv,chit,engke,engrot,quattol,
+     x        sigma,taut,tolnce,tstep,vircom,vircon)
+
+          endif
+            
+        elseif(keyens.eq.4) then
+
+          if(.not.lcnb) then
+
+            call nptq_b1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,virtot,vircom,
+     x        vircon,volm)
+          
+          else
+
+            call nptq_b2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,
+     x        virtot,volm)
+
+          endif
+
+        elseif(keyens.eq.5) then
+          
+          if(.not.lcnb) then 
+
+            call nptq_h1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,virtot,vircom,vircon,volm)
+
+          else
+
+            call nptq_h2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,vircom,vircon,virtot,volm)
+
+          endif
+            
+        elseif(keyens.eq.6) then
+
+          if(.not.lcnb) then
+
+            call nstq_b1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+
+          else
+
+            call nstq_b2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+
+          endif
+
+        elseif(keyens.eq.7) then
+
+          if(.not.lcnb) then
+
+            call nstq_h1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,vircom,vircon,volm)
+
+          else
+
+            call nstq_h2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,vircom,vircon,volm)
+            
+          endif
+
+        else
+
+c     invalid option
+
+          call error(idnode,430)
+
+        endif
+
+      endif
+
+c    check on convergence of pmf-shake
+
+      if(ntpmf.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safep)
+        if(.not.safep) call error(idnode,438)
+
+      endif    
+
+c    check on convergence of shake
+
+      if(ntcons.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) call error(idnode,105)
+
+      endif    
+
+c     check on convergence of quaternion algorithm
+
+      if(ngrp.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safeq)
+        if(.not.safeq) call error(idnode,321)
+
+      endif
+
+c     eliminate "flying ice cube" in long simulations (Berendsen)
+      
+      if(lnfic.and.(keyens.eq.2.or.keyens.eq.4.or.keyens.eq.6))then
+        
+        if(mod(nstep,nofic).eq.0)then
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine lf_integrate
+
+      subroutine vv_integrate
+     x  (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms,nstep,ngrp,
+     x  keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x  ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,virtot,
+     x  temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,elrc,
+     x  virlrc,virpmf,chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the integration algorithm
+c     to solve the the equations of motion. based on the velocity
+c     verlet algorithm
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,safep,lcnb,lshmov,lnfic
+      integer isw,idnode,mxnode,imcon,natms,ngrp,keyens,nscons
+      integer ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nstep,nofic
+      integer ntshl,keyshl
+      real(8) tstep,engke,engrot,tolnce,vircon,vircom
+      real(8) virtot,temp,press,volm,sigma,taut,taup,chit,chip
+      real(8) consv,conint,elrc,virlrc,virpmf,chit_shl,sigma_shl
+      
+      if(ngrp.eq.0) then
+        
+        if(keyens.eq.0) then
+
+c     verlet leapfrog 
+
+          call nvevv_1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,tstep,engke,tolnce,vircon)
+          
+        else if(keyens.eq.1) then
+
+c     Evans Gaussian Temperature constraints
+          
+          call nvtvv_e1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,tstep,engke,tolnce,vircon)
+          
+        else if(keyens.eq.2) then
+
+c     Berendsen thermostat
+          
+          call nvtvv_b1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,tstep,taut,sigma,engke,tolnce,vircon)
+          
+        else if(keyens.eq.3) then
+
+c     Nose-Hoover thermostat
+          
+          call nvtvv_h1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntshl,keyshl,tstep,taut,sigma,chit,consv,
+     x      conint,engke,tolnce,vircon,chit_shl,sigma_shl)
+          
+        elseif(keyens.eq.4) then
+
+c     Berendsen thermostat and isotropic barostat
+
+          call nptvv_b1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,tstep,taut,taup,sigma,engke,press,elrc,
+     x      virlrc,tolnce,virtot,vircon,volm)
+
+        else if(keyens.eq.5) then
+
+c     Nose-Hoover thermostat and isotropic barostat 
+
+          call nptvv_h1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,ntshl,keyshl,tstep,taut,taup,sigma,temp,
+     x      chip,chit,consv,conint,engke,elrc,tolnce,vircon,
+     x      virtot,virlrc,volm,press,chit_shl,sigma_shl)
+
+        else if(keyens.eq.6) then
+
+c     Berendsen thermostat and barostat (cell shape varying)
+
+          call nstvv_b1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,mode,tstep,taut,taup,sigma,engke,press,
+     x      elrc,virlrc,tolnce,vircon,volm)
+
+        else if(keyens.eq.7) then
+
+c     Nose-Hoover thermostat and barostat (cell shape varying)
+          
+          call nstvv_h1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,mode,ntshl,keyshl,tstep,taut,taup,sigma,
+     x      temp,chit,consv,conint,engke,elrc,tolnce,vircon,
+     x      virlrc,volm,press,chit_shl,sigma_shl)
+
+        elseif(keyens.eq.8) then
+
+c     Potential of mean force in NVE
+
+          call pmfvv
+     x      (safe,safep,lshmov,isw,idnode,mxnode,imcon,natms,nscons,
+     x      ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+
+        endif
+
+      elseif(ngrp.gt.0) then
+
+c     apply rigid body equations of motion
+        
+        if(keyens.eq.0) then
+          
+          if(.not.lcnb) then
+
+            call nveqvv_1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+
+          else
+
+            call nveqvv_2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+            
+          endif
+
+        elseif(keyens.eq.1) then
+
+c     invalid option
+
+          call error(idnode,430)
+          
+        elseif(keyens.eq.2) then
+          
+          if(.not.lcnb) then
+
+            call nvtqvv_b1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x        vircom,vircon)
+
+          else
+
+            call nvtqvv_b2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x        vircom,vircon)
+            
+          endif
+
+        elseif(keyens.eq.3) then
+          
+          if(.not.lcnb) then 
+
+            call nvtqvv_h1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,
+     x        engrot,taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,
+     x        sigma_shl)
+
+          else
+
+            call nvtqvv_h2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,
+     x        engrot,taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,
+     x        sigma_shl)
+
+          endif
+          
+        elseif(keyens.eq.4) then
+
+          if(.not.lcnb) then
+
+            call nptqvv_b1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x        tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+            
+          else
+
+            call nptqvv_b2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x        tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+
+          endif
+
+        elseif(keyens.eq.5) then
+          
+          if(.not.lcnb) then 
+
+            call nptqvv_h1
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x        temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircon,virtot,virlrc,vircom,volm,press,chit_shl,
+     x        sigma_shl)
+
+          else
+      
+            call nptqvv_h2
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x        temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircom,vircon,virtot,virlrc,volm,press,chit_shl,
+     x        sigma_shl)
+      
+          endif
+          
+        elseif(keyens.eq.6) then
+
+          if(.not.lcnb) then
+
+            call nstqvv_b1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,
+     x        sigma,tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+
+          else
+
+            call nstqvv_b2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,
+     x        sigma,tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+
+          endif
+
+        elseif(keyens.eq.7) then
+
+          if(.not.lcnb) then
+
+            call nstqvv_h1
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x        sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircon,virlrc,vircom,volm,press,chit_shl,sigma_shl)
+
+          else
+
+            call nstqvv_h2
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x        sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircom,vircon,virlrc,volm,press,chit_shl,sigma_shl)
+            
+          endif
+
+        else
+
+c     invalid option
+
+          call error(idnode,430)
+
+        endif
+
+      endif
+
+c     check on convergence of pmf-shake
+
+      if(ntpmf.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safep)
+        if(.not.safep) call error(idnode,438)
+
+      endif    
+
+c     check on convergence of shake
+
+      if(ntcons.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) call error(idnode,105)
+
+      endif    
+
+c     eliminate "flying ice cube" in long simulations (Berendsen)
+      
+      if(lnfic.and.(keyens.eq.2.or.keyens.eq.4.or.keyens.eq.6))then
+        
+        if(mod(nstep,nofic).eq.0)then
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine vv_integrate
+
+      end module integrator_module
diff -urN dl_class_1.9.orig/srcmod/inversion_module.f dl_class_1.9/srcmod/inversion_module.f
--- dl_class_1.9.orig/srcmod/inversion_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/inversion_module.f	2011-08-16 14:42:52.000000000 +0200
@@ -0,0 +1,828 @@
+      module inversion_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining inversion potential arrays
+c     copyright - daresbury laboratory
+c     
+c     author  - w. smith  sep 2003
+c     adapted - w. smith  jun 2008 : solvation, free energy, excitation
+c     adapted - w. smith  jan 2011 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+
+      implicit none
+
+      real(8), allocatable :: prminv(:,:)
+      integer, allocatable :: listinv(:,:)
+      integer, allocatable :: numinv(:),keyinv(:),lstinv(:,:)
+
+      save prminv,listinv,numinv,keyinv,lstinv
+
+      contains
+
+      subroutine alloc_inv_arrays(idnode)
+
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(5)
+
+      do i=1,5
+        fail(i)=0
+      enddo
+
+      allocate (prminv(mxtinv,mxpinv),stat=fail(1))
+      allocate (numinv(mxtmls),stat=fail(2))
+      allocate (keyinv(mxtinv),stat=fail(3))
+      allocate (lstinv(mxtinv,4),stat=fail(4))
+      allocate (listinv(mxinv,5),stat=fail(5))
+
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1120)
+      enddo
+
+      do i=1,mxtmls
+         numinv(i)=0
+      enddo
+
+      end subroutine alloc_inv_arrays
+
+      subroutine define_inversions
+     x  (safe,idnode,itmols,ninver,nsite,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining inversion angle potentials
+c     note: includes calcite planar potential which is not strictly
+c     an inversion potential and is different in implementation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,ninver,nsite,ntmp,inv,inv1,i
+      integer iatm1,iatm2,iatm3,iatm4,isite1,isite2,isite3,isite4
+      integer ia,ja,idum
+      real(8) engunit
+
+      ntmp=intstr(record,lenrec,idum)
+      numinv(itmols)=numinv(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of inversion terms',
+     x    6x,i10)")ntmp
+        write(nrite,"(/,/,1x,'inversion potential details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',5x,
+     x    'index',5x,'index',5x,'f-const',7x,'angle',/)")
+      endif
+      
+      inv1=numinv(itmols)
+      do inv=1,inv1
+
+c     read inversion potential parameters
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        iatm3=intstr(record,lenrec,idum)
+        iatm4=intstr(record,lenrec,idum)
+
+c     test for frozen atom pairs
+
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        isite3=nsite-numsit(itmols)+iatm3
+        isite4=nsite-numsit(itmols)+iatm4
+
+        if(lfzsit(isite1)*lfzsit(isite2)*
+     x    lfzsit(isite3)*lfzsit(isite4).ne.0)then
+          
+          numinv(itmols)=numinv(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+
+        else
+
+          ninver=ninver+1
+          
+          if(ninver.gt.mxtinv)call error(idnode,73)
+
+          if(keyword(1:4).eq.'harm')then
+            keyinv(ninver)=1
+          elseif(keyword(1:4).eq.'hcos')then
+            keyinv(ninver)=2
+          elseif(keyword(1:4).eq.'plan')then
+            keyinv(ninver)=3
+          elseif(keyword(1:4).eq.'calc')then
+            keyinv(ninver)=4
+          else
+            if(idnode.eq.0)write(nrite,*)record
+            call error(idnode,449)
+          endif
+
+          lstinv(ninver,1)=iatm1
+          lstinv(ninver,2)=iatm2
+          lstinv(ninver,3)=iatm3
+          lstinv(ninver,4)=iatm4
+          prminv(ninver,1)=dblstr(record,lenrec,idum)
+          prminv(ninver,2)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,4i10,1p,e12.4,0p,9f12.6)")
+     x      keyword(1:4),(lstinv(ninver,ia),ia=1,4),
+     x      (prminv(ninver,ja),ja=1,mxpinv)
+
+c     convert energies to internal units and angles to radians
+          
+          prminv(ninver,1)=prminv(ninver,1)*engunit
+
+          if(keyinv(ninver).eq.2)then
+
+            prminv(ninver,2)=cos(prminv(ninver,2)*(pi/180.d0))
+
+          elseif(keyinv(ninver).eq.4)then
+            
+            prminv(ninver,2)=prminv(ninver,2)*engunit
+            
+          endif
+          
+        endif
+
+      enddo
+      
+      return
+      end subroutine define_inversions
+
+      subroutine invfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntinv,enginv,virinv)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating inversion energy and force 
+c     terms in molecular dynamics.
+c     
+c     copyright - daresbury laboratory 1996
+c     author    - w. smith       may   1996
+c     modified  - w.smith        jan   2011 : metadynamics
+c     
+c***********************************************************************
+            
+      implicit none
+
+      logical safe,lsolva,lfree,lexcite,lselect,lcalcite
+      logical idrive,jdrive,kdrive,ldrive
+      integer idnode,imcon,mxnode,ntinv,fail1,fail2
+      integer fail3,inv1,inv2,i,ii,ia,id,kk,ib,ic
+      real(8) strs(6),strs_loc(6)
+      real(8) xab,yab,zab,rab2,rrab,xac,yac,zac,rac2,rrac,xad,yad
+      real(8) zad,rad2,rrad,rbc,rcd,rdb,ubx,uby,ubz,ubn,rub,vbx
+      real(8) vby,vbz,rvb,wwb,ucx,ucy,ucz,ucn,vcx,vcy,vcz,rvc,wwc
+      real(8) udx,udy,udz,udn,vdx,vdy,vdz,vdn,rvd,wwd,cosb,cosc
+      real(8) cosd,thb,thc,thd,gamb,gamc,gamd,rubc,rubd,rucd,rucb
+      real(8) rudb,rudc,rvbc,rvbd,rvcd,rvcb,rvdb,rvdc,fax,fay,faz
+      real(8) fbx,fby,fbz,fcx,fcy,fcz,fdx,fdy,fdz,vbn,vcn,ruc,rud
+      real(8) uuu,uu2,uun,uux,uuy,uuz,enginv,virinv,omega,gamma
+      real(8) gamvir
+
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      real(8), allocatable :: xdac(:),ydac(:),zdac(:)
+      real(8), allocatable :: xdad(:),ydad(:),zdad(:)
+      
+      data fail1,fail2,fail3/0,0,0/
+
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail1)
+      allocate (xdac(msbad),ydac(msbad),zdac(msbad),stat=fail2)
+      allocate (xdad(msbad),ydad(msbad),zdad(msbad),stat=fail3)
+      if(fail1.ne.0.or.fail2.ne.0.or.fail3.ne.0)
+     x     call error(idnode,1130)
+
+c     check size of work arrays
+      
+      if((ntinv-mxnode+1)/mxnode.gt.msbad)call error(idnode,427)
+
+c     block indices
+      
+      inv1=(idnode*ntinv)/mxnode+1
+      inv2=((idnode+1)*ntinv)/mxnode
+      
+      safe=.true.
+      
+c     initialise accumulators
+      
+      enginv=0.d0
+      virinv=0.d0
+      inv_fre=0.d0
+      inv_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+      if(lsolva)then
+        
+        lcomp(4)=.true.
+        inv_sol(:)=0.d0
+        if(lexcite)inv_exc(:)=0.d0
+        
+      endif
+      
+c     calculate bond vectors
+      
+      ii=0
+      do i=inv1,inv2
+        
+        ii=ii+1
+        
+c     potential energy function type
+        
+        kk=listinv(ii,1)
+        
+c     indices of bonded atoms
+        
+        ia=listinv(ii,2)
+        ib=listinv(ii,3)
+        ic=listinv(ii,4)
+        id=listinv(ii,5)
+        
+c     define components of bond vectors
+        
+        xdab(ii)=xxx(ib)-xxx(ia)
+        ydab(ii)=yyy(ib)-yyy(ia)
+        zdab(ii)=zzz(ib)-zzz(ia)
+        
+        if(keyinv(kk).eq.4)then
+
+          xdac(ii)=xxx(ic)-xxx(ib)
+          ydac(ii)=yyy(ic)-yyy(ib)
+          zdac(ii)=zzz(ic)-zzz(ib)
+          
+          xdad(ii)=xxx(id)-xxx(ib)
+          ydad(ii)=yyy(id)-yyy(ib)
+          zdad(ii)=zzz(id)-zzz(ib)
+          
+        else
+          
+          xdac(ii)=xxx(ic)-xxx(ia)
+          ydac(ii)=yyy(ic)-yyy(ia)
+          zdac(ii)=zzz(ic)-zzz(ia)
+          
+          xdad(ii)=xxx(id)-xxx(ia)
+          ydad(ii)=yyy(id)-yyy(ia)
+          zdad(ii)=zzz(id)-zzz(ia)
+          
+        endif   
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      call images(imcon,0,1,ii,cell,xdac,ydac,zdac)
+      call images(imcon,0,1,ii,cell,xdad,ydad,zdad)
+      
+c     loop over all specified inversions
+      
+      ii=0
+      do i=inv1,inv2
+        
+        ii=ii+1
+        
+c     select potential energy function type
+        
+        kk=listinv(ii,1)
+        lcalcite=(keyinv(kk).eq.4)
+        
+c     define components of bond vectors
+        
+        xab=xdab(ii)
+        yab=ydab(ii)
+        zab=zdab(ii)
+        rab2=xab*xab+yab*yab+zab*zab
+        rrab=1.d0/sqrt(rab2)
+        
+        xac=xdac(ii)
+        yac=ydac(ii)
+        zac=zdac(ii)
+        rac2=xac*xac+yac*yac+zac*zac
+        rrac=1.d0/sqrt(rac2)
+        
+        xad=xdad(ii)
+        yad=ydad(ii)
+        zad=zdad(ii)
+        rad2=xad*xad+yad*yad+zad*zad
+        rrad=1.d0/sqrt(rad2)
+        
+        if(lcalcite)then
+          
+c     calculate vector normal to plane
+        
+          uux=yac*zad-zac*yad
+          uuy=zac*xad-xac*zad
+          uuz=xac*yad-yac*xad
+          uun=1.d0/sqrt(uux**2+uuy**2+uuz**2)
+          uux=uun*uux
+          uuy=uun*uuy
+          uuz=uun*uuz
+          uuu=xab*uux+yab*uuy+zab*uuz
+          
+        else
+          
+c     scalar products of bond vectors
+        
+          rbc=xab*xac+yab*yac+zab*zac
+          rcd=xac*xad+yac*yad+zac*zad
+          rdb=xad*xab+yad*yab+zad*zab
+        
+c     calculate bond-angle-plane vectors
+        
+          ubx=xac*rrac+xad*rrad
+          uby=yac*rrac+yad*rrad
+          ubz=zac*rrac+zad*rrad
+          ubn=1.d0/sqrt(ubx**2+uby**2+ubz**2)
+          ubx=ubn*ubx
+          uby=ubn*uby
+          ubz=ubn*ubz
+          rub=xab*ubx+yab*uby+zab*ubz
+          
+          vbx=xac*rrac-xad*rrad
+          vby=yac*rrac-yad*rrad
+          vbz=zac*rrac-zad*rrad
+          vbn=1.d0/sqrt(vbx**2+vby**2+vbz**2)
+          vbx=vbn*vbx
+          vby=vbn*vby
+          vbz=vbn*vbz
+          rvb=xab*vbx+yab*vby+zab*vbz
+          wwb=sqrt(rub**2+rvb**2)
+          
+          ucx=xad*rrad+xab*rrab
+          ucy=yad*rrad+yab*rrab
+          ucz=zad*rrad+zab*rrab
+          ucn=1.d0/sqrt(ucx**2+ucy**2+ucz**2)
+          ucx=ucn*ucx
+          ucy=ucn*ucy
+          ucz=ucn*ucz
+          ruc=xac*ucx+yac*ucy+zac*ucz
+          
+          vcx=xad*rrad-xab*rrab
+          vcy=yad*rrad-yab*rrab
+          vcz=zad*rrad-zab*rrab
+          vcn=1.d0/sqrt(vcx**2+vcy**2+vcz**2)
+          vcx=vcn*vcx
+          vcy=vcn*vcy
+          vcz=vcn*vcz
+          rvc=xac*vcx+yac*vcy+zac*vcz
+          wwc=sqrt(ruc**2+rvc**2)
+          
+          udx=xab*rrab+xac*rrac
+          udy=yab*rrab+yac*rrac
+          udz=zab*rrab+zac*rrac
+          udn=1.d0/sqrt(udx**2+udy**2+udz**2)
+          udx=udn*udx
+          udy=udn*udy
+          udz=udn*udz
+          rud=xad*udx+yad*udy+zad*udz
+          
+          vdx=xab*rrab-xac*rrac
+          vdy=yab*rrab-yac*rrac
+          vdz=zab*rrab-zac*rrac
+          vdn=1.d0/sqrt(vdx**2+vdy**2+vdz**2)
+          vdx=vdn*vdx
+          vdy=vdn*vdy
+          vdz=vdn*vdz
+          rvd=xad*vdx+yad*vdy+zad*vdz
+          wwd=sqrt(rud**2+rvd**2)
+          
+c     calculate inversion angle cosines
+          
+          cosb=wwb*rrab
+          cosc=wwc*rrac
+          cosd=wwd*rrad
+          
+        endif
+        
+c     calculate potential energy and scalar force term
+        
+        if(keyinv(kk).eq.1)then
+          
+c     key=1 for harmonic inversion potential
+          
+          thb=acos(cosb)
+          thc=acos(cosc)
+          thd=acos(cosd)
+          omega=0.5d0*prminv(kk,1)*((thb-prminv(kk,2))**2+
+     x      (thc-prminv(kk,2))**2+(thd-prminv(kk,2))**2)/3.d0
+          gamvir=0.d0
+          
+          gamb=0.d0
+          if(abs(thb).gt.1.d-12)
+     x      gamb=prminv(kk,1)*(thb-prminv(kk,2))/(3.d0*sin(thb))
+          gamc=0.d0
+          if(abs(thc).gt.1.d-12)
+     x      gamc=prminv(kk,1)*(thc-prminv(kk,2))/(3.d0*sin(thc))
+          gamd=0.d0
+          if(abs(thd).gt.1.d-12)
+     x      gamd=prminv(kk,1)*(thd-prminv(kk,2))/(3.d0*sin(thd))
+          
+        else if(keyinv(kk).eq.2)then
+          
+c     key=2 for harmonic cosine inversion potential
+          
+          omega=0.5d0*prminv(kk,1)*((cosb-prminv(kk,2))**2+
+     x      (cosc-prminv(kk,2))**2+(cosb-prminv(kk,2))**2)/3.d0
+          gamvir=0.d0
+
+          gamb=-prminv(kk,1)*(cosb-prminv(kk,2))/3.d0
+          gamc=-prminv(kk,1)*(cosc-prminv(kk,2))/3.d0
+          gamd=-prminv(kk,1)*(cosd-prminv(kk,2))/3.d0
+          
+        else if(keyinv(kk).eq.3)then
+
+c     key=3 for planar inversion potentials
+          
+          omega=prminv(kk,1)*((1.d0-cosb)+(1.d0-cosc)+(1.d0-cosd))/3.d0
+          gamvir=0.d0
+          
+          gamb=prminv(kk,1)/3.d0
+          gamc=prminv(kk,1)/3.d0
+          gamd=prminv(kk,1)/3.d0
+
+        else if(keyinv(kk).eq.4)then
+          
+c     key=4 for planar calcite potential
+          
+          uu2=uuu*uuu
+          omega=uu2*(prminv(kk,1)+prminv(kk,2)*uu2)
+          gamvir=uu2*(2.d0*prminv(kk,1)+4.d0*prminv(kk,2)*uu2)
+          gamma=-uuu*(2.d0*prminv(kk,1)+4.d0*prminv(kk,2)*uu2)
+
+        else
+
+c     undefined potential
+          
+          safe=.false.
+          gamvir=0.d0
+          gamb=0.d0
+          gamc=0.d0
+          gamd=0.d0
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listinv(ii,2)
+        ib=listinv(ii,3)
+        ic=listinv(ii,4)
+        id=listinv(ii,5)
+
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          kdrive=driven(ltype(ic))
+          ldrive=driven(ltype(id))
+          
+        endif
+        
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+        
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x      (atm_fre(ic).ne.1).and.(atm_fre(id).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic)+
+     x        atm_fre(id).eq.0)
+            
+            if(lsolva)then
+              inv_exc(atmolt(ia))=inv_exc(atmolt(ia))+omega
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x      (atm_fre(ic).eq.1).or.(atm_fre(id).eq.1))then
+            
+c     set hamiltonian mixing parameter
+
+            inv_fre=inv_fre-omega
+            omega=lambda1*omega
+            gamb=lambda1*gamb
+            gamc=lambda1*gamc
+            gamd=lambda1*gamd
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x        (atm_fre(ic).eq.2).or.(atm_fre(id).eq.2))then
+            
+c     set hamiltonian mixing parameter
+
+            inv_fre=inv_fre+omega
+            omega=lambda2*omega
+            gamb=lambda2*gamb
+            gamc=lambda2*gamc
+            gamd=lambda2*gamd
+                        
+          endif
+          
+        endif
+        
+c     calculate bond and u,v scalar products
+        
+        if(.not.lcalcite)then
+          
+          rubc=xab*ucx+yab*ucy+zab*ucz
+          rubd=xab*udx+yab*udy+zab*udz
+          rucd=xac*udx+yac*udy+zac*udz
+          rucb=xac*ubx+yac*uby+zac*ubz
+          rudb=xad*ubx+yad*uby+zad*ubz
+          rudc=xad*ucx+yad*ucy+zad*ucz
+          
+          rvbc=xab*vcx+yab*vcy+zab*vcz
+          rvbd=xab*vdx+yab*vdy+zab*vdz
+          rvcd=xac*vdx+yac*vdy+zac*vdz
+          rvcb=xac*vbx+yac*vby+zac*vbz
+          rvdb=xad*vbx+yad*vby+zad*vbz
+          rvdc=xad*vcx+yad*vcy+zad*vcz
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate potential energy and virial
+          
+          enginv=enginv+omega
+          virinv=virinv+gamvir
+          
+c     calculate solvation energy
+          
+          if(lsolva)then
+            inv_sol(atmolt(ia))=inv_sol(atmolt(ia))+omega
+          endif
+          
+c     calculate atomic forces
+          
+          if(lcalcite)then
+            
+            fax=-gamma*uux
+            fay=-gamma*uuy
+            faz=-gamma*uuz
+            
+            fcx=gamma*uun*((yad*zab-zad*yab)-uuu*(yad*uuz-zad*uuy))
+            fcy=gamma*uun*((zad*xab-xad*zab)-uuu*(zad*uux-xad*uuz))
+            fcz=gamma*uun*((xad*yab-yad*xab)-uuu*(xad*uuy-yad*uux))
+            
+            fdx=gamma*uun*((yab*zac-zab*yac)-uuu*(zac*uuy-yac*uuz))
+            fdy=gamma*uun*((zab*xac-xab*zac)-uuu*(xac*uuz-zac*uux))
+            fdz=gamma*uun*((xab*yac-yab*xac)-uuu*(yac*uux-xac*uuy))
+            
+            fbx=-(fax+fcx+fdx)
+            fby=-(fay+fcy+fdy)
+            fbz=-(faz+fcz+fdz)
+            
+c     stress tensor calculation for calcite terms
+            
+            strs(1)=strs(1)+uuu*gamma*uux*uux
+            strs(2)=strs(2)+uuu*gamma*uux*uuy
+            strs(3)=strs(3)+uuu*gamma*uux*uuz
+            strs(4)=strs(4)+uuu*gamma*uuy*uuy
+            strs(5)=strs(5)+uuu*gamma*uuy*uuz
+            strs(6)=strs(6)+uuu*gamma*uuz*uuz
+          
+          else
+            
+            fbx=gamb*(-cosb*xab*rrab**2+rrab*(rub*ubx+rvb*vbx)/wwb)
+     x      +(ruc*ucn*rrab*(xac-ruc*ucx-(rbc-ruc*rubc)*xab*rrab**2)
+     x      -rvc*vcn*rrab*(xac-rvc*vcx-(rbc-rvc*rvbc)*xab*rrab**2))
+     x      *gamc*rrac/wwc
+     x      +(rud*udn*rrab*(xad-rud*udx-(rdb-rud*rubd)*xab*rrab**2)
+     x      +rvd*vdn*rrab*(xad-rvd*vdx-(rdb-rvd*rvbd)*xab*rrab**2))
+     x      *gamd*rrad/wwd
+          
+            fby=gamb*(-cosb*yab*rrab**2+rrab*(rub*uby+rvb*vby)/wwb)
+     x      +(ruc*ucn*rrab*(yac-ruc*ucy-(rbc-ruc*rubc)*yab*rrab**2)
+     x      -rvc*vcn*rrab*(yac-rvc*vcy-(rbc-rvc*rvbc)*yab*rrab**2))
+     x      *gamc*rrac/wwc
+     x      +(rud*udn*rrab*(yad-rud*udy-(rdb-rud*rubd)*yab*rrab**2)
+     x      +rvd*vdn*rrab*(yad-rvd*vdy-(rdb-rvd*rvbd)*yab*rrab**2))
+     x      *gamd*rrad/wwd
+          
+            fbz=gamb*(-cosb*zab*rrab**2+rrab*(rub*ubz+rvb*vbz)/wwb)
+     x      +(ruc*ucn*rrab*(zac-ruc*ucz-(rbc-ruc*rubc)*zab*rrab**2)
+     x      -rvc*vcn*rrab*(zac-rvc*vcz-(rbc-rvc*rvbc)*zab*rrab**2))
+     x      *gamc*rrac/wwc
+     x      +(rud*udn*rrab*(zad-rud*udz-(rdb-rud*rubd)*zab*rrab**2)
+     x      +rvd*vdn*rrab*(zad-rvd*vdz-(rdb-rvd*rvbd)*zab*rrab**2))
+     x      *gamd*rrad/wwd
+          
+            fcx=gamc*(-cosc*xac*rrac**2+rrac*(ruc*ucx+rvc*vcx)/wwc)
+     x      +(rud*udn*rrac*(xad-rud*udx-(rcd-rud*rucd)*xac*rrac**2)
+     x      -rvd*vdn*rrac*(xad-rvd*vdx-(rcd-rvd*rvcd)*xac*rrac**2))
+     x      *gamd*rrad/wwd
+     x      +(rub*ubn*rrac*(xab-rub*ubx-(rbc-rub*rucb)*xac*rrac**2)
+     x      +rvb*vbn*rrac*(xab-rvb*vbx-(rbc-rvb*rvcb)*xac*rrac**2))
+     x      *gamb*rrab/wwb
+          
+            fcy=gamc*(-cosc*yac*rrac**2+rrac*(ruc*ucy+rvc*vcy)/wwc)
+     x      +(rud*udn*rrac*(yad-rud*udy-(rcd-rud*rucd)*yac*rrac**2)
+     x      -rvd*vdn*rrac*(yad-rvd*vdy-(rcd-rvd*rvcd)*yac*rrac**2))
+     x      *gamd*rrad/wwd
+     x      +(rub*ubn*rrac*(yab-rub*uby-(rbc-rub*rucb)*yac*rrac**2)
+     x      +rvb*vbn*rrac*(yab-rvb*vby-(rbc-rvb*rvcb)*yac*rrac**2))
+     x      *gamb*rrab/wwb
+          
+            fcz=gamc*(-cosc*zac*rrac**2+rrac*(ruc*ucz+rvc*vcz)/wwc)
+     x      +(rud*udn*rrac*(zad-rud*udz-(rcd-rud*rucd)*zac*rrac**2)
+     x      -rvd*vdn*rrac*(zad-rvd*vdz-(rcd-rvd*rvcd)*zac*rrac**2))
+     x      *gamd*rrad/wwd
+     x      +(rub*ubn*rrac*(zab-rub*ubz-(rbc-rub*rucb)*zac*rrac**2)
+     x      +rvb*vbn*rrac*(zab-rvb*vbz-(rbc-rvb*rvcb)*zac*rrac**2))
+     x      *gamb*rrab/wwb
+          
+            fdx=gamd*(-cosd*xad*rrad**2+rrad*(rud*udx+rvd*vdx)/wwd)
+     x      +(rub*ubn*rrad*(xab-rub*ubx-(rdb-rub*rudb)*xad*rrad**2)
+     x      -rvb*vbn*rrad*(xab-rvb*vbx-(rdb-rvb*rvdb)*xad*rrad**2))
+     x      *gamb*rrab/wwb
+     x      +(ruc*ucn*rrad*(xac-ruc*ucx-(rcd-ruc*rudc)*xad*rrad**2)
+     x      +rvc*vcn*rrad*(xac-rvc*vcx-(rcd-rvc*rvdc)*xad*rrad**2))
+     x      *gamc*rrac/wwc
+          
+            fdy=gamd*(-cosd*yad*rrad**2+rrad*(rud*udy+rvd*vdy)/wwd)
+     x      +(rub*ubn*rrad*(yab-rub*uby-(rdb-rub*rudb)*yad*rrad**2)
+     x      -rvb*vbn*rrad*(yab-rvb*vby-(rdb-rvb*rvdb)*yad*rrad**2))
+     x      *gamb*rrab/wwb
+     x      +(ruc*ucn*rrad*(yac-ruc*ucy-(rcd-ruc*rudc)*yad*rrad**2)
+     x      +rvc*vcn*rrad*(yac-rvc*vcy-(rcd-rvc*rvdc)*yad*rrad**2))
+     x      *gamc*rrac/wwc
+          
+            fdz=gamd*(-cosd*zad*rrad**2+rrad*(rud*udz+rvd*vdz)/wwd)
+     x      +(rub*ubn*rrad*(zab-rub*ubz-(rdb-rub*rudb)*zad*rrad**2)
+     x      -rvb*vbn*rrad*(zab-rvb*vbz-(rdb-rvb*rvdb)*zad*rrad**2))
+     x      *gamb*rrab/wwb
+     x      +(ruc*ucn*rrad*(zac-ruc*ucz-(rcd-ruc*rudc)*zad*rrad**2)
+     x      +rvc*vcn*rrad*(zac-rvc*vcz-(rcd-rvc*rvdc)*zad*rrad**2))
+     x      *gamc*rrac/wwc
+          
+            fax=-(fbx+fcx+fdx)
+            fay=-(fby+fcy+fdy)
+            faz=-(fbz+fcz+fdz)
+            
+c     stress tensor calculation for inversion terms
+            
+            strs(1)=strs(1)+xab*fbx+xac*fcx+xad*fdx 
+            strs(2)=strs(2)+yab*fbx+yac*fcx+yad*fdx 
+            strs(3)=strs(3)+zab*fbx+zac*fcx+zad*fdx 
+            strs(4)=strs(4)+yab*fby+yac*fcy+yad*fdy 
+            strs(5)=strs(5)+yab*fbz+yac*fcz+yad*fdz 
+            strs(6)=strs(6)+zab*fbz+zac*fcz+zad*fdz 
+          
+          endif
+          
+          fxx(ia)=fxx(ia)+fax
+          fyy(ia)=fyy(ia)+fay
+          fzz(ia)=fzz(ia)+faz
+          
+          fxx(ib)=fxx(ib)+fbx
+          fyy(ib)=fyy(ib)+fby
+          fzz(ib)=fzz(ib)+fbz
+        
+          fxx(ic)=fxx(ic)+fcx
+          fyy(ic)=fyy(ic)+fcy
+          fzz(ic)=fzz(ic)+fcz
+          
+          fxx(id)=fxx(id)+fdx
+          fyy(id)=fyy(id)+fdy
+          fzz(id)=fzz(id)+fdz
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive.or.kdrive.or.ldrive))then
+          
+c     local energy and virial
+          
+          eng_loc=eng_loc+omega
+          vir_loc=vir_loc+gamvir
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fax
+          fyy_loc(ia)=fyy_loc(ia)+fay
+          fzz_loc(ia)=fzz_loc(ia)+faz
+          
+          fxx_loc(ib)=fxx_loc(ib)+fbx
+          fyy_loc(ib)=fyy_loc(ib)+fby
+          fzz_loc(ib)=fzz_loc(ib)+fbz
+          
+          fxx_loc(ic)=fxx_loc(ic)+fcx
+          fyy_loc(ic)=fyy_loc(ic)+fcy
+          fzz_loc(ic)=fzz_loc(ic)+fcz
+          
+          fxx_loc(id)=fxx_loc(id)+fdx
+          fyy_loc(id)=fyy_loc(id)+fdy
+          fzz_loc(id)=fzz_loc(id)+fdz
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xab*fbx+xac*fcx+xad*fdx 
+          strs_loc(2)=strs_loc(2)+yab*fbx+yac*fcx+yad*fdx 
+          strs_loc(3)=strs_loc(3)+zab*fbx+zac*fcx+zad*fdx 
+          strs_loc(4)=strs_loc(4)+yab*fby+yac*fcy+yad*fdy 
+          strs_loc(5)=strs_loc(5)+yab*fbz+yac*fcz+yad*fdz 
+          strs_loc(6)=strs_loc(6)+zab*fbz+zac*fcz+zad*fdz 
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     check for undefined potentials
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,449)
+      
+c     sum contributions over all nodes
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=enginv
+        buffer(2)=virinv
+        buffer(3)=inv_fre
+        buffer(4)=inv_vir
+        call gdsum(buffer(1),4,buffer(5))
+        enginv=buffer(1)
+        virinv=buffer(2)
+        inv_fre=buffer(3)
+        inv_vir=buffer(4)
+        
+        if(lsolva)then
+          
+          call gdsum(inv_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(inv_exc(1),mxtmls,buffer(1))
+          
+        endif
+
+      endif
+      
+      deallocate (xdab,ydab,zdab,stat=fail1)
+      deallocate (xdac,ydac,zdac,stat=fail2)
+      deallocate (xdad,ydad,zdad,stat=fail3)
+      
+      return
+      end subroutine invfrc
+      
+      end module inversion_module
diff -urN dl_class_1.9.orig/srcmod/lf_motion_module.f dl_class_1.9/srcmod/lf_motion_module.f
--- dl_class_1.9.orig/srcmod/lf_motion_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/lf_motion_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,2994 @@
+      module lf_motion_module
+
+c***********************************************************************
+c     
+c     dl_poly module for verlet leap frog integration schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use property_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+
+      subroutine rdshake_1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x  tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x  txx,tyy,tzz,xxt,yyt,zzt,stresh)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration.
+c     Must be used in conjunction with integration algorithms
+c     
+c     assume bond vectors dxx,dyy,dzz are input
+c     dxx =xxx(i) - xxx(j) etc
+c
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith august 1992.
+c     amended   - t. forester march 1994.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,icyc,i,j,k
+      real(8) tolnce,tstep,vircon,stresh,dxx,dyy,dzz,strs1,strs2
+      real(8) strs3,strs5,strs6,strs9,tstep2,esig,esig1
+      real(8) dis,amti,amtj,omega2,gamma,gammi,gammj,dli,dlj
+      real(8) dxt,dyt,dzt,txx,tyy,tzz,xxt,yyt,zzt
+
+      dimension stresh(9)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      
+c     test size of work arrays
+
+      safe=.true.
+      if(mxxdf.lt.nscons)safe=.false.
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,412)
+
+c     timestep squared
+
+      tstep2=tstep*tstep
+
+c     accumulators for stress tensor
+
+      vircon=0.d0
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      safe=.false.
+
+      do while(.not.safe.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate temporary bond vector
+          
+          dxt(k)=xxx(i)-xxx(j)
+          dyt(k)=yyy(i)-yyy(j)
+          dzt(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition
+        
+        call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+        
+c     calculate maximum error in bondlength
+        
+        esig=0.d0
+        
+        do k=1,nscons
+          
+c     set bond parameter
+          
+          dis=prmcon(listcon(k,1))
+          esig1=abs(dxt(k)**2+dyt(k)**2+dzt(k)**2-dis**2)/dis
+          esig=max(esig,esig1)
+          
+        enddo
+        
+        esig=esig*0.5d0
+
+c     global verification of convergence
+        
+        safe=(esig.lt.tolnce)
+        
+        if(mxnode.gt.1)call gstate(safe)
+
+c     bypass calculations if all tolerances satisfied 
+        
+        if(.not.safe)then
+          
+c     initialise increment arrays
+          
+          do i=1,natms
+            
+            xxt(i)=0.d0
+            yyt(i)=0.d0
+            zzt(i)=0.d0
+            
+          enddo
+          
+c     calculate constraint forces
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+c     set constraint parameters
+            
+            dis=prmcon(listcon(k,1))
+            omega2=dis*dis
+            amti= tstep2/weight(i)
+            amtj=-tstep2/weight(j)
+            
+            if(lstfrz(i).ne.0) amti=0.d0
+            if(lstfrz(j).ne.0) amtj=0.d0
+            
+c     constraint force parameter
+            
+            gamma=(omega2-(dxt(k)**2+dyt(k)**2+dzt(k)**2))/
+     x        (-2.d0*(amti-amtj)*
+     x        (dxx(k)*dxt(k)+dyy(k)*dyt(k)+dzz(k)*dzt(k)))
+            
+c     accumulate bond virial
+            
+            vircon=vircon+gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+            
+            strs1=strs1-gamma*dxx(k)*dxx(k)
+            strs2=strs2-gamma*dxx(k)*dyy(k)
+            strs3=strs3-gamma*dxx(k)*dzz(k)
+            strs5=strs5-gamma*dyy(k)*dyy(k)
+            strs6=strs6-gamma*dyy(k)*dzz(k)
+            strs9=strs9-gamma*dzz(k)*dzz(k)
+            
+c     improve approximate atomic positions
+            
+            gammi=-gamma*amti
+            xxt(i)=xxt(i)+dxx(k)*gammi
+            yyt(i)=yyt(i)+dyy(k)*gammi
+            zzt(i)=zzt(i)+dzz(k)*gammi
+            
+            gammj=-gamma*amtj
+            xxt(j)=xxt(j)+dxx(k)*gammj
+            yyt(j)=yyt(j)+dyy(k)*gammj
+            zzt(j)=zzt(j)+dzz(k)*gammj
+            
+          enddo
+          
+c     transport temporary positions to other nodes
+          
+          if(mxnode.gt.1)then
+            
+            if(lshmov) call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x        txx,tyy,tzz,buffer)
+            
+          endif
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+            dli=1.d0/dble(listme(i))
+            dlj=1.d0/dble(listme(j))
+            
+            xxx(i)=xxx(i)+xxt(i)*dli
+            yyy(i)=yyy(i)+yyt(i)*dli
+            zzz(i)=zzz(i)+zzt(i)*dli
+            xxx(j)=xxx(j)+xxt(j)*dlj
+            yyy(j)=yyy(j)+yyt(j)*dlj
+            zzz(j)=zzz(j)+zzt(j)*dlj
+            
+          enddo
+          
+        endif
+
+      enddo
+        
+c     error exit for non-convergence
+
+      if(.not.safe)return
+
+c     complete stress tensor
+        
+      stresh(1)=strs1
+      stresh(2)=strs2
+      stresh(3)=strs3
+      stresh(4)=strs2
+      stresh(5)=strs5
+      stresh(6)=strs6
+      stresh(7)=strs3
+      stresh(8)=strs6
+      stresh(9)=strs9
+
+c     splice coordinate arrays across nodes
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(stresh,9,buffer)
+        call splice 
+     x    (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+      endif
+
+      return
+      end subroutine rdshake_1
+
+      subroutine nve_1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  engke,tolnce,tstep,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics. Verlet leapfrog With RD-SHAKE
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith august 1992.
+c     amended   - t.forester sept 1994
+c     amended   - t.forester dec  1994 : block data
+c     amended   - w.smith    oct  2005
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail,iatm0
+      integer iatm1,i,j,k
+      real(8) engke,tolnce,tstep,vircon,strkin,rstep
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      
+      dimension strkin(9),fail(7)
+      
+c     allocate working arrays
+
+      do i=1,7
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(7))
+      do i=1,7
+         if(fail(i).ne.0)call error(idnode,1380)
+      enddo
+
+      safe=.false.
+      
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     move atoms by leapfrog algorithm
+      
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+c     update velocities
+        
+        uxx(i)=vxx(i)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyy(i)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzz(i)+tstep*rmass(i)*fzz(i)
+
+c     update positions
+        
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+      
+c     start of bond constraint procedures
+
+      if(ntcons.eq.0)safe=.true.
+      if(ntcons.gt.0)then
+
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+        
+        call rdshake_1
+     x    (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x    tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x    txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+c     calculate velocity correction
+        
+        j=0
+        rstep=1.d0/tstep
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+c     calculate corrected velocity
+          
+          uxx(i)=(xxx(i)-xxo(j))*rstep
+          uyy(i)=(yyy(i)-yyo(j))*rstep
+          uzz(i)=(zzz(i)-zzo(j))*rstep
+          
+c     calculate the corrected forces
+          
+          fxx(i)=(uxx(i)-vxo(j))*weight(i)*rstep
+          fyy(i)=(uyy(i)-vyo(j))*weight(i)*rstep
+          fzz(i)=(uzz(i)-vzo(j))*weight(i)*rstep
+          
+        enddo
+        
+      endif
+
+c     calculate full timestep velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=0.5d0*(vxx(i)+uxx(i))
+        vyy(i)=0.5d0*(vyy(i)+uyy(i))
+        vzz(i)=0.5d0*(vzz(i)+uzz(i))
+
+      enddo
+      
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+      
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c     updated velocity
+      
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nve_1
+
+      subroutine nvt_e1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  engke,tolnce,tstep,vircon)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Evans
+c     thermostat.
+c     Comp. Phys. reports 1, 299, (1984)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond CONSTRAINTS.
+c     
+c     copyright - daresbury laboratory
+c     author    - t forester july 1993
+c     amended   - w.smith october 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail,iatm0
+      integer iatm1,i,j,k,iter,mxiter
+      real(8) engke,tolnce,tstep,vircon,strkin
+      real(8) rstep,chit,viracc,strcon,vdotf
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),strcon(9),fail(7)
+      
+c     allocate working arrays
+
+      do i=1,7
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(7))
+      do i=1,7
+         if(fail(i).ne.0)call error(idnode,1390)
+      enddo
+
+      safe=.false.
+
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial positions and velocities
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+        
+c     begin temperature control iteration
+      
+      mxiter=3
+      if(ntcons.eq.0)mxiter=2
+      chit=0.d0
+      
+      do iter=1,mxiter
+        
+c     move atoms by leapfrog algorithm
+        
+        j=0
+        
+        do i=iatm0,iatm1
+
+          j=j+1
+          
+c     update velocities
+          
+          uxx(i)=vxo(j)+tstep*(rmass(i)*fxx(i)-chit*vxx(i))
+          uyy(i)=vyo(j)+tstep*(rmass(i)*fyy(i)-chit*vyy(i))
+          uzz(i)=vzo(j)+tstep*(rmass(i)*fzz(i)-chit*vzz(i))
+          
+c     update positions
+          
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+          
+        enddo
+        
+c     start of bond constraint procedures
+        
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+          
+c     merge configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          do i=iatm0,iatm1
+            
+            j=j+1
+            
+c     calculate corrected velocity
+            
+            uxx(i)=(xxx(i)-xxo(j))*rstep
+            uyy(i)=(yyy(i)-yyo(j))*rstep
+            uzz(i)=(zzz(i)-zzo(j))*rstep
+            
+c     calculate the corrected forces
+            
+            fxx(i)=(uxx(i)-vxo(j))*weight(i)*rstep
+            fyy(i)=(uyy(i)-vyo(j))*weight(i)*rstep
+            fzz(i)=(uzz(i)-vzo(j))*weight(i)*rstep
+            
+          enddo
+          
+c     end of shake corrections
+
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy and evans thermostat parameter
+        
+        engke=0.d0
+        vdotf=0.d0
+        do i=iatm0,iatm1
+          
+          engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+          vdotf=vdotf+vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=engke
+          buffer(2)=vdotf
+          call gdsum(buffer(1),2,buffer(3))
+          engke=buffer(1)
+          vdotf=buffer(2)
+          
+        endif
+        chit=vdotf/engke
+        engke=0.5d0*engke
+        
+c     end of thermal constraint iteration
+        
+      enddo
+      
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nvt_e1
+
+      subroutine nvt_b1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  engke,taut,sigma,tolnce,tstep,vircon)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat.
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     copyright - daresbury laboratory 1993
+c     author    -    t. forester   may 1993
+c     amended : t.forester sept 1994
+c     amended : t.forester  dec 1994 : block data
+c     amended   - w.smith   oct 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail
+      integer iatm0,iatm1,i,j,k,maxit,iter
+      real(8) engke,taut,sigma,tolnce,tstep,vircon,strkin,viracc
+      real(8) rstep,rtsq,chit0,strcon
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),fail(8),strcon(9)
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1400)
+      enddo
+
+      safe=.false.
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+      
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate kinetic energy at full timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+      engke=getkin(natms,idnode,mxnode)
+      
+c     begin iterations !!-----------------------------------------------
+
+      maxit=3
+      if(ntcons.eq.0) maxit=maxit-1
+      do iter=1,maxit
+
+c     temperature scaling  coefficient - taut is the decay constant
+        
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+
+c     unconstrained new positions with thermostat
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+
+c     store uncorrected positions
+
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+
+        enddo
+
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1)then
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+          
+c     end of shake corrections
+
+        endif
+
+c     calculate kinetic energy
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+c     estimate velocity at the full step
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nvt_b1
+
+      subroutine nvt_h1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  chit,consv,conint,engke,taut,sigma,tolnce,tstep,vircon)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat.
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     copyright - daresbury laboratory
+c     author    - t. forester may 1993
+c     amended   - w.smith october 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail,i,j,k
+      integer iatm0,iatm1,maxit,iter
+      real(8) chit,consv,conint,engke,taut,sigma,tolnce,tstep,vircon
+      real(8) strkin,rstep,rtsq,qmass,chitp,chit0,viracc
+      real(8) chitnew,strcon
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),fail(8),strcon(9)
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1410)
+      enddo
+
+      safe=.false.
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     inertia parameter for Nose-Hoover thermostat
+      
+      qmass=2.0d0*sigma*taut**2
+
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+      
+c     construct current bond vectors
+        
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate velocities at full time step
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+        
+      enddo
+      
+c     kinetic energy at full time step
+      
+      engke=getkin(natms,idnode,mxnode)
+
+c     propagate chit
+
+      chitp=2.d0*(engke-sigma)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=4
+      if(ntcons.eq.0) maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-chit0*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-chit0*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-chit0*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+
+c     store uncorrected positions
+
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+
+        enddo
+
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1)then
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     improved prediction of chit 
+
+        chitp=2.d0*(engke-sigma)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     update thermostat
+
+      chit=chitnew
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*qmass/taut**2
+      consv=conint+0.5d0*qmass*chit0**2
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nvt_h1
+
+      subroutine npt_b1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,elrc,engke,virlrc,press,taup,taut,sigma,tolnce,
+     x  tstep,virtot,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and isotropic pressure control
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond CONSTRAINTS. Frozen atoms feb 1994
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester dec 1993
+c     amended   - w.smith     oct 2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons
+      integer fail,i,j,k,iatm0,iatm1,maxit,iter
+      real(8) elrc,engke,virlrc,press,taup,taut,sigma,tolnce,tstep
+      real(8) virtot,vircon,volm,strkin,beta,volm0,cell0
+      real(8) elrc0,virlrc0,rstep,rtsq,psyst,chip0,scale
+      real(8) chit0,viracc,strcon
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),cell0(9),fail(8),strcon(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+
+      data newjob/.true./
+      data beta/7.3728d-3/
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1420)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume and long range corrections
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1430)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial terms
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial cell vectors
+
+      do i=1,9
+        cell0(i)=cell(i)
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+      
+c     construct current bond vectors
+        
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate velocity at full timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy at current timestep
+
+      engke=getkin(natms,idnode,mxnode)
+
+c     pressure control variable - taup is pressure relaxation time
+
+      psyst=(2.d0*engke-virtot-vircon)/(3.d0*volm)
+      chip0=1.d0+beta*tstep*(psyst-press)/taup
+      scale=chip0**(1.d0/3.d0)
+      
+c     temperature scaling  coefficient - taut is temperature relaxation time
+
+      chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0)maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+scale*xxo(j)
+          yyy(i)=tstep*uyy(i)+scale*yyo(j)
+          zzz(i)=tstep*uzz(i)+scale*zzo(j)
+
+        enddo
+        
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     estimate new cell tensor
+          
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     improved prediction of chip and chit
+
+        psyst=(2.d0*engke-virtot-vircon)/(3.d0*volm)
+        chip0=1.d0+beta*tstep*(psyst-press)/taup
+        scale=chip0**(1.d0/3.d0)
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     update volume
+
+      volm=volm*chip0
+
+c     scale cell vectors - isotropic
+
+      do i=1,9
+        cell(i)=cell0(i)*scale
+      enddo
+
+c     construct scaling tensor (for use with tethers)
+
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=scale
+      eta(5)=scale
+      eta(9)=scale
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine npt_b1
+
+      subroutine npt_h1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,chip,chit,conint,consv,elrc,engke,virlrc,press,
+     x  taup,taut,sigma,temp,tolnce,tstep,virtot,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat+piston.
+c     
+c     reference: Melchionna, Ciccotti and Holian,
+c     Mol Phys 1993, 78, p533
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond constraints (using atomic pressure)
+c     
+c     copyright daresbury laboratory 1995
+c     author    -    s. melchionna   april 1995
+c     and       -    t. forester     april 1995
+c     amended   -    w. smith     october  2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons
+      integer i,j,k,iatm0,iatm1,fail,maxit,iter
+      real(8) chip,chit,conint,consv,elrc,engke,virlrc,press
+      real(8) taup,taut,sigma,temp,tolnce,tstep,virtot,vircon,volm
+      real(8) strcon,volm0,elrc0,virlrc0,rstep,rtsq,qmass
+      real(8) chipnew,chitp,chitnew,chit0,volnew,scale,viracc,vold
+      real(8) cons1,cons2,cons3,strkin,cell0
+      real(8) pmass,totmas,chipp,chip0,com,vom
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strcon(9),fail(8),strkin(9),com(3),vom(3),cell0(9)
+      
+      save newjob,volm0,elrc0,virlrc0,cell0,dens0
+
+      data newjob/.true./
+
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1440)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume, long range corrections etc
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1450)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     inertia parameter for Nose-Hoover thermostat
+      
+      qmass=2.0d0*sigma*taut**2
+      pmass=2.0d0*sigma*taup**2
+
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+
+c     total system mass
+
+      totmas=getmass(natms,idnode,mxnode)
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate centre of mass
+
+      call getcom(natms,idnode,mxnode,totmas,com)
+
+c     estimate kinetic energy at current timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+c     estimate velocity at the full step
+
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     calculate kinetic energy
+
+      engke=getkin(natms,idnode,mxnode)
+        
+c     propagate chip
+
+      chipp=(2.d0*engke-virtot-vircon-3.d0*press*volm)/pmass-
+     x  chit*chip
+      chipnew=chip+tstep*chipp
+      chip0=0.5d0*(chip+chipnew)
+
+c     propagate chit
+
+      chitp=(2.d0*(engke-sigma)+pmass*chip**2-boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0) maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0+chip0)*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0+chip0)*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0+chip0)*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      chipnew*((xxx(i)+xxo(j))*0.5d0-com(1)))
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      chipnew*((yyy(i)+yyo(j))*0.5d0-com(2)))
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      chipnew*((zzz(i)+zzo(j))*0.5d0-com(3)))
+
+        enddo
+        
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     estimate new cell tensor
+
+          volnew=volm*exp(3.d0*tstep*chipnew)
+          scale=(volnew/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     improved prediction of chip and chit 
+
+        chipp=(2.d0*engke-virtot-vircon-3.d0*press*volm)/pmass-
+     x    chit0*chip0
+        chipnew=chip+tstep*chipp
+        chip0=0.5d0*(chip+chipnew)
+
+        chitp=(2.d0*(engke-sigma)+pmass*chip0**2-boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     update volume
+      
+      vold=volm
+      volm=volm*exp(3.d0*tstep*chipnew)
+
+c     scale cell vectors - isotropic
+
+      scale=(volm/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=cell0(i)*scale
+      enddo
+
+c     construct scaling tensor (for later!)
+
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=chipnew
+      eta(5)=chipnew
+      eta(9)=chipnew
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      chip=chipnew
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      cons3=0.5d0*pmass*chip0**2
+      consv=conint+cons1+cons2+cons3
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c     updated velocity
+      
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     ensure total momentum is zero
+
+      call getvom(natms,idnode,mxnode,totmas,vom)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine npt_h1
+
+      subroutine nst_b1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,mode,elrc,engke,virlrc,press,taup,taut,sigma,tolnce,
+     x  tstep,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and anisotropic pressure control
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond CONSTRAINTS. Frozen atoms feb 1994
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester december 1993
+c     amended   - w. smith  october    2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons,mode
+      integer fail,i,j,k,iatm0,iatm1,maxit,iter
+      real(8) elrc,engke,virlrc,press,taup,taut,sigma,tolnce,tstep
+      real(8) vircon,volm,beta,volm0,elrc0,virlrc0,rstep,rtsq,chit0
+      real(8) viracc,strkin,strcon,cell0,stres0,uni
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),strcon(9),cell0(9),fail(8),stres0(9),uni(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data beta/7.3728d-3/
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1460)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume, long range corrections etc
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1470)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store original cell vectors and stress tensor
+
+      do i=1,9
+        
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate kinetic energy at current timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     calculate kinetic energy
+
+      engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     current estimate of stres tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)
+      enddo
+      
+c     initial estimate of eta matrix and chit 
+
+      chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+      do i=1,9
+        eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+      
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0)maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+
+     x      eta(1)*xxo(j)+eta(4)*yyo(j)+eta(7)*zzo(j)
+          yyy(i)=tstep*uyy(i)+
+     x      eta(2)*xxo(j)+eta(5)*yyo(j)+eta(8)*zzo(j)
+          zzz(i)=tstep*uzz(i)+
+     x      eta(3)*xxo(j)+eta(6)*yyo(j)+eta(9)*zzo(j)
+
+        enddo
+        
+c     start of bond constraint procedures
+        
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     estimate new cell parameters
+      
+          call mat_mul(eta,cell0,cell)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)
+        enddo
+
+c     improved calculation of eta matrix and chit 
+
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        do i=1,9
+          eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+        enddo
+        if(mode.gt.0)then
+          eta(3)=0.d0
+          eta(6)=0.d0
+          eta(7)=0.d0
+          eta(8)=0.d0
+          if(mode.lt.3)then
+            eta(2)=0.d0
+            eta(4)=0.d0
+            if(mode.eq.2)then
+              eta(1)=0.5d0*(eta(1)+eta(5))
+              eta(5)=eta(1)
+            endif
+          endif
+        endif
+        
+c     end of thermostat and barostat iterations
+
+      enddo
+
+c     update volume
+      
+      volm=volm*eta(1)*eta(5)*eta(9)
+
+c     adjust cell vectors - anisotropic
+
+      call mat_mul(eta,cell0,cell)
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     restore half step velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nst_b1
+
+      subroutine nst_h1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,mode,chit,conint,consv,elrc,engke,virlrc,press,
+     x  taup,taut,sigma,temp,tolnce,tstep,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat+piston.
+c     
+c     Parrinello - Rahman type : changing cell shape.
+c     
+c     reference: Melchionna, Ciccotti and Holian,
+c     Mol Phys 1993, 78, p533
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond constraints (using atomic pressure)
+c     
+c     copyright daresbury laboratory 1995
+c     author    -    t. forester     june  1995
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons
+      integer fail,i,j,k,iatm0,iatm1,maxit,iter,mode
+      real(8) chip,chit,conint,consv,elrc,engke,virlrc,press
+      real(8) taup,taut,sigma,temp,tolnce,tstep,vircon,volm
+      real(8) strcon,strkin,etanew,eta0,cell0,volm0,elrc0,virlrc0
+      real(8) rstep,rtsq,pmass,qmass,totmas,com,vom,uni,fac
+      real(8) chitp,chitnew,chit0,xxa,yya,zza,etadot
+      real(8) viracc,cons1,cons2,cons3,vold,stres0
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),strcon(9),fail(8),com(3),vom(3)
+      dimension etanew(9),eta0(9),cell0(9),stres0(9),uni(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+
+      data newjob/.true./,uni/1.d0,3*0.d0,1.d0,3*0.d0,1.d0/
+      
+c     allocate working arrays
+      
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1480)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume, long range corrections etc
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1490)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     inertia parameter for Nose-Hoover thermostat
+      
+      qmass=2.0d0*sigma*taut**2
+      pmass=2.0d0*sigma*taup**2
+
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store original cell vectors and stress tensor
+
+      do i=1,9
+        
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+
+c     total system mass
+
+      totmas=getmass(natms,idnode,mxnode)
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate system centre of mass
+
+      call getcom(natms,idnode,mxnode,totmas,com)
+
+c     estimate kinetic energy at current timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+c     estimate position at current time step
+
+        xxx(i)=xxo(j)+tstep*(vxo(j)+tstep*rmass(i)*fxx(i))
+        yyy(i)=yyo(j)+tstep*(vyo(j)+tstep*rmass(i)*fyy(i))
+        zzz(i)=zzo(j)+tstep*(vzo(j)+tstep*rmass(i)*fzz(i))
+        
+c     estimate velocity at the full step
+
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     calculate kinetic energy
+
+      engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     initial estimate of stress tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)
+      enddo
+
+c     propagation of eta
+
+      fac=9.d0
+      do i=1,9
+        etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x    chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        fac=5.d0
+        etanew(3)=0.d0
+        etanew(6)=0.d0
+        etanew(7)=0.d0
+        etanew(8)=0.d0
+        if(mode.lt.3)then
+          fac=3.d0
+          etanew(2)=0.d0
+          etanew(4)=0.d0
+          if(mode.eq.2)then
+            fac=2.d0
+            etanew(1)=0.5d0*(etanew(1)+etanew(5))
+            etanew(5)=etanew(1)
+          endif
+        endif
+      endif
+      do i=1,9
+        eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+      enddo
+
+c     propagate chit
+
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      chitp=(2.d0*(engke-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0) maxit=maxit-1
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-(eta0(1)+chit0)*vxx(i)-
+     x      eta0(4)*vyy(i)-eta0(7)*vzz(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-(eta0(5)+chit0)*vyy(i)-
+     x      eta0(2)*vxx(i)-eta0(8)*vzz(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-(eta0(9)+chit0)*vzz(i)-
+     x      eta0(3)*vxx(i)-eta0(6)*vyy(i))
+
+c     advance positions using leapfrog
+
+          xxa=(xxx(i)+xxo(j))*0.5d0-com(1)
+          yya=(yyy(i)+yyo(j))*0.5d0-com(2)
+          zza=(zzz(i)+zzo(j))*0.5d0-com(3)
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      etanew(1)*xxa+etanew(4)*yya+etanew(7)*zza)
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      etanew(2)*xxa+etanew(5)*yya+etanew(8)*zza)
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      etanew(3)*xxa+etanew(6)*yya+etanew(9)*zza)
+
+        enddo
+        
+c     start of bond constraint procedures
+        
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     estimate new cell parameters
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        call cell_propagate(tstep,cell,etanew)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)
+        enddo
+
+c     improved prediction of eta
+
+        do i=1,9
+          etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x      chit0*eta0(i))
+        enddo
+        if(mode.gt.0)then
+          etanew(3)=0.d0
+          etanew(6)=0.d0
+          etanew(7)=0.d0
+          etanew(8)=0.d0
+          if(mode.lt.3)then
+            etanew(2)=0.d0
+            etanew(4)=0.d0
+            if(mode.eq.2)then
+              etanew(1)=0.5d0*(etanew(1)+etanew(5))
+              etanew(5)=etanew(1)
+            endif
+          endif
+        endif
+        do i=1,9
+          eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+        enddo
+
+c     improved prediction of chit
+
+        etadot=sdot0(9,eta0,eta0)
+        if(mode.eq.2)etadot=etadot-eta0(1)**2
+        chitp=(2.d0*(engke-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      do i=1,9
+        eta(i)=etanew(i)
+      enddo
+
+c     update volume
+      
+      chip=eta(1)+eta(5)+eta(9)
+      vold=volm
+      volm=volm*exp(tstep*chip)
+
+c     adjust cell vectors - anisotropic
+
+      do i=1,9
+        cell(i)=cell0(i)
+      enddo
+      call cell_propagate(tstep,cell,eta)
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     conserved quantity less kinetic and potential energy
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+fac*boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      cons3=0.5d0*pmass*etadot
+      consv=conint+cons1+cons2+cons3
+
+c     restore half step velocity
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+
+c     ensure total momentum is zero
+
+      call getvom(natms,idnode,mxnode,totmas,vom)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nst_h1
+      
+      end module lf_motion_module
diff -urN dl_class_1.9.orig/srcmod/lf_rotation1_module.f dl_class_1.9/srcmod/lf_rotation1_module.f
--- dl_class_1.9.orig/srcmod/lf_rotation1_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/lf_rotation1_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,5315 @@
+      module lf_rotation1_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 1 for verlet leap frog rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use lf_motion_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+      
+      subroutine update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c***********************************************************************
+c     
+c     dlpoly routine to update the quaternion arrays as part of
+c     the leapfrog algorithm
+c     
+c     copyright daresbury laboratory
+c     author   -  w.smith october 2005
+c     based on -  t.forester oct. 1993
+c     
+c**********************************************************************
+
+      implicit none
+
+      real(8), parameter :: pt5=0.5d0
+
+      logical safeq
+      integer igrp1,igrp2,jg,itq,ig
+      real(8) qn0,qn1,qn2,qn3,qn0a,qn1a,qn2a,qn3a,qn0b,qn1b,qn2b,qn3b
+      real(8) rnorm,tstep,quattol,eps
+      real(8) opx(msgrp),opy(msgrp),opz(msgrp)
+      real(8) oqx(msgrp),oqy(msgrp),oqz(msgrp)
+
+      jg=0
+      safeq=.true.
+
+      do ig=igrp1,igrp2
+
+        jg=jg+1
+
+c     first iteration of new quaternions (lab fixed)
+        
+        qn0=q0(ig)+(-q1(ig)*opx(jg)-q2(ig)*opy(jg)-q3(ig)*opz(jg))
+     x    *tstep*pt5
+        qn1=q1(ig)+( q0(ig)*opx(jg)-q3(ig)*opy(jg)+q2(ig)*opz(jg))
+     x    *tstep*pt5
+        qn2=q2(ig)+( q3(ig)*opx(jg)+q0(ig)*opy(jg)-q1(ig)*opz(jg))
+     x    *tstep*pt5
+        qn3=q3(ig)+(-q2(ig)*opx(jg)+q1(ig)*opy(jg)+q0(ig)*opz(jg))
+     x    *tstep*pt5
+        
+        qn0b=0.d0
+        qn1b=0.d0
+        qn2b=0.d0
+        qn3b=0.d0
+        
+        itq=0
+        eps=1.0d9
+        do while((itq.lt.mxquat).and.(eps.gt.quattol))
+          
+          itq=itq+1
+          
+          qn0a=pt5*(-q1(ig)*opx(jg)-q2(ig)*opy(jg)-q3(ig)*opz(jg))
+     x      +pt5*(-qn1*oqx(jg)-qn2*oqy(jg)-qn3*oqz(jg))
+          qn1a=pt5*(  q0(ig)*opx(jg)-q3(ig)*opy(jg)+q2(ig)*opz(jg))
+     x      +   pt5*( qn0*oqx(jg)-qn3*oqy(jg)+qn2*oqz(jg))
+          qn2a=pt5*(  q3(ig)*opx(jg)+q0(ig)*opy(jg)-q1(ig)*opz(jg))
+     x      +   pt5*( qn3*oqx(jg)+qn0*oqy(jg)-qn1*oqz(jg))
+          qn3a=pt5*(-q2(ig)*opx(jg)+q1(ig)*opy(jg)+q0(ig)*opz(jg))
+     x      +   pt5*(-qn2*oqx(jg)+qn1*oqy(jg)+qn0*oqz(jg))
+          
+          qn0=q0(ig)+pt5*qn0a*tstep
+          qn1=q1(ig)+pt5*qn1a*tstep
+          qn2=q2(ig)+pt5*qn2a*tstep
+          qn3=q3(ig)+pt5*qn3a*tstep
+          
+          rnorm=1.d0/sqrt(qn0**2+qn1**2+qn2**2+qn3**2)
+          qn0=qn0*rnorm
+          qn1=qn1*rnorm
+          qn2=qn2*rnorm
+          qn3=qn3*rnorm
+          
+c     convergence test 
+          
+          eps=sqrt(((qn0a-qn0b)**2+(qn1a-qn1b)**2+(qn2a-qn2b)**2
+     x      +(qn3a-qn3b)**2)*tstep**2)
+          
+          qn0b=qn0a
+          qn1b=qn1a
+          qn2b=qn2a
+          qn3b=qn3a
+          
+        enddo
+        
+        if(itq.ge.mxquat) safeq=.false.
+        
+c     store new quaternions
+        
+        q0(ig)=qn0
+        q1(ig)=qn1
+        q2(ig)=qn2
+        q3(ig)=qn3
+        
+      enddo
+
+      return
+      end subroutine update_quaternions
+      
+      subroutine nveq_1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x  vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=12
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,safeq,lshmov,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer fail,i,igrp,igrp1,igrp2,idum,ifre1,ifre2,j,ifre
+      integer jg,ig,k,id,jr
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) strkin,rot,rstep,rtsq,engtrn,vaa,vbb,vcc
+      real(8) trx,try,trz,delx,dely,delz,engfke
+      real(8) strgrp,tqx,tqy,tqz,fmx,fmy,fmz
+
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension strkin(9),strgrp(9),rot(9),fail(nnn)
+      
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(12))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1500)
+      enddo
+     
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        newjob=.false.
+        
+      endif
+
+      safe=.false.
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     integrate 'free' particles
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+c     advance velocity by leapfrog
+
+        uxx(i)=vxo(j)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyo(j)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzo(j)+tstep*rmass(i)*fzz(i)
+
+c     advance position by leapfrog
+
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+
+      if(ntcons.eq.0) safe=.true.
+      if(ntcons.gt.0) then
+
+c     store integrated positions
+
+        j=0
+        do ifre=ifre1,ifre2
+
+          i=lstfre(ifre)
+          j=j+1
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+
+        enddo
+
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+        
+        call rdshake_1
+     x    (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x    tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x    txx,tyy,tzz,xxt,yyt,zzt,strcns)
+        
+c     calculate force and velocity corrections
+        
+        j=0
+        rstep=1.d0/tstep
+        rtsq=1.d0/tstep**2
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     calculate force correction
+        
+          fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+          fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+          fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+
+          uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+          uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+          uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+        enddo
+
+c     end of shake corrections
+        
+      endif
+
+c     estimate full step velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+        vxx(i)=0.5d0*(uxx(i)+vxo(j))
+        vyy(i)=0.5d0*(uyy(i)+vyo(j))
+        vzz(i)=0.5d0*(uzz(i)+vzo(j))
+        
+      enddo
+      
+c     calculate new kinetic energy at current timestep
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+        
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+
+c     restore free atom half step velocity
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+        
+c     *************  Rigid body motion ****************************
+
+c     translational rigid body motion
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+          
+        enddo
+
+c     advance velocity by leapfrog
+        
+        uxx(ig)=gvxx(ig)+fmx*tstep/gmass(id)
+        uyy(ig)=gvyy(ig)+fmy*tstep/gmass(id)
+        uzz(ig)=gvzz(ig)+fmz*tstep/gmass(id)
+
+c     advance position by leapfrog
+
+        gcmx(ig)=gcmx(ig)+tstep*uxx(ig)
+        gcmy(ig)=gcmy(ig)+tstep*uyy(ig)
+        gcmz(ig)=gcmz(ig)+tstep*uzz(ig)
+
+c     estimate velocity at full time step
+
+        gvxx(ig)=0.5d0*(gvxx(ig)+uxx(ig))
+        gvyy(ig)=0.5d0*(gvyy(ig)+uyy(ig))
+        gvzz(ig)=0.5d0*(gvzz(ig)+uzz(ig))
+        
+      enddo
+
+c     calculate rigid body translational kinetic energy
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     total translational kinetic energy
+      
+      engke=engtrn+engfke
+
+c     calculate rigid body kinetic stress tensor
+      
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     restore rigid body half timestep velocity
+
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=uxx(ig)
+        gvyy(ig)=uyy(ig)
+        gvzz(ig)=uzz(ig)
+
+      enddo
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx=0.d0
+        tqy=0.d0
+        tqz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx=tqx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy=tqy+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz=tqz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     store current angular velocity
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx*rot(1)+tqy*rot(4)+tqz*rot(7))*rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*rotinx(id,2)
+          try=(tqx*rot(2)+tqy*rot(5)+tqz*rot(8))*rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*rotiny(id,2)
+          trz=(tqx*rot(3)+tqy*rot(6)+tqz*rot(9))*rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*rotinz(id,2)
+
+          delx=tstep*trx
+          dely=tstep*try
+          delz=tstep*trz
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+delx*pt5
+          opy(jg)=omy(ig)+dely*pt5
+          opz(jg)=omz(ig)+delz*pt5
+
+        enddo
+
+c     angular velocity at time step n+1/2
+
+        uxx(ig)=omx(ig)+delx
+        uyy(ig)=omy(ig)+dely
+        uzz(ig)=omz(ig)+delz
+
+c     angular velocity at time step n+1  (needed for quat algorithm)
+        
+        oqx(jg)=omx(ig)+delx*1.5d0
+        oqy(jg)=omy(ig)+dely*1.5d0
+        oqz(jg)=omz(ig)+delz*1.5d0
+
+c     angular velocity at timestep n
+        
+        omx(ig)=omx(ig)+pt5*delx
+        omy(ig)=omy(ig)+pt5*dely
+        omz(ig)=omz(ig)+pt5*delz
+        
+      enddo
+
+c     rotational kinetic energy
+        
+      engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocity
+
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+        omx(ig)=uxx(ig)
+        omy(ig)=uyy(ig)
+        omz(ig)=uzz(ig)
+        
+      enddo
+      
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies - relative to c.o.m
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     deallocate work arrays
+
+      deallocate(opx,opy,opz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(oqx,oqy,oqz,dtx,dty,dtz,stat=fail(2))
+      deallocate(dxx,dyy,dzz,uxx,uyy,uzz,stat=fail(3))
+      deallocate(txx,tyy,tzz,dxt,dyt,dzt,stat=fail(4))
+      deallocate(xxo,yyo,zzo,xx1,yy1,zz1,stat=fail(5))
+      deallocate(vxo,vyo,vzo,gcxo,gcyo,gczo,stat=fail(6))
+      
+      return
+      end subroutine nveq_1
+
+      subroutine nvtq_b1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x  tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat.
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principle axis)
+c     rotinx,y,z = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,safeq,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer i,fail,igrp,igrp1,igrp2,ifre,ifre1,ifre2,jg,ig
+      integer j,k,jr,id,mxiter,iter,idum
+      real(8) engke,engrot,quattol,sigma,taut,tolnce,tstep,vircom
+      real(8) vircon,strkin,strgrp,rot,rstep,rtsq
+      real(8) engtrn,trx,try,trz,chit0,rgmas,engfke
+      real(8) vaa,vbb,vcc,engtot,viracc,strcon
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+
+      dimension strkin(9),strgrp(9),strcon(9),rot(9),fail(nnn)
+      
+      save igrp1,igrp2,ifre1,ifre2,newjob
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1510)
+      enddo
+     
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+
+      endif
+
+      safe=.false.
+
+c     initialise constraint virial terms
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity and temperature at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omxo(jg)
+        opy(jg)=omyo(jg)
+        opz(jg)=omzo(jg)
+
+c     iterate angular velocity for time step n (e. yezdimer)
+        
+        do i=1,5
+          
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*rotinz(id,2)
+
+c     improved angular velocity at time step n
+          
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+        
+        enddo
+        
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     temperature scaling  coefficient - taut is the relaxation time
+      
+      engtot=engfke+engrot+engtrn
+      chit0= sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=2
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions 
+          
+          xxx(i)=tstep*uxx(i)+xxo(j)
+          yyy(i)=tstep*vyy(i)+yyo(j)
+          zzz(i)=tstep*uzz(i)+zzo(j)
+
+        enddo
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+        
+c     calculate force and velocity corrections
+        
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+        
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+c     estimate full step velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+        vxx(i)=0.5d0*(uxx(i)+vxo(j))
+        vyy(i)=0.5d0*(uyy(i)+vyo(j))
+        vzz(i)=0.5d0*(uzz(i)+vzo(j))
+        
+      enddo
+      
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        if(iter.eq.mxiter)call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore free atom half step velocity
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vxx(i)=uxx(i)
+          vyy(i)=uyy(i)
+          vzz(i)=uzz(i)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :************
+        
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=(gvxo(jg)+tstep*(fmx(jg)*rgmas))*chit0
+          uyy(ig)=(gvyo(jg)+tstep*(fmy(jg)*rgmas))*chit0
+          uzz(ig)=(gvzo(jg)+tstep*(fmz(jg)*rgmas))*chit0
+
+c     update positions 
+          
+          gcmx(ig)=gcxo(jg)+tstep*uxx(ig)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(ig)
+          gcmz(ig)=gczo(jg)+tstep*uzz(ig)
+          
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities 
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+          
+        enddo
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     scaled angular velocity at time step n
+            
+          omx(ig)=(omxo(jg)+pt5*tstep*trx)*chit0
+          omy(ig)=(omyo(jg)+pt5*tstep*try)*chit0
+          omz(ig)=(omzo(jg)+pt5*tstep*trz)*chit0
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=(omxo(jg)+tstep*trx)*chit0
+          uyy(ig)=(omyo(jg)+tstep*try)*chit0
+          uzz(ig)=(omzo(jg)+tstep*trz)*chit0
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+1.5d0*tstep*trx)*chit0
+          oqy(jg)=(omyo(jg)+1.5d0*tstep*try)*chit0
+          oqz(jg)=(omzo(jg)+1.5d0*tstep*trz)*chit0
+
+        enddo
+        
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+
+c     total translational kinetic energy
+      
+        engke=engtrn+engfke
+      
+c     total kinetic energy
+        
+        engtot=engke+engrot
+        
+c     improved prediction of chit
+
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nvtq_b1
+
+      subroutine nvtq_h1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,chit,consv,conint,engke,engrot,quattol,
+     x  sigma,taut,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat.
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principle axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,lshmov,safeq,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer fail,i,idum,igrp,igrp1,igrp2,ifre,ifre1,ifre2
+      integer j,k,ig,jg,jr,id,iter,mxiter
+      real(8) chit,consv,conint,engke,engrot,quattol,sigma,taut
+      real(8) tolnce,tstep,vircom,vircon,strkin,strgrp,strcon,rot
+      real(8) rstep,rtsq,qmass,engtrn,cons1,engtot,vaa,vbb,vcc
+      real(8) chit0,chitnew,chitp,viracc,rgmas,trx,try,trz,delx
+      real(8) dely,delz,engfke
+
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension strkin(9),strgrp(9),strcon(9),rot(9),fail(nnn)
+      
+      save igrp1,igrp2,ifre1,ifre2,qmass,newjob
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1520)
+      enddo
+
+      if(newjob)then
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+
+c     initialise constraint virial terms
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity and temperature at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+      
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omxo(jg)
+        opy(jg)=omyo(jg)
+        opz(jg)=omzo(jg)
+
+c     iterate angular velocity for time step n (e. yezdimer)
+        
+        do i=1,5
+          
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+          
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+        
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     propagate chit
+
+      engke=engfke+engtrn
+      engtot=engke+engrot
+      chitp=2.d0*(engtot-sigma)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=4
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-chit0*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-chit0*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-chit0*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+
+        enddo
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+            
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate force and velocity corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+        
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+        if(iter.eq.mxiter)then
+          
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)
+          
+c     restore free atom half step velocity
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+          
+        endif
+        
+c     ********: rigid body motion - thermostated  :************
+        
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=gvxo(jg)+tstep*(fmx(jg)*rgmas-chit0*gvxx(ig))
+          uyy(ig)=gvyo(jg)+tstep*(fmy(jg)*rgmas-chit0*gvyy(ig))
+          uzz(ig)=gvzo(jg)+tstep*(fmz(jg)*rgmas-chit0*gvzz(ig))
+
+c     update positions
+
+          gcmx(ig)=gcxo(jg)+tstep*uxx(ig)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(ig)
+          gcmz(ig)=gczo(jg)+tstep*uzz(ig)
+
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)then
+
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     restore half step velocities 
+          
+          do ig=igrp1,igrp2
+            
+            gvxx(ig)=uxx(ig)
+            gvyy(ig)=uyy(ig)
+            gvzz(ig)=uzz(ig)
+            
+          enddo
+        
+        endif
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        safeq=.true.
+        engrot=0.d0
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     correction due to thermostat
+
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=omxo(jg)+delx
+          uyy(ig)=omyo(jg)+dely
+          uzz(ig)=omzo(jg)+delz
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+
+        enddo
+
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+
+c     improved prediction of chit 
+
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chitp=2.d0*(engtot-sigma)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+c     update thermostat variable
+
+      chit=chitnew
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*qmass/taut**2
+      cons1=0.5d0*qmass*chit0**2
+      consv=conint+cons1
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nvtq_h1
+
+      subroutine nptq_b1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,virtot,vircom,
+     x  vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and barostat.
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principl axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob,safeq
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,i,fail,igrp,igrp1,igrp2,idum,ifre,ifre1
+      integer ifre2,j,jg,ig,jr,k,id,iter,mxiter
+      real(8) elrc,engke,engrot,virlrc,press,quattol,sigma,taup,taut
+      real(8) tolnce,tstep,virtot,vircom,vircon,volm,rot,engfke,uni
+      real(8) cell0,beta,volm0,elrc0,virlrc0,rstep,rtsq
+      real(8) engtrn,trx,try,trz,chip0,scale,engtot,chit0,viracc,czero
+      real(8) rgmas,vaa,vbb,vcc,strkin,strcon,strgrp,psyst
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension fail(nnn),rot(9),cell0(9),czero(9),uni(9)
+      dimension strcon(9),strgrp(9),strkin(9)
+
+      save newjob,volm0,elrc0,virlrc0,cell0,dens0,igrp1,igrp2
+      save ifre1,ifre2
+      
+      data newjob/.true./,beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1530)
+      enddo
+     
+      if(newjob) then
+
+c     store initial values of volume and long range corrections
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1540)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+
+c     constraint stress tensor accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     current cell vectors
+      
+      do i=1,9
+        czero(i)=cell(i)
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity and temperature at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     pressure control variable - taup is the relaxation time
+
+      engke=engfke+engtrn
+      psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+      chip0=1.d0+beta*tstep*(psyst-press)/taup
+      scale=chip0**(1.d0/3.d0)
+      
+c     temperature scaling  coefficient - taut is the relaxation time
+      
+      engtot=engke+engrot
+      chit0= sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+scale*xxo(j)
+          yyy(i)=tstep*uyy(i)+scale*yyo(j)
+          zzz(i)=tstep*uzz(i)+scale*zzo(j)
+
+        enddo
+
+c     estimate new cell tensor
+
+        do i=1,9
+          cell(i)=scale*czero(i)
+        enddo
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate force correction
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+
+c     calculate force correction
+        
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        if(iter.eq.mxiter)call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore free atom half step velocity
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vxx(i)=uxx(i)
+          vyy(i)=uyy(i)
+          vzz(i)=uzz(i)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :************
+
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=(gvxo(jg)+tstep*(fmx(jg)*rgmas))*chit0
+          uyy(ig)=(gvyo(jg)+tstep*(fmy(jg)*rgmas))*chit0
+          uzz(ig)=(gvzo(jg)+tstep*(fmz(jg)*rgmas))*chit0
+
+c     update positions : 
+          
+          gcmx(ig)=scale*gcxo(jg)+tstep*uxx(ig)
+          gcmy(ig)=scale*gcyo(jg)+tstep*uyy(ig)
+          gcmz(ig)=scale*gczo(jg)+tstep*uzz(ig)
+          
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities 
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+          
+        enddo
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     scaled angular velocity at time step n
+          
+          omx(ig)=(omxo(jg)+pt5*tstep*trx)*chit0
+          omy(ig)=(omyo(jg)+pt5*tstep*try)*chit0
+          omz(ig)=(omzo(jg)+pt5*tstep*trz)*chit0
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=(omxo(jg)+tstep*trx)*chit0
+          uyy(ig)=(omyo(jg)+tstep*try)*chit0
+          uzz(ig)=(omzo(jg)+tstep*trz)*chit0
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+1.5d0*tstep*trx)*chit0
+          oqy(jg)=(omyo(jg)+1.5d0*tstep*try)*chit0
+          oqz(jg)=(omzo(jg)+1.5d0*tstep*trz)*chit0
+
+        enddo
+        
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+        
+c     total translational kinetic energy
+      
+        engke=engtrn+engfke
+      
+c     total kinetic energy
+        
+        engtot=engke+engrot
+        
+c     improved pressure control variable
+
+        psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+        chip0=1.d0+beta*tstep*(psyst-press)/taup
+        scale=chip0**(1.d0/3.d0)
+        
+c     improved temperature scaling  coefficient
+        
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     scale cell vectors
+
+      scale=((chip0*volm)/volm0)**(1.d0/3.d0)
+
+      do i=1,9
+        cell(i)=scale*cell0(i)
+      enddo
+
+c     construct scaling tensor (for later!)
+
+      do i=1,9
+        eta(i)=scale*uni(i)
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nptq_b1
+
+      subroutine nptq_h1
+     x (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x  engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x  tstep,virtot,vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover
+c     thermostat and barostat (Melchionna et al variant)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principl axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,safeq,lshmov,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,fail,i,igrp,igrp1,igrp2,ifre,ifre1,ifre2
+      integer j,k,ig,jg,jr,id,iter,mxiter,idum
+      real(8) chip,chit,consv,conint,elrc,engke,engrot,virlrc,press
+      real(8) quattol,sigma,taup,taut,temp,tolnce,tstep,virtot,vircom
+      real(8) vircon,volm,cell0,rot,volm0,elrc0,rtsq,uni
+      real(8) virlrc0,strkin,rstep,qmass,pmass,strgrp,strcon
+      real(8) trx,try,trz,chipp,chipnew,chip0,engtot,chitp
+      real(8) chitnew,chit0,volnew,scale,viracc,rgmas
+      real(8) vaa,vbb,vcc,vold,cons1,cons2,cons3,delx,dely,delz
+      real(8) engtrn,totmas,com,vom,engfke
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension fail(nnn),rot(9),cell0(9),uni(9)
+      dimension strkin(9),strcon(9),strgrp(9),com(3),vom(3)
+
+      save newjob,volm0,elrc0,virlrc0,cell0,dens0,pmass,qmass
+      save igrp1,igrp2,ifre1,ifre2,totmas
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1550)
+      enddo
+
+      if(newjob) then
+
+c     store initial values of volume and long range corrections
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1560)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+        
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+
+      safe=.false.
+
+c     temporary stress tensor accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     ensure total momentum is zero
+
+      call getvom(natms,idnode,mxnode,totmas,vom)
+      
+c     correction to velocities
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+
+      enddo
+
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     calculate centre of mass
+
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     estimate velocity at full step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+          
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     propagate chip
+
+      engke=engfke+engtrn
+      chipp=(2.d0*engke-virtot-vircon-vircom-3.d0*press*volm)/pmass-
+     x  chit*chip
+      chipnew=chip+tstep*chipp
+      chip0=0.5d0*(chip+chipnew)
+
+c     propagate chit
+
+      engtot=engke+engrot
+      chitp=(2.d0*(engtot-sigma)+pmass*chip0**2-boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0+chip0)*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0+chip0)*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0+chip0)*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      chipnew*((xxx(i)+xxo(j))*0.5d0-com(1)))
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      chipnew*((yyy(i)+yyo(j))*0.5d0-com(2)))
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      chipnew*((zzz(i)+zzo(j))*0.5d0-com(3)))
+
+        enddo
+
+c     estimate new cell parameters
+
+        volnew=volm*exp(3.d0*tstep*chipnew)
+        scale=(volnew/volm0)**(1.d0/3.d0)
+        do i=1,9
+          cell(i)=cell0(i)*scale
+        enddo
+        
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate force correction
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        if(iter.eq.mxiter)then
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)
+          
+c     restore free atom half step velocity
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+        
+        endif
+        
+c     ********: rigid body motion - thermostated  :***********
+
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=gvxo(jg)+tstep*(fmx(jg)*rgmas-(chit0+chip0)*
+     x      gvxx(ig))
+          uyy(ig)=gvyo(jg)+tstep*(fmy(jg)*rgmas-(chit0+chip0)*
+     x      gvyy(ig))
+          uzz(ig)=gvzo(jg)+tstep*(fmz(jg)*rgmas-(chit0+chip0)*
+     x      gvzz(ig))
+
+c     advance positions using leapfrog
+
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(ig)+
+     x      chipnew*((gcmx(ig)+gcxo(jg))*0.5d0-com(1)))
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(ig)+
+     x      chipnew*((gcmy(ig)+gcyo(jg))*0.5d0-com(2)))
+          gcmz(ig)=gczo(jg)+tstep*(uzz(ig)+
+     x      chipnew*((gcmz(ig)+gczo(jg))*0.5d0-com(3)))
+          
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate kinetic energy and stress tensor
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities 
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+          
+        enddo
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+          
+c     correction due to thermostat
+
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=omxo(jg)+delx
+          uyy(ig)=omyo(jg)+dely
+          uzz(ig)=omzo(jg)+delz
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+
+        enddo
+
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+        
+c     improved prediction of chip
+
+        engke=engfke+engtrn
+        chipp=(2.d0*engke-virtot-vircom-vircon-3.d0*press*volm)/pmass-
+     x    chit0*chip0
+        chipnew=chip+tstep*chipp
+        chip0=0.5d0*(chip+chipnew)
+
+c     improved prediction of chit
+        
+        engtot=engke+engrot
+        chitp=(2.d0*(engtot-sigma)+pmass*chip0**2-boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+c     update volume
+
+      vold=volm
+      volm=volm*exp(3.d0*tstep*chipnew)
+
+c     scale cell vectors - isotropic
+
+      scale=(volm/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=cell0(i)*scale
+      enddo
+
+c     construct scaling tensor (for later!)
+
+      do i=1,9
+        eta(i)=chipnew*uni(i)
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      chip=chipnew
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      cons3=0.5d0*pmass*chip0**2
+      consv=conint+cons1+cons2+cons3
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nptq_h1
+
+      subroutine nstq_b1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and barostat. (cell may change shape).
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principl axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,lshmov,newjob,safeq
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,fail,i,idum,igrp,igrp1,igrp2,ifre,ifre1,mode
+      integer ifre2,j,k,ig,jg,jr,id,iter,mxiter
+      real(8) elrc,engke,engrot,virlrc,press,quattol,sigma,taup,taut
+      real(8) tolnce,tstep,vircom,vircon,volm,beta,uni,cell0
+      real(8) volm0,elrc0,virlrc0,rot,rstep,rtsq,engfke
+      real(8) engtrn,trx,try,trz,engtot,chit0,rgmas
+      real(8) vaa,vbb,vcc,viracc,strkin,strcon,strgrp,stres0
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension strkin(9),strcon(9),strgrp(9),stres0(9),rot(9)
+      dimension fail(nnn),uni(9),cell0(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+      save igrp1,igrp2,ifre1,ifre2
+
+      data newjob/.true./, beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxxdf),yyo(mxxdf),zzo(mxxdf),stat=fail(9))
+      allocate (xx1(mxxdf),yy1(mxxdf),zz1(mxxdf),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1570)
+      enddo
+
+      if(newjob) then
+
+c     store initial values of volume, long range corrections etc
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1580)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe= (igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        newjob=.false.
+
+      endif
+      
+      safe=.false.
+      
+c     temporary stress tensor accumulators and new cell
+
+      vircon=0.d0
+      do i=1,9
+
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+c     construct current bond vectors - required by shake
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+      endif
+      
+c     calculate atom displacement from coms
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     estimate kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     stress tensor of free atoms
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+
+c     estimate translational kinetic energy of rigid bodies
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+
+c     forces on centre of mass
+          
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+        
+      enddo
+
+c     translational kinetic energy of rigid body
+      
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     stress tensor of rigid body
+      
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+
+c     calculate rotational kinetic energy of rigid bodies
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     find eta - taup is the relaxation time
+
+      do i=1,9
+        eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     temperature scaling  coefficient - taut is the relaxation time
+      
+      engke=engfke+engtrn
+      engtot=engke+engrot
+      chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+      
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+eta(1)*xxo(j)+eta(4)*yyo(j)+eta(7)*zzo(j)
+          yyy(i)=tstep*uyy(i)+eta(2)*xxo(j)+eta(5)*yyo(j)+eta(8)*zzo(j)
+          zzz(i)=tstep*uzz(i)+eta(3)*xxo(j)+eta(6)*yyo(j)+eta(9)*zzo(j)
+
+        enddo
+
+c     estimate new cell tensor
+
+        call mat_mul(eta,cell0,cell)
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy 
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate current stress tensor
+
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+
+c     restore half step velocity
+          
+        if(iter.eq.mxiter)then
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+          
+        endif
+        
+c     ********: rigid body motion - thermostated  :***********
+
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=(gvxo(jg)+tstep*(fmx(jg)*rgmas))*chit0
+          uyy(ig)=(gvyo(jg)+tstep*(fmy(jg)*rgmas))*chit0
+          uzz(ig)=(gvzo(jg)+tstep*(fmz(jg)*rgmas))*chit0
+
+c     update positions : 
+
+          gcmx(ig)=tstep*uxx(ig)+eta(1)*gcxo(jg)+eta(4)*gcyo(jg)+
+     x      eta(7)*gczo(jg)
+          gcmy(ig)=tstep*uyy(ig)+eta(2)*gcxo(jg)+eta(5)*gcyo(jg)+
+     x      eta(8)*gczo(jg)
+          gcmz(ig)=tstep*uzz(ig)+eta(3)*gcxo(jg)+eta(6)*gcyo(jg)+
+     x      eta(9)*gczo(jg)
+
+c     full step com velocity
+
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate rigid body kinetic energy and stress tensor
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     restore half step velocity
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+
+        enddo
+
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     scaled angular velocity at time step n
+            
+          omx(ig)=(omxo(jg)+pt5*tstep*trx)*chit0
+          omy(ig)=(omyo(jg)+pt5*tstep*try)*chit0
+          omz(ig)=(omzo(jg)+pt5*tstep*trz)*chit0
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=(omxo(jg)+tstep*trx)*chit0
+          uyy(ig)=(omyo(jg)+tstep*try)*chit0
+          uzz(ig)=(omzo(jg)+tstep*trz)*chit0
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+1.5d0*tstep*trx)*chit0
+          oqy(jg)=(omyo(jg)+1.5d0*tstep*try)*chit0
+          oqz(jg)=(omzo(jg)+1.5d0*tstep*trz)*chit0
+
+        enddo
+        
+c     rotational kinetic energy
+
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+
+        enddo
+        
+c     complete stress tensor - add all contributions
+
+        do i=1,9
+          stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+        enddo
+
+c     improved prediction of eta and chit 
+
+        do i=1,9
+          eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+        enddo
+        if(mode.gt.0)then
+          eta(3)=0.d0
+          eta(6)=0.d0
+          eta(7)=0.d0
+          eta(8)=0.d0
+          if(mode.lt.3)then
+            eta(2)=0.d0
+            eta(4)=0.d0
+            if(mode.eq.2)then
+              eta(1)=0.5d0*(eta(1)+eta(5))
+              eta(5)=eta(1)
+            endif
+          endif
+        endif
+
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     update cell vectors
+
+      call mat_mul(eta,cell0,cell)
+
+c     update volume
+      
+      volm=volm*eta(1)*eta(5)*eta(9)
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nstq_b1
+
+      subroutine nstq_h1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,engrot,
+     x  virlrc,press,quattol,sigma,taup,taut,temp,tolnce,tstep,
+     x  vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover like
+c     thermostat and barostat. (cell may change shape).
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principle axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob,safeq
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,fail,i,igrp,igrp1,igrp2,ifre,ifre1,ifre2
+      integer j,k,ig,jg,jr,id,iter,mxiter,idum,mode
+      real(8) chit,conint,consv,elrc,engke,engrot,virlrc,press,quattol
+      real(8) sigma,taup,taut,temp,tolnce,tstep,vircom,vircon,volm
+      real(8) strkin,strcon,strgrp,eta0,etanew,rot,cell0,volm0,stres0
+      real(8) elrc0,virlrc0,rstep,rtsq,qmass,pmass,totmas
+      real(8) engtrn,trx,try,trz,engtot,engfke,fac,etadot
+      real(8) chitp,chitnew,chit0,xxa,yya,zza,viracc,rgmas,uni
+      real(8) delx,dely,delz,vold,cons1,cons2,cons3
+      real(8) vaa,vbb,vcc,chip,com,vom
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension eta0(9),etanew(9),rot(9),cell0(9),fail(nnn),uni(9)
+      dimension strkin(9),strcon(9),strgrp(9),stres0(9),com(3),vom(3)
+      
+      save newjob,volm0,elrc0,virlrc0,dens0,pmass,qmass,totmas
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1590)
+      enddo
+
+      if(newjob) then
+        
+c     store initial values of volume, long range corrections etc
+      
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1600)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+
+c     calculate total system mass 
+
+        totmas=getmass(natms,idnode,mxnode)
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      
+c     initialise stress tensor accumulators
+
+      vircon=0.d0
+
+      do i=1,9
+
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+c     ensure total momentum is zero
+      
+      call getvom(natms,idnode,mxnode,totmas,vom)
+
+c     correction to velocities
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+
+      enddo
+
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     calculate centre of mass
+      
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     estimate velocity at full step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+      
+c     estimate kinetic energy
+        
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate stress tensor
+      
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     estimate rigid body translational kinetic energy
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep/gmass(id)*fmx(jg)
+        gvyy(ig)=gvyo(jg)+pt5*tstep/gmass(id)*fmy(jg)
+        gvzz(ig)=gvzo(jg)+pt5*tstep/gmass(id)*fmz(jg)
+
+      enddo
+      
+c     rigid body translational kinetic energy
+        
+      engtrn=getkint(ngrp,idnode,mxnode)
+
+c     rigid body stress tensor
+        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+      
+c     calculate rgid body contribution to stress tensor
+      
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+
+        enddo
+
+c     store angular velcoity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+
+c     calculate rotational kinetic energy of rigid bodies
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     propagate eta
+      
+      fac=9.d0
+      do i=1,9
+        etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x    chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        fac=5.d0
+        etanew(3)=0.d0
+        etanew(6)=0.d0
+        etanew(7)=0.d0
+        etanew(8)=0.d0
+        if(mode.lt.3)then
+          fac=3.d0
+          etanew(2)=0.d0
+          etanew(4)=0.d0
+          if(mode.eq.2)then
+            fac=2.d0
+            etanew(1)=0.5d0*(etanew(1)+etanew(5))
+            etanew(5)=etanew(1)
+          endif
+        endif
+      endif
+      do i=1,9
+        eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+      enddo
+
+c     propagate chit
+      
+      engke=engfke+engtrn
+      engtot=engke+engrot
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      chitp=(2.d0*(engtot-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-
+     x      (chit0+eta0(1))*vxx(i)-eta0(4)*vyy(i)-eta0(7)*vzz(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-
+     x      eta0(2)*vxx(i)-(eta0(5)+chit0)*vyy(i)-eta0(8)*vzz(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-
+     x      eta0(3)*vxx(i)-eta0(6)*vyy(i)-(eta0(9)+chit0)*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxa=(xxx(i)+xxo(j))*0.5d0-com(1)
+          yya=(yyy(i)+yyo(j))*0.5d0-com(2)
+          zza=(zzz(i)+zzo(j))*0.5d0-com(3)
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+          
+        enddo
+
+c     estimate new cell parameters
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        call cell_propagate(tstep,cell,etanew)
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+        
+c     estimate velocity at the full step
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore free half step velocity
+          
+        if(iter.eq.mxiter)then
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+          
+        endif
+        
+c     ********: rigid body motion - thermostated  :***********
+        
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=gvxo(jg)+tstep*(fmx(jg)*rgmas-
+     x      (chit0+eta0(1))*gvxx(ig)-eta0(4)*gvyy(ig)-eta0(7)*gvzz(ig))
+          uyy(ig)=gvyo(jg)+tstep*(fmy(jg)*rgmas-
+     x      eta0(2)*gvxx(ig)-(eta0(5)+chit0)*gvyy(ig)-eta0(8)*gvzz(ig))
+          uzz(ig)=gvzo(jg)+tstep*(fmz(jg)*rgmas-
+     x      eta0(3)*gvxx(ig)-eta0(6)*gvyy(ig)-(eta0(9)+chit0)*gvzz(ig))
+
+c     advance positions using leapfrog
+
+          xxa=(gcmx(ig)+gcxo(jg))*0.5d0-com(1)
+          yya=(gcmy(ig)+gcyo(jg))*0.5d0-com(2)
+          zza=(gcmz(ig)+gczo(jg))*0.5d0-com(3)
+
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(ig)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(ig)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          gcmz(ig)=gczo(jg)+tstep*(uzz(ig)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+
+c     full step com velocity
+
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate rigid body kinetic energy and stress tensor
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     restore half step velocity
+
+        if(iter.eq.mxiter)then
+          
+          do ig=igrp1,igrp2
+            
+            gvxx(ig)=uxx(ig)
+            gvyy(ig)=uyy(ig)
+            gvzz(ig)=uzz(ig)
+            
+          enddo
+          
+        endif
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     correction due to thermostat
+
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=omxo(jg)+delx
+          uyy(ig)=omyo(jg)+dely
+          uzz(ig)=omzo(jg)+delz
+
+c     angular velocity at time step n+1  (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+
+        enddo
+        
+c     rotational kinetic energy
+
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+
+        enddo
+        
+c     complete stress tensor - add all contributions
+
+        do i=1,9
+          stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+        enddo
+
+c     improved prediction of eta and chit 
+
+        do i=1,9
+          etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x      chit0*eta0(i))
+        enddo
+        if(mode.gt.0)then
+          etanew(3)=0.d0
+          etanew(6)=0.d0
+          etanew(7)=0.d0
+          etanew(8)=0.d0
+          if(mode.lt.3)then
+            etanew(2)=0.d0
+            etanew(4)=0.d0
+            if(mode.eq.2)then
+              etanew(1)=0.5d0*(etanew(1)+etanew(5))
+              etanew(5)=etanew(1)
+            endif
+          endif
+        endif
+        do i=1,9
+          eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+        enddo
+
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        etadot=sdot0(9,eta0,eta0)
+        if(mode.eq.2)etadot=etadot-eta0(1)**2
+        chitp=(2.d0*(engtot-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      do i=1,9
+        eta(i)=etanew(i)
+      enddo
+
+c     update volume
+      
+      chip=eta(1)+eta(5)+eta(9)
+      vold=volm
+      volm=volm*exp(tstep*chip)
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     conserved quantity less kinetic and potential energy
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+fac*boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      cons3=0.5d0*pmass*etadot
+      consv=conint+cons1+cons2+cons3
+      
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nstq_h1
+      
+      end module lf_rotation1_module
diff -urN dl_class_1.9.orig/srcmod/lf_rotation2_module.f dl_class_1.9/srcmod/lf_rotation2_module.f
--- dl_class_1.9.orig/srcmod/lf_rotation2_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/lf_rotation2_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,5007 @@
+      module lf_rotation2_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 2 for verlet leap frog rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use lf_rotation1_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+      
+      subroutine nveq_2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x  vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites 
+c     may coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strcon,strgrp,engfke,engtrn
+      real(8) delx,dely,delz,trx,try,trz,vaa,vbb,vcc,viracc
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      
+      save newjob,igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1620)
+      enddo
+      
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     accumulators for constraint and virial stress tensor
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     start of shake cycle
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=1
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=vxo(j)+tstep*rmass(i)*fxx(i)
+          uyy(j)=vyo(j)+tstep*rmass(i)*fyy(i)
+          uzz(j)=vzo(j)+tstep*rmass(i)*fzz(i)
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)+tstep*uxx(j)
+          yyy(i)=yyo(i)+tstep*uyy(j)
+          zzz(i)=zzo(i)+tstep*uzz(j)
+          
+c     estimate full step velocities
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocities
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=gvxo(jg)+tstep/gmass(id)*fmx(jg)
+          uyy(jg)=gvyo(jg)+tstep/gmass(id)*fmy(jg)
+          uzz(jg)=gvzo(jg)+tstep/gmass(id)*fmz(jg)
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*uxx(jg)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(jg)
+          gcmz(ig)=gczo(jg)+tstep*uzz(jg)
+          
+c     centre of mass velocities at full step
+          
+          gvxx(ig)=pt5*(uxx(jg)+gvxo(jg))
+          gvyy(ig)=pt5*(uyy(jg)+gvyo(jg))
+          gvzz(ig)=pt5*(uzz(jg)+gvzo(jg))
+
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body contribution to stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+            opx(jg)=omxo(jg)+delx*pt5
+            opy(jg)=omyo(jg)+dely*pt5
+            opz(jg)=omzo(jg)+delz*pt5
+            
+          enddo
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+c     angular velocity at time step n
+          
+          omx(ig)=opx(jg)
+          omy(ig)=opy(jg)
+          omz(ig)=opz(jg)
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     total kinetic energy
+      
+      engke=engfke+engtrn
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,fmx,fmy,fmz,stat=fail(5))
+      deallocate (tqx,tqy,tqz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nveq_2
+      
+      subroutine nvtq_b2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x  tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Berendsen thermostat.
+c
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon,engfke
+      real(8) rot,strkin,strgrp,strcon,engtrn,trx,try,trz
+      real(8) delx,dely,delz,vaa,vbb,vcc,viracc,engtot,chit0
+      real(8) sigma,taut
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      
+      save chit0,igrp1,igrp2,ifre1,ifre2,newjob
+      
+      data chit0/1.d0/,newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1630)
+      enddo
+      
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+        
+        call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+        
+c     accumulators for constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     shake and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=2
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(j)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(j)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)+tstep*uxx(j)
+          yyy(i)=yyo(i)+tstep*uyy(j)
+          zzz(i)=zzo(i)+tstep*uzz(j)
+          
+c     calculate full time velocity
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     update centre of mass velocities
+          
+          gvxx(ig)=gvxo(jg)+tstep/gmass(id)*fmx(jg)
+          gvyy(ig)=gvyo(jg)+tstep/gmass(id)*fmy(jg)
+          gvzz(ig)=gvzo(jg)+tstep/gmass(id)*fmz(jg)
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          
+c     advance velocity by leapfrog
+          
+          gvxx(ig)=(gvxo(jg)+tstep/gmass(id)*fmx(jg))*chit0
+          gvyy(ig)=(gvyo(jg)+tstep/gmass(id)*fmy(jg))*chit0
+          gvzz(ig)=(gvzo(jg)+tstep/gmass(id)*fmz(jg))*chit0
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*gvxx(ig)
+          gcmy(ig)=gcyo(jg)+tstep*gvyy(ig)
+          gcmz(ig)=gczo(jg)+tstep*gvzz(ig)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+            opx(jg)=(omxo(jg)+delx*pt5)
+            opy(jg)=(omyo(jg)+dely*pt5)
+            opz(jg)=(omzo(jg)+delz*pt5)
+            
+          enddo
+          
+c     scaled angular velocity at timestep n
+          
+          omx(ig)=opx(jg)*chit0
+          omy(ig)=opy(jg)*chit0
+          omz(ig)=opz(jg)*chit0
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+delx*1.5d0)*chit0
+          oqy(jg)=(omyo(jg)+dely*1.5d0)*chit0
+          oqz(jg)=(omzo(jg)+delz*1.5d0)*chit0
+          
+c     angular velocity at full time step
+          
+          uxx(jg)=(omxo(jg)+delx)*chit0
+          uyy(jg)=(omyo(jg)+dely)*chit0
+          uzz(jg)=(omzo(jg)+delz)*chit0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     new estimate of chit
+        
+        engke=engfke+engtrn
+        engtot=engke+engrot 
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+      
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x      +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x      +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x      +gcmz(ig)
+          
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+          
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+      
+      
+      if(mxnode.gt.1)then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nvtq_b2
+      
+      subroutine nvtq_h2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,conint,consv,chit,engke,engrot,quattol,
+     x  sigma,taut,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Hoover thermostat.
+c
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon,engtot
+      real(8) rot,strkin,strcon,strgrp,engtrn,engfke,trx,try,trz
+      real(8) delx,dely,delz,vaa,vbb,vcc,viracc,sigma,taut,chit0
+      real(8) chitnew,chitp,conint,consv,chit,qmass
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      
+      save newjob,igrp1,igrp2,ifre1,ifre2,qmass
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1640)
+      enddo
+      
+      if(newjob)then
+        
+c     mass parameters for thermostat
+        
+        qmass=2.d0*sigma*taut**2
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atoms displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     initial thermostat variable
+      
+      chit0=chit
+      
+c     accumulators for constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=3
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0)*
+     x      pt5*(vxx(i)+vxo(j)))
+          uyy(j)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0)*
+     x      pt5*(vyy(i)+vyo(j)))
+          uzz(j)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0)*
+     x      pt5*(vzz(i)+vzo(j)))
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)+tstep*uxx(j)
+          yyy(i)=yyo(i)+tstep*uyy(j)
+          zzz(i)=zzo(i)+tstep*uzz(j)
+          
+c     estimate full step velocities
+          
+          vxx(i)=pt5*(vxo(j)+uxx(j))
+          vyy(i)=pt5*(vyo(j)+uyy(j))
+          vzz(i)=pt5*(vzo(j)+uzz(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=gvxo(jg)+tstep*(fmx(jg)/gmass(id)-chit0*
+     x      pt5*(gvxx(ig)+gvxo(jg)))
+          uyy(jg)=gvyo(jg)+tstep*(fmy(jg)/gmass(id)-chit0*
+     x      pt5*(gvyy(ig)+gvyo(jg)))
+          uzz(jg)=gvzo(jg)+tstep*(fmz(jg)/gmass(id)-chit0*
+     x      pt5*(gvzz(ig)+gvzo(jg)))
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*uxx(jg)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(jg)
+          gcmz(ig)=gczo(jg)+tstep*uzz(jg)
+          
+c     centre of mass velocities at half-step
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=omxo(jg)+pt5*tstep*trx
+            opy(jg)=omyo(jg)+pt5*tstep*try
+            opz(jg)=omzo(jg)+pt5*tstep*trz
+            
+          enddo
+          
+c     correction due to thermostat
+          
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+          
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     new estimate of chit
+        
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chitp=2.d0*(engtot-sigma)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=pt5*(chit+chitnew)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10.and.icyc.gt.3)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+      
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x      +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x      +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x      +gcmz(ig)
+          
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+          
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     update thermostat variable
+      
+      chit=chitnew
+      
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*qmass/taut**2
+      consv=conint+pt5*qmass*chit0**2
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nvtq_h2
+      
+      subroutine nptq_b2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,
+     x  virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Berendsen thermostat and barostat.
+c     (cell may change volume)
+c
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith     sep 1999
+c     amended     w.smith     nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strgrp,strcon,engtrn,engfke,trx,try,trz
+      real(8) delx,dely,delz,czero
+      real(8) vaa,vbb,vcc,viracc,beta,elrc,virlrc,press,engtot
+      real(8) sigma,taup,taut,virtot,volm,cell0,elrc0,virlrc0
+      real(8) chit0,volm0,chip0,psyst,scale
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      dimension cell0(9),czero(9)
+      
+      save newjob,volm0,elrc0,virlrc0,czero,chit0,chip0,dens0
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      data beta/7.3728d-3/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1670)
+      enddo
+      
+c     store initial values of volume and long range corrections
+      
+      if(newjob) then
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1660)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          czero(i)=cell(i)
+        enddo
+        newjob=.false.
+        
+        chit0=1.d0
+        chip0=1.d0
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     set constraint stress and virial and inital cell vectors
+      
+      vircon=0.d0
+      do i=1,9
+        
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     length scaling parameter
+      
+      scale=chip0**(1.d0/3.d0)
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=3
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore cell vectors
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(j)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(j)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)*scale+tstep*uxx(j)
+          yyy(i)=yyo(i)*scale+tstep*uyy(j)
+          zzz(i)=zzo(i)*scale+tstep*uzz(j)
+          
+c     estimate full step velocity
+          
+          vxx(i)=pt5*(vxo(j)+uxx(j))
+          vyy(i)=pt5*(vyo(j)+uyy(j))
+          vzz(i)=pt5*(vzo(j)+uzz(j))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=(gvxo(jg)+tstep/gmass(id)*fmx(jg))*chit0
+          uyy(jg)=(gvyo(jg)+tstep/gmass(id)*fmy(jg))*chit0
+          uzz(jg)=(gvzo(jg)+tstep/gmass(id)*fmz(jg))*chit0
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)*scale+tstep*uxx(jg)
+          gcmy(ig)=gcyo(jg)*scale+tstep*uyy(jg)
+          gcmz(ig)=gczo(jg)*scale+tstep*uzz(jg)
+          
+c     centre of mass velocities at full step
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=(omxo(jg)+pt5*delx)
+            opy(jg)=(omyo(jg)+pt5*dely)
+            opz(jg)=(omzo(jg)+pt5*delz)
+            
+          enddo
+          
+c     scaled angular velocity at time step n
+          
+          omx(ig)=opx(jg)*chit0
+          omy(ig)=opy(jg)*chit0
+          omz(ig)=opz(jg)*chit0
+          
+c     angular velocity at time step n+1  (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+delx*1.5d0)*chit0
+          oqy(jg)=(omyo(jg)+dely*1.5d0)*chit0
+          oqz(jg)=(omzo(jg)+delz*1.5d0)*chit0
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=(omxo(jg)+delx)*chit0
+          uyy(jg)=(omyo(jg)+dely)*chit0
+          uzz(jg)=(omzo(jg)+delz)*chit0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     pressure control variable
+        
+        engke=engfke+engtrn
+        psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+        chip0=1.d0+beta*tstep*(psyst-press)/taup
+        scale=chip0**(1.d0/3.d0)
+        
+c     new estimate of chit
+        
+        engtot=engke+engrot 
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+c     new cell parameters 
+          
+          do i=1,9
+            cell(i)=scale*cell0(i)
+          enddo
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     scale cell vectors
+      
+      scale=((chip0*volm)/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=scale*czero(i)
+      enddo
+      
+c     construct scaling tensor (for later!)
+      
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=scale
+      eta(5)=scale
+      eta(9)=scale
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nptq_b2
+      
+      subroutine nptq_h2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x  engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x  tstep,vircom,vircon,virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Hoover thermostat and barostat. 
+c     (cell may change volume)
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon,com
+      real(8) rot,strkin,strcon,strgrp,vom,engtrn,trx,try,trz
+      real(8) delx,dely,delz,engfke
+      real(8) vaa,vbb,vcc,viracc,pmass,qmass,totmas,czero
+      real(8) chip,chit,consv,conint,elrc,virlrc,press,sigma,taup,taut
+      real(8) temp,virtot,cell0,volm0,elrc0,virlrc0
+      real(8) chit0,chip0,chipnew,chipp,engtot,chitnew,chitp,volnew
+      real(8) scale,volm,vold,cons1,cons2,cons3
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      dimension czero(9),cell0(9),com(3),vom(3)
+      
+      save newjob,volm0,elrc0,virlrc0,czero,dens0,pmass,qmass
+      save igrp1,igrp2,ifre1,ifre2,totmas
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1670)
+      enddo
+      
+      if(newjob) then
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+        
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1680)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          czero(i)=cell(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+c     calculate system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     ensure total momentum is zero
+      
+      call getvom(natms,idnode,mxnode,totmas,vom)
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     calculate centre of mass
+      
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     initial thermostat and barostat variables
+      
+      chit0=chit
+      chip0=chip
+      chipnew=chip
+      
+c     initialise constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        
+      enddo
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=4
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore cell vectors
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity using leapfrog
+          
+          uxx(j)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0+chip0)*
+     x      pt5*(vxx(i)+vxo(j)))
+          uyy(j)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0+chip0)*
+     x      pt5*(vyy(i)+vyo(j)))
+          uzz(j)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0+chip0)*
+     x      pt5*(vzz(i)+vzo(j)))
+          
+c     advance position using leapfrog
+          
+          xxx(i)=xxo(i)+tstep*(uxx(j)+
+     x      chipnew*((xxx(i)+xxo(i))*pt5-com(1)))
+          yyy(i)=yyo(i)+tstep*(uyy(j)+
+     x      chipnew*((yyy(i)+yyo(i))*pt5-com(2)))
+          zzz(i)=zzo(i)+tstep*(uzz(j)+
+     x      chipnew*((zzz(i)+zzo(i))*pt5-com(3)))
+          
+c     estimate full step velocity
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=gvxo(jg)+tstep*(fmx(jg)/gmass(id)-(chit0+chip0)*
+     x      pt5*(gvxx(ig)+gvxo(jg)))
+          uyy(jg)=gvyo(jg)+tstep*(fmy(jg)/gmass(id)-(chit0+chip0)*
+     x      pt5*(gvyy(ig)+gvyo(jg)))
+          uzz(jg)=gvzo(jg)+tstep*(fmz(jg)/gmass(id)-(chit0+chip0)*
+     x      pt5*(gvzz(ig)+gvzo(jg)))
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(jg)+
+     x      chipnew*((gcxo(jg)+gcmx(ig))*pt5-com(1)))
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(jg)+
+     x      chipnew*((gcyo(jg)+gcmy(ig))*pt5-com(2)))
+          gcmz(ig)=gczo(jg)+tstep*(uzz(jg)+
+     x      chipnew*((gczo(jg)+gcmz(ig))*pt5-com(3)))
+          
+c     estimate full step velocities
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=omxo(jg)+pt5*tstep*trx
+            opy(jg)=omyo(jg)+pt5*tstep*try
+            opz(jg)=omzo(jg)+pt5*tstep*trz
+            
+          enddo
+          
+c     correction due to thermostat
+          
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+          
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1  (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     new estimate of chip and chit
+        
+        engke=engfke+engtrn
+        chipp=(2.d0*engke-virtot-vircom-vircon-3.d0*press*volm)/pmass-
+     x    chit0*chip0
+        chipnew=chip+tstep*chipp
+        chip0=pt5*(chip+chipnew)
+        
+        engtot=engke+engrot
+        chitp=(2.d0*(engtot-sigma)+pmass*chip0**2-boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=pt5*(chit+chitnew)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+c     estimate new cell tensor
+          
+          volnew=volm*exp(3.d0*tstep*chipnew)
+          scale=(volnew/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=czero(i)*scale
+          enddo
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     update volume
+      
+      vold=volm
+      volm=volm*exp(3.d0*tstep*chipnew)
+      
+c     scale cell vectors-isotropic
+      
+      scale=(volm/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=czero(i)*scale
+      enddo
+      
+c     construct scaling tensor (for later!)
+      
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=chipnew
+      eta(5)=chipnew
+      eta(9)=chipnew
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+c     update thermostat and barostat variables
+      
+      chit=chitnew
+      chip=chipnew
+      
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+boltz*temp)
+      cons1=pt5*qmass*chit0**2
+      cons2=press*vold
+      cons3=pt5*pmass*chip0**2
+      consv=conint+cons1+cons2+cons3
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nptq_h2
+      
+      subroutine nstq_b2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints. Rigid body sites and constraint sites may
+c     coincide. 
+c     
+c     verlet leapfrog with Berendsen thermostat and barostat. 
+c     (cell may change shape)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,lshmov,newjob,safeq,newstep,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons,mode
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strcon,strgrp,engtrn,trx,try,trz
+      real(8) delx,dely,delz,engfke
+      real(8) vaa,vbb,vcc,viracc,elrc,virlrc,press,sigma
+      real(8) taup,taut,volm,cell0,volm0,elrc0,chit0,uni
+      real(8) beta,stres0,engtot,virlrc0
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      dimension cell0(9),uni(9),stres0(9)
+      
+      save newjob,volm0,elrc0,virlrc0,chit0,dens0
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      data beta/7.3728d-3/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1690)
+      enddo
+      
+c     store initial values of volume, long range corrections etc
+      
+      if(newjob) then
+        
+        chit0=1.d0
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1700)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     set virial, strain and stress tensors
+      
+      vircon=0.d0
+      do i=1,9
+        
+        eta(i)=uni(i)
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=4
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity using leapfrog
+          
+          uxx(j)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(j)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(j)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+          
+c     update positions
+          
+          xxx(i)=tstep*uxx(j)+eta(1)*xxo(i)+eta(4)*yyo(i)+eta(7)*zzo(i)
+          yyy(i)=tstep*uyy(j)+eta(2)*xxo(i)+eta(5)*yyo(i)+eta(8)*zzo(i)
+          zzz(i)=tstep*uzz(j)+eta(3)*xxo(i)+eta(6)*yyo(i)+eta(9)*zzo(i)
+          
+c     calculate velocity at full time step
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocities
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :***********
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     calculate thermostated velocities
+          
+          uxx(jg)=(gvxo(jg)+tstep/gmass(id)*fmx(jg))*chit0
+          uyy(jg)=(gvyo(jg)+tstep/gmass(id)*fmy(jg))*chit0
+          uzz(jg)=(gvzo(jg)+tstep/gmass(id)*fmz(jg))*chit0
+          
+c     update positions
+          
+          gcmx(ig)=tstep*uxx(jg)+
+     x      eta(1)*gcxo(jg)+eta(4)*gcyo(jg)+eta(7)*gczo(jg)
+          gcmy(ig)=tstep*uyy(jg)+
+     x      eta(2)*gcxo(jg)+eta(5)*gcyo(jg)+eta(8)*gczo(jg)
+          gcmz(ig)=tstep*uzz(jg)+
+     x      eta(3)*gcxo(jg)+eta(6)*gcyo(jg)+eta(9)*gczo(jg)
+          
+c     centre of mass velocities at full step
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=(omxo(jg)+pt5*delx)
+            opy(jg)=(omyo(jg)+pt5*dely)
+            opz(jg)=(omzo(jg)+pt5*delz)
+            
+          enddo
+          
+c     scaled angular velocity at time step n
+          
+          omx(ig)=opx(jg)*chit0
+          omy(ig)=opy(jg)*chit0
+          omz(ig)=opz(jg)*chit0
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+delx*1.5d0)*chit0
+          oqy(jg)=(omyo(jg)+dely*1.5d0)*chit0
+          oqz(jg)=(omzo(jg)+delz*1.5d0)*chit0
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=(omxo(jg)+delx)*chit0
+          uyy(jg)=(omyo(jg)+dely)*chit0
+          uzz(jg)=(omzo(jg)+delz)*chit0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     calculate total stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+        enddo
+        
+c     calculate new cell tensor
+        
+        call mat_mul(eta,cell0,cell)
+        
+c     calculate eta tensor
+        
+        do i=1,9
+          eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+        enddo
+        if(mode.gt.0)then
+          eta(3)=0.d0
+          eta(6)=0.d0
+          eta(7)=0.d0
+          eta(8)=0.d0
+          if(mode.lt.3)then
+            eta(2)=0.d0
+            eta(4)=0.d0
+            if(mode.eq.2)then
+              eta(1)=0.5d0*(eta(1)+eta(5))
+              eta(5)=eta(1)
+            endif
+          endif
+        endif
+        
+c     new estimate of chit
+        
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     update volume
+      
+      volm=volm*eta(1)*eta(5)*eta(9)
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nstq_b2
+      
+      subroutine nstq_h2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,engrot,
+     x  virlrc,press,quattol,sigma,taup,taut,temp,tolnce,tstep,
+     x  vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints- rigid body sites and constraint sites 
+c     may coincide. 
+c     
+c     verlet leapfrog with Hoover like thermostat and barostat. 
+c     (cell may change shape)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm,mode
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strcon,strgrp,engtrn,vxt,vyt,vzt,trx,try,trz
+      real(8) delx,dely,delz,vaa,vbb,vcc,viracc,com,fac,etadot
+      real(8) chit,conint,consv,virlrc,elrc,press,sigma,taut,taup
+      real(8) volm,eta0,etanew,cell0,volm0,elrc0,virlrc0,pmass,qmass
+      real(8) totmas,chit0,xxa,yya,zza,chip,chitp,vom,engfke
+      real(8) chitnew,vold,cons1,cons2,cons3,temp,uni
+      real(8) stres0,engtot
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn),vom(3)
+      dimension cell0(9),eta0(9),etanew(9),stres0(9),uni(9),com(3)
+      
+      save newjob,volm0,elrc0,virlrc0,dens0,pmass,qmass
+      save igrp1,igrp2,ifre1,ifre2,totmas
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1710)
+      enddo
+      
+      if(newjob) then
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+        
+c     store initial values of volume, long range corrections etc
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1720)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+c     system total mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     ensure total momentum is zero
+      
+      call getvom(natms,idnode,mxnode,totmas,vom)
+      
+c     correction to velocities
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     calculate centre of mass
+      
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     initial thermostat and barostat variables and new cell
+      
+      chit0=chit
+      do i=1,9
+        
+        eta0(i)=eta(i)
+        cell0(i)=cell(i)
+        
+      enddo
+      
+c     initialise constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        
+        strcns(i)=0.d0
+        stres0(i)=stress(i)
+        
+      enddo
+      
+c     shake and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=4
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore cell vectors
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity using leapfrog
+          
+          vxt=pt5*(vxx(i)+vxo(j))
+          vyt=pt5*(vyy(i)+vyo(j))
+          vzt=pt5*(vzz(i)+vzo(j))
+          
+          uxx(j)=vxo(j)+tstep*(fxx(i)*rmass(i)-
+     x      (eta0(1)+chit0)*vxt-eta0(4)*vyt-eta0(7)*vzt)
+          uyy(j)=vyo(j)+tstep*(fyy(i)*rmass(i)-
+     x      eta0(2)*vxt-(eta0(5)+chit0)*vyt-eta0(8)*vzt)
+          uzz(j)=vzo(j)+tstep*(fzz(i)*rmass(i)-
+     x      eta0(3)*vxt-eta0(6)*vyt-(eta0(9)+chit0)*vzt)
+          
+c     advance positions using leapfrog
+          
+          xxa=(xxx(i)+xxo(i))*pt5-com(1)
+          yya=(yyy(i)+yyo(i))*pt5-com(2)
+          zza=(zzz(i)+zzo(i))*pt5-com(3)
+          
+          xxx(i)=xxo(i)+tstep*(uxx(j)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          yyy(i)=yyo(i)+tstep*(uyy(j)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          zzz(i)=zzo(i)+tstep*(uzz(j)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+          
+c     estimate full step  velocities
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocities
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     calculate thermostated velocities
+          
+          vxt=pt5*(gvxx(ig)+gvxo(jg))
+          vyt=pt5*(gvyy(ig)+gvyo(jg))
+          vzt=pt5*(gvzz(ig)+gvzo(jg))
+          
+          uxx(jg)=gvxo(jg)+tstep*(fmx(jg)/gmass(id)-
+     x      (chit0+eta0(1))*vxt-eta0(4)*vyt-eta0(7)*vzt)
+          uyy(jg)=gvyo(jg)+tstep*(fmy(jg)/gmass(id)-
+     x      eta0(2)*vxt-(eta0(5)+chit0)*vyt-eta0(8)*vzt)
+          uzz(jg)=gvzo(jg)+tstep*(fmz(jg)/gmass(id)-
+     x      eta0(3)*vxt-eta0(6)*vyt-(eta0(9)+chit0)*vzt)
+          
+c     advance positions using leapfrog
+          
+          xxa=(gcmx(ig)+gcxo(jg))*pt5-com(1)
+          yya=(gcmy(ig)+gcyo(jg))*pt5-com(2)
+          zza=(gcmz(ig)+gczo(jg))*pt5-com(3)
+          
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(jg)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(jg)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          gcmz(ig)=gczo(jg)+tstep*(uzz(jg)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+          
+c     estimate full step velocities
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=omxo(jg)+pt5*tstep*trx
+            opy(jg)=omyo(jg)+pt5*tstep*try
+            opz(jg)=omzo(jg)+pt5*tstep*trz
+            
+          enddo
+          
+c     correction due to thermostat
+          
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+          
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     calculate total stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+        enddo
+        
+c     propagate eta
+        
+        fac=9.d0
+        do i=1,9
+          etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x      chit0*eta0(i))
+        enddo
+        if(mode.gt.0)then
+          fac=5.d0
+          etanew(3)=0.d0
+          etanew(6)=0.d0
+          etanew(7)=0.d0
+          etanew(8)=0.d0
+          if(mode.lt.3)then
+            fac=3.d0
+            etanew(2)=0.d0
+            etanew(4)=0.d0
+            if(mode.eq.2)then
+              fac=2.d0
+              etanew(1)=0.5d0*(etanew(1)+etanew(5))
+              etanew(5)=etanew(1)
+            endif
+          endif
+        endif
+        do i=1,9
+          eta0(i)=pt5*(etanew(i)+eta(i)) 
+        enddo
+        
+c     propagate chit
+        
+        etadot=sdot0(9,eta0,eta0)
+        if(mode.eq.2)etadot=etadot-eta0(1)**2
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chitp=(2.d0*(engtot-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=pt5*(chit+chitnew)
+        
+c     estimate new cell parameters
+        
+        call cell_propagate(tstep,cell,etanew)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     update thermostat and barostat variables
+      
+      chit=chitnew
+      do i=1,9
+        eta(i)=etanew(i)
+      enddo
+      
+c     update volume
+      
+      chip=eta(1)+eta(5)+eta(9)
+      vold=volm
+      volm=volm*exp(tstep*chip)
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+c     conserved quantity less kinetic and potential energy
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+fac*boltz*temp)
+      cons1=pt5*qmass*chit0**2
+      cons2=press*vold
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      cons3=pt5*pmass*etadot
+      consv=conint+cons1+cons2+cons3
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nstq_h2
+      
+      subroutine qshake
+     x  (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x  nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x  dzt,txx,tyy,tzz,xxt,yyt,zzt,stresh)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for appling bond constraint corrections after
+c     atomic integration. Assumes rigid bodies connected by constraints
+c     If this is not so use rdshake_1 instead
+c     Must be used in conjunction with leapfrog integration algorithms
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester june 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov,newstep,newjob
+      integer fail,idnode,imcon,mxnode,natms,nscons,i,j,k
+      integer ik,ig,id,jj
+      real(8) tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,txx,tyy
+      real(8) tzz,xxt,yyt,zzt,stresh,tstep2,esig,dis,dis2
+      real(8) xxa,yya,zza,tax,tay,taz,doti,amti,amtj
+      real(8) trx,try,trz,vix,viy,viz,vxi,vyi,vzi
+      real(8) vjx,vjy,vjz,vxj,vyj,vzj,gamma,dli,dlj,rot
+      
+      real(8), allocatable :: redmass(:),esig1(:)
+      
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension stresh(9),rot(9)
+      
+      save newjob,esig1,redmass
+      
+      data newjob/.true./,fail/0/
+      
+      if(newjob)then
+        
+        allocate (redmass(mxcons),esig1(mxcons),stat=fail)
+        if(fail.ne.0)call error(idnode,1610)
+        newjob=.false.
+        
+      endif
+      
+c     constraint virial
+      
+      vircon=0.d0
+      
+c     accumulators for stress tensor
+      
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+      
+c     timestep squared
+      
+      tstep2=tstep*tstep
+      
+c     one iteration of constraint (shake) algorithm
+      
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+c     calculate temporary bond vector
+        
+        dxt(k)=xxx(i)-xxx(j)
+        dyt(k)=yyy(i)-yyy(j)
+        dzt(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+      
+c     calculate maximum error in bondlength
+      
+      esig=0.d0
+      do k=1,nscons
+        
+c     set bond parameter
+        
+        dis=prmcon(listcon(k,1))
+        dis2=dis*dis
+        esig1(k)=0.5d0*(dis2-(dxt(k)**2+dyt(k)**2+dzt(k)**2))/dis2
+        esig=max(esig,abs(esig1(k)))
+
+      enddo
+      
+c     global verification of convergence
+      
+      safe=(esig.lt.tolnce)
+      
+      if(mxnode.gt.1)call gstate(safe)
+      
+c     terminate iteration if all tolerances satisfied 
+      
+      if (.not.safe) then
+        
+c     initialise force increment arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+          
+        enddo
+        
+c     calculate constraint forces
+        
+        ik=0
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     assign effective reduced mass
+          
+          if(newstep) then
+            
+            ig=lstbod(i)
+            
+            if(ig.eq.0) then
+              
+              amti=rmass(i)
+              
+            else
+              
+              ik=ik+1
+              id=lstgtp(ig)
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+              jj=lstcsit(ik)
+              
+c     site to com in lab frame
+              
+              xxa=(gxx(id,jj)*rot(1)+gyy(id,jj)*rot(2)+
+     x          gzz(id,jj)*rot(3))
+              yya=(gxx(id,jj)*rot(4)+gyy(id,jj)*rot(5)+
+     x          gzz(id,jj)*rot(6))
+              zza=(gxx(id,jj)*rot(7)+gyy(id,jj)*rot(8)+
+     x          gzz(id,jj)*rot(9))
+              
+c     find cross product between interatomic vector and vector to com
+              
+              tax=yya*dzz(k)-zza*dyy(k)
+              tay=zza*dxx(k)-xxa*dzz(k)
+              taz=xxa*dyy(k)-yya*dxx(k)
+              
+c     transform to body fixed frame
+              
+              trx=(tax*rot(1)+tay*rot(4)+taz*rot(7))*rotinx(id,2)
+              try=(tax*rot(2)+tay*rot(5)+taz*rot(8))*rotiny(id,2)
+              trz=(tax*rot(3)+tay*rot(6)+taz*rot(9))*rotinz(id,2)
+              
+c     direction of induced velocites in body frame
+              
+              vix=try*gzz(id,jj)-trz*gyy(id,jj)
+              viy=trz*gxx(id,jj)-trx*gzz(id,jj)
+              viz=trx*gyy(id,jj)-try*gxx(id,jj)
+              
+c     transform to lab frame
+              
+              vxi=vix*rot(1)+viy*rot(2)+viz*rot(3)
+              vyi=vix*rot(4)+viy*rot(5)+viz*rot(6)
+              vzi=vix*rot(7)+viy*rot(8)+viz*rot(9)
+              
+c     find dot product between induced translational and rotational velocities
+              
+              doti=abs(vxi*dxx(k)+vyi*dyy(k)+vzi*dzz(k))
+              doti=doti/dis2
+              
+              amti=(1.d0/gmass(id)+doti)
+              
+            endif
+            
+            ig=lstbod(j)
+            if(ig.eq.0) then
+              
+              amtj=rmass(j)
+              
+            else
+              
+              ik=ik+1
+              id=lstgtp(ig)
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+              jj=lstcsit(ik)
+              
+c     site to com in lab frame
+              
+              xxa=(gxx(id,jj)*rot(1)+gyy(id,jj)*rot(2)+
+     x          gzz(id,jj)*rot(3))
+              yya=(gxx(id,jj)*rot(4)+gyy(id,jj)*rot(5)+
+     x          gzz(id,jj)*rot(6))
+              zza=(gxx(id,jj)*rot(7)+gyy(id,jj)*rot(8)+
+     x          gzz(id,jj)*rot(9))
+              
+c     find cross product between interatomic vector and vector to com
+              
+              tax =yya*dzz(k)-zza*dyy(k)
+              tay =zza*dxx(k)-xxa*dzz(k)
+              taz =xxa*dyy(k)-yya*dxx(k)
+              
+c     transform to body fixed frame
+              
+              trx=(tax*rot(1)+tay*rot(4)+taz*rot(7))*rotinx(id,2)
+              try=(tax*rot(2)+tay*rot(5)+taz*rot(8))*rotiny(id,2)
+              trz=(tax*rot(3)+tay*rot(6)+taz*rot(9))*rotinz(id,2)
+              
+c     direction of induced velocites in body frame
+              
+              vjx=try*gzz(id,jj)-trz*gyy(id,jj)
+              vjy=trz*gxx(id,jj)-trx*gzz(id,jj)
+              vjz=trx*gyy(id,jj)-try*gxx(id,jj)
+              
+c     transform to lab frame
+              
+              vxj=vjx*rot(1)+vjy*rot(2)+vjz*rot(3)
+              vyj=vjx*rot(4)+vjy*rot(5)+vjz*rot(6)
+              vzj=vjx*rot(7)+vjy*rot(8)+vjz*rot(9)
+              
+c     find dot product between induced translational and rotational velocities
+              
+              doti=abs(vxj*dxx(k)+vyj*dyy(k)+vzj*dzz(k))
+              doti=doti/dis2
+              
+              amtj=(1.d0/gmass(id)+doti)
+              
+            endif
+            
+            redmass(k)=1.d0/(amti+amtj)/tstep2
+            
+          endif
+          
+c     constraint force parameter 
+          
+          gamma=esig1(k)*redmass(k)
+          
+c     accumulate bond virial
+          
+          vircon=vircon-gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+          
+          stresh(1)=stresh(1)+gamma*dxx(k)*dxx(k)
+          stresh(2)=stresh(2)+gamma*dxx(k)*dyy(k)
+          stresh(3)=stresh(3)+gamma*dxx(k)*dzz(k)
+          stresh(5)=stresh(5)+gamma*dyy(k)*dyy(k)
+          stresh(6)=stresh(6)+gamma*dyy(k)*dzz(k)
+          stresh(9)=stresh(9)+gamma*dzz(k)*dzz(k)
+          
+c     improved atomic force
+          
+          xxt(i)=xxt(i)+dxx(k)*gamma
+          yyt(i)=yyt(i)+dyy(k)*gamma
+          zzt(i)=zzt(i)+dzz(k)*gamma
+          
+          xxt(j)=xxt(j)-dxx(k)*gamma
+          yyt(j)=yyt(j)-dyy(k)*gamma
+          zzt(j)=zzt(j)-dzz(k)*gamma
+          
+        enddo
+        
+c     transport temporary positions to other nodes
+        
+        if(mxnode.gt.1)then
+          
+          if(lshmov) call shmove
+     x      (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+          
+        endif
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dli=1.d0/dble(listme(i))
+          dlj=1.d0/dble(listme(j))
+          
+          fxx(i)=fxx(i)+xxt(i)*dli
+          fyy(i)=fyy(i)+yyt(i)*dli
+          fzz(i)=fzz(i)+zzt(i)*dli
+          fxx(j)=fxx(j)+xxt(j)*dlj
+          fyy(j)=fyy(j)+yyt(j)*dlj
+          fzz(j)=fzz(j)+zzt(j)*dlj
+          
+        enddo
+        
+c     complete (symmetrical) stress tensor
+        
+        stresh(4)=stresh(2)
+        stresh(7)=stresh(3)
+        stresh(8)=stresh(6)
+        
+c     splice force arrays across nodes
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(stresh,9,buffer)
+          call splice 
+     x      (idnode,natms,listme,listot,fxx,fyy,fzz,buffer)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine qshake
+      
+      end module lf_rotation2_module
diff -urN dl_class_1.9.orig/srcmod/Makefile dl_class_1.9/srcmod/Makefile
--- dl_class_1.9.orig/srcmod/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Makefile	2015-11-09 14:32:49.349871999 +0100
@@ -0,0 +1,101 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith January Dec 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+include ../Plumed.inc 
+ 
+
+BINROOT = ../execute
+CC  := $(CC)
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=par
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = basic_comms.o merge_tools.o pass_tools.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "gfortran                   (parallel)"
+	@echo "woodcrest                  (parallel)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#================== GNU Fortran, MPI version ==============================
+gfortran:
+	$(MAKE) FC="$(MPIF90)" LD="$(MPIF90) -o" \
+	LDFLAGS="$(LDFLAGS)" \
+	FFLAGS="-c $(FFLAGS)" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#================= Woodcrest =========================================
+woodcrest:
+	$(MAKE) LD="mpif90 -o" LDFLAGS="" \
+	FC=mpif90 FFLAGS="-c -O3" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for parallel (MPI) execution
+
+par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) $(PLUMED_DEPENDENCIES)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) $(PLUMED_LOAD)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+.c.o: 
+	$(CC) -c $*.c
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
diff -urN dl_class_1.9.orig/srcmod/Makefile.plumedbck dl_class_1.9/srcmod/Makefile.plumedbck
--- dl_class_1.9.orig/srcmod/Makefile.plumedbck	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Makefile.plumedbck	2011-02-22 12:46:11.000000000 +0100
@@ -0,0 +1,98 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith January Dec 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+BINROOT = ../execute
+CC  = gcc
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=par
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = basic_comms.o merge_tools.o pass_tools.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "gfortran                   (parallel)"
+	@echo "woodcrest                  (parallel)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#================== GNU Fortran, MPI version ==============================
+gfortran:
+	$(MAKE) FC="mpif90" LD="mpif90 -o" \
+	LDFLAGS="-O2 -ffast-math" \
+	FFLAGS="-c -O2 -ffast-math" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#================= Woodcrest =========================================
+woodcrest:
+	$(MAKE) LD="mpif90 -o" LDFLAGS="" \
+	FC=mpif90 FFLAGS="-c -O3" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for parallel (MPI) execution
+
+par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+.c.o: 
+	$(CC) -c $*.c
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
diff -urN dl_class_1.9.orig/srcmod/merge_tools.f dl_class_1.9/srcmod/merge_tools.f
--- dl_class_1.9.orig/srcmod/merge_tools.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/merge_tools.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,670 @@
+      subroutine merge(idnode,mxnode,natms,nbuff,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for merging coordinate arrays across
+c     a number of processors
+c     
+c     parallel replicated data version
+c
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith november 1992.
+c     MPI version - t. forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      use error_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nbuff,nsize,ierr,iatm1,iatm2
+      integer j,i,k,jdnode,kdnode,katm1,katm2,iatm,katm
+      real*8 xxx(natms),yyy(natms),zzz(natms),buffer(nbuff)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+c     check that buffer is large enough
+
+      nsize=(natms+mxnode-1)/mxnode
+      if(nbuff.lt.6*nsize)call error(idnode,47)
+
+c     load initial transfer buffer
+
+      j=0
+
+c     set up this nodes atoms
+
+      iatm1 = (idnode*natms)/mxnode + 1
+      iatm2 = ((idnode+1)*natms)/mxnode
+
+      iatm = iatm2-iatm1+1
+	
+      do i=iatm1,iatm2
+
+         buffer(j+1)=xxx(i)
+         buffer(j+2)=yyy(i)
+         buffer(j+3)=zzz(i)
+         j=j+3
+
+      enddo
+
+
+      call gsync()
+
+c     identity of neighbour node for systolic transfer
+
+      jdnode=mod(idnode+1,mxnode)
+
+      do k=1,mxnode-1
+
+c     identity of node of origin of incoming data
+
+         kdnode=mod(idnode+mxnode-k,mxnode)
+
+c     identity of incoming  atoms
+
+         katm1 = (kdnode*natms)/mxnode + 1
+         katm2 = ((kdnode+1)*natms)/mxnode
+         katm = katm2-katm1 + 1
+
+c     systolic data pulse to transfer data
+
+         call MPI_IRECV(buffer(3*nsize+1),3*nsize,MPI_DOUBLE_PRECISION,
+     x        MPI_ANY_SOURCE,Merge_tag+k,MPI_COMM_WORLD,request,ierr)
+
+         call MPI_SEND(buffer(1),3*nsize,MPI_DOUBLE_PRECISION,jdnode,
+     x        Merge_tag+k,MPI_COMM_WORLD,ierr)
+
+         call MPI_WAIT(request,status,ierr)
+
+c     merge the incoming data into current arrays
+
+         j=3*nsize
+
+         do i=katm1,katm2
+
+            xxx(i)=buffer(j+1)
+            yyy(i)=buffer(j+2)
+            zzz(i)=buffer(j+3)
+            j=j+3
+
+         enddo
+
+c     shift new data to start of buffer
+
+         do i=1,3*nsize
+
+            buffer(i)=buffer(3*nsize+i)
+
+         enddo
+
+      enddo
+      
+      return
+      end
+
+      subroutine merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for merging together coordinate arrays
+c     across a number of processors during rigid body algorithm
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t.forester  november 1993
+c     systolic pulse version. T3D t.forester sept 1994
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c*********************************************************************
+      
+      use setup_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+      
+      logical safe
+      integer idnode,mxnode,natms,ierr,i,j,k,l,mxb,nout,nin
+      integer nin1,jdnode,j1,kdnode
+      integer lstme(natms)
+      real*8 xxx(mxatms),yyy(mxatms),zzz(mxatms),buffer(mxbuff)
+      
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+      
+      safe =.true.
+      
+c     load up buffers
+      
+      j=1
+      l=1
+      do while(lstme(l).gt.0.and.l.le.natms)
+        
+        i=lstme(l)
+        buffer(j+1)=dble(i)
+        buffer(j+2)=xxx(i)
+        buffer(j+3)=yyy(i)
+        buffer(j+4)=zzz(i)
+        j=j+4
+        l=l+1
+        
+      enddo
+      
+c     length of message
+      
+      buffer(1) = dble(j)
+      
+c     array position for incoming messages
+      
+      mxb = mxbuff/2
+      
+c     load initial transfer buffer
+      
+      call gsync()
+      
+c     identity of neighbour node for systolic transfer
+      
+      jdnode=mod(idnode+1,mxnode)
+      
+      do k=1,mxnode-1
+        
+c     identity of node of origin of incoming data
+        
+        kdnode=mod(idnode+mxnode-k,mxnode)
+        
+c     out going message size
+        
+        nout = nint(buffer(1))
+        
+        call MPI_IRECV(nin,1,MPI_INTEGER,
+     x    MPI_ANY_SOURCE,Merge1_tag+k,MPI_COMM_WORLD,request,ierr)
+        
+        call MPI_SEND(nout,1,MPI_INTEGER,jdnode,
+     x    Merge1_tag+k,MPI_COMM_WORLD,ierr)
+        
+        call MPI_WAIT(request,status,ierr)
+        
+        call MPI_IRECV(buffer(mxb),nin,MPI_DOUBLE_PRECISION,
+     x    MPI_ANY_SOURCE,Merge1_tag+k,MPI_COMM_WORLD,request,ierr)
+        
+        call MPI_SEND(buffer(1),nout,MPI_DOUBLE_PRECISION,jdnode,
+     x    Merge1_tag+k,MPI_COMM_WORLD,ierr)
+        
+        call MPI_WAIT(request,status,ierr)
+        
+c     check buffer array not exceeded
+        
+        if(nin.gt.mxbuff-mxb) safe =.false.
+        
+c     position of first data element in incoming array
+        
+        nin1 = (nin-1)/4
+        j = mxb+1
+        
+        do j1=1,nin1
+          
+          i = nint(buffer(j))
+          xxx(i)=buffer(j+1)
+          yyy(i)=buffer(j+2)
+          zzz(i)=buffer(j+3)
+          j=j+4
+          
+        enddo
+        
+c     shift new data to start of buffer
+        
+        do i=1,nin
+          
+          buffer(i)=buffer(mxb-1+i)
+          
+        enddo
+        
+      enddo
+      
+c     global check 
+      
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,47)
+      
+      return
+      end
+
+      subroutine merge4(idnode,mxnode,ngrp,nbuff,q0,q1,q2,q3,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for merging coordinate arrays across
+c     a number of processors
+c     
+c     parallel replicated data version
+c
+c     copyright - daresbury laboratory 1994
+c     author    - t.forester  february 1994
+c     T3D version - sept 1994 t.forester
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      use error_module
+      
+      implicit none
+      
+      integer idnode,mxnode,ngrp,nbuff,ierr,nsize,i,j,igrp1,igrp2
+      integer k,jdnode,kdnode,kgrp1,kgrp2
+      real*8 q0(ngrp),q1(ngrp),q2(ngrp),q3(ngrp),buffer(nbuff)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+
+c     check that buffer is large enough
+
+      nsize=(ngrp+mxnode-1)/mxnode
+      if(nbuff.lt.8*nsize)call error(idnode,47)
+
+c     load initial transfer buffer
+
+      j=0
+
+      igrp1 = (idnode*ngrp)/mxnode+1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+
+      do i=igrp1,igrp2
+
+         buffer(j+1)=q0(i)
+         buffer(j+2)=q1(i)
+         buffer(j+3)=q2(i)
+         buffer(j+4)=q3(i)
+         j=j+4
+
+      enddo
+
+      call gsync()
+
+c     identity of neighbour node for systolic transfer
+
+      jdnode=mod(idnode+1,mxnode)
+     
+      do k=1,mxnode-1
+
+c     identity of node of origin of incoming data
+
+         kdnode=mod(idnode+mxnode-k,mxnode)
+
+c	identity of incoming groups 
+
+         kgrp1 = (kdnode*ngrp)/mxnode+1
+         kgrp2 = ((kdnode+1)*ngrp)/mxnode
+
+         call MPI_IRECV(buffer(4*nsize+1),4*nsize,MPI_DOUBLE_PRECISION,
+     x        MPI_ANY_SOURCE,Merge4_tag+k,MPI_COMM_WORLD,request,ierr)
+
+         call MPI_SEND(buffer(1),4*nsize,MPI_DOUBLE_PRECISION,jdnode,
+     x        Merge4_tag+k,MPI_COMM_WORLD,ierr)
+
+         call MPI_WAIT(request,status,ierr)
+
+c     merge the incoming data into current arrays
+
+         j=4*nsize
+
+         do i=kgrp1,kgrp2
+
+            q0(i)=buffer(j+1)
+            q1(i)=buffer(j+2)
+            q2(i)=buffer(j+3)
+            q3(i)=buffer(j+4)
+            j=j+4
+
+         enddo
+
+c     shift new data to start of buffer
+
+         do i=1,4*nsize
+
+            buffer(i)=buffer(4*nsize+i)
+
+         enddo
+
+      enddo
+      
+      return
+      end
+
+      subroutine shlmerge(idnode,mxnode,ntshl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for merging core-shell velocity data
+c     to restore data replication on all nodes
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - w. smith february 1993
+c     MPI version - w. smith june 1995
+c     CPP version - w. smith june 1995
+c     
+c***********************************************************************
+     
+      use setup_module
+      use config_module
+      use core_shell_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+      
+      integer idnode,mxnode,ntshl,ierr,i,j,k,n,m,ishl1,ishl2,nsize
+      integer jdnode,kshl1,kshl2,kdnode
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+c     check that buffer is large enough
+      
+      nsize=8*((ntshl+mxnode-1)/mxnode)
+      
+      if(mxbuff.lt.2*nsize)call error(idnode,425)
+
+c     block indices
+
+      ishl1 = (idnode*ntshl)/mxnode+1
+      ishl2 = ((idnode+1)*ntshl)/mxnode
+
+c     load initial transfer buffer
+      
+      n=0
+      m=0
+      
+      do k=ishl1,ishl2
+
+        m=m+1
+        
+c     indices of core and shell
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        buffer(n+1)=dble(i)
+        buffer(n+2)=dble(j)
+        buffer(n+3)=vxx(i)
+        buffer(n+4)=vyy(i)
+        buffer(n+5)=vzz(i)
+        buffer(n+6)=vxx(j)
+        buffer(n+7)=vyy(j)
+        buffer(n+8)=vzz(j)
+        n=n+8
+
+      enddo
+      
+      call gsync()
+      
+c     identity of neighbour node for systolic transfer
+      
+      jdnode=mod(idnode+1,mxnode)
+      
+      do k=1,mxnode-1
+
+c     identity of node of origin of incoming data
+        
+        kdnode=mod(idnode+mxnode-k,mxnode)
+        
+c     systolic data pulse to transfer data
+        
+        call MPI_IRECV(buffer(nsize+1),nsize,MPI_DOUBLE_PRECISION,
+     x    MPI_ANY_SOURCE,Shell_tag+k,MPI_COMM_WORLD,request,ierr)
+
+        call MPI_SEND(buffer(1),nsize,MPI_DOUBLE_PRECISION,jdnode,
+     x    Shell_tag+k,MPI_COMM_WORLD,ierr)
+
+         call MPI_WAIT(request,status,ierr)
+
+c     merge the incoming data into current arrays
+        
+        n=nsize
+
+c     block indices
+
+        kshl1 = (kdnode*ntshl)/mxnode+1
+        kshl2 = ((kdnode+1)*ntshl)/mxnode
+
+        do m=kshl1,kshl2
+          
+          i=nint(buffer(n+1))
+          j=nint(buffer(n+2))
+          
+          vxx(i)=buffer(n+3)
+          vyy(i)=buffer(n+4)
+          vzz(i)=buffer(n+5)
+          vxx(j)=buffer(n+6)
+          vyy(j)=buffer(n+7)
+          vzz(j)=buffer(n+8)
+
+          n=n+8
+          
+        enddo
+        
+c     shift new data to start of buffer
+        
+        do i=1,nsize
+          
+          buffer(i)=buffer(nsize+i)
+          
+        enddo
+        
+      enddo
+      
+      return
+      end
+
+      subroutine shmove
+     x     (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for passing coordinate updates between
+c     nodes during the shake iteration cycle
+c     
+c     parallel replicated data algorithm 
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith august 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      include "comms.inc"
+
+      integer idnode, mxnode, natms,ierr,i,k,j0,k0,n,jdnode,j
+      integer lishap(mxlshp),lashap(mxproc)
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+      real*8 xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      real*8 txx(mxatms),tyy(mxatms),tzz(mxatms)
+      real*8 buffer(mxbuff)
+
+c     store increments to be transferred
+
+      do i=1,natms
+
+         txx(i)=xxt(i)
+         tyy(i)=yyt(i)
+         tzz(i)=zzt(i)
+
+      enddo
+
+c     transfer coordinate data to all nodes
+
+      call gsync()
+
+      do k=1,mxnode-1
+
+         i=0
+         j0=0
+         if(k.gt.1)j0=lashap(k-1)
+
+         do j=j0+1,lashap(k)
+
+            buffer(i+1)=txx(lishap(j))
+            buffer(i+2)=tyy(lishap(j))
+            buffer(i+3)=tzz(lishap(j))
+            i=i+3                             
+                                               
+         enddo
+
+c     inter node communication
+
+         k0=0
+
+         if(k+1.lt.mxnode)k0=lashap(mxnode-k-1)
+         n=3*(lashap(mxnode-k)-k0)
+         jdnode=mod(idnode+k,mxnode)
+
+c     check for zero length messages
+
+         if(n.gt.0) call MPI_IRECV(buffer(i+1),n,MPI_DOUBLE_PRECISION,
+     x        MPI_ANY_SOURCE,Shmove_tag+k,MPI_COMM_WORLD,request,ierr)
+
+         if(i.gt.0) call MPI_SEND(buffer(1),i,MPI_DOUBLE_PRECISION,
+     x        jdnode,Shmove_tag+k,MPI_COMM_WORLD,ierr)
+
+         if(n.gt.0) call MPI_WAIT(request,status,ierr)
+
+c     consolidate transferred data
+
+         do j=k0+1,lashap(mxnode-k)
+
+            xxt(lishap(j))=xxt(lishap(j))+buffer(i+1)
+            yyt(lishap(j))=yyt(lishap(j))+buffer(i+2)
+            zzt(lishap(j))=zzt(lishap(j))+buffer(i+3)
+            i=i+3
+
+         enddo
+         
+      enddo
+      
+      return
+      end
+
+      subroutine splice
+     x      (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for splicing together coordinate arrays
+c     across a number of processors during shake algorithm
+c     
+c     parallel replicated data version
+c
+c     copyright - daresbury laboratory 1993
+c     author    - w. smith       march 1993
+c
+c     second version of splice
+c
+c*********************************************************************
+
+      use setup_module
+      use error_module
+      
+      implicit none
+
+      integer idnode,natms,listme,listot,j,n3,i,lastot
+      real*8 xxx,yyy,zzz,buffer
+
+      dimension listme(mxatms),listot(mxatms)
+      dimension xxx(natms),yyy(natms),zzz(natms)
+      dimension buffer(mxbuff)
+
+c     check buffer size
+
+      if(mxbuff.lt.6*natms) call error(idnode,190)
+
+c     load initial transfer buffers
+
+      j=3*natms
+      n3=3*natms
+
+      do i=1,natms
+
+         if(listot(i).gt.0)then
+
+            if(listme(i).gt.0)then
+
+               buffer(j+1)=xxx(i)
+               buffer(j+2)=yyy(i)
+               buffer(j+3)=zzz(i)
+
+            else
+
+               buffer(j+1)=0.d0
+               buffer(j+2)=0.d0
+               buffer(j+3)=0.d0
+
+            endif
+
+            j=j+3
+
+         endif
+
+      enddo
+
+      lastot=j-n3
+
+c     splice constraint coordinates
+
+      if(lastot.gt.0) call gdsum(buffer(n3+1),lastot,buffer(1))
+
+c     reconstitute coordinate arrays
+
+      j=n3
+
+      do i=1,natms
+
+         if(listot(i).gt.0)then
+
+            xxx(i)=buffer(j+1)/dble(listot(i))
+            yyy(i)=buffer(j+2)/dble(listot(i))
+            zzz(i)=buffer(j+3)/dble(listot(i))
+
+            j=j+3
+
+         endif
+
+      enddo
+      
+      return
+      end
diff -urN dl_class_1.9.orig/srcmod/metafreeze_module.f dl_class_1.9/srcmod/metafreeze_module.f
--- dl_class_1.9.orig/srcmod/metafreeze_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/metafreeze_module.f	2012-04-24 18:30:31.000000000 +0200
@@ -0,0 +1,3539 @@
+      module metafreeze_module
+
+c---------------------------------------------------------------------
+c     
+c     Metafreeze module for metadynamics
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     Adapted for dl_poly classic w. smith dec 2010
+c
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+c     Minimise usage by making everything private
+      
+      private
+
+c---------------------------------------------------------------------
+c     P u b l i c   R o u t i n e s
+c     ...  unless exposed here.
+c---------------------------------------------------------------------
+      
+      public :: define_metadynamics ! Called to intitialise this module
+      public :: metafreeze_driver ! Called at every MD time-step
+
+c---------------------------------------------------------------------
+c     P u b l i c   V a r i a b l e s
+c---------------------------------------------------------------------
+      
+      public :: lmetadyn  ! Is this a metadynamics calculation?
+      public :: driven    ! Is this atom site involved in metadynamics
+      public :: lstein,ltet,lglobpe,llocpe,ncolvar,nq4,nq6,ntet,hkey
+      public :: meta_step_int,globpe_scale,locpe_scale,ref_W_aug
+      public :: h_aug,wt_Dt
+
+c     Local copies of exluded atom arrays note that these are
+c     not indexed by atom number, but by an index which loops
+c     over the atoms handles by each MPI rank.
+      public :: mtd_nexatm,mtd_lexatm
+
+c------------------------------------
+c     Populated from CONTROL file   
+c------------------------------------
+      
+      logical,save :: lmetadyn =.false. ! Master metadynamics flag
+      
+c-------------------------------------------------------
+c     Energy, virial, stress and forces from 'local' pe
+c     Populated by dlpoly energy routines  
+c-------------------------------------------------------
+      
+      
+      public :: eng_loc,vir_loc,stress_loc  
+      public :: fxx_loc,fyy_loc,fzz_loc
+
+c----------------------------------------------------------------------
+c     Data accumulated for local potential energy (computed elsewhere) 
+c----------------------------------------------------------------------
+      
+      real(8),save                           :: eng_loc,vir_loc
+      real(8),dimension(9),save              :: stress_loc
+      real(8),allocatable,dimension(:),save  :: fxx_loc,fyy_loc,fzz_loc
+      
+c----------------------------------------------------------------------
+c     Arrays holding information on excluded interactions. Replicated 
+c     here to avoid a compilation dependency loop which would occur
+c     if simply using the arrays already in exclude_module.f
+c----------------------------------------------------------------------
+      integer,allocatable,dimension(:),save   :: mtd_nexatm
+      integer,allocatable,dimension(:,:),save :: mtd_lexatm
+
+c---------------------------------------------------------------------
+c     P r i v a t e   V a r i a b l e s 
+c---------------------------------------------------------------------
+
+c----------------------------------------------------------------
+c     Collective variables and derivatives of v_aug w.r.t colvars
+c----------------------------------------------------------------
+
+      integer,parameter :: maxhis = 150000 ! Size of history arrays      
+      real(8),allocatable,dimension(:),save   :: colvar,dcolvar
+      real(8),allocatable,dimension(:),save   :: colvar_scale
+
+c----------------------------------------------------------------
+c     Positions and heights of previous Gaussians in colvar space
+c----------------------------------------------------------------
+      
+      real(8),allocatable,dimension(:,:),save :: colvar_his
+      real(8),allocatable,dimension(:),save   :: w_aug
+      
+c------------------------------
+c     Read from CONTROL file
+c------------------------------
+      
+      integer,save :: ncolvar  = 0 ! Total number of collvars
+      logical,save :: lstein   =.false. ! Q4/Q6 collective variables
+      logical,save :: ltet     =.false. ! Tetrahedral order parameter
+      logical,save :: lglobpe  =.false. ! Global potential energy
+      logical,save :: llocpe   =.false. ! Local potential energy
+      
+      integer,save :: nq4   = 0 ! Number of Q4 pair types
+      integer,save :: nq6   = 0 ! Number of Q6 pair types
+      integer,save :: ntet  = 0 ! Number of zeta triplets
+      
+      real(8),save :: globpe_scale = 1.0d0 ! Scaling factors for local 
+      real(8),save :: locpe_scale  = 1.0d0 ! and global pe colvars
+      
+      real(8),save :: ref_W_aug=1.0d0 ! Reference Gaussian height
+      real(8),save :: h_aug=1.0d0     ! Gaussian width
+      integer,save :: hkey=0          ! Height control scheme
+      real(8),save :: wt_Dt=100.0d0   ! "Well-tempered" parameter
+      integer,save :: meta_step_int=5 ! interval between depositions
+      
+c----------------------------------------
+c     Read from STEINHARDT or TETRAHEDRAL
+c----------------------------------------
+      
+c     Global Steinhardt order parameters
+      
+      real(8),allocatable,dimension(:),save   :: q4_global 
+      real(8),allocatable,dimension(:),save   :: q6_global 
+      
+c     Global Tetrahedral order parameters
+      
+      real(8),allocatable,dimension(:),save   :: zeta_global 
+      
+c     Bookkeeping arrays for order parameter computation
+      
+      character(8),allocatable,dimension(:,:),save  :: q4label
+      character(8),allocatable,dimension(:,:),save  :: q6label
+      character(8),allocatable,dimension(:),save    :: zetalabel
+      
+c     Inner and outer cutoffs
+      
+      real(8),allocatable,dimension(:,:),save :: q4cutoff
+      real(8),allocatable,dimension(:,:),save :: q6cutoff
+      real(8),allocatable,dimension(:,:),save :: zetacutoff
+      
+c     Scaling factors for q4 and q6
+      
+      real(8),allocatable,dimension(:),save   :: q4scale
+      real(8),allocatable,dimension(:),save   :: q6scale
+      real(8),allocatable,dimension(:),save   :: zetascale
+      
+c     Number of nearest neighbours for q4, q6 and zeta
+      
+      integer,allocatable,dimension(:),save   :: q4nn,q6nn
+      integer,allocatable,dimension(:),save   :: zetann
+
+c------------------------------------------------------------
+c     Arrays holding data for computation of order parameters
+c------------------------------------------------------------
+      
+c     Steinhardt site-site interaction arrays
+      
+      integer,allocatable,dimension(:,:),save  :: q4site
+      integer,allocatable,dimension(:,:),save  :: q6site
+      integer,allocatable,dimension(:)  ,save  :: zetasite
+      
+c     Number of included sites
+      
+      integer,allocatable,dimension(:),save    :: q4ninc
+      integer,allocatable,dimension(:),save    :: q6ninc
+      integer,allocatable,dimension(:),save    :: zetaninc
+      
+c     Real and imaginary parts of q4bar and q6bar
+      
+      real(8),allocatable,dimension(:,:),save :: ReQ6bar,ImQ6bar
+      real(8),allocatable,dimension(:,:),save :: ReQ4bar,ImQ4bar
+      
+c     Max number of entries in co-ordination shell
+      
+      integer,parameter :: mxflist = 50 
+      integer :: mxninc
+      
+c     Full neighbour list for Tetrahedral order parameter
+      
+      integer,allocatable,dimension(:)  ,save   :: nflist 
+      integer,allocatable,dimension(:,:),save   :: flist
+      
+c-------------------------------------
+c     Internal bookkeeping
+c-------------------------------------
+      
+      logical,allocatable,dimension(:),save :: driven ! Metadynamics option
+      integer,save :: meta_step=1 ! Current metadynamics step number
+      real(8),save :: meta_energy ! Value of metadynamics bias potential
+      
+      integer,save :: wl_nbins=30    ! Number of bins for WL recursion
+      integer,save :: wl_cycle=0     ! Current WL cycle
+      real(8),save :: wl_range=0.175 ! range of WL 
+      real(8),allocatable,dimension(:),save :: wl_bin ! WL bins
+
+c--------------------------------------
+c     Miscellaneous internal variables
+c--------------------------------------
+
+      integer,allocatable,dimension(:) :: buff ! Comms buffer
+
+c     File units
+      
+      integer,save :: stn = 91  ! STEINHARDT
+      integer,save :: mtd = 92  ! METADYNAMICS
+      integer,save :: zta = 93  ! ZETA
+      integer,save :: wlb = 94  ! WL_BINS.DAT
+      
+c     Error flag
+      
+      integer,dimension(100) :: ierr = 0
+      
+c     Local store of comms variables
+c     Assuming no task farming, comms will require changing if farmed
+      
+      integer, save :: myrank,commsize 
+      logical, save :: onroot
+      real(8),save :: kt
+
+      contains
+
+      Subroutine Metafreeze_Driver
+     x  (imcon,natms,temp,nstep,engcfg,virtot,engord,virord)
+      
+c---------------------------------------------------------------------
+c     Top level metadynamics routine called after evaluation of all 
+c     other energetic and force terms within the main molecular 
+c     dynamics loop. 
+c     
+c     1. Computes the ncolvar order parameters
+c     2. Deposits a new Gaussian at the current collective variables 
+c        as the current number of steps reaches meta_step_int
+c     3. Computed the bias potential and its derivative w.r.t. the 
+c        ncolvar collective variables.
+c     4. Computes the forces stresses and virial resulting from the 
+c        bias
+c     
+c     Author  D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c
+c---------------------------------------------------------------------
+
+      use setup_module,    only : boltz
+      use config_module,   only : fxx,fyy,fzz,stress
+      
+      implicit none
+      
+      integer,intent(in)    :: nstep,imcon,natms
+      real(8),intent(in)    :: engcfg,virtot,temp
+      real(8),intent(out)   :: engord,virord
+      
+c     Local variables
+      
+      integer       :: k,iq,itet,ibin,nfail,my_meta_step
+      integer,save  :: nlastg = 0
+      real(8)       :: height,buff1,wl_mean
+      logical       :: flat,safe
+      
+c------------------------------------------------------
+c     Compute order parameters / collective variables
+c------------------------------------------------------
+
+c     Steinhardt order parameters
+      
+      if ( nq4>0.or.nq6>0 ) call compute_steinhardt(imcon,natms)
+      
+      k = 1
+      do iq = 1,nq4
+        colvar(k) = q4_global(iq)
+        k = k + 1
+      end do
+      do iq = 1,nq6
+        colvar(k) = q6_global(iq)
+        k = k + 1
+      end do
+      
+c     Tetrahedral order parameters
+      
+      if ( ntet > 0 ) then
+        call compute_tet_nlist(imcon,natms)
+        call compute_tetrahedral(imcon,natms)
+      end if  
+      
+      do itet = 1,ntet
+        colvar(k) = zeta_global(itet)
+        k = k + 1
+      end do
+      
+c     Energy order parameters
+      
+      if (lglobpe) then
+        colvar(k) = engcfg
+        k = k + 1
+      end if
+      if (llocpe) then
+        
+c     Global reduction of local virial and energy
+        
+        if ( commsize > 1 ) call gdsum(eng_loc,1,buff1)
+        if ( commsize > 1 ) call gdsum(vir_loc,1,buff1)
+        colvar(k)   = eng_loc
+        k = k + 1
+      end if
+      
+      if ( k-1/=ncolvar ) call Mfrz_Error(2500,0.d0) 
+      
+      if ( hkey==1 ) then
+        k = int(dble(wl_nbins)*colvar(1)/wl_range) + 1
+        if ( k < wl_nbins) wl_bin(k) = wl_bin(k) + 1.0d0
+      end if
+      
+c--------------------------------------------------------
+c     Deposit a new Gaussian if now is the correct time
+c--------------------------------------------------------
+      
+      if ( (mod(nstep,meta_step_int)==0).and.(nstep>nlastg) ) then
+        nlastg = nstep          ! Avoid multiple depositions at the
+                                ! same timestep (relaxed shell model)
+        
+        select case (hkey)
+          
+        case(0)
+          
+c     Always deposit Gaussians of the same height
+          
+          height = ref_W_aug
+          
+        case(1)
+          
+c     Wang-Landau style recursion
+          
+          open(unit=wlb,file='WL_BINS.DAT',status='replace')
+          
+          do ibin = 1,wl_nbins
+            write(wlb,*)ibin,wl_bin(ibin)
+          end do
+          
+          close(wlb)
+          
+          if ( ncolvar/=1 ) then
+            call Mfrz_Error(2501,0.d0)
+          else
+            
+            height    = ref_W_aug*(0.5d0**dble(wl_cycle))
+            
+            nfail = 0
+            wl_mean = 0.d0
+            do ibin = 6,wl_nbins-5
+              wl_mean = wl_mean + wl_bin(ibin)
+              nfail = nfail + 1
+            end do
+            wl_mean = wl_mean/dble(nfail)
+            
+            nfail = 0
+            flat = .true.
+            do ibin = 6,wl_nbins-5
+              if ( wl_bin(ibin) < 0.8d0*wl_mean ) then
+                if ( nfail > 2 ) flat = .false.
+                nfail = nfail + 1
+              end if
+            end do
+            
+            if ( flat.and.(sum(wl_bin)>50.0d0) ) then
+              wl_cycle = wl_cycle + 1
+              wl_bin   = 0.0d0
+            end if
+            
+            height = ref_W_aug*(0.5d0**dble(wl_cycle))
+            
+          end if   
+          
+        case(2)
+          
+c     Well-tempered metadynamics
+          
+          meta_energy = 0.0d0
+          call compute_bias_potential()
+          
+          height = ref_W_aug*exp(-meta_energy/wt_Dt)
+          
+        case default
+          
+          call Mfrz_Error(2502,0.d0)
+          
+        end select
+        
+        call deposit_gaussian(height,temp)
+        my_meta_step = (meta_step-1)/commsize + 1
+        safe = ( maxhis >= my_meta_step )
+        call gstate(safe)
+        if ( .not.safe ) call Mfrz_Error(2503,0.d0)
+        
+      end if
+      
+c-----------------------------------------------------------
+c     Compute the bias potential and its derivatives w.r.t.
+c     to the ncolvar collective variables.                 
+c-----------------------------------------------------------
+      
+      call compute_bias_potential()
+
+c-----------------------------------------------------------
+c     Add in the forces, stresses and virial contributions
+c     from this derivative.
+c-----------------------------------------------------------
+      
+      virord = 0.0d0            ! Zero the virial
+      
+c     Must compute contributions from pe order parameters
+c     first before we change any forces.
+      
+      k = nq4+nq6+ntet+1
+      
+c     Energy order parameters
+      
+      if (lglobpe) then
+        
+        fxx(:) = fxx(:)*(1.0d0+dcolvar(k))
+        fyy(:) = fyy(:)*(1.0d0+dcolvar(k))  
+        fzz(:) = fzz(:)*(1.0d0+dcolvar(k))
+        
+c     correct for later summation:
+        
+        virord = virord+dcolvar(k)*virtot/dble(commsize)
+        stress = stress*(1.0d0+dcolvar(k))
+        
+      end if
+      if (llocpe) then
+        
+        fxx(:) = fxx(:) + fxx_loc(:)*dcolvar(k)
+        fyy(:) = fyy(:) + fyy_loc(:)*dcolvar(k)
+        fzz(:) = fzz(:) + fzz_loc(:)*dcolvar(k)
+        
+c     correct for later summation:
+        
+        virord = virord + dcolvar(k)*vir_loc/dble(commsize)
+        stress = stress + stress_loc*dcolvar(k)
+        
+      end if
+      
+c     Steinhardt order parameters
+      
+      if ( nq4>0.or.nq6>0 ) call 
+     x  compute_steinhardt_forces(imcon,natms,engord,virord)
+      
+c     Tetrahedral order parameters
+      
+      if ( ntet > 0 ) call
+     x  compute_tetrahedral_forces(imcon,natms,engord,virord)
+      
+c     global reduction of virord
+
+      if ( commsize > 1 ) call gdsum(virord,1,buff1)
+      
+      engord = meta_energy
+
+c     write(0,'("DEBUG : engord = ",F12.6)')engord/(temp*boltz)
+      
+      return
+      
+      end Subroutine Metafreeze_Driver
+      
+      Subroutine Deposit_Gaussian(height,temp)
+
+c---------------------------------------------------------------------
+c     
+c     Deposits a new Gaussian at the current collective variables and 
+c     appends to the METADYNAMICs file.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c
+c---------------------------------------------------------------------
+      
+      use setup_module, only : boltz
+      
+      implicit none
+      
+      real(8),intent(in) :: height,temp
+      integer       :: my_meta_step
+      character(11) :: fmtstring
+      
+c     store current order parameters and Gaussian height
+      
+      if ( mod(meta_step-1,commsize) == myrank ) then
+        
+        my_meta_step = (meta_step-1)/commsize + 1
+        w_aug(my_meta_step)        = height
+        colvar_his(:,my_meta_step) = colvar(:)
+        
+      end if
+      
+      if (onroot) then
+        
+c     Create format string
+        
+        write(fmtstring,'("(I8,",I1,"E15.6)")')ncolvar+1
+        
+c     write METADYNAMICS file
+        
+        open(unit=mtd,file='METADYNAMICS',status='old',position=
+     x    'append',iostat=ierr(1))
+        write(unit=mtd,fmt=fmtstring)meta_step,colvar(:),
+     x    height/(temp*boltz)
+        close(unit=mtd)
+        
+      end if
+      
+      meta_step = meta_step+1
+      
+      return
+      
+      end Subroutine Deposit_Gaussian
+
+      Subroutine Compute_Bias_Potential()
+      
+c---------------------------------------------------------------------
+c
+c     Computes the augmenting bias potential as a function of the 
+c     collective variables. Also computes the derivative of the bias 
+c     potential w.r.t. the collective variables required to compute 
+c     the metadynamics forces.
+c
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+      integer :: istep,ic,k,my_meta_step
+      real(8) :: vsq,exp1,dWpsq
+      real(8),allocatable,dimension(:) :: buff1,buff2
+      
+      allocate(buff1(1:2*(ncolvar+1)),stat=ierr(1))
+      allocate(buff2(1:2*(ncolvar+1)),stat=ierr(2))
+      
+      if (any(ierr/=0)) call Mfrz_Error(2504,0.d0)
+
+c     Set squared-width of gaussians
+      
+      dWpsq = 1.0d0/h_aug**2
+      meta_energy  = 0.0d0
+      
+c     Zero accumulators of derivative w.r.t. each order parameter
+      
+      dcolvar(:) = 0.0d0
+      my_meta_step = (meta_step-1)/commsize + 1
+      do istep=1,my_meta_step
+        
+        vsq = 0.0d0
+        do ic = 1,ncolvar
+          vsq = vsq + ( colvar_scale(ic)*(colvar(ic) - 
+     x          colvar_his(ic,istep)) )**2
+        end do
+        exp1 = w_aug(istep)*exp(-0.5d0*vsq*dWpsq)
+        do ic = 1,ncolvar
+          dcolvar(ic) = dcolvar(ic) - (colvar_scale(ic)**2)*exp1*
+     x                  (colvar(ic) - colvar_his(ic,istep))*dWpsq
+        end do
+        
+        meta_energy = meta_energy + exp1
+        
+      end do
+      
+      buff1(1) = meta_energy
+      k = 2
+      do ic = 1,ncolvar
+        buff1(k) = dcolvar(ic)
+        k = k + 1
+      end do
+      
+      if ( commsize > 1 ) then
+        call gdsum(buff1,ncolvar+1,buff2)
+      end if
+      
+      meta_energy = buff1(1)
+      
+      k = 2
+      do ic=1,ncolvar
+        dcolvar(ic) = buff1(k)
+        k = k + 1
+      end do
+
+c     write(0,'("DEBUG : CV derivs = ",6F15.6)')dcolvar
+
+      deallocate(buff1,buff2,stat=ierr(1))
+      
+      return
+      
+      end Subroutine Compute_Bias_Potential
+      
+      Subroutine Define_Metadynamics(tm,ts,natms,ntpatm,temp)
+      
+c---------------------------------------------------------------------
+c     Processes the metadynamics input file. This is done in several 
+c     stages.
+c     1. Process the metadynamics control data read from the CONTROL
+c        file, which defines the number of collective variables and
+c        indicates if we need to read from auxilliary input files 
+c        (e.g. STEINHARDT or ZETA) which define order parameters.
+c     2. Read and process these auxilliary files.
+c     3. Process the information obtained from the CONTROL file which
+c        controls the properties of the Gaussians used to build the 
+c        bias potential.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     Adapted w. smith  - jan 2011
+c     
+c---------------------------------------------------------------------
+      
+      use site_module
+      use config_module, only : ltype
+      use parse_module
+      
+      implicit none
+      
+      integer,intent(in) :: tm,ts,natms,ntpatm
+      real(8),intent(in) :: temp
+      
+c     Local variables
+      
+      integer :: isite,jsite,ilin,i,iq,iatm0,iatm1,istrd,iatm,k,n,idum
+      logical :: lexist,go,safe
+      real(8) :: waug,dummy(1)
+      
+c     Allocate the driven list. Modifications elsewhere in DLPOLY always
+c     check if sites are driven (for accumulation of local PE) and hence
+c     this should be allocated if this is a metadynamics run or not.
+      
+      allocate(driven(1:size(unqatm)),stat=ierr(1))
+      if (ierr(1)/=0) call Mfrz_Error(2505,0.d0)
+      driven = .false.
+
+c     Do nothing else if the metafreeze flag has not been set in CONTROL
+      
+      if (.not.lmetadyn) then
+        return
+      end if
+      
+      myrank=tm 
+      commsize = ts
+      onroot = (myrank==0)
+
+    
+c$$$     DEBUG
+cc$$$    if (onroot) write(0,'("================================")')
+cc$$$    if (onroot) write(0,'("Available sites from site module")')
+cc$$$    if (onroot) write(0,'("================================")')
+cc$$$    if (onroot) then
+cc$$$       do isite = 1,size(unqatm)
+cc$$$          write(0,'("Site index ",i4,": ",a8)')isite,unqatm(isite)
+cc$$$       end do
+cc$$$    end if
+    
+c     Cannot bias the global and local PE in the same run.
+      
+      if ( lglobpe.and.llocpe ) call Mfrz_Error(2509,0.d0)
+
+c     Allocate local force arrays if anything is driven.
+      
+      allocate(fxx_loc(1:mxatms),stat=ierr(1))
+      allocate(fyy_loc(1:mxatms),stat=ierr(2))
+      allocate(fzz_loc(1:mxatms),stat=ierr(3))
+      if (any(ierr/=0)) call Mfrz_Error(2510,0.d0)
+   
+c     Allocate arrays to hold collective variables 
+      
+      allocate( colvar(1:ncolvar),stat=ierr(1))
+      allocate(dcolvar(1:ncolvar),stat=ierr(2))
+      allocate(colvar_his(1:ncolvar,1:maxhis),stat=ierr(3))
+      allocate(colvar_scale(1:ncolvar),stat=ierr(4))
+      allocate(w_aug(1:maxhis),stat=ierr(5))
+      if (any(ierr/=0)) call Mfrz_Error(2511,0.d0)
+      
+c     Allocate Wang-Landau bin array
+
+      allocate(wl_bin(1:wl_nbins),stat=ierr(1))
+      if (any(ierr/=0)) call Mfrz_Error(2512,0.d0)
+      wl_bin = 0.0d0
+      
+c-------------------------------------------------------------
+c     Process Steinhardt order parameter settings if present
+c-------------------------------------------------------------
+      
+      if ( lstein ) then
+        
+        allocate(q4label(1:2,1:nq4),stat=ierr(1))
+        allocate(q6label(1:2,1:nq6),stat=ierr(2))
+        allocate(q4cutoff(1:2,1:nq4),stat=ierr(3))
+        allocate(q6cutoff(1:2,1:nq6),stat=ierr(4))
+        allocate(q4scale(1:nq4),stat=ierr(5))
+        allocate(q6scale(1:nq6),stat=ierr(6))
+        allocate(q4nn(1:nq4),stat=ierr(7))
+        allocate(q6nn(1:nq6),stat=ierr(8))
+        allocate(q4ninc(1:nq4),stat=ierr(9))
+        allocate(q6ninc(1:nq6),stat=ierr(10))
+        allocate(buff(1:max(nq4,nq6)),stat=ierr(11))
+        allocate(q4_global(1:nq4),stat=ierr(12))
+        allocate(q6_global(1:nq6),stat=ierr(13))
+        allocate(ReQ4Bar(-4:+4,1:nq4),stat=ierr(14))
+        allocate(ImQ4Bar(-4:+4,1:nq4),stat=ierr(15))
+        allocate(ReQ6Bar(-6:+6,1:nq6),stat=ierr(16))
+        allocate(ImQ6Bar(-6:+6,1:nq6),stat=ierr(17))       
+        if (any(ierr/=0)) call Mfrz_Error(2515,0.d0)
+        
+c     Open STEINHARDT file and process
+        
+        if (onroot) then
+          open(unit=stn,file='STEINHARDT',status='old',iostat=ierr(1))
+        else
+          ierr(1)=0
+        endif
+        call gisum(ierr(1),1,ierr(2))
+        if ( ierr(1)/=0 ) call Mfrz_Error(2516,0.d0)
+        
+        ilin = 1
+        safe=.true.
+        if (nq4>0) then
+          call getrec(safe,myrank,stn) ! Ignore q4 comment line
+          ilin = ilin + 1
+          do i = 1,nq4
+            call getrec(safe,myrank,stn)
+            if (safe) then
+              call getword(q4label(1,i),record,8,lenrec)
+              call getword(q4label(2,i),record,8,lenrec)
+              q4cutoff(1,i)=dblstr(record,lenrec,idum)
+              q4cutoff(2,i)=dblstr(record,lenrec,idum)
+              q4scale(i)=dblstr(record,lenrec,idum)
+              q4nn(i)=intstr(record,lenrec,idum)
+              ierr(ilin)=0
+            else
+              ierr(ilin)=1
+            endif
+            ilin = ilin + 1
+          end do
+        end if
+        if (nq6>0) then
+          call getrec(safe,myrank,stn) ! Ignore q6 comment line
+          ilin = ilin + 1
+          do i = 1,nq6
+            call getrec(safe,myrank,stn)
+            if (safe) then
+              call getword(q6label(1,i),record,8,lenrec)
+              call getword(q6label(2,i),record,8,lenrec)
+              q6cutoff(1,i)=dblstr(record,lenrec,idum)
+              q6cutoff(2,i)=dblstr(record,lenrec,idum)
+              q6scale(i)=dblstr(record,lenrec,idum)
+              q6nn(i)=intstr(record,lenrec,idum)
+              ierr(ilin)=0
+            else
+              ierr(ilin)=1
+            endif
+            ilin = ilin + 1
+          end do
+        end if
+        if (onroot) close(unit=stn)
+        
+        call gisum(ierr(1),ilin-1,ierr(ilin))
+        do i = 1,ilin-1
+          if (ierr(i)/=0) then
+            call Mfrz_Error(2521,dble(i))
+          end if
+        end do
+        
+c     Create array indicating which site-site connections use
+c     which set of q4 cut-offs, scaling factors and num neighbours.
+       
+       allocate(q4site(1:size(unqatm),1:size(unqatm)),stat=ierr(1))
+       if (ierr(1)/=0) call Mfrz_Error(2517,0.d0)
+       q4site(:,:) = 0
+       
+       do isite = 1,ntpatm
+         do jsite = isite,ntpatm
+           do iq = 1,nq4
+             if ((q4label(1,iq)==unqatm(isite)).and.
+     x         (q4label(2,iq)==unqatm(jsite))) then
+               q4site(jsite,isite) = iq
+               q4site(isite,jsite) = iq
+               driven(jsite) = .true.
+               driven(isite) = .true.
+             end if
+           end do
+         end do
+       end do
+
+       allocate(q6site(1:size(unqatm),1:size(unqatm)),stat=ierr(1))
+       if (ierr(1)/=0) call Mfrz_Error(2518,0.d0)
+       q6site(:,:) = 0
+       do isite = 1,ntpatm
+         do jsite = isite,ntpatm
+           do iq = 1,nq6
+             if ((q6label(1,iq)==unqatm(isite)).and.
+     x         q6label(2,iq)==unqatm(jsite)) then
+               q6site(jsite,isite) = iq
+               q6site(isite,jsite) = iq
+               driven(jsite) = .true.
+               driven(isite) = .true.
+             end if
+           end do
+         end do
+       end do
+       
+c     Count number of included sites
+       
+       iatm0 = myrank+1
+       iatm1 = natms
+       istrd = commsize
+       
+       q4ninc = 0 
+       q6ninc = 0
+       do iatm = iatm0,iatm1,istrd
+         
+         isite = ltype(iatm)
+         
+         do iq = 1,nq4
+           if (unqatm(isite)==q4label(1,iq)) q4ninc(iq) = q4ninc(iq) + 1
+         end do
+         do iq = 1,nq6
+           if (unqatm(isite)==q6label(1,iq)) q6ninc(iq) = q6ninc(iq) + 1
+         end do
+         
+       end do
+       
+       if ( commsize > 0 ) then
+         if (nq4>0) call gisum(q4ninc,nq4,buff(1:nq4))
+         if (nq6>0) call gisum(q6ninc,nq6,buff(1:nq6))
+       end if
+       
+       deallocate(buff,stat=ierr(1))
+       if (ierr(1)/=0) call Mfrz_Error(2519,0.d0)
+       
+      end if                    ! end if steinhardt order parameters
+      
+      if ( ltet ) then
+        
+        allocate(zetacutoff(1:2,1:ntet),stat=ierr(1))
+        allocate(zeta_global(1:ntet),stat=ierr(2))
+        allocate(zetascale(1:ntet),stat=ierr(3))
+        allocate(zetalabel(1:ntet),stat=ierr(4))
+        allocate(zetann(1:ntet),stat=ierr(5))
+        allocate(zetaninc(1:ntet),stat=ierr(6))
+        allocate(buff(1:ntet),stat=ierr(7))
+        if (any(ierr/=0)) call Mfrz_Error(2522,0.d0)
+        
+c     Open ZETA file and process
+
+        if (onroot) then
+          open(unit=zta,file='ZETA',status='old',iostat=ierr(1))
+        else
+          ierr(1)=0
+        endif
+        call gisum(ierr(1),1,ierr(2))
+        if ( ierr(1)/=0 ) call Mfrz_Error(2523,0.d0)
+        
+        ilin = 1
+        safe=.true.
+        if (ntet>0) then
+          call getrec(safe,myrank,zta) ! Ignore comment line
+          ilin = ilin + 1
+          do i = 1,ntet
+            call getrec(safe,myrank,zta)
+            if (safe) then
+              call getword(zetalabel(i),record,8,lenrec)
+              zetacutoff(1,i)=dblstr(record,lenrec,idum)
+              zetacutoff(2,i)=dblstr(record,lenrec,idum)
+              zetascale(i)=dblstr(record,lenrec,idum)
+              zetann(i)=intstr(record,lenrec,idum)
+              ierr(ilin)=0
+            else
+              ierr(ilin)=1
+            endif
+            ilin = ilin + 1
+          end do
+        end if
+        if (onroot) close(unit=zta)
+
+        call gisum(ierr(1),ilin-1,ierr(ilin))
+        do i = 1,ilin-1
+          if (ierr(i)/=0) then
+            call Mfrz_Error(2529,dble(i))
+          end if
+        end do
+        
+c     Create array indicating which site-site connections use
+c     which set of q4 cut-offs, scaling factors and num neighbours.
+        
+        allocate(zetasite(1:size(unqatm)),stat=ierr(1))
+        if (ierr(1)/=0) call Mfrz_Error(2524,0.d0)
+        zetasite(:) = 0
+        
+        do isite = 1,size(unqatm)
+          do iq = 1,ntet
+            if (zetalabel(iq)==unqatm(isite)) then
+              zetasite(isite) = iq
+              driven(isite) = .true.
+            end if
+          end do
+        end do
+        
+c     Count number of included sites
+        
+        iatm0 = myrank+1
+        iatm1 = natms
+        istrd = commsize
+        
+        zetaninc(:) = 0
+        do iatm = iatm0,iatm1,istrd
+          
+          isite = ltype(iatm)
+          
+          do iq = 1,ntet
+            if (unqatm(isite)==zetalabel(iq)) 
+     x        zetaninc(iq) = zetaninc(iq) + 1
+          end do
+        end do
+        
+        if (commsize>1) then
+          if (ntet>0) call gisum(zetaninc,ntet,buff)
+        end if
+        
+c$$$        do iq = 1,ntet
+c$$$          write(0,'("Number of sites for zeta type ",I5," : ",I5)')
+c$$$     x      iq,zetaninc(iq)
+c$$$        end do
+        
+        mxninc = max(100,4*maxval(zetaninc)/commsize)
+        allocate(nflist(1:mxninc),stat=ierr(1))
+        allocate(flist(1:mxflist,1:mxninc),stat=ierr(2))
+        if (any(ierr/=0)) call Mfrz_Error(2525,0.d0)
+        
+        deallocate(buff,stat=ierr(1))
+        if (ierr(1)/=0) call Mfrz_Error(2519,0.d0)
+        
+      end if                    ! end if tetrahedral order parameters
+      
+c     Check total number of collective variables (ncolvar) matches total
+c     number specified by nq4, nq6, ntet and potential energy flags.
+      
+      k = 0
+      if (llocpe  ) k = k + 1
+      if (lglobpe ) k = k + 1
+      k = k + ntet + nq4 + nq6
+      if ( k /= ncolvar ) call Mfrz_Error(2527,0.d0)
+    
+c     populate colvar_scale
+      
+      k = 1
+      do iq = 1,nq4
+        colvar_scale(k) = q4scale(iq)
+        k = k + 1
+      end do
+      do iq = 1,nq6
+        colvar_scale(k) = q6scale(iq)
+        k = k + 1
+      end do
+      do iq = 1,ntet
+        colvar_scale(k) = zetascale(iq)
+        k = k + 1
+      end do
+      if (lglobpe) then
+        colvar_scale(k) = globpe_scale
+        k = k + 1
+      end if
+      if (llocpe) then
+        colvar_scale(k) = locpe_scale
+        k = k + 1
+      end if
+      
+c     write(0,*)lglobpe,llocpe
+c     write(0,'("DEBUG : CV Scaling factors : ",6F15.6)')colvar_scale(:)
+
+
+c     Convert into internal units
+      
+      wt_Dt = wt_Dt*temp*boltz
+      ref_W_aug = ref_W_aug*temp*boltz
+      kt        = temp*boltz
+      
+c---------------------------------------------------------------------
+c     Purge the METADYNAMICS file or re-open and read if this is a 
+c     restart. N.B. we assume a restart if REVOLD if present and 
+c     ignore keyres.
+c---------------------------------------------------------------------
+      
+      if (onroot) then
+        inquire(file='REVOLD',exist=lexist)
+      else
+        lexist=.true.
+      endif
+      call gstate(lexist)
+      
+      if (lexist) then
+        
+c     read contents of METADYNAMICS file
+        
+        if (onroot) then
+          
+          open(unit=mtd,file='METADYNAMICS',status='old',iostat=ierr(1))
+          
+          k = 0
+          do
+            read(unit=mtd,fmt=*,end=10)meta_step,colvar(:),waug
+            waug = waug*temp*boltz
+            if (k == 0) then
+              n = (meta_step-1)/commsize + 1
+              colvar_his(:,n)=colvar(:)
+              w_aug(n)=waug
+            else
+              dummy(1)=dble(meta_step)
+              call csend(17947,dummy,1,k,idum)
+              call csend(17948,colvar,ncolvar,k,ierr(3))
+              dummy(1)=waug
+              call csend(17949,dummy,1,k,ierr(4))
+            end if
+            
+            k = k + 1
+            if (k == commsize) k = 0
+          end do
+          
+   10     close(unit=mtd)
+          
+          do k=1,commsize-1
+            dummy(1)=-dble(meta_step)
+            call csend(17947,dummy,1,k,ierr(2))
+          end do
+          
+        else
+          
+          go = .true.
+          do while(go)
+            
+            call crecv(17947,dummy,1)
+            meta_step=nint(dummy(1))
+            ierr(2)=0
+            
+            if ( meta_step < 0 ) then
+              meta_step = -meta_step
+              go = .false.
+            else
+              call crecv(17948,colvar,ncolvar)
+              ierr(3)=0
+              call crecv(17949,dummy,1)
+              waug=dummy(1)
+              ierr(4)=0
+              n = (meta_step-1)/commsize + 1
+              colvar_his(:,n)=colvar(:)
+              w_aug(n)=waug
+            end if
+          
+          enddo
+          
+        end if
+        call gisum(ierr(1),4,ierr(5))
+        do i=1,4
+          if (ierr(i)/=0) call Mfrz_Error(2531,0.d0)
+        enddo
+        meta_step = meta_step + 1
+        
+      else
+        
+c     purge any existing METADYNAMICS file
+        
+        if (onroot) then
+          
+          open(unit=mtd,file='METADYNAMICS',status='replace',
+     x      iostat=ierr(1))
+          close(unit=mtd)
+          
+        end if
+        
+      end if
+      
+      return
+      
+      end Subroutine Define_Metadynamics
+      
+      Function Fc(r,inner_cut,outer_cut)
+      
+c---------------------------------------------------------------------
+c
+c     Computes the smooth cut-off function used when computing an order
+c     parameter as a function of pair separation.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+      real(8),parameter :: Pi=3.141592653589793238462643383279502884d0
+      real(8),intent(in) :: r,inner_cut,outer_cut
+      real(8) :: fc
+      
+      if ( r > outer_cut ) then
+        fc = 0.0d0
+      elseif ( r > inner_cut ) then
+        fc = 0.5d0*cos((r-inner_cut)*Pi/(outer_cut-inner_cut))+0.5d0
+      elseif ( r <= inner_cut ) then
+        fc = 1.0d0
+      else
+        call Mfrz_Error(2532,r)
+      end if
+      
+      return
+      
+      end Function Fc
+      
+      Function Dfc(r,inner_cut,outer_cut)
+      
+c---------------------------------------------------------------------
+c     Computes the derivative of the smooth cut-off function used when
+c     computing an order parameter as a function of pair separation.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+      real(8),parameter :: Pi=3.141592653589793238462643383279502884d0
+      real(8),intent(in) :: r,inner_cut,outer_cut
+      real(8) :: dfc
+      
+      if ( r > outer_cut ) then
+        dfc = 0.0d0
+      elseif ( r > inner_cut ) then
+        dfc = -0.5d0*sin((r-inner_cut)*Pi/(outer_cut-inner_cut))
+     x    *Pi/(outer_cut-inner_cut)
+      else
+        dfc = 0.0d0
+      end if
+      
+      return
+      
+      end Function Dfc
+  
+      subroutine compute_steinhardt(imcon,natms)
+      
+c---------------------------------------------------------------------
+c     
+c     Computes nq4 Q4 and nq6 Q6 global order parameters.
+c
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use setup_module,   only : mxlist
+      use utility_module, only : images
+      
+      implicit none
+      
+c     Arguments
+      
+      integer,intent(in) :: imcon,natms
+      
+c     sqrt(pi/13) , sqrt(pi/9) , 1/3
+      
+      real(8),parameter :: rpibtt = 0.491590249d0
+      real(8),parameter :: rpibn  = 0.590817950d0
+      real(8),parameter :: third  = 1.0d0/3.0d0
+      
+c     Prefactors for spherical harmonics with l = 6
+      
+      real(8),parameter :: ypre6m6 =  0.48308411358006625446748d0
+      real(8),parameter :: ypre6m5 =  1.67345245810009801701312d0
+      real(8),parameter :: ypre6m4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6m3 =  0.65139048586771575166665d0
+      real(8),parameter :: ypre6m2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6m1 =  0.41197551630114082055201d0
+      real(8),parameter :: ypre6m0 =  0.06356920226762842462964d0
+      real(8),parameter :: ypre6p1 = -0.41197551630114082055201d0
+      real(8),parameter :: ypre6p2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6p3 = -0.65139048586771575166665d0
+      real(8),parameter :: ypre6p4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6p5 = -1.67345245810009801701312d0
+      real(8),parameter :: ypre6p6 =  0.48308411358006625446748d0
+      
+c     Prefactors for spherical harmonics with l = 4
+      
+      real(8),parameter :: ypre4m4 =  0.44253269244498261159038d0
+      real(8),parameter :: ypre4m3 =  1.25167147089835228968013d0
+      real(8),parameter :: ypre4m2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4m1 =  0.47308734787878004013351d0
+      real(8),parameter :: ypre4m0 =  0.10578554691520430930396d0
+      real(8),parameter :: ypre4p1 = -0.47308734787878004013351d0
+      real(8),parameter :: ypre4p2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4p3 = -1.25167147089835228968013d0
+      real(8),parameter :: ypre4p4 =  0.44253269244498261159038d0
+      
+c     Maximum no. of entries in solvation list
+      
+      integer :: maxneigh
+      
+c     Solvation shell information - Q4
+      
+      real(8),allocatable,dimension(:) :: solvx4,solvy4,solvz4
+      real(8),allocatable,dimension(:) :: solvrmag4,solvimag4,solvrsq4
+      integer,allocatable,dimension(:) :: solvlist4,solvtype4
+      integer :: isolvmax4
+      
+c     Solvation shell information - Q6
+      
+      real(8),allocatable,dimension(:) :: solvx6,solvy6,solvz6
+      real(8),allocatable,dimension(:) :: solvrmag6,solvimag6,solvrsq6
+      integer,allocatable,dimension(:) :: solvlist6,solvtype6
+      integer :: isolvmax6
+      
+c     separation vectors and powers thereof
+      
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8) :: x,y,z
+      real(8) :: x2,y2,z2,x3,y3,z3
+      real(8) :: x4,y4,z4,x5,y5,z5
+      real(8) :: x6,y6,z6
+      real(8) :: invrc,invrs
+
+c     list of separation vectors
+      integer :: numdst
+      integer,allocatable,dimension(:) :: dstlst
+
+      
+c     Comms buffers
+      
+      real(8),allocatable,dimension(:) :: buff1,buff2
+      
+c     Temporaries
+      
+      real(8) :: tmpsq,f_ij,df_ij,ReYlm,ImYlm,tmpvar
+      
+c     Loop counters
+      
+      integer :: iatm1,iatm0,iatm,isite,istrd,ii,isolv4,isolv6,isolv
+      integer :: idi,idj,limit,nn,k,jatm,jsite,q4type,q6type
+      integer :: itype,jtype,l,m,iq
+      
+      maxneigh = 100            ! Max number of atoms in coordination shell
+
+      ierr = 0                  ! Error flags
+      
+
+c     DQ - modified 10/12/11, arrays now big enough
+c     to hold maximum number of neighbours plus
+c     maximum number of excluded atoms.
+      allocate(xdf(1:mxlist+mxexcl),stat=ierr(1))
+      allocate(ydf(1:mxlist+mxexcl),stat=ierr(2))
+      allocate(zdf(1:mxlist+mxexcl),stat=ierr(3))
+
+c     DQ - modified 10/12/11, array to hold a list of
+c     all atom entries in the above three arrays
+      allocate(dstlst(1:mxlist+mxexcl),stat=ierr(4))
+      
+      allocate(solvx4(1:maxneigh),stat=ierr(5))
+      allocate(solvy4(1:maxneigh),stat=ierr(6))
+      allocate(solvz4(1:maxneigh),stat=ierr(7))
+      allocate(solvrmag4(1:maxneigh),stat=ierr(8))
+      allocate(solvimag4(1:maxneigh),stat=ierr(9))
+      allocate(solvrsq4 (1:maxneigh),stat=ierr(10))
+      allocate(solvlist4(1:maxneigh),stat=ierr(11)) 
+      allocate(solvtype4(1:maxneigh),stat=ierr(12))
+      
+      allocate(solvx6(1:maxneigh),stat=ierr(13))
+      allocate(solvy6(1:maxneigh),stat=ierr(14))
+      allocate(solvz6(1:maxneigh),stat=ierr(15))
+      allocate(solvrmag6(1:maxneigh),stat=ierr(16))
+      allocate(solvimag6(1:maxneigh),stat=ierr(17))
+      allocate(solvrsq6 (1:maxneigh),stat=ierr(18))
+      allocate(solvlist6(1:maxneigh),stat=ierr(19)) 
+      allocate(solvtype6(1:maxneigh),stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2533,0.d0) 
+      
+      allocate(buff1(1:18*nq4+26*nq6),stat=ierr(1))
+      allocate(buff2(1:18*nq4+26*nq6),stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2534,0.d0)
+      
+c     Zero accumulators used in Steinhardt order parameters
+      
+      ReQ6bar = 0.0d0
+      ImQ6bar = 0.0d0
+      ReQ4bar = 0.0d0
+      ImQ4bar = 0.0d0
+      
+c     Set atoms looped over by current rank
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+c --------------------------------------------------------------
+c     Build a list of the required connections to iatm. This  
+c     differs depending on the version of DLPOLY we are using.
+c     First we loop over atoms in the neighbour list of iatm.
+c---------------------------------------------------------------
+      
+      ii = ii + 1
+      isite=ltype(iatm)
+      limit=lentry(ii)
+      nn = 0
+      do k = 1,limit
+        
+        jatm  = list(ii,k)
+        jsite = ltype(jatm)
+        
+        if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+        nn = nn + 1
+
+        dstlst(nn) = jatm
+        
+        xdf(nn)=xxx(jatm)-xxx(iatm)
+        ydf(nn)=yyy(jatm)-yyy(iatm)
+        zdf(nn)=zzz(jatm)-zzz(iatm) 
+        
+      end do
+
+c --------------------------------------------------------------
+c     Next we loop over the excluded atom list of iatm and add 
+c     and pairs needed for computation of the current OP.
+c---------------------------------------------------------------
+
+ccc   DEBUG
+ccc      write(0,'("atom ",I5," has ",I5," excluded interactions")')
+ccc     x iatm,mtd_nexatm(iatm)
+
+      do k = 1,mtd_nexatm(ii)
+
+         jatm  = mtd_lexatm(ii,k)
+         jsite = ltype(jatm)
+
+ccc   DEBUG
+ccc         write(0,'("Interaction with atom ",I5," is excluded. ")')jatm
+
+         if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+         nn = nn + 1
+        
+         dstlst(nn) = jatm
+
+         xdf(nn)=xxx(jatm)-xxx(iatm)
+         ydf(nn)=yyy(jatm)-yyy(iatm)
+         zdf(nn)=zzz(jatm)-zzz(iatm) 
+
+      end do
+
+ccc   DEBUG
+ccc      write(0,'("Num neighbours to consider for atom ",I5," : ",I5)')
+ccc     x iatm,nn
+
+      numdst = nn
+
+      call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+      nn = 0
+      isolvmax4 = 0
+      isolvmax6 = 0
+      isolv4 = 0
+      isolv6 = 0
+
+      do k = 1,numdst
+        jatm  = dstlst(k)
+        jsite = ltype(jatm)
+        
+        if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+        nn = nn + 1
+        
+        q4type = q4site(jsite,isite)
+        q6type = q6site(jsite,isite)
+        
+        tmpsq = xdf(nn)*xdf(nn)+ydf(nn)*ydf(nn)+zdf(nn)*zdf(nn)
+        
+        if (nq4>0) then
+          
+c     Add to solvation lists if within cut-off 
+          
+          if (  tmpsq < q4cutoff(2,q4type)**2 ) then
+            isolv4 = isolv4 + 1
+            solvlist4(isolv4) = jatm
+            solvrsq4(isolv4)  = tmpsq
+            solvrmag4(isolv4) = sqrt(tmpsq)
+            solvimag4(isolv4) = 1.0d0/solvrmag4(isolv4)
+            solvx4(isolv4)    = xdf(nn)
+            solvy4(isolv4)    = ydf(nn)
+            solvz4(isolv4)    = zdf(nn)
+            solvtype4(isolv4) = q4type
+          end if
+        end if
+        
+        if (nq6>0) then
+          
+c     Add to solvation lists if within cut-off 
+          
+          if (  tmpsq < q6cutoff(2,q6type)**2 ) then
+            isolv6 = isolv6 + 1
+            solvlist6(isolv6) = jatm
+            solvrsq6(isolv6)  = tmpsq
+            solvrmag6(isolv6) = sqrt(tmpsq)
+            solvimag6(isolv6) = 1.0d0/solvrmag6(isolv6)
+            solvx6(isolv6)    = xdf(nn)
+            solvy6(isolv6)    = ydf(nn)
+            solvz6(isolv6)    = zdf(nn)
+            solvtype6(isolv6) = q6type
+          end if
+        end if
+        isolvmax4 = isolv4
+        isolvmax6 = isolv6
+        if ((isolv4>maxneigh) .or. (isolv6>maxneigh))
+     x    call Mfrz_Error(2535,0.d0)
+        
+      end do                    ! end loop over k
+
+ccc      write(0,'("Num in range for OPs on atom ",I5," : ",I5)')
+ccc     x iatm,isolvmax4
+
+      
+c---------------------------------------------------------
+c     Compute Q4 Steinhardt order parameters              
+c---------------------------------------------------------
+      
+      if ( (nq4>0).and.isolvmax4>0 ) then
+        
+        do isolv4 = 1,isolvmax4
+          
+          jatm = solvlist4(isolv4)
+          itype = solvtype4(isolv4)
+          
+          invrc = solvimag4(isolv4)**6
+          invrs = solvimag4(isolv4)**4
+          
+          x     = solvx4(isolv4)
+          y     = solvy4(isolv4)
+          z     = solvz4(isolv4)
+          
+          f_ij  = fc(solvrmag4(isolv4),q4cutoff(1,itype),
+     x              q4cutoff(2,itype))
+          
+          x2 = x*x
+          y2 = y*y
+          z2 = z*z
+          
+          x3 = x2*x
+          y3 = y2*y
+          z3 = z2*z
+          
+          x4 = x2*x2
+          y4 = y2*y2
+          z4 = z2*z2
+          
+          x5 = x4*x
+          y5 = y4*y
+          z5 = z4*z
+          
+          x6 = x4*x2
+          y6 = y4*y2
+          z6 = z4*z2
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-4/+4)
+c----------------------------------------------------------
+          
+          ReYlm = ypre4m4*invrs*(x4-6.d0*x2*y2+y4)
+          ImYlm = ypre4m4*invrs*(-4.d0*x3*y+4.d0*x*y3)
+          
+          ReQ4bar(-4,itype) = ReQ4bar(-4,itype) + f_ij*ReYlm
+          ImQ4bar(-4,itype) = ImQ4bar(-4,itype) + f_ij*ImYlm
+
+          ReQ4bar(+4,itype) = ReQ4bar(+4,itype) + f_ij*ReYlm
+          ImQ4bar(+4,itype) = ImQ4bar(+4,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-3/+3)
+c----------------------------------------------------------
+          
+          ReYlm = ypre4m3*invrs*z*(x3-3.d0*x*y2)
+          ImYlm = ypre4m3*invrs*z*(-3.d0*x2*y+y3)
+          
+          ReQ4bar(-3,itype) = ReQ4bar(-3,itype) + f_ij*ReYlm
+          ImQ4bar(-3,itype) = ImQ4bar(-3,itype) + f_ij*ImYlm
+
+          ReQ4bar(+3,itype) = ReQ4bar(+3,itype) - f_ij*ReYlm
+          ImQ4bar(+3,itype) = ImQ4bar(+3,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-2/+2)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre4m2*invrs*(x2-y2)*(-6.d0*z2+x2+y2)
+          ImYlm = ypre4m2*invrs*2.d0*(-6.d0*z2+x2+y2)*x*y
+          
+          ReQ4bar(-2,itype) = ReQ4bar(-2,itype) + f_ij*ReYlm
+          ImQ4bar(-2,itype) = ImQ4bar(-2,itype) + f_ij*ImYlm
+
+          ReQ4bar(+2,itype) = ReQ4bar(+2,itype) + f_ij*ReYlm
+          ImQ4bar(+2,itype) = ImQ4bar(+2,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-1/+1)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*x
+          ImYlm = ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*y
+          
+          ReQ4bar(-1,itype) = ReQ4bar(-1,itype) + f_ij*ReYlm
+          ImQ4bar(-1,itype) = ImQ4bar(-1,itype) + f_ij*ImYlm
+
+          ReQ4bar(+1,itype) = ReQ4bar(+1,itype) - f_ij*ReYlm
+          ImQ4bar(+1,itype) = ImQ4bar(+1,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(0)
+c----------------------------------------------------------
+          
+          ReYlm = ypre4m0*invrs*(8.d0*z4-24.d0*z2*x2-24.d0*z2*y2+
+     x      3.d0*x4+6.d0*x2*y2+3.d0*y4)
+          
+          ReQ4bar(0,itype)  = ReQ4bar(0,itype) + f_ij*ReYlm
+          
+        end do                  ! end loop over connection list for iatm
+        
+      end if                    ! end if computing Q4
+      
+c------------------------------------------------
+c     Compute Q6 Steinhardt order parameters     
+c------------------------------------------------
+      
+      if ( (nq6>0).and.isolvmax6>0 ) then
+        
+        do isolv6 = 1,isolvmax6
+          
+          jatm = solvlist6(isolv6)
+          itype = solvtype6(isolv6)
+          
+          invrc = solvimag6(isolv6)**6
+          invrs = solvimag6(isolv6)**4
+          
+          x     = solvx6(isolv6)
+          y     = solvy6(isolv6)
+          z     = solvz6(isolv6)
+          
+          f_ij  =  fc(solvrmag6(isolv6),q6cutoff(1,itype),
+     x               q6cutoff(2,itype))
+          
+          x2 = x*x
+          y2 = y*y
+          z2 = z*z
+          
+          x3 = x2*x
+          y3 = y2*y
+          z3 = z2*z
+          
+          x4 = x2*x2
+          y4 = y2*y2
+          z4 = z2*z2
+          
+          x5 = x4*x
+          y5 = y4*y
+          z5 = z4*z
+          
+          x6 = x4*x2
+          y6 = y4*y2
+          z6 = z4*z2
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-6/+6)
+c----------------------------------------------------------
+          
+          ReYlm = ypre6m6*invrc*(x6-15.0d0*x4*y2+15.0d0*x2*y4-y6)
+          ImYlm = ypre6m6*invrc*(-6.0d0*x5*y+20.0d0*x3*y3-6.0d0*x*y5)
+          
+          ReQ6bar(-6,itype) = ReQ6bar(-6,itype) + f_ij*ReYlm
+          ImQ6bar(-6,itype) = ImQ6bar(-6,itype) + f_ij*ImYlm
+
+          ReQ6bar(+6,itype) = ReQ6bar(+6,itype) + f_ij*ReYlm
+          ImQ6bar(+6,itype) = ImQ6bar(+6,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-5/+5)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre6m5*invrc*z*(-x5+10.0d0*x3*y2-5.0d0*x*y4)
+          ImYlm = -ypre6m5*invrc*z*(5.0d0*x4*y-10.0d0*x2*y3+y5)
+          
+          ReQ6bar(-5,itype) = ReQ6bar(-5,itype) + f_ij*ReYlm
+          ImQ6bar(-5,itype) = ImQ6bar(-5,itype) + f_ij*ImYlm
+
+          ReQ6bar(+5,itype) = ReQ6bar(+5,itype) - f_ij*ReYlm
+          ImQ6bar(+5,itype) = ImQ6bar(+5,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-4/+4)
+c----------------------------------------------------------
+          
+          ReYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(x4-6.0d0*x2*y2+y4)
+          ImYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(-4.0d0*x3*y+
+     x            4.0d0*x*y3)
+          
+          ReQ6bar(-4,itype) = ReQ6bar(-4,itype) + f_ij*ReYlm
+          ImQ6bar(-4,itype) = ImQ6bar(-4,itype) + f_ij*ImYlm
+
+          ReQ6bar(+4,itype) = ReQ6bar(+4,itype) + f_ij*ReYlm
+          ImQ6bar(+4,itype) = ImQ6bar(+4,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-3/+3)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x             (-x3+3.0d0*x*y2)
+          ImYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x             (3.0d0*x2*y-y3)
+          
+          ReQ6bar(-3,itype) = ReQ6bar(-3,itype) + f_ij*ReYlm
+          ImQ6bar(-3,itype) = ImQ6bar(-3,itype) + f_ij*ImYlm
+
+          ReQ6bar(+3,itype) = ReQ6bar(+3,itype) - f_ij*ReYlm
+          ImQ6bar(+3,itype) = ImQ6bar(+3,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-2/+2)
+c----------------------------------------------------------
+
+          ReYlm =  ypre6m2*invrc*(16.0d0*z4-16.0d0*z2*x2-16.0d0*z2*y2+
+     x             x4+2.0d0*x2*y2+y4)*(x2-y2)
+          ImYlm = -ypre6m2*invrc*2.0d0*(16.0d0*z4-16.0d0*z2*x2-16.0d0*
+     x             z2*y2+x4+2.0d0*x2*y2+y4)*x*y
+          
+          ReQ6bar(-2,itype) = ReQ6bar(-2,itype) + f_ij*ReYlm
+          ImQ6bar(-2,itype) = ImQ6bar(-2,itype) + f_ij*ImYlm
+
+          ReQ6bar(+2,itype) = ReQ6bar(+2,itype) + f_ij*ReYlm
+          ImQ6bar(+2,itype) = ImQ6bar(+2,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-1/+1)
+c----------------------------------------------------------
+          
+          ReYlm =  ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2+
+     x             5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*x
+          ImYlm = -ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2+
+     x             5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*y
+          
+          ReQ6bar(-1,itype) = ReQ6bar(-1,itype) + f_ij*ReYlm
+          ImQ6bar(-1,itype) = ImQ6bar(-1,itype) + f_ij*ImYlm
+
+          ReQ6bar(+1,itype) = ReQ6bar(+1,itype) - f_ij*ReYlm
+          ImQ6bar(+1,itype) = ImQ6bar(+1,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(0)
+c----------------------------------------------------------
+          
+          ReYlm =  ypre6m0*invrc*(16.0d0*z6-120.0d0*z4*x2-120.0d0*z4*
+     x             y2+90.0d0*z2*x4+180.0d0*z2*x2*y2+90.0d0*z2*y4-5.0d0
+     x             *x6-15.0d0*x4*y2-15.0d0*x2*y4-5.0d0*y6)
+          
+          ReQ6bar(0,itype) = ReQ6bar(0,itype) + f_ij*ReYlm
+          
+        end do                  ! end loop over connection list for iatm
+        
+      end if                    ! end if computing Q6
+      
+      end do                    ! end loop over iatm
+      
+c-----------------------------------------------
+c     Global summation of order parameters      
+c-----------------------------------------------
+      
+      l = 1
+      do itype = 1,nq4
+        do m = -4,4
+          buff1(l) = ReQ4bar(m,itype)
+          l = l + 1
+        end do
+        do m = -4,4
+          buff1(l) = ImQ4bar(m,itype)
+          l = l + 1
+        end do
+      end do
+      do itype = 1,nq6
+        do m = -6,6
+          buff1(l) = ReQ6bar(m,itype)
+          l = l + 1
+        end do
+        do m = -6,6
+          buff1(l) = ImQ6bar(m,itype)
+          l = l + 1
+        end do
+      end do
+      
+      if (commsize>1)   call gdsum(buff1,18*nq4+26*nq6,buff2)
+      
+      l = 1
+      do itype = 1,nq4
+        do m = -4,4
+          ReQ4bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+        do m = -4,4
+          ImQ4bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+      end do
+      do itype = 1,nq6
+        do m = -6,6
+          ReQ6bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+        do m = -6,6
+          ImQ6bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+      end do
+      
+c---------------------------------------------------
+c     Final computation of global order parameters  
+c---------------------------------------------------
+      
+      l = 1
+      do iq = 1,nq4
+        tmpvar = 0.0d0
+        do m = 1,18
+          tmpvar = tmpvar + buff1(l)**2
+          l = l + 1
+        end do
+        q4_global(iq) = 4.0d0*rpibn*sqrt(tmpvar)/
+     x                  dble(q4ninc(iq)*q4nn(iq))
+      end do
+      
+      do iq = 1,nq6
+        tmpvar = 0.0d0
+        do m = 1,26
+          tmpvar = tmpvar + buff1(l)**2
+          l = l + 1
+        end do
+        q6_global(iq) = 4.0d0*rpibtt*sqrt(tmpvar)/
+     x                  dble(q6ninc(iq)*q6nn(iq))
+      end do
+      
+c     Tidy up
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+
+      deallocate(dstlst,stat=ierr(4))
+      
+      deallocate(solvx4,stat=ierr(5))
+      deallocate(solvy4,stat=ierr(6))
+      deallocate(solvz4,stat=ierr(7))
+      deallocate(solvrmag4,stat=ierr(8))
+      deallocate(solvimag4,stat=ierr(9))
+      deallocate(solvrsq4 ,stat=ierr(10))
+      deallocate(solvlist4,stat=ierr(11)) 
+      deallocate(solvtype4,stat=ierr(12))
+      
+      deallocate(solvx6,stat=ierr(13))
+      deallocate(solvy6,stat=ierr(14))
+      deallocate(solvz6,stat=ierr(15))
+      deallocate(solvrmag6,stat=ierr(16))
+      deallocate(solvimag6,stat=ierr(17))
+      deallocate(solvrsq6 ,stat=ierr(18))
+      deallocate(solvlist6,stat=ierr(19)) 
+      deallocate(solvtype6,stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2536,0.d0) 
+      
+      deallocate(buff1,stat=ierr(1))
+      deallocate(buff2,stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2537,0.d0)
+
+      return
+      
+      end Subroutine Compute_Steinhardt
+      
+      Subroutine Compute_Steinhardt_Forces(imcon,natms,engord,virord)
+
+c---------------------------------------------------------------------
+c     
+c     Computes forces from nq4 Q4 and nq6 Q6 global order parameters.
+c
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use setup_module,   only : mxlist
+      use utility_module, only : images
+      implicit none
+      
+c     Arguments
+      
+      integer,intent(in) :: imcon,natms
+      
+      real(8),intent(inout) :: engord,virord
+      
+c     sqrt(pi/13) , sqrt(pi/9) , 1/3
+      
+      real(8),parameter :: rpibtt = 0.491590249d0
+      real(8),parameter :: rpibn  = 0.590817950d0
+      real(8),parameter :: third  = 1.0d0/3.0d0
+      
+c     Prefactors for spherical harmonics with l = 6
+      
+      real(8),parameter :: ypre6m6 =  0.48308411358006625446748d0
+      real(8),parameter :: ypre6m5 =  1.67345245810009801701312d0
+      real(8),parameter :: ypre6m4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6m3 =  0.65139048586771575166665d0
+      real(8),parameter :: ypre6m2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6m1 =  0.41197551630114082055201d0
+      real(8),parameter :: ypre6m0 =  0.06356920226762842462964d0
+      real(8),parameter :: ypre6p1 = -0.41197551630114082055201d0
+      real(8),parameter :: ypre6p2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6p3 = -0.65139048586771575166665d0
+      real(8),parameter :: ypre6p4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6p5 = -1.67345245810009801701312d0
+      real(8),parameter :: ypre6p6 =  0.48308411358006625446748d0
+      
+c     Prefactors for speherical harmonics with l = 4
+      
+      real(8),parameter :: ypre4m4 =  0.44253269244498261159038d0
+      real(8),parameter :: ypre4m3 =  1.25167147089835228968013d0
+      real(8),parameter :: ypre4m2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4m1 =  0.47308734787878004013351d0
+      real(8),parameter :: ypre4m0 =  0.10578554691520430930396d0
+      real(8),parameter :: ypre4p1 = -0.47308734787878004013351d0
+      real(8),parameter :: ypre4p2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4p3 = -1.25167147089835228968013d0
+      real(8),parameter :: ypre4p4 =  0.44253269244498261159038d0
+      
+c     Maximum no. of entries in solvation list
+      
+      integer :: maxneigh
+      
+c     Solvation shell information - Q4
+      
+      real(8),allocatable,dimension(:) :: solvx4,solvy4,solvz4
+      real(8),allocatable,dimension(:) :: solvrmag4,solvimag4,solvrsq4
+      integer,allocatable,dimension(:) :: solvlist4,solvtype4
+      integer :: isolvmax4
+      
+c     Solvation shell information - Q6
+      
+      real(8),allocatable,dimension(:) :: solvx6,solvy6,solvz6
+      real(8),allocatable,dimension(:) :: solvrmag6,solvimag6,solvrsq6
+      integer,allocatable,dimension(:) :: solvlist6,solvtype6
+      integer :: isolvmax6
+      
+c     Prefactors arising from derivative of bias potential
+
+      real(8),allocatable,dimension(:) :: q4prefactor,q6prefactor
+      
+c     Separation vectors and powers thereof
+      
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8) :: x,y,z
+      real(8) :: x2,y2,z2,x3,y3,z3
+      real(8) :: x4,y4,z4,x5,y5,z5
+      real(8) :: x6,y6,z6
+      real(8) :: invrc,invrs,invrq
+
+c     list of separation vectors
+      integer :: numdst
+      integer,allocatable,dimension(:) :: dstlst
+      
+c     Comms buffers
+      
+      real(8),allocatable,dimension(:) :: buff1,buff2
+      
+c     Temporaries
+
+      real(8) :: tmpsq,f_ij,df_ij,ReYlm,ImYlm,tmpvar,invrN
+      real(8) :: fx,fy,fz,fx2,fy2,fz2,prefactor2,fx1,fy1,fz1
+      real(8) :: strs1,strs2,strs3,strs4,strs5,strs6,strs7,strs8,strs9
+      
+      integer :: iatm1,iatm0,iatm,isite,istrd,ii,isolv4,isolv6,isolv
+      integer :: idi,idj,limit,nn,k,jatm,jsite,q4type,q6type
+      integer :: itype,jtype,l,m,iq
+      
+      maxneigh = 500         ! Max number of atoms in coordination shell
+      
+      ierr = 0               ! Error flags
+      
+c     DQ - modified 10/12/11, arrays now big enough
+c     to hold maximum number of neighbours plus
+c     maximum number of excluded atoms.
+      allocate(xdf(1:mxlist+mxexcl),stat=ierr(1))
+      allocate(ydf(1:mxlist+mxexcl),stat=ierr(2))
+      allocate(zdf(1:mxlist+mxexcl),stat=ierr(3))
+
+c     DQ - modified 10/12/11, array to hold a list of
+c     all atom entries in the above three arrays
+      allocate(dstlst(1:mxlist+mxexcl),stat=ierr(4))
+      
+      allocate(solvx4(1:maxneigh),stat=ierr(5))
+      allocate(solvy4(1:maxneigh),stat=ierr(6))
+      allocate(solvz4(1:maxneigh),stat=ierr(7))
+      allocate(solvrmag4(1:maxneigh),stat=ierr(8))
+      allocate(solvimag4(1:maxneigh),stat=ierr(9))
+      allocate(solvrsq4 (1:maxneigh),stat=ierr(10))
+      allocate(solvlist4(1:maxneigh),stat=ierr(11)) 
+      allocate(solvtype4(1:maxneigh),stat=ierr(12))
+      
+      allocate(solvx6(1:maxneigh),stat=ierr(13))
+      allocate(solvy6(1:maxneigh),stat=ierr(14))
+      allocate(solvz6(1:maxneigh),stat=ierr(15))
+      allocate(solvrmag6(1:maxneigh),stat=ierr(16))
+      allocate(solvimag6(1:maxneigh),stat=ierr(17))
+      allocate(solvrsq6 (1:maxneigh),stat=ierr(18))
+      allocate(solvlist6(1:maxneigh),stat=ierr(19)) 
+      allocate(solvtype6(1:maxneigh),stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2538,0.d0)
+      
+      allocate(buff1(1:18*nq4+26*nq6),stat=ierr(1))
+      allocate(buff2(1:18*nq4+26*nq6),stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2534,0.d0)
+      
+      allocate(q4prefactor(1:nq4),stat=ierr(1))
+      allocate(q6prefactor(1:nq6),stat=ierr(2))
+      if (any(ierr/=0)) call Mfrz_Error(2540,0.d0)
+      
+c     Compute the prefactors associated from dV_aug/d_q4
+      
+      k = 1
+      do iq = 1,nq4
+        invrN = 1.0d0/dble(q4ninc(iq)*q4nn(iq))
+        q4prefactor(iq) = -16.0d0*(rpibn**2)*(invrN**2)*dcolvar(k)/
+     x                    Q4_global(iq)
+        k = k + 1
+      end do
+      
+c     Compute the prefactors associated from dV_aug/d_q6
+      
+      do iq = 1,nq6
+        invrN = 1.0d0/dble(q6ninc(iq)*q6nn(iq))
+        q6prefactor(iq) = -16.0d0*(rpibtt**2)*(invrN**2)*dcolvar(k)/
+     x                    Q6_global(iq)
+        k = k + 1
+      end do
+
+c     write(0,'("DEBUG : q4prefactors = ",5F15.6)')q4prefactor
+      
+c     Set atoms looper over by current rank
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      strs1 = 0.0d0
+      strs2 = 0.0d0
+      strs3 = 0.0d0
+      strs4 = 0.0d0
+      strs5 = 0.0d0
+      strs6 = 0.0d0
+      strs7 = 0.0d0
+      strs8 = 0.0d0
+      strs9 = 0.0d0
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+c --------------------------------------------------------------
+c     Build a list of the required connections to iatm. This  
+c     differs depending on the version of DLPOLY we are using.
+c     First we loop over atoms in the neighbour list of iatm.
+c---------------------------------------------------------------
+        
+        ii = ii + 1
+        isite=ltype(iatm)
+        limit=lentry(ii)
+        
+        nn = 0
+        do k = 1,limit
+          
+          jatm  = list(ii,k)
+          jsite = ltype(jatm)
+          
+          if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+          
+          nn = nn + 1
+
+          dstlst(nn) = jatm
+          
+          xdf(nn)=xxx(jatm)-xxx(iatm)
+          ydf(nn)=yyy(jatm)-yyy(iatm)
+          zdf(nn)=zzz(jatm)-zzz(iatm) 
+          
+        end do
+
+c --------------------------------------------------------------
+c     Next we loop over the excluded atom list of iatm and add 
+c     and pairs needed for computation of the current OP.
+c---------------------------------------------------------------
+
+ccc   DEBUG
+ccc        write(0,'("atom ",I5," has ",I5," excluded interactions")')
+ccc     x       iatm,mtd_nexatm(iatm)
+
+        do k = 1,mtd_nexatm(ii)
+           
+           jatm  = mtd_lexatm(ii,k)
+           jsite = ltype(jatm)
+           
+ccc   DEBUG
+ccc           write(0,'("Interaction with atom ",I5," is excluded. ")')jatm
+           
+           if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+           nn = nn + 1
+           
+           dstlst(nn) = jatm
+           
+           xdf(nn)=xxx(jatm)-xxx(iatm)
+           ydf(nn)=yyy(jatm)-yyy(iatm)
+           zdf(nn)=zzz(jatm)-zzz(iatm) 
+           
+        end do
+        
+ccc   DEBUG
+ccc        write(0,*)
+        
+        numdst = nn
+        
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        nn = 0
+        isolvmax4 = 0
+        isolvmax6 = 0
+        isolv4 = 0
+        isolv6 = 0
+        do k = 1,numdst
+          jatm  = dstlst(k)
+          jsite = ltype(jatm)
+          
+          if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+          
+          nn = nn + 1
+          
+          q4type = q4site(jsite,isite)
+          q6type = q6site(jsite,isite)
+          
+          tmpsq = xdf(nn)*xdf(nn)+ydf(nn)*ydf(nn)+zdf(nn)*zdf(nn)
+          if (nq4>0) then
+            
+c     Add to solvation lists if within cut-off 
+            
+            if (  tmpsq < q4cutoff(2,q4type)**2 ) then
+              isolv4 = isolv4 + 1
+              solvlist4(isolv4) = jatm
+              solvrsq4(isolv4)  = tmpsq
+              solvrmag4(isolv4) = sqrt(tmpsq)
+              solvimag4(isolv4) = 1.0d0/solvrmag4(isolv4)
+              solvx4(isolv4)    = xdf(nn)
+              solvy4(isolv4)    = ydf(nn)
+              solvz4(isolv4)    = zdf(nn)
+              solvtype4(isolv4) = q4type
+            end if
+          end if
+          
+          if (nq6>0) then
+            
+c     Add to solvation lists if within cut-off 
+            
+            if (  tmpsq < q6cutoff(2,q6type)**2 ) then
+              isolv6 = isolv6 + 1
+              solvlist6(isolv6) = jatm
+              solvrsq6(isolv6)  = tmpsq
+              solvrmag6(isolv6) = sqrt(tmpsq)
+              solvimag6(isolv6) = 1.0d0/solvrmag6(isolv6)
+              solvx6(isolv6)    = xdf(nn)
+              solvy6(isolv6)    = ydf(nn)
+              solvz6(isolv6)    = zdf(nn)
+              solvtype6(isolv6) = q6type
+            end if
+          end if
+          isolvmax4 = isolv4
+          isolvmax6 = isolv6
+          if ((isolv4>maxneigh) .or. (isolv6>maxneigh))
+     x      call Mfrz_Error(2535,0.d0)
+          
+        end do                  ! end loop over k
+        
+c---------------------------------------------------------
+c---------------------------------------------------------
+c     Compute forces arising from  Q4 order parameters    
+c---------------------------------------------------------
+c---------------------------------------------------------
+        
+        if ( (nq4>0).and.isolvmax4>0 ) then
+          
+          do isolv4 = 1,isolvmax4
+            
+            jatm = solvlist4(isolv4)
+            itype = solvtype4(isolv4)
+            
+            invrc = solvimag4(isolv4)**6
+            invrq = solvimag4(isolv4)**8
+            invrs = solvimag4(isolv4)**4
+            
+            x     = solvx4(isolv4)
+            y     = solvy4(isolv4)
+            z     = solvz4(isolv4)
+            
+            f_ij  =  fc(solvrmag4(isolv4),q4cutoff(1,itype),
+     x                 q4cutoff(2,itype))
+            df_ij = dfc(solvrmag4(isolv4),q4cutoff(1,itype),
+     x                 q4cutoff(2,itype))
+            
+            x2 = x*x
+            y2 = y*y
+            z2 = z*z
+            
+            x3 = x2*x
+            y3 = y2*y
+            z3 = z2*z
+            
+            x4 = x2*x2
+            y4 = y2*y2
+            z4 = z2*z2
+            
+            x5 = x4*x
+            y5 = y4*y
+            z5 = z4*z
+            
+            x6 = x4*x2
+            y6 = y4*y2
+            z6 = z4*z2
+            
+            fx = 0.0d0 
+            fy = 0.0d0 
+            fz = 0.0d0
+            
+c-------------------------------------
+c     Gradient of f_ij w.r.t. r_{j}   
+c-------------------------------------
+            
+            fx2 = df_ij*x*solvimag4(isolv4)
+            fy2 = df_ij*y*solvimag4(isolv4)
+            fz2 = df_ij*z*solvimag4(isolv4)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -4  
+c--------------------------------------------------------
+
+            ReYlm = ypre4m4*invrs*(x4-6.d0*x2*y2+y4)
+            ImYlm = ypre4m4*invrs*(-4.d0*x3*y+4.d0*x*y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -4 (real part)
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-4,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{4,-4}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  invrc*ypre4m4*4.d0*x*(4.d0*x2*y2-4.d0*y4+z2*x2-
+     x             3.d0*z2*y2)
+            fy1 = -invrc*ypre4m4*4.d0*y*(4.d0*x4-4.d0*x2*y2+3.d0*
+     x             z2*x2-z2*y2)
+            fz1 = -invrc*ypre4m4*4.d0*z*(x4-6.d0*x2*y2+y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -4 (imaginary part) 
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-4,itype)
+            
+c----------------------------------------------
+c     Gradient of Im(Y_{4,-4}) w.r.t r_{j}
+c----------------------------------------------
+
+            fx1 =  invrc*ypre4m4*4.d0*y*(x4-6.d0*x2*y2-3.d0*z2*x2+
+     x             y4+z2*y2)
+            fy1 = -invrc*ypre4m4*4.d0*x*(-6.d0*x2*y2+y4+x4+z2*x2-
+     x             3.d0*z2*y2)
+            fz1 =  invrc*ypre4m4*16.d0*x*y*z*(x2-y2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -3  
+c--------------------------------------------------------
+            
+            ReYlm = ypre4m3*invrs*z*(x3-3.d0*x*y2)
+            ImYlm = ypre4m3*invrs*z*(-3.d0*x2*y+y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -3 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-3,itype)
+            
+c---------------------------------------------
+c     Gradient of Re(Y_{4,-3}) w.r.t r_{j}
+c---------------------------------------------
+            
+            fx1 = -invrc*ypre4m3*z*(x4-12.d0*x2*y2-3.d0*z2*x2+
+     x             3.d0*y4+3.d0*z2*y2)
+            fy1 = -invrc*ypre4m3*2.d0*z*x*y*(5.0d0*x2-3.d0*y2+
+     x             3.d0*z2)
+            fz1 =  invrc*ypre4m3*x*(x2-3.d0*y2)*(x2+y2-3.d0*z2)
+
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c-------------------------------------------------------
+c     Force contributions from m = -3 (imaginary part) 
+c-------------------------------------------------------
+
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-3,itype)
+            
+c--------------------------------------------------
+c     Gradient of Im(Y_{4,-3}) w.r.t r_{j}
+c--------------------------------------------------
+
+            fx1 =  invrc*ypre4m3*2.d0*z*x*y*(3.d0*x2-5.d0*y2-3.0d0*z2)
+            fy1 = -invrc*ypre4m3*z*(-12.d0*x2*y2+y4+3.d0*x4+3.d0*z2*x2
+     x            -3.d0*z2*y2)
+            fz1 = -invrc*ypre4m3*y*(3.d0*x2-y2)*(x2+y2-3.d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -2  
+c--------------------------------------------------------
+            
+            ReYlm = -ypre4m2*invrs*(x2-y2)*(-6.d0*z2+x2+y2)
+            ImYlm = ypre4m2*invrs*2.d0*(-6.d0*z2+x2+y2)*x*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -2 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-2,itype)
+            
+c---------------------------------------------
+c     Gradient of Re(Y_{4,-2}) w.r.t r_{j}
+c---------------------------------------------
+
+            fx1 = -invrc*ypre4m2*4.d0*x*(4.d0*z2*x2+y4-9.d0*z2*y2-
+     x             3.d0*z4+x2*y2)
+            fy1 =  invrc*ypre4m2*4.d0*y*(x4-9.d0*z2*x2+4.d0*z2*y2-
+     x             3.d0*z4+x2*y2)
+            fz1 =  invrc*ypre4m2*4.d0*z*(x2-y2)*(4.d0*x2+4.d0*y2-
+     x             3.d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c-------------------------------------------------------
+c     Force contributions from m = -2 (imaginary part) 
+c-------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-2,itype)
+            
+c-----------------------------------------
+c Gradient of Im(Y_{4,-2}) w.r.t r_{j}
+c-----------------------------------------
+            
+            fx1 = -invrc*ypre4m2*2.d0*y*(x4-21.d0*z2*x2+5.d0*z2*y2+
+     x             6.d0*z4-y4)
+            fy1 =  invrc*ypre4m2*2.d0*x*(-y4+21.d0*z2*y2-5.d0*z2*x2
+     x            -6.d0*z4+x4)
+            fz1 = -invrc*ypre4m2*8.d0*z*x*y*(4.d0*x2+4.d0*y2-3.d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -1
+c--------------------------------------------------------
+            
+            ReYlm = -ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*x
+            ImYlm = ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -1 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-1,itype)
+            
+c----------------------------------------
+c Gradient of Re(Y_{4,-1}) w.r.t r_{j}
+c----------------------------------------
+            
+            fx1 =  invrc*ypre4m1*z*(3.d0*x4-21.d0*z2*x2+z2*y2+4.d0*z4-
+     x             3.d0*y4)
+            fy1 =  invrc*ypre4m1*2.d0*z*x*y*(3.d0*x2+3.d0*y2-11.d0*z2)
+            fz1 = -invrc*ypre4m1*x*(-21.d0*x2*z2-21.d0*z2*y2+4.d0*z4+
+     x             3.d0*x4+6.d0*x2*y2+3.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c-------------------------------------------------------
+c     Force contributions from m = -1 (imaginary part) 
+c-------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-1,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{4,-1}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -invrc*ypre4m1*2.d0*z*x*y*(3.d0*x2+3.d0*y2-11.d0*z2)
+            fy1 =  invrc*ypre4m1*z*(-3.d0*y4+21.d0*z2*y2-z2*x2-4.d0*z4+
+     x             3.d0*x4)
+            fz1 =  invrc*ypre4m1*y*(-21.d0*z2*x2-21.d0*z2*y2+4.d0*z4+
+     x             3.d0*x4+6.d0*x2*y2+3.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real spherical harmonics for m = 0                 
+c--------------------------------------------------------
+            
+            ReYlm =  ypre4m0*invrs*(8.d0*z4-24.d0*z2*x2-24.d0*z2*y2+
+     x        3.d0*x4+6.d0*x2*y2+3.d0*y4)
+            
+c--------------------------------------------------
+c     Force contributions from m = 0 (real part)   
+c--------------------------------------------------
+            
+            prefactor2 = q4prefactor(itype)*ReQ4bar(0,itype)
+            
+c-------------------------------------------
+c     Gradient of Re(Y_{4,0}) w.r.t r_{j}
+c-------------------------------------------
+            
+            fx1 =  20.d0*ypre4m0*invrc*z2*(-4.d0*z2+3.d0*x2+3.d0*y2)*x
+            fy1 =  20.d0*ypre4m0*invrc*z2*(-4.d0*z2+3.d0*x2+3.d0*y2)*y
+            fz1 = -20.d0*ypre4m0*invrc*z*(-4.d0*z2*x2-4.d0*z2*y2+3.d0*
+     x             x4+6.d0*x2*y2+3.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c     Add into global force and stress arrays
+            
+            fxx(jatm) = fxx(jatm) + fx
+            fyy(jatm) = fyy(jatm) + fy
+            fzz(jatm) = fzz(jatm) + fz
+            fxx(iatm) = fxx(iatm) - fx
+            fyy(iatm) = fyy(iatm) - fy
+            fzz(iatm) = fzz(iatm) - fz
+            
+c     Virial
+            
+            virord = virord - (fx*x + fy*y + fz*z)
+            
+c     Stress
+            
+            strs1=strs1+x*fx
+            strs2=strs2+x*fy
+            strs3=strs3+x*fz
+            strs5=strs5+y*fy
+            strs6=strs6+y*fz
+            strs9=strs9+z*fz
+            
+          end do                ! end loop over connection list for iatm
+          
+        end if                  ! end of computing Q4
+        
+c---------------------------------------------------------
+c---------------------------------------------------------
+c     Compute forces arising from  Q6 order parameters        
+c---------------------------------------------------------
+c---------------------------------------------------------
+        
+        if ( (nq6>0).and.isolvmax6>0 ) then
+          
+          do isolv6 = 1,isolvmax6
+            
+            jatm = solvlist6(isolv6)
+            itype = solvtype6(isolv6)
+            
+            invrc = solvimag6(isolv6)**6
+            invrq = solvimag6(isolv6)**8
+            invrs = solvimag6(isolv6)**4
+            
+            x     = solvx6(isolv6)
+            y     = solvy6(isolv6)
+            z     = solvz6(isolv6)
+            
+            f_ij  =  fc(solvrmag6(isolv6),q6cutoff(1,itype),
+     x                 q6cutoff(2,itype))
+            df_ij = dfc(solvrmag6(isolv6),q6cutoff(1,itype),
+     x                 q6cutoff(2,itype))
+            
+            x2 = x*x
+            y2 = y*y
+            z2 = z*z
+            
+            x3 = x2*x
+            y3 = y2*y
+            z3 = z2*z
+            
+            x4 = x2*x2
+            y4 = y2*y2
+            z4 = z2*z2
+            
+            x5 = x4*x
+            y5 = y4*y
+            z5 = z4*z
+            
+            x6 = x4*x2
+            y6 = y4*y2
+            z6 = z4*z2
+            
+            fx = 0.0d0
+            fy = 0.0d0
+            fz = 0.0d0
+            
+c----------------------------------------
+c     Gradient of f_ij w.r.t. r_{j}  
+c----------------------------------------
+            
+            fx2 = df_ij*x*solvimag6(isolv6)
+            fy2 = df_ij*y*solvimag6(isolv6)
+            fz2 = df_ij*z*solvimag6(isolv6)
+            
+c-----------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -6     
+c-----------------------------------------------------------
+            
+            ReYlm      = ypre6m6*invrc*(x6-15.0d0*x4*y2+15.0d0*x2*y4-y6)
+            ImYlm      = ypre6m6*invrc*(-6.0d0*x5*y+20.0d0*x3*y3-6.0d0*
+     x                   x*y5)
+            
+c-----------------------------------------------------
+c     Force contributions from m = -6 (real part)     
+c-----------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-6,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-6}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  invrq*ypre6m6*6.0d0*x*(6.0d0*x4*y2-20.0d0*x2*y4+
+     x             6.0d0*y6+z2*x4-10.0d0*z2*x2*y2+5.0d0*z2*y4)
+            fy1 = -invrq*ypre6m6*6.0d0*y*(6.0d0*x6-20.0d0*x4*y2+6.0d0
+     x             *x2*y4+5.0d0*z2*x4-10.0d0*z2*x2*y2+z2*y4)
+            fz1 = -invrq*ypre6m6*6.0d0*z*(x6-15.0d0*x4*y2+15.0d0*x2*
+     x             y4-y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c----------------------------------------------------------
+c     Force contributions from m = -6 (Imaginary part)     
+c----------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-6,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-6}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -invrq*ypre6m6*6.0d0*y*(-x6+15.0d0*x4*y2-15.0d0*x2*
+     x             y4+5.0d0*z2*x4-10.0d0*z2*x2*y2+y6+z2*y4)
+            fy1 = -invrq*ypre6m6*6.0d0*x*(-15.0d0*x4*y2+15.0d0*x2*y4-
+     x             y6+x6+z2*x4-10.0d0*z2*x2*y2+5.0d0*z2*y4)
+            fz1 =  invrq*ypre6m6*12.0d0*x*y*z*(3.0d0*x4-10.0d0*x2*y2+
+     x             3.0d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c---------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -5   
+c---------------------------------------------------------
+            
+            ReYlm = -ypre6m5*invrc*z*(-x5+10.0d0*x3*y2-5.0d0*x*y4)
+            ImYlm = -ypre6m5*invrc*z*(5.0d0*x4*y-10.0d0*x2*y3+y5)
+            
+c--------------------------------------------------
+c     Force contributions from m = -5 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-5,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-5}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = ypre6m5*invrq*z*(-x6+35.0d0*x4*y2-55.d0*x2*y4+
+     x            5.0d0*z2*x4-30.0d0*z2*x2*y2+5.0d0*y6+5.0d0*z2*y4)
+            fy1 = -2.0d0*ypre6m5*invrq*x*y*z*(13.0d0*x4-30.0d0*x2
+     x        *y2+5.0d0*y4+10.0d0*z2*x2-10.0d0*z2*y2) 
+            fz1 = -ypre6m5*invrq*x*(x4-10.0d0*x2*y2+5.0d0*y4)*
+     x        (-x2-y2+5.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -5 (Imaginary part)   
+c--------------------------------------------------------
+
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-5,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-5}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -2.0d0*ypre6m5*invrq*x*y*z*(-5.0d0*x4+30.0d0*x2*y2
+     x            -13.0d0*y4+10.0d0*z2*x2-10.0d0*z2*y2)
+            fy1 = -ypre6m5*invrq*z*(-55.0d0*x4*y2+35.0d0*x2*y4-y6+
+     x             5.0d0*x6+5.0d0*z2*x4-30.0d0*z2*x2*y2+5.0d0*z2*y4)
+            fz1 =  ypre6m5*invrq*y*(5.0d0*x4-10.0d0*x2*y2+y4)*
+     x             (-x2-y2+5.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -4  
+c--------------------------------------------------------
+            
+            ReYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(x4-6.0d0*x2*y2+y4)
+            ImYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(-4.0d0*x3*y+4.0d0*
+     x              x*y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -4 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-4,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-4}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = 2.0d0*ypre6m4*invrq*x*(-8.0d0*x4*y2-13.0d0*z2*x4+
+     x            150.0d0*z2*x2*y2+8.0d0*y6-85.0d0*z2*y4+20.0d0*z4*
+     x            x2-60.0d0*z4*y2)
+            fy1 =-2.0d0*ypre6m4*invrq*y*(-8.0d0*x6+85.0d0*z2*x4+8.0d0
+     x           *x2*y4-150.0d0*z2*x2*y2+13.0d0*z2*y4+60.0d0*z4*x2-
+     x            20.0d0*z4*y2)
+            fz1 =-2.0d0*ypre6m4*invrq*z*(x4-6.0d0*x2*y2+y4)*(-13.0d0
+     x           *x2-13.0d0*y2+20.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -4 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-4,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-4}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -4.0d0*ypre6m4*invrq*y*(x6-35.0d0*z2*x4-5.0d0*x2*y4
+     x             +80.0d0*z2*x2*y2+30*z4*x2-9.0d0*z2*y4-10*z4*y2-5.0d0
+     x             *x4*y2+y6)
+            fy1 = -4.0d0*ypre6m4*invrq*x*(5.0d0*x4*y2-80.0d0*z2*x2*y2
+     x            -y6+35.0d0*z2*y4+9.0d0*z2*x4+10.0d0*z4*x2-30.0d0*z4
+     x            *y2-x6+5.0d0*x2*y4)
+            fz1 =  8.0d0*ypre6m4*invrq*z*x*y*(x2-y2)*(-13.0d0*x2-
+     x             13.0d0*y2+20.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -3  
+c--------------------------------------------------------
+
+            ReYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x               (-x3+3.0d0*x*y2)
+            ImYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x               (3.0d0*x2*y-y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -3 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-3,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-3}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  3.d0*ypre6m3*invrq*z*(x6-11.d0*x4*y2-13.d0*z2*x4-
+     x             9.d0*x2*y4+54.d0*z2*x2*y2+8.d0*z4*x2-5.d0*z2*y4-
+     x             8.d0*z4*y2+3.d0*y6)
+            fy1 = -6.d0*ypre6m3*invrq*z*x*y*(-5.d0*x4-2.d0*x2*y2+14.d0
+     x            *z2*x2+3.d0*y4-22.d0*z2*y2+8.d0*z4)
+            fz1 = -3.d0*ypre6m3*invrq*x*(x2-3.d0*y2)*(-13.d0*z2*x2-
+     x             13.d0*z2*y2+8.d0*z4+x4+2.d0*x2*y2+y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -3 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-3,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-3}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -6.d0*ypre6m3*invrq*z*x*y*(3.d0*x4-2.d0*x2*y2-22.d0
+     x            *z2*x2-5.d0*y4+14.d0*z2*y2+8.d0*z4)
+            fy1 = -3.d0*ypre6m3*invrq*z*(9.d0*x4*y2+11.d0*x2*y4-54.d0
+     x            *z2*x2*y2-y6+13.d0*z2*y4+5.d0*z2*x4+8.d0*z4*x2-8.d0
+     x            *z4*y2-3.d0*x6)
+            fz1 =  3.d0*ypre6m3*invrq*y*(3.d0*x2-y2)*(-13.d0*z2*x2-
+     x             13.d0*z2*y2+8.d0*z4+x4+2.d0*x2*y2+y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -2  
+c--------------------------------------------------------
+            
+            ReYlm =  ypre6m2*invrc*(16.0d0*z4-16.0d0*z2*x2-16.0d0*z2
+     x              *y2+x4+2.0d0*x2*y2+y4)*(x2-y2)
+            ImYlm = -ypre6m2*invrc*2.0d0*(16.0d0*z4-16.0d0*z2*x2-
+     x               16.0d0*z2*y2+x4+2.0d0*x2*y2+y4)*x*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -2 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-2,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-2}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  2.d0*ypre6m2*invrq*x*( 19.d0*z2*x4-64.d0*z4*x2-
+     x             49.d0*z2*y4+64.d0*z4*y2+2.d0*x4*y2+4.d0*x2*y4+
+     x             2.d0*y6+16.d0*z6-30.d0*z2*x2*y2)
+            fy1 = -2.d0*ypre6m2*invrq*y*(-49.d0*z2*x4+64.d0*z4*x2+
+     x             19.d0*z2*y4-64.d0*z4*y2+2.d0*x6+4.d0*x4*y2+2.d0*
+     x             x2*y4+16.d0*z6-30.d0*z2*x2*y2)
+            fz1 = -2.d0*ypre6m2*invrq*z*(x2-y2)*(-64.d0*z2*x2-64.d0
+     x            *z2*y2+16.d0*z4+19.d0*x4+38.d0*x2*y2+19.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -2 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-2,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-2}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -2.d0*ypre6m2*invrq*y*(53.d0*z2*x4+38.d0*z2*x2*
+     x             y2-128.d0*z4*x2-x6-x4*y2+x2*y4+16.d0*z6-15.d0*
+     x             z2*y4+y6)
+            fy1 = -2.d0*ypre6m2*invrq*x*(38.d0*z2*x2*y2+53.d0*z2*
+     x             y4-128.d0*z4*y2+x4*y2-x2*y4-y6+16.d0*z6-15.d0*
+     x             z2*x4+x6)
+            fz1 =  4.d0*ypre6m2*invrq*z*x*y*(-64.d0*z2*x2-64.d0*
+     x             z2*y2+16.d0*z4+19.d0*x4+38.d0*x2*y2+19.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -1  
+c--------------------------------------------------------
+            
+            ReYlm =  ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2
+     x               +5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*x
+            ImYlm = -ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2
+     x               +5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -1 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-1,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-1}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =       ypre6m1*invrq*z*(85.d0*z2*x4+70.d0*z2*x2*y2
+     x            -100.d0*z4*x2-5.d0*x6-5.d0*x4*y2+5.d0*x2*y4-12.d0
+     x            *z4*y2+8.d0*z6-15.d0*z2*y4+5.d0*y6)
+            fy1 = -2.d0*ypre6m1*invrq*z*x*y*(-50.d0*z2*x2-50.d0*z2*
+     x             y2+44.d0*z4+5.d0*x4+10.d0*x2*y2+5.d0*y4)
+            fz1 =      -ypre6m1*invrq*x*(-100.d0*z4*x2-100.d0*z4*y2+
+     x             8.d0*z6+85.d0*z2*x4+170.d0*z2*x2*y2+85.d0*z2*y4-
+     x             5.d0*x6-15.d0*x4*y2-15.d0*x2*y4-5.d0*y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -1 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-1,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-1}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  2.d0*ypre6m1*invrq*z*x*y*(-50.d0*z2*x2-50.d0*
+     x             z2*y2+44.d0*z4+5.d0*x4+10.d0*x2*y2+5.d0*y4)
+            fy1 =      -ypre6m1*invrq*z*(70.d0*z2*x2*y2+85.d0*z2
+     x            *y4-100.d0*z4*y2+5.d0*x4*y2-5.d0*x2*y4-5.d0*y6
+     x            -12.d0*z4*x2+8.d0*z6-15.d0*z2*x4+5.d0*x6)
+            fz1 =       ypre6m1*invrq*y*(-100.d0*z4*x2-100.d0*z4
+     x            *y2+8.d0*z6+85.d0*z2*x4+170.d0*z2*x2*y2+85.d0*
+     x             z2*y4-5.d0*x6-15.d0*x4*y2-15.d0*x2*y4-5.d0*y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real spherical harmonics for m = 0                 
+c--------------------------------------------------------
+            
+            ReYlm = ypre6m0*invrc*(16.0d0*z6-120.0d0*z4*x2-120.0d0
+     x             *z4*y2+90.0d0*z2*x4+180.0d0*z2*x2*y2+90.0d0*z2*y4
+     x             -5.0d0*x6-15.0d0*x4*y2-15.0d0*x2*y4-5.0d0*y6)
+            
+c--------------------------------------------------
+c     Force contributions from m = 0 (real part)       
+c--------------------------------------------------
+            
+            prefactor2 = q6prefactor(itype)*ReQ6bar(0,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,0}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -42.d0*ypre6m0*invrq*z2*(8.d0*z4-20.d0*z2*x2-20.d0
+     x            *z2*y2+5.d0*x4+10.d0*x2*y2+5.d0*y4)*x
+            fy1 = -42.d0*ypre6m0*invrq*z2*(8.d0*z4-20.d0*z2*x2-20.d0
+     x            *z2*y2+5.d0*x4+10.d0*x2*y2+5.d0*y4)*y
+            fz1 =  42.d0*ypre6m0*invrq*z*(8.d0*z4*x2+8.d0*z4*y2-20.d0
+     x            *z2*x4-40.d0*z2*x2*y2-20.d0*z2*y4+5.d0*x6+15.d0*x4*
+     x             y2+15.d0*x2*y4+5.d0*y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+            
+c     Add into global force and stress arrays
+            
+            fxx(jatm) = fxx(jatm) + fx
+            fyy(jatm) = fyy(jatm) + fy
+            fzz(jatm) = fzz(jatm) + fz
+            fxx(iatm) = fxx(iatm) - fx
+            fyy(iatm) = fyy(iatm) - fy
+            fzz(iatm) = fzz(iatm) - fz
+            
+c     Virial
+            
+            virord = virord - (fx*x + fy*y + fz*z)
+            
+c     Stress
+            
+            strs1=strs1+x*fx
+            strs2=strs2+x*fy
+            strs3=strs3+x*fz
+            strs5=strs5+y*fy
+            strs6=strs6+y*fz
+            strs9=strs9+z*fz
+            
+          end do                ! end loop over connection list for iatm
+          
+        end if                  ! end of computing Q6
+        
+        
+      end do                    ! end loop over iatm
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs1
+      stress(2)=stress(2)+strs2
+      stress(3)=stress(3)+strs3
+      stress(4)=stress(4)+strs2
+      stress(5)=stress(5)+strs5
+      stress(6)=stress(6)+strs6
+      stress(7)=stress(7)+strs3
+      stress(8)=stress(8)+strs6
+      stress(9)=stress(9)+strs9
+      
+c     tidy up
+      
+      ierr = 0
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+
+      deallocate(dstlst,stat=ierr(4))
+      
+      deallocate(solvx4,stat=ierr(5))
+      deallocate(solvy4,stat=ierr(6))
+      deallocate(solvz4,stat=ierr(7))
+      deallocate(solvrmag4,stat=ierr(8))
+      deallocate(solvimag4,stat=ierr(9))
+      deallocate(solvrsq4 ,stat=ierr(10))
+      deallocate(solvlist4,stat=ierr(11)) 
+      deallocate(solvtype4,stat=ierr(12))
+      
+      deallocate(solvx6,stat=ierr(13))
+      deallocate(solvy6,stat=ierr(14))
+      deallocate(solvz6,stat=ierr(15))
+      deallocate(solvrmag6,stat=ierr(16))
+      deallocate(solvimag6,stat=ierr(17))
+      deallocate(solvrsq6 ,stat=ierr(18))
+      deallocate(solvlist6,stat=ierr(19)) 
+      deallocate(solvtype6,stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2536,0.d0)
+      
+      deallocate(buff1,stat=ierr(1))
+      deallocate(buff2,stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2537,0.d0)
+      
+      deallocate(q4prefactor,stat=ierr(1))
+      deallocate(q6prefactor,stat=ierr(2))
+      if (any(ierr/=0)) call Mfrz_Error(2540,0.d0)
+      
+      return
+      
+      end Subroutine Compute_Steinhardt_Forces
+      
+      Subroutine Compute_Tet_Nlist(imcon,natms)
+      
+c---------------------------------------------------------------------
+c
+c     The existing neighbour list is not known by all nodes and 
+c     therefore we compute a new one from scratch rather than trying
+c     to merge a full neighbour list across all MPI tasks or restore
+c     symmetry.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use utility_module, only : images
+      
+      implicit none
+      integer,intent(in) :: imcon,natms
+      integer :: nlast,megatm
+      
+      integer :: iatm0,iatm1,istrd,iatm,jatm,nn,itype,jtype
+      integer :: ninclude,ifi,ii,ztype,nnn,k
+      real(8) :: rsq,rangesq
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      ninclude = maxval(zetaninc)
+      
+      nlast  = natms
+      megatm = natms
+      
+      nnn = int(dble(ninclude*nlast*1.2)/dble(megatm))
+      
+      allocate(xdf(1:nnn),stat=ierr(1))
+      allocate(ydf(1:nnn),stat=ierr(2))
+      allocate(zdf(1:nnn),stat=ierr(3))
+      if (any(ierr/=0)) call Mfrz_Error(2541,0.d0) 
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+        itype = ltype(iatm)
+        
+        ztype = zetasite(itype)
+        if ( ztype==0 ) cycle
+        
+        nn  = 0                 ! Number of images to compute
+        ii  = ii + 1            ! index for this list
+        ifi = 0                 ! index for entries in this list
+        
+        if (ii>mxninc) call Mfrz_Error(2542,0.d0)
+        
+        do jatm = 1,nlast
+          
+          jtype = ltype(jatm)
+          
+          if ( itype/=jtype ) cycle
+          if ( iatm == jatm ) cycle
+          
+          nn = nn + 1
+          xdf(nn) = xxx(iatm) - xxx(jatm) ! separation vector
+          ydf(nn) = yyy(iatm) - yyy(jatm)
+          zdf(nn) = zzz(iatm) - zzz(jatm)
+          
+        end do
+        
+        if ( nn > nnn ) call Mfrz_Error(2543,0.d0)
+        
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        nn = 0
+        do jatm = 1,nlast
+          
+          jtype = ltype(jatm)
+          
+          if ( itype/=jtype ) cycle
+          if ( iatm == jatm ) cycle
+          
+          nn = nn + 1
+          rsq = xdf(nn)*xdf(nn) + ydf(nn)*ydf(nn) + zdf(nn)*zdf(nn)
+          
+          rangesq =  zetacutoff(2,ztype)**2
+          
+          if ( rsq < rangesq ) then
+            
+            ifi = ifi + 1
+            flist(ifi,ii) = jatm      
+            
+          end if
+          
+        end do
+        if ( ifi > mxflist ) call Mfrz_Error(2544,0.d0)
+        nflist(ii) = ifi
+        
+      end do                    ! end loop over iatm
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+      if (any(ierr/=0))call Mfrz_Error(2545,0.d0) 
+      
+      return
+      
+      end Subroutine Compute_Tet_Nlist
+      
+      Subroutine Compute_Tetrahedral(imcon,natms)
+      
+c---------------------------------------------------------------------
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use utility_module, only : images
+      
+      implicit none
+      integer,intent(in) :: imcon,natms
+      
+      integer :: iatm0,iatm1,istrd,iatm,jatm,nn,itype,jtype
+      integer :: ninclude,ifi,ii,k,ztype,mm,katm,ktype,it
+      real(8) :: f_ij,f_ik,r_ij,r_ik,x,y,z,dot
+      real(8),parameter :: third=1.0d0/3.0d0
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8),allocatable,dimension(:) :: buff1
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      allocate(xdf(1:mxflist),stat=ierr(1))
+      allocate(ydf(1:mxflist),stat=ierr(2))
+      allocate(zdf(1:mxflist),stat=ierr(3))
+      allocate(buff1(1:ntet),stat=ierr(4))
+      if (any(ierr/=0)) call Mfrz_Error(2546,0.d0)
+      
+      zeta_global(:) = 0.0d0
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+        itype = ltype(iatm)
+        
+c     no tetrahedral contributions from this atom type?
+        
+        ztype = zetasite(itype)
+        if ( ztype == 0 ) cycle
+        
+        ii  = ii + 1            ! index for this list
+        
+        do k = 1,nflist(ii)
+          
+          jatm = flist(k,ii)
+          
+          xdf(k) = xxx(jatm) - xxx(iatm) ! separation vector
+          ydf(k) = yyy(jatm) - yyy(iatm)
+          zdf(k) = zzz(jatm) - zzz(iatm)
+          
+        end do
+        
+        nn = nflist(ii)
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        do k = 1,nflist(ii)
+          
+          jatm = flist(k,ii)
+          
+          r_ij = sqrt(xdf(k)*xdf(k) + ydf(k)*ydf(k) + zdf(k)*zdf(k))
+          f_ij = fc(r_ij,zetacutoff(1,ztype),zetacutoff(2,ztype)) 
+          
+          x = xdf(k) ; y = ydf(k) ; z = zdf(k)
+          
+c     loop over all other entries katm
+          
+          do mm = k+1,nflist(ii)
+            
+c     katm also in solvation shell of iatm
+            
+            katm  = flist(mm,ii)
+            
+            r_ik = sqrt(xdf(mm)*xdf(mm) + ydf(mm)*ydf(mm) + 
+     x        zdf(mm)*zdf(mm))
+            f_ik = fc(r_ik,zetacutoff(1,ztype),zetacutoff(2,ztype)) 
+            
+c     The node holding the central atom keeps the contrib
+            
+            dot = (x*xdf(mm) + y*ydf(mm) + z*zdf(mm)) / (r_ij*r_ik) +
+     x            third
+            zeta_global(ztype) = zeta_global(ztype) + f_ij*f_ik*dot*dot
+          end do       
+        end do
+        
+      end do
+      
+      call gdsum(zeta_global(1),ntet,buff1(1:ntet))
+      
+      do it = 1,ntet
+        zeta_global(it) = 1.0d0 - zeta_global(it)/dble(zetaninc(it)*
+     x    zetann(it))
+      end do
+      
+      deallocate(xdf ,stat=ierr(1))
+      deallocate(ydf ,stat=ierr(2))
+      deallocate(zdf ,stat=ierr(3))
+      deallocate(buff1,stat=ierr(4))
+      if (any(ierr/=0)) call Mfrz_Error(2547,0.d0)
+      
+      return
+      
+      end Subroutine Compute_Tetrahedral
+      
+      Subroutine Compute_Tetrahedral_Forces(imcon,natms,engord,virord)
+      
+c---------------------------------------------------------------------
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use utility_module, only : images
+      
+      implicit none
+      integer,intent(in) :: imcon,natms
+      real(8),intent(inout) :: engord,virord
+      
+      integer :: iatm,jatm,katm,iatm0,iatm1,istrd,nn
+      integer :: ii,k,m,itet,itype,jtype,ztype,it
+      
+      real(8),parameter :: third = 1.0d0/3.0d0
+      real(8) :: strs1,strs2,strs3,strs5,strs6,strs9
+      real(8) :: xj,yj,zj,xk,yk,zk,tmpvar,tmpvar2,dot
+      real(8) :: r_ij,r_ik,f_ij,f_ik,df_ij,df_ik
+      real(8) :: invrij,invrik,ctheta
+      real(8) :: fxj,fyj,fzj,fxk,fyk,fzk
+      
+      real(8),dimension(3) :: rij_hat,rik_hat
+      
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8),allocatable,dimension(:) :: tetprefactor
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      allocate(xdf(1:mxflist),stat=ierr(1))
+      allocate(ydf(1:mxflist),stat=ierr(2))
+      allocate(zdf(1:mxflist),stat=ierr(3))
+      allocate(tetprefactor(1:ntet),stat=ierr(4))
+      if (any(ierr/=0)) call Mfrz_Error(2548,0.d0)
+      
+c     Compute the prefactor
+      
+      k = nq4+nq6+1
+      do it = 1,ntet
+        tetprefactor = dcolvar(k)/dble(zetaninc(it)*zetann(it))
+        k = k + 1
+      end do
+      
+c     zero contribution to the stress tensor
+      
+      strs1=0.0d0
+      strs2=0.0d0
+      strs3=0.0d0
+      strs5=0.0d0
+      strs6=0.0d0
+      strs9=0.0d0
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+        itype = ltype(iatm)
+        
+c     no tetrahedral contributions from this atom type?
+        
+        ztype = zetasite(itype)
+        if ( ztype == 0 ) cycle
+        
+        ii  = ii + 1            ! index for this list
+        
+        do k = 1,nflist(ii)
+          
+          jatm = flist(k,ii)
+          
+          xdf(k) = xxx(jatm) - xxx(iatm) ! separation vector
+          ydf(k) = yyy(jatm) - yyy(iatm)
+          zdf(k) = zzz(jatm) - zzz(iatm)
+          
+        end do
+        
+        nn = nflist(ii)
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        do k = 1,nflist(ii)
+          
+          jatm  = flist(k,ii)
+          
+          r_ij  = sqrt(xdf(k)*xdf(k) + ydf(k)*ydf(k) + zdf(k)*zdf(k))
+          f_ij  =  fc(r_ij,zetacutoff(1,ztype),zetacutoff(2,ztype))
+          df_ij = dfc(r_ij,zetacutoff(1,ztype),zetacutoff(2,ztype))
+          
+          xj = xdf(k) ; yj = ydf(k) ; zj = zdf(k)
+          
+          invrij = 1.0d0/r_ij
+          
+          rij_hat(1) = xj*invrij
+          rij_hat(2) = yj*invrij
+          rij_hat(3) = zj*invrij
+          
+          do m = k + 1,nflist(ii)
+            
+            r_ik = sqrt(xdf(m)*xdf(m) + ydf(m)*ydf(m) + zdf(m)*zdf(m))
+            f_ik  =  fc(r_ik,zetacutoff(1,ztype),zetacutoff(2,ztype))
+            df_ik = dfc(r_ik,zetacutoff(1,ztype),zetacutoff(2,ztype))
+            
+            xk = xdf(m) ; yk = ydf(m) ; zk = zdf(m)
+            
+            invrik = 1.0d0/r_ik
+            
+            rik_hat(1) = xk*invrik
+            rik_hat(2) = yk*invrik
+            rik_hat(3) = zk*invrik
+            
+            ctheta = dot_product(rij_hat,rik_hat)
+            dot    = ctheta + third
+            
+            tmpvar  = 2.0d0*dot*f_ij*f_ik*tetprefactor(ztype)*invrij
+            tmpvar2 = tetprefactor(ztype)*dot*dot*df_ij*f_ik
+            
+c     force between atom i and atom j due to second term 
+c     i.e. ( f_ij*f_ik*dot*dot )
+            
+            fxj =  tmpvar*(rik_hat(1) - rij_hat(1)*ctheta) + 
+     x             tmpvar2*rij_hat(1)
+            fyj =  tmpvar*(rik_hat(2) - rij_hat(2)*ctheta) + 
+     x             tmpvar2*rij_hat(2)
+            fzj =  tmpvar*(rik_hat(3) - rij_hat(3)*ctheta) + 
+     x             tmpvar2*rij_hat(3)
+            
+            tmpvar  = 2.0d0*dot*f_ij*f_ik*tetprefactor(ztype)*invrik
+            tmpvar2 = tetprefactor(ztype)*dot*dot*df_ik*f_ij
+            
+c     force between atom i and atom k due to second term 
+c     i.e ( f_ij*f_ik*dot*dot )
+            
+            fxk =  tmpvar*(rij_hat(1) - rik_hat(1)*ctheta) + 
+     x             tmpvar2*rik_hat(1)
+            fyk =  tmpvar*(rij_hat(2) - rik_hat(2)*ctheta) + 
+     x             tmpvar2*rik_hat(2)
+            fzk =  tmpvar*(rij_hat(3) - rik_hat(3)*ctheta) + 
+     x             tmpvar2*rik_hat(3)        
+            
+c     Add in to forces, virial and stress tensor 
+            
+            katm = flist(m,ii)
+            
+            fxx(iatm) = fxx(iatm) + fxj + fxk
+            fyy(iatm) = fyy(iatm) + fyj + fyk
+            fzz(iatm) = fzz(iatm) + fzj + fzk
+            
+            fxx(jatm) = fxx(jatm) - fxj
+            fyy(jatm) = fyy(jatm) - fyj
+            fzz(jatm) = fzz(jatm) - fzj
+            
+            fxx(katm) = fxx(katm) - fxk
+            fyy(katm) = fyy(katm) - fyk
+            fzz(katm) = fzz(katm) - fzk         
+            
+            virord = virord - fxj*xj - fyj*yj - fzj*zj
+            virord = virord - fxk*xk - fyk*yk - fzk*zk
+            
+            strs1 = strs1 + xk*fxk + xj*fxj
+            strs2 = strs2 + xk*fyk + xj*fyj
+            strs3 = strs3 + xk*fzk + xj*fzj
+            strs5 = strs5 + yk*fyk + yj*fyj
+            strs6 = strs6 + yk*fzk + yj*fzj
+            strs9 = strs9 + zk*fzk + zj*fzj
+            
+          end do
+        end do
+      end do
+      
+c     Complete stress tensor
+      
+      stress(1)=stress(1)+strs1
+      stress(2)=stress(2)+strs2
+      stress(3)=stress(3)+strs3
+      stress(4)=stress(4)+strs2
+      stress(5)=stress(5)+strs5
+      stress(6)=stress(6)+strs6
+      stress(7)=stress(7)+strs3
+      stress(8)=stress(8)+strs6
+      stress(9)=stress(9)+strs9
+      
+      
+c     Tidy up
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+      if (any(ierr/=0)) call Mfrz_Error(2547,0.d0)
+      
+      return
+      
+      end Subroutine Compute_Tetrahedral_Forces
+      
+      Subroutine Mfrz_Error(kode,arg)
+      
+c---------------------------------------------------------------------
+c     
+c     Author W. Smith Daresbury Laboratory January 2011
+c     Adapted from D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use setup_module,   only : nrite,nhist,nread,nconf,nstats,
+     x                           nrest,nfield,ntable,nevnt
+      
+      implicit none
+      integer,intent(in) :: kode
+      real(8),intent(in) :: arg
+      
+      if(onroot)then
+        
+        if(kode.eq.2500)then
+          
+          write(nrite,"(
+     x      'Error in number of collective variables - '//
+     x      'ncolvar too small?'
+     x      )")
+          
+        elseif(kode.eq.2501)then
+          
+          write(nrite,"(
+     x      'Wang-Landau style recursion not yet implemented'//
+     x      'for ncolvar > 1'             
+     x      )")
+          
+        elseif(kode.eq.2502)then
+          
+          write(nrite,"('Unrecognised Gaussian height scheme')")
+          
+        elseif(kode.eq.2503)then
+          
+          write(nrite,"('Error maxhis exceeded in metadynamics')")
+          
+        elseif(kode.eq.2504)then
+          
+          write(nrite,"(
+     x      'Error allocating comms buffer in compute_bias_potential'
+     x      )")
+          
+        elseif(kode.eq.2505)then
+          
+          write(nrite,"('Error allocating driven array')")
+          
+        elseif(kode.eq.2506)then
+          
+          write(nrite,"('Could not open METACONTROL')")
+          
+        elseif(kode.eq.2508)then
+          
+          write(nrite,"('Comms error in metadynamics setup')")
+          
+        elseif(kode.eq.2509)then
+          
+          write(nrite,"(
+     x      'Cannot bias local and global PE in same run'
+     x      )")
+          
+        elseif(kode.eq.2510)then
+          
+          write(nrite,"('Error allocating local force arrays')")
+          
+        elseif(kode.eq.2511)then
+          
+          write(nrite,"(
+     x      'Error allocating collective variables arrays'
+     x      )")
+          
+        elseif(kode.eq.2512)then
+          
+          write(nrite,"('Error allocating Wang-Landau bins')")
+          
+        elseif(kode.eq.2515)then
+          
+          write(nrite,"(
+     x      'Error allocating Steinhardt parameter arrays'       
+     x      )")
+          
+        elseif(kode.eq.2516)then
+          
+          write(nrite,"('Could not open STEINHARDT')")
+          
+        elseif(kode.eq.2517)then
+          
+          write(nrite,"('Error allocating q4site')")
+          
+        elseif(kode.eq.2518)then
+          
+          write(nrite,"('Error allocating q6site')")
+          
+        elseif(kode.eq.2519)then
+          
+          write(nrite,"('Error deallocating buff')")
+          
+        elseif(kode.eq.2521)then
+          
+          write(nrite,"('Error reading line ',i5,' of STEINHARDT'
+     x      )")nint(arg)
+          
+        elseif(kode.eq.2522)then
+          
+          write(nrite,"(
+     x      'Error allocating Steinhardt parameter arrays'       
+     x      )")
+          
+        elseif(kode.eq.2523)then
+          
+          write(nrite,"('Could not open ZETA')")
+          
+        elseif(kode.eq.2524)then
+          
+          write(nrite,"('Error allocating zetasite')")
+          
+        elseif(kode.eq.2525)then
+          
+          write(nrite,"('Error allocating full neighbour list')")
+          
+        elseif(kode.eq.2527)then
+          
+          write(nrite,"(
+     x      'Number of collective variables incorrect  for specified'//
+     x      'order parameters'
+     x      )")
+          
+        elseif(kode.eq.2529)then
+          
+          write(nrite,"('Error reading line ',i5,' of ZETA'
+     x      )")nint(arg)
+          
+        elseif(kode.eq.2531)then
+          
+          write(nrite,"('Comms error on reading METADYNAMICS')")
+          
+        elseif(kode.eq.2532)then
+          
+          write(nrite,"('Error in fc function - out of range')")
+          write(nrite,"('Value of r was ',1p,e14.6)")arg
+          
+        elseif(kode.eq.2533)then
+          
+          write(nrite,"(
+     x      'Error allocating solvation arrays for metadynamics'
+     x      )")
+          
+        elseif(kode.eq.2534)then
+          
+          write(nrite,"('Error allocating comms buffer arrays')")
+          
+        elseif(kode.eq.2535)then
+          
+          write(nrite,"('Solvation list overrun')")
+          
+        elseif(kode.eq.2536)then
+          
+          write(nrite,"(
+     x      'Error deallocating solvation arrays for metadynamics'
+     x      )")
+          
+        elseif(kode.eq.2537)then
+          
+          write(nrite,"('Error deallocating comms buffer arrays')")
+          
+        elseif(kode.eq.2538)then
+          
+          write(nrite,"(
+     x      'Error allocating solvation arrays for metadynamics'
+     x      )")
+          
+        elseif(kode.eq.2540)then
+          
+          write(nrite,"('Error allocating force prefactor arrays')")
+          
+        elseif(kode.eq.2541)then
+          
+          write(nrite,"(
+     x      'Memory allocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2542)then
+          
+          write(nrite,"(
+     x      'Error in metafreeze_module.f90 mxninc too small'
+     x      )")
+          
+        elseif(kode.eq.2543)then
+          
+          write(nrite,"('nnn too small in compute_tet_nlist')")
+          
+        elseif(kode.eq.2544)then
+          
+          write(nrite,"('mxflist too small in metafreeze_module')")
+          
+        elseif(kode.eq.2545)then
+          
+          write(nrite,"(
+     x      'Memory deallocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2546)then
+          
+          write(nrite,"(
+     x      'Memory allocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2547)then
+          
+          write(nrite,"(
+     x      'Memory deallocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2548)then
+          
+          write(nrite,"(
+     x      'Memory allocation error in compute_tet_nlist'
+     x      )")
+          
+        endif
+        
+c     close all i/o channels
+        
+        close (nrite)
+        close (nhist)
+        close (nread)
+        close (nconf)
+        close (nstats)
+        close (nrest)
+        close (nfield)
+        close (ntable)
+        close (nevnt)
+        close (stn)
+        close (zta)
+        close (mtd)
+        
+      endif
+      
+c     shut down communications
+      
+      call gsync()
+      call exitcomms()
+        
+      end Subroutine Mfrz_Error
+      
+      end module metafreeze_module
+      
diff -urN dl_class_1.9.orig/srcmod/metal_module.f dl_class_1.9/srcmod/metal_module.f
--- dl_class_1.9.orig/srcmod/metal_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/metal_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1669 @@
+      module metal_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining metal potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use pair_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use utility_module
+      
+      implicit none
+
+      logical lmetab
+      integer, allocatable :: ltpmet(:),lstmet(:)
+      real(8), allocatable :: prmmet(:,:),vmet(:,:,:),dmet(:,:,:)
+      real(8), allocatable :: rho(:),elrcm(:),vlrcm(:),fmet(:,:,:)
+
+      save lmetab,ltpmet,lstmet,prmmet,vmet,dmet,fmet,rho,elrcm,vlrcm
+
+      contains
+      
+      subroutine alloc_met_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=8
+      integer i,fail,idnode
+
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (ltpmet(mxmet),stat=fail(1))
+      allocate (lstmet(mxmet),stat=fail(2))
+      allocate (prmmet(mxmet,mxpmet),stat=fail(3))
+      allocate (vmet(mxgrid,mxmet,2),stat=fail(4))
+      allocate (dmet(mxgrid,mxmet,2),stat=fail(5))
+      allocate (rho(mxatms),stat=fail(6))
+      allocate (elrcm(0:mxsmet),stat=fail(7))
+      allocate (vlrcm(0:mxsmet),stat=fail(8))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1280)
+      enddo
+
+      end subroutine alloc_met_arrays
+
+      subroutine define_metals
+     x   (safe,lunits,lmols,idnode,ntpmet,ntpatm,rmet,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining metal potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom1,atom2
+      character*1 message(80)
+      integer idnode,ntpmet,ntpatm,idum,imet,j
+      integer keypot,numpar,katm1,katm2,keymet,ntab,i,fail,itpmet
+      integer jtpatm
+      real(8) rmet,engunit
+
+      real(8), allocatable :: parpot(:)
+      allocate (parpot(mxpmet),stat=fail)
+
+      ntpmet=intstr(record,lenrec,idum)
+      
+      lmetab=.false.
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified metal ',
+     x    'potentials',i10)") ntpmet
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ',3x,
+     x    ' key',30x,'parameters'/,/)")
+        
+      endif      
+
+      if(ntpmet.ge.mxmet) call error(idnode,71)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do imet=1,mxmet
+        lstmet(imet)=0
+        ltpmet(imet)=0
+      enddo
+      
+      do itpmet=1,ntpmet
+        
+        do i=1,mxpmet
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        
+        if(keyword(1:4).eq.'stch') then
+          keypot=1
+          numpar=5
+        else if(keyword(1:4).eq.'fnsc') then
+          keypot=2
+          numpar=7
+        else if(keyword(1:4).eq.'gupt') then
+          keypot=3
+          numpar=5
+        elseif(keyword(1:4).eq.'eam ') then
+          keypot=999
+          lmetab=.true.
+          numpar=0
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,461)
+        endif
+        
+        if(.not.lmetab)then
+          
+          parpot(1)=dblstr(record,lenrec,idum)
+          parpot(2)=dblstr(record,lenrec,idum)
+          parpot(3)=dblstr(record,lenrec,idum)
+          parpot(4)=dblstr(record,lenrec,idum)
+          parpot(5)=dblstr(record,lenrec,idum)
+          parpot(6)=dblstr(record,lenrec,idum)
+          parpot(7)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(16x,2a8,2x,a4,3x,1p,9e13.5)") 
+     x      atom1,atom2,keyword(1:4),(parpot(j),j=1,numpar)
+        
+        endif
+        
+        katm1=0
+        katm2=0
+        
+        do jtpatm=1,ntpatm
+
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          
+        enddo
+        
+        if(katm1.eq.0.or.katm2.eq.0) then
+          call  error(idnode,463)
+        endif
+        
+        keymet=loc2(katm1,katm2)
+        
+c     convert energies to internal unit
+
+        if(keymet.ge.mxmet) call error(idnode,465)
+        
+        parpot(1)=parpot(1)*engunit
+
+        if(keypot.eq.2)then
+
+          parpot(2)=parpot(2)*engunit
+          parpot(3)=parpot(3)*engunit
+          parpot(5)=parpot(5)*engunit
+
+        endif
+
+        if(keypot.eq.3)then
+          parpot(4)=parpot(4)*engunit
+        endif
+
+        if(lstmet(keymet).ne.0) call error(idnode,141)
+        lstmet(keymet)=itpmet
+        ltpmet(itpmet)=keypot
+        if(itpmet.gt.1)then
+          if(keypot.ne.ltpmet(itpmet-1))call error(idnode,72)
+        endif        
+        
+        if(.not.lmetab)then
+          
+          do i=1,numpar
+            prmmet(itpmet,i)=parpot(i)
+          enddo
+          
+        endif
+        
+      enddo
+
+c     check for unspecified atom-atom potentials
+      
+      ntab=(ntpatm*(ntpatm+1))/2
+      
+      if(ntpmet.lt.ntab) then
+        
+        call warning(idnode,110,0.d0,0.d0,0.d0)
+
+        do i=1,ntab
+          if(lstmet(i).eq.0) lstmet(i)=ntpmet+1
+        enddo
+
+c     set zero potential for undefined interactions
+        
+        do i=1,mxmet
+          
+          vmet(1,i,1)=0.d0
+          vmet(1,i,2)=0.d0
+          dmet(1,i,1)=0.d0
+          dmet(1,i,2)=0.d0
+          
+        enddo
+        
+      endif
+
+c     generate metal force arrays
+      
+      call metgen(idnode,ntpatm,rmet)
+      
+      if(lmetab)
+     x  call mettab(ntpatm,idnode,rmet,engunit)
+      
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_metals
+
+      subroutine metdens
+     x  (idnode,imcon,mxnode,natms,engmet,virden)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating local density in metals
+c     using the verlet neighbour list and sutton-chen potentials
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - w. smith june 1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer idnode,imcon,mxnode,natms,i,j,k,ii,k0,l
+      real(8) engmet,engtmp,virden,rhosqr,rrr,ppp,fk0,fk1,fk2,t1,t2
+      
+      safe=.true.
+      
+c     initialise energy accumulator
+      
+      engmet=0.d0
+      virden=0.d0
+
+c     initialise density array
+      
+      do i=1,natms
+        rho(i)=0.d0
+      enddo
+
+c     calculate local atomic density
+      
+      ii=0
+      
+c     outer loop over atoms
+
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        do k=1,lentry(ii)
+          
+          j=list(ii,k)
+          ilist(k)=j
+          xdf(k)=xxx(i)-xxx(j)
+          ydf(k)=yyy(i)-yyy(j)
+          zdf(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     square of distances
+        
+        do k=1,lentry(ii)
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+        enddo
+        
+        if(lmetab)then
+          
+c     calculate EAM density contributions
+          
+          call eamden(safe,i,lentry(ii))
+          
+        else
+          
+c     calculate FS density contributions
+          
+          call fsden(safe,i,lentry(ii))
+          
+        endif
+        
+      enddo
+
+c     global sum of local atomic densities
+      
+      if(mxnode.gt.1)call gdsum(rho,natms,buffer)
+      
+c     calculate embedding energy
+
+      if(lmetab)then
+        
+c     density terms for eam potentials
+        
+        do i=1,natms
+          
+          if(rho(i).gt.0.d0)then
+            
+            k0=ltype(i)
+            rrr=rho(i)-fmet(2,k0,1)
+            l=min(nint(rrr/fmet(4,k0,1)),int(fmet(1,k0,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              
+            else
+              
+              ppp=(rrr/fmet(4,k0,1))-dble(l)
+              
+c     calculate embedding energy using 3-point interpolation
+              
+              fk0=fmet(l-1,k0,1)
+              fk1=fmet(l,k0,1)
+              fk2=fmet(l+1,k0,1)
+              
+              t1=fk1+(fk1-fk0)*ppp
+              t2=fk1+(fk2-fk1)*ppp
+              if(ppp.lt.0.d0)then
+                engtmp=-(t1+0.5d0*(t2-t1)*(ppp+1.d0))
+              else
+                engtmp=-(t2+0.5d0*(t2-t1)*(ppp-1.d0))
+              endif
+
+              engmet=engmet+engtmp
+
+c     calculate derivative of embedding function wrt density using 3-point
+c     interpolation - store result in rho array
+              
+              fk0=fmet(l-1,k0,2)
+              fk1=fmet(l,k0,2)
+              fk2=fmet(l+1,k0,2)
+              
+              t1=fk1+(fk1-fk0)*ppp
+              t2=fk1+(fk2-fk1)*ppp
+              if(ppp.lt.0.d0)then
+                rho(i)=(t1+0.5d0*(t2-t1)*(ppp+1.d0))
+              else
+                rho(i)=(t2+0.5d0*(t2-t1)*(ppp-1.d0))
+              endif
+            
+            endif
+            
+          endif
+          
+        enddo
+        
+      else
+        
+c     analytical square root of density dependence
+        
+        do i=1,natms
+          
+          if(rho(i).gt.0.d0)then
+            
+            rhosqr=sqrt(rho(i)+elrcm(ltype(i)))
+            engmet=engmet+rhosqr
+            rho(i)=0.5d0/rhosqr
+            virden=virden+vlrcm(ltype(i))/rhosqr
+
+          endif
+          
+        enddo
+        
+      endif
+      
+      engmet=-engmet/dble(mxnode)
+      virden=virden/dble(mxnode)
+      
+c     check interpolation is safe
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,142)
+      
+      return
+      end subroutine metdens
+
+      subroutine fsden(safe,iatm,ik)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating local atomic density
+c     for FS type metal potentials
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith  june  1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer iatm,jatm,ik,m,k0,l
+      real(8) rdr,ai,aj,ab,rsq,rrr,ppp,t1,t2
+      real(8) vk0,vk1,vk2,density
+      
+c     start of primary loop for density
+
+      ai=dble(ltype(iatm))
+
+      do m=1,ik
+
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+
+        aj=dble(ltype(jatm))
+        if(ai.gt.aj) then
+          ab=ai*(ai-1.d0)*0.5d0+aj+0.5d0
+        else
+          ab=aj*(aj-1.d0)*0.5d0+ai+0.5d0
+        endif
+
+        k0=lstmet(int(ab))
+        
+        if((ltpmet(k0).ge.1).and.(abs(dmet(1,k0,1)).gt.0.d0))then
+
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+
+c     apply cutoff condition
+      
+          if(rsq.le.dmet(3,k0,1)**2)then
+            
+c     interpolation parameters
+
+            rdr=1.d0/dmet(4,k0,1)
+            rrr=sqrt(rsq)-dmet(2,k0,1)
+            l=min(nint(rrr*rdr),int(dmet(1,k0,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              
+            else
+              
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate density using 3-point interpolation
+              
+              vk0=dmet(l-1,k0,1)
+              vk1=dmet(l,k0,1)
+              vk2=dmet(l+1,k0,1)
+              
+              t1=vk1+ppp*(vk1-vk0)
+              t2=vk1+ppp*(vk2-vk1)
+              if(ppp.lt.0.d0)then
+                density=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                density=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+              if(ai.gt.aj)then
+                
+                rho(iatm)=rho(iatm)+density*dmet(1,k0,2)
+                rho(jatm)=rho(jatm)+density*dmet(2,k0,2)
+                
+              else
+                
+                rho(iatm)=rho(iatm)+density*dmet(2,k0,2)
+                rho(jatm)=rho(jatm)+density*dmet(1,k0,2)
+                
+              endif
+              
+            endif
+            
+          endif
+        
+        endif
+        
+      enddo
+      
+      return
+      end subroutine fsden
+
+      subroutine eamden(safe,iatm,ik)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating local atomic density
+c     for EAM type metal potentials
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith  june  1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+            
+      implicit none
+      logical safe
+      integer iatm,jatm,ik,m,l,ktyp1,ktyp2
+      real(8) rdr,rsq,rrr,ppp,t1,t2
+      real(8) vk0,vk1,vk2,density
+      
+c     start of primary loop for density
+
+      ktyp1=ltype(iatm)
+
+      do m=1,ik
+
+c     first metal atom density
+        
+        jatm=ilist(m)
+        ktyp2=ltype(jatm)
+        
+        if(abs(dmet(1,ktyp2,1)).gt.0.d0)then
+          
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+
+          if(rsq.le.dmet(3,ktyp2,1)**2)then
+            
+c     interpolation parameters
+            
+            rdr=1.d0/dmet(4,ktyp2,1)
+            rrr=sqrt(rsq)-dmet(2,ktyp2,1)
+            l=min(nint(rrr*rdr),int(dmet(1,ktyp2,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              
+            else
+              
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate density using 3-point interpolation
+              
+              vk0=dmet(l-1,ktyp2,1)
+              vk1=dmet(l,ktyp2,1)
+              vk2=dmet(l+1,ktyp2,1)
+              
+              t1=vk1+ppp*(vk1-vk0)
+              t2=vk1+ppp*(vk2-vk1)
+              if(ppp.lt.0.d0)then
+                density=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                density=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+              rho(iatm)=rho(iatm)+density
+              if(ktyp1.eq.ktyp2)rho(jatm)=rho(jatm)+density
+              
+            endif
+            
+          endif
+
+        endif
+        
+c     second  metal atom density
+            
+        if(ktyp1.ne.ktyp2)then
+          
+          if(abs(dmet(1,ktyp1,1)).gt.0.d0)then
+            
+c     apply truncation of potential
+            
+            if(rsq.le.dmet(3,ktyp1,1)**2)then
+              
+c     interpolation parameters
+              
+              rdr=1.d0/dmet(4,ktyp1,1)
+              rrr=sqrt(rsq)-dmet(2,ktyp1,1)
+              l=min(nint(rrr*rdr),int(dmet(1,ktyp1,1))-1)
+              if(l.lt.1)then
+                
+                safe=.false.
+                
+              else
+                
+                ppp=rrr*rdr-dble(l)
+                
+c     calculate density using 3-point interpolation
+                
+                vk0=dmet(l-1,ktyp1,1)
+                vk1=dmet(l,ktyp1,1)
+                vk2=dmet(l+1,ktyp1,1)
+                
+                t1=vk1+(vk1-vk0)*ppp
+                t2=vk1+(vk2-vk1)*ppp
+                if(ppp.lt.0.d0)then
+                  density=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                else
+                  density=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                endif
+                
+                rho(jatm)=rho(jatm)+density
+                
+              endif
+              
+            endif
+            
+          endif
+        
+        endif
+        
+      enddo
+      
+      return
+      end subroutine eamden
+
+      subroutine metfrc(safe,iatm,ik,engmet,virmet)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating metal forces
+c     for EAM and FS potentials using a verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith   june 1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer iatm,jatm,ik,m,k0,l,ld,ktyp1,ktyp2
+      real(8) engmet,virmet,strs
+      real(8) rdr,rsq,rrr,ppp,vk0,vk1,vk2,t1,t2,gk0,gk1,gk2
+      real(8) gamma,gamma1,gamma2,gamma3,fx,fy,fz,fi
+      dimension fi(3),strs(6)
+
+CDIR$ CACHE_ALIGN fi
+
+c     initialise potential energy and virial
+      
+      engmet=0.d0
+      virmet=0.d0
+
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+
+c     store forces for iatm 
+      
+      fi(1)=fxx(iatm)
+      fi(2)=fyy(iatm)
+      fi(3)=fzz(iatm)
+      ktyp1=ltype(iatm)
+      
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+        ktyp2=ltype(jatm)
+        k0=lstmet(loc2(ktyp1,ktyp2))
+        
+        if((ltpmet(k0).gt.0).and.(abs(vmet(1,k0,1)).gt.0.d0))then
+
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+
+          if(rsq.le.vmet(3,k0,1)**2)then
+            
+c     interpolation parameters
+      
+            rdr=1.d0/vmet(4,k0,1)
+            rrr=sqrt(rsq)-vmet(2,k0,1)
+            l=min(nint(rrr*rdr),int(vmet(1,k0,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              gamma1=0.d0
+              
+            else
+              
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate interaction energy using 3-point interpolation
+              
+              vk0=vmet(l-1,k0,1)
+              vk1=vmet(l,k0,1)
+              vk2=vmet(l+1,k0,1)
+              
+              t1=vk1+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*ppp
+              if(ppp.lt.0.d0)then
+                engmet=engmet+t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                engmet=engmet+t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+c     calculate pair forces using 3-point interpolation
+              
+              gk0=vmet(l-1,k0,2)
+              gk1=vmet(l,k0,2)
+              gk2=vmet(l+1,k0,2)
+              
+              t1=gk1+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*ppp
+              if(ppp.lt.0.d0)then
+                gamma1=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                gamma1=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+            endif
+            
+c     calculate embedding forces using 3-point interpolation
+
+            if(lmetab)then
+              
+              if(rsq.le.dmet(3,ktyp2,1)**2)then
+                
+                rdr=1.d0/dmet(4,ktyp2,1)
+                rrr=sqrt(rsq)-dmet(2,ktyp2,1)
+                ld=min(nint(rrr*rdr),int(dmet(1,ktyp2,1))-1)
+                if(ld.lt.1)then
+                  
+                  safe=.false.
+                  gamma2=0.d0
+                  
+                else
+                  
+                  ppp=rrr*rdr-dble(ld)
+                  
+                  gk0=dmet(ld-1,ktyp2,2)
+                  gk1=dmet(ld,ktyp2,2)
+                  gk2=dmet(ld+1,ktyp2,2)
+                  
+                  t1=gk1+(gk1-gk0)*ppp
+                  t2=gk1+(gk2-gk1)*ppp
+                  if(ppp.lt.0.d0)then
+                    gamma2=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                  else
+                    gamma2=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                  endif
+                
+                endif
+                
+              else
+                
+                gamma2=0.d0
+                
+              endif
+              
+              if(ktyp1.eq.ktyp2)then
+                
+                gamma3=gamma2
+                
+              elseif(rsq.le.dmet(3,ktyp1,1)**2)then
+                
+                rdr=1.d0/dmet(4,ktyp1,1)
+                rrr=sqrt(rsq)-dmet(2,ktyp1,1)
+                ld=min(nint(rrr*rdr),int(dmet(1,ktyp1,1))-1)
+                if(ld.lt.1)then
+                  
+                  safe=.false.
+                  gamma3=0.d0
+                  
+                else
+                  
+                  ppp=rrr*rdr-dble(ld)
+                  gk0=dmet(ld-1,ktyp1,2)
+                  gk1=dmet(ld,ktyp1,2)
+                  gk2=dmet(ld+1,ktyp1,2)
+                  
+                  t1=gk1+(gk1-gk0)*ppp
+                  t2=gk1+(gk2-gk1)*ppp
+                  if(ppp.lt.0.d0)then
+                    gamma3=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                  else
+                    gamma3=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                  endif
+                  
+                endif
+                
+              else
+                
+                gamma3=0.d0
+                
+              endif
+                
+              gamma=(gamma1+(gamma2*rho(iatm)+gamma3*rho(jatm)))/rsq
+              
+            else
+              
+              if(safe.and.rsq.le.dmet(3,k0,1)**2)then
+                
+                gk0=dmet(l-1,k0,2)
+                gk1=dmet(l,k0,2)
+                gk2=dmet(l+1,k0,2)
+                
+                t1=gk1+(gk1-gk0)*ppp
+                t2=gk1+(gk2-gk1)*ppp
+                if(ppp.lt.0.d0)then
+                  gamma2=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                else
+                  gamma2=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                endif
+                
+              else
+                
+                gamma2=0.d0
+                
+              endif
+              
+              if(ktyp1.gt.ktyp2)then
+                
+                gamma=(gamma1-gamma2*(rho(iatm)*dmet(1,k0,2)+
+     x            rho(jatm)*dmet(2,k0,2)))/rsq
+                
+              else
+                
+                gamma=(gamma1-gamma2*(rho(iatm)*dmet(2,k0,2)+
+     x            rho(jatm)*dmet(1,k0,2)))/rsq
+                
+              endif
+              
+            endif
+            
+c     calculate forces
+            
+            fx=gamma*xdf(m)
+            fy=gamma*ydf(m)
+            fz=gamma*zdf(m)
+            
+            fi(1)=fi(1)+fx
+            fi(2)=fi(2)+fy
+            fi(3)=fi(3)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+c     calculate virial
+            
+            virmet=virmet-gamma*rsq
+            
+          endif
+          
+        endif
+        
+      enddo
+
+c     load temps back to fxx(iatm) etc
+      
+      fxx(iatm)=fi(1)
+      fyy(iatm)=fi(2)
+      fzz(iatm)=fi(3)
+
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      return
+      end subroutine metfrc
+
+      subroutine metgen(idnode,ntpatm,rmet)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating potential energy and 
+c     force arrays for metal potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith june 1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,kmet,mmet,katm1,katm2,ntpatm,imet,nmet
+      integer idnode,nnn,mmm
+      real(8) dlrpot,rmet,rrr,eps,sig,cc0,cc1,cc2,ccc
+      real(8) ddd,bet,cut1,cut2,aaa,rr0,ppp,qqq
+      
+c     define grid resolution for potential arrays
+      
+      dlrpot=rmet/dble(mxgrid-1)
+
+c     construct arrays for metal potentials
+      
+      kmet=0
+      do katm1=1,ntpatm
+
+        do katm2=1,katm1
+
+          kmet=kmet+1
+          imet=lstmet(kmet)
+
+          if(ltpmet(imet).gt.0)then
+
+c     store array specification parameters
+            
+            vmet(1,imet,1)=dble(mxgrid)
+            vmet(2,imet,1)=0.d0
+            vmet(3,imet,1)=rmet
+            vmet(4,imet,1)=dlrpot
+            
+            do i=1,4
+              
+              vmet(i,imet,2)=vmet(i,imet,1)
+              dmet(i,imet,1)=vmet(i,imet,1)
+              dmet(i,imet,2)=0.d0
+              
+            enddo
+
+            if(ltpmet(imet).eq.1)then
+              
+c     sutton-chen potentials
+
+              eps=prmmet(imet,1)
+              sig=prmmet(imet,2)
+              nnn=nint(prmmet(imet,3))
+              mmm=nint(prmmet(imet,4))
+
+              do i=5,mxgrid
+                
+                rrr=dble(i)*dlrpot
+                vmet(i,imet,1)=eps*(sig/rrr)**nnn
+                vmet(i,imet,2)=dble(nnn)*eps*(sig/rrr)**nnn
+                dmet(i,imet,1)=(sig/rrr)**mmm
+                dmet(i,imet,2)=dble(mmm)*(sig/rrr)**mmm
+
+              enddo
+              
+              if(katm1.eq.katm2)then
+
+                dmet(1,imet,2)=(prmmet(imet,1)*prmmet(imet,5))**2
+                dmet(2,imet,2)=(prmmet(imet,1)*prmmet(imet,5))**2
+
+              else
+
+                nmet=lstmet((katm1*(katm1+1))/2)
+                mmet=lstmet((katm2*(katm2+1))/2)
+                dmet(1,imet,2)=(prmmet(nmet,1)*prmmet(nmet,5))**2
+                dmet(2,imet,2)=(prmmet(mmet,1)*prmmet(mmet,5))**2
+
+              endif
+
+            else if(ltpmet(imet).eq.2)then
+              
+c     finnis sinclair potentials
+
+              cc0=prmmet(imet,1)
+              cc1=prmmet(imet,2)
+              cc2=prmmet(imet,3)
+              ccc=prmmet(imet,4)
+              ddd=prmmet(imet,6)
+              bet=prmmet(imet,7)
+              cut1=ccc+4.d0*dlrpot
+              cut2=ddd+4.d0*dlrpot
+
+              do i=5,mxgrid
+                
+                rrr=dble(i)*dlrpot
+                vmet(i,imet,1)=0.d0
+                vmet(i,imet,2)=0.d0
+                dmet(i,imet,1)=0.d0
+                dmet(i,imet,2)=0.d0
+                
+                if(rrr.le.cut1)then
+                  
+                  vmet(i,imet,1)=(cc0+cc1*rrr+cc2*rrr*rrr)*(rrr-ccc)**2
+                  vmet(i,imet,2)=-rrr*(2.d0*(cc0+cc1*rrr+cc2*rrr*rrr)*
+     x              (rrr-ccc)+(cc1+2.d0*cc2*rrr)*(rrr-ccc)**2)
+                  
+                endif
+
+                if(rrr.le.cut2)then
+                  
+                  dmet(i,imet,1)=(rrr-ddd)**2+bet*(rrr-ddd)**3/ddd
+                  dmet(i,imet,2)=-rrr*(2.d0*(rrr-ddd)+
+     x              3.d0*bet*(rrr-ddd)**2/ddd)
+                  
+                endif
+                
+              enddo
+              
+              if(katm1.eq.katm2)then
+
+                dmet(1,imet,2)=prmmet(imet,5)**2
+                dmet(2,imet,2)=prmmet(imet,5)**2
+
+              else
+
+                nmet=lstmet((katm1*(katm1+1))/2)
+                mmet=lstmet((katm2*(katm2+1))/2)
+                dmet(1,imet,2)=prmmet(nmet,5)**2
+                dmet(2,imet,2)=prmmet(mmet,5)**2
+
+              endif
+              
+            else if(ltpmet(imet).eq.3)then
+              
+c     gupta potentials
+
+              aaa=prmmet(imet,1)
+              rr0=prmmet(imet,2)
+              ppp=prmmet(imet,3)
+              qqq=prmmet(imet,5)
+
+              do i=5,mxgrid
+                
+                rrr=dble(i)*dlrpot
+                vmet(i,imet,1)=aaa*exp(-ppp*(rrr-rr0)/rr0)
+                vmet(i,imet,2)=vmet(i,imet,1)*rrr*ppp/rr0
+                dmet(i,imet,1)=exp(-2.d0*qqq*(rrr-rr0)/rr0)
+                dmet(i,imet,2)=2.d0*dmet(i,imet,1)*rrr*qqq/rr0
+                
+              enddo
+              
+              dmet(1,imet,2)=prmmet(imet,4)**2
+              dmet(2,imet,2)=prmmet(imet,4)**2
+
+            else if(.not.lmetab)then
+              
+              call error(idnode,151)
+              
+            endif
+
+          endif
+          
+        enddo
+
+      enddo
+      
+      return
+      end subroutine metgen
+
+      subroutine lrcmetal
+     x  (idnode,imcon,natms,ntpatm,engunit,rmet,volm)
+      
+c*************************************************************************
+c     
+c     DL_POLY subroutine to evaluate long-range corrections to
+c     pressure and energy in a periodic metal system.
+c     
+c     copyright daresbury laboratory
+c     author -  w. smith   june 1995
+c     amended - w. smith  march 2006
+c     
+c***************************************************************************
+      
+      implicit none
+      
+      logical newjob
+      integer idnode,imcon,natms,ntpatm,i,ka,j
+      integer kmet,k0,k1,k2
+      real(8) engunit,rmet,volm,twopi,forpi,eps,sig,nnn,mmm,ccc
+      real(8) elrcm0,elrcm1,elrcm2,vlrcm0,vlrcm1,vlrcm2,aaa,rr0,ppp
+      real(8) zet,qqq,eee
+
+      save newjob
+      data newjob/.true./
+      
+      twopi=2.0d0*pi
+      forpi=4.0d0*pi
+
+c     initalise counter arrays
+      
+      do i=1,mxsmet
+        numtyp(i)=0
+      enddo
+
+c     evaluate species populations in system
+      
+      do i=1,natms
+        
+        ka=ltype(i)
+        numtyp(ka)=numtyp(ka)+1
+        
+      enddo
+      
+c     number densities
+      
+      do i=1,ntpatm
+        dens(i)=dble(numtyp(i))/volm
+      enddo
+      
+c     long range corrections to density, energy and pressure
+      
+      do i=0,mxsmet
+
+        elrcm(i)=0.d0
+        vlrcm(i)=0.d0
+
+      enddo
+      
+      if(imcon.ne.0.and.imcon.ne.6) then
+        
+        kmet=0
+        do i=1,ntpatm
+          
+          do j=1,i
+            
+            elrcm0=0.d0
+            elrcm1=0.d0
+            elrcm2=0.d0
+            vlrcm0=0.d0
+            vlrcm1=0.d0
+            vlrcm2=0.d0
+            
+            kmet=kmet+1
+            k0=lstmet(kmet)
+            
+            if(ltpmet(k0).eq.1) then
+              
+c     sutton-chen potentials
+              
+              eps=prmmet(k0,1)
+              sig=prmmet(k0,2)
+              nnn=prmmet(k0,3)
+              mmm=prmmet(k0,4)
+              ccc=prmmet(k0,5)
+
+              elrcm0=eps*sig**3*(sig/rmet)**(nnn-3.d0)/(nnn-3.d0)
+              vlrcm0=eps*nnn*sig**3*(sig/rmet)**(nnn-3.d0)/(nnn-3.d0)
+              if(i.ne.j) then
+                elrcm0=elrcm0*2.d0
+                vlrcm0=vlrcm0*2.d0
+              endif
+              elrcm(0)=elrcm(0)+twopi*volm*dens(i)*dens(j)*elrcm0
+              vlrcm(0)=vlrcm(0)-twopi*volm*dens(i)*dens(j)*vlrcm0
+              
+              if(i.eq.j) then
+                
+                elrcm1=sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (eps*ccc)**2
+                elrcm(i)=elrcm(i)+forpi*dens(i)*elrcm1
+                
+                vlrcm1=mmm*sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (eps*ccc)**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(i)*vlrcm1
+
+              else
+
+                k1=lstmet((i*(i+1))/2)
+                k2=lstmet((j*(j+1))/2)
+                elrcm1=sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k1,1)*prmmet(k1,5))**2
+                elrcm2=sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k2,1)*prmmet(k2,5))**2
+                elrcm(i)=elrcm(i)+forpi*dens(j)*elrcm1
+                elrcm(j)=elrcm(j)+forpi*dens(i)*elrcm2
+
+                vlrcm1=mmm*sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k1,1)*prmmet(k1,5))**2
+                vlrcm2=mmm*sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k2,1)*prmmet(k2,5))**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(j)*vlrcm1
+                vlrcm(j)=vlrcm(j)+twopi*dens(i)*vlrcm2
+
+              endif
+              
+            else if(ltpmet(k0).eq.3) then
+              
+c     gupta potentials
+              
+              aaa=prmmet(k0,1)
+              rr0=prmmet(k0,2)
+              ppp=prmmet(k0,3)
+              zet=prmmet(k0,4)
+              qqq=prmmet(k0,5)
+              eee=exp(-ppp*(rmet-rr0)/rr0)
+
+              elrcm0=aaa*(rr0/ppp)*(rmet**2+2.d0*rmet*(rr0/ppp)+
+     x          2.d0*(rr0/ppp)**2)*eee
+              vlrcm0=aaa*(rmet**3+3.d0*rmet**2*(rr0/ppp)+
+     x          6.d0*rmet*(rr0/ppp)**2+6.d0*(rr0/rmet)**3)*eee
+              if(i.ne.j) then
+                elrcm0=elrcm0*2.d0
+                vlrcm0=vlrcm0*2.d0
+              endif
+              elrcm(0)=elrcm(0)+twopi*volm*dens(i)*dens(j)*elrcm0
+              vlrcm(0)=vlrcm(0)-twopi*volm*dens(i)*dens(j)*vlrcm0
+              
+              eee=exp(-2.d0*qqq*(rmet-rr0)/rr0)
+
+              if(i.eq.j) then
+                
+                elrcm1=(rmet**2+2.d0*rmet*(0.5d0*rr0/qqq)+
+     x            2.d0*(0.5d0*rr0/qqq)**2)*(0.5d0*rr0/qqq)*eee*zet**2
+                elrcm(i)=elrcm(i)+forpi*dens(i)*elrcm1
+
+                vlrcm1=(rmet**3+3.d0*rmet**2*(0.5d0*rr0/qqq)+
+     x            6.d0*rmet*(0.5d0*rr0/qqq)**2+(0.5d0*rr0/qqq)**3)*
+     x            eee*zet**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(i)*vlrcm1
+
+              else
+
+                elrcm1=(rmet**2+2.d0*rmet*(0.5d0*rr0/qqq)+
+     x            2.d0*(0.5d0*rr0/qqq)**2)*(0.5d0*rr0/qqq)*eee*
+     x            zet**2
+                elrcm2=(rmet**2+2.d0*rmet*(0.5d0*rr0/qqq)+
+     x            2.d0*(0.5d0*rr0/qqq)**2)*(0.5d0*rr0/qqq)*eee*
+     x            zet**2
+                elrcm(i)=elrcm(i)+forpi*dens(j)*elrcm1
+                elrcm(j)=elrcm(j)+forpi*dens(i)*elrcm2
+
+                vlrcm1=(rmet**3+3.d0*rmet**2*(0.5d0*rr0/qqq)+
+     x            6.d0*rmet*(0.5d0*rr0/qqq)**2+(0.5d0*rr0/qqq)**3)*
+     x            eee*zet**2
+                vlrcm2=(rmet**3+3.d0*rmet**2*(0.5d0*rr0/qqq)+
+     x            6.d0*rmet*(0.5d0*rr0/qqq)**2+(0.5d0*rr0/qqq)**3)*
+     x            eee*zet**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(j)*vlrcm1
+                vlrcm(j)=vlrcm(j)+twopi*dens(i)*vlrcm2
+
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+      if(newjob)then
+        
+        newjob=.false.
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,"(/,/,
+     x      'long range corrections for metal potentials',/)")
+          write(nrite,
+     x      "('short range energy and virial corrections:',
+     x      1p,2e15.6,/)")
+     x    elrcm(0)/engunit,vlrcm(0)/engunit
+          write(nrite,
+     x      "('density dependent energy and virial corrections',/)")
+          
+          do i=1,ntpatm
+            
+            kmet=lstmet((i*(i+1))/2)
+            if(lstmet(kmet).gt.0)then
+              
+              write(nrite,"(25x,a8,1p,2e15.6)")unqatm(i),
+     x          elrcm(i)/engunit,vlrcm(i)/engunit
+              
+            endif
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine lrcmetal
+
+      subroutine mettab(ntpatm,idnode,rmet,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading potential energy and 
+c     force arrays for EAM metal forces only
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical safe
+      character*8 atom1,atom2,type
+      integer idnode,ntpatm,idum,fail
+      integer imet,katm1,katm2,jtpatm,i,j,k,ktype
+      integer numpot,numpts,ipot
+      real(8) rmet,engunit,start,finish
+      data fail/0/
+      
+c     allocate embedding array
+      
+      allocate(fmet(mxgrid,mxmet,2),stat=fail)
+      if(fail.ne.0)call error(idnode,36)
+      
+c     define zero function for undefined interactions
+      
+      do i=1,mxmet
+        
+        fmet(1,i,1)=0.d0
+        fmet(1,i,2)=0.d0
+        
+      enddo
+      
+      if(idnode.eq.0)open (ntable,file='TABEAM')
+      
+c     skip header record
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_eamtable_read(idnode,ntable)
+      
+c     read number of potential functions in file
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_eamtable_read(idnode,ntable)
+      numpot=intstr(record,lenrec,idum)
+      
+      do ipot=1,numpot
+        
+c     read data type, atom labels, number of points, start and end
+        
+        call getrec(safe,idnode,ntable)
+        if(.not.safe)call abort_eamtable_read(idnode,ntable)
+        
+c     indentify data type
+        
+        ktype=1
+        if(findstring('dens',record,idum).or.
+     x    findstring('DENS',record,idum))ktype=2
+        if(findstring('embe',record,idum).or.
+     x    findstring('EMBE',record,idum))ktype=3
+        call getword(type,record,8,lenrec)
+        
+c     identify atom types
+        
+        call getword(atom1,record,8,lenrec)
+        if(ktype.eq.1)then
+          call getword(atom2,record,8,lenrec)
+        else
+          atom2=atom1
+        endif
+        
+c     data specifiers
+        
+        numpts=intstr(record,lenrec,idum)
+        start=dblstr(record,lenrec,idum)
+        finish=dblstr(record,lenrec,idum)
+        
+c     check atom indentities
+        
+        katm1=0
+        katm2=0
+        
+        do jtpatm=1,ntpatm
+          
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          
+        enddo
+        
+        if(katm1.eq.0.or.katm2.eq.0) then
+          if(idnode.eq.0) 
+     x      write(nrite,'(a)') ' **** '//atom1//' *** '//atom2//' ****'
+          call  error(idnode,81)
+        endif
+        
+c     check array dimensions
+        
+        if(mxbuff.lt.numpts+4)then
+          
+          if(idnode.eq.0)
+     x      write(nrite,*) 'mxbuff must be >=',numpts+4,' in mettab'
+          call error(idnode,28)
+          
+        endif
+        
+c     store working parameters (start shifted for DL_POLY interpolation)
+        
+        buffer(1)=dble(numpts+4)
+        buffer(4)=(finish-start)/dble(numpts-1)
+        buffer(2)=start-5.d0*buffer(4)
+        buffer(3)=finish
+        if(idnode.eq.0)
+     x    write(nrite,"(16x,2a8,2x,a4,3x,1p,4e13.5)") 
+     x    atom1,atom2,type,dble(numpts),start,finish,buffer(4)
+
+c     read potential arrays
+        
+        k=4
+        do j=1,(numpts+3)/4
+          
+          call getrec(safe,idnode,ntable)
+          if(.not.safe)call abort_eamtable_read(idnode,ntable)
+          buffer(k+1)=dblstr(record,lenrec,idum)
+          buffer(k+2)=dblstr(record,lenrec,idum)
+          buffer(k+3)=dblstr(record,lenrec,idum)
+          buffer(k+4)=dblstr(record,lenrec,idum)
+          k=k+4
+          
+        enddo
+        
+c     copy data to internal arrays
+        
+        if(ktype.eq.1)then
+          
+c     check range against specified cutoff
+        
+          if(rmet.lt.finish)call error(idnode,26)
+        
+c     identify potential
+
+          imet=lstmet(loc2(katm1,katm2))
+        
+c     pair potential terms
+          
+          vmet(1,imet,1)=buffer(1)
+          vmet(2,imet,1)=buffer(2)
+          vmet(3,imet,1)=buffer(3)
+          vmet(4,imet,1)=buffer(4)
+          
+          do i=5,mxgrid
+            
+            if(i-4.gt.numpts)then
+              vmet(i,imet,1)=0.d0
+            else
+              vmet(i,imet,1)=buffer(i)*engunit
+              buffer(i)=buffer(i)*engunit
+            endif
+            
+          enddo
+          
+c     calculate derivative of pair potential function
+          
+          call metal_deriv(imet,vmet,buffer)
+          
+c     adapt derivatives for use in interpolation
+      
+          do i=5,numpts+4
+            vmet(i,imet,2)=-(dble(i)*buffer(4)+buffer(2))*
+     x        vmet(i,imet,2)
+          enddo          
+          
+        else if(ktype.eq.2)then
+          
+c     check range against specified cutoff
+        
+          if(rmet.lt.finish)call error(idnode,26)
+        
+c     density  terms
+          
+          dmet(1,katm1,1)=buffer(1)
+          dmet(2,katm1,1)=buffer(2)
+          dmet(3,katm1,1)=buffer(3)
+          dmet(4,katm1,1)=buffer(4)
+          
+          do i=5,mxgrid
+            
+            if(i-4.gt.numpts)then
+              dmet(i,katm1,1)=0.d0
+            else
+              dmet(i,katm1,1)=buffer(i)
+            endif
+            
+          enddo
+          
+c     calculate derivative of density function
+          
+          call metal_deriv(katm1,dmet,buffer)
+          
+c     adapt derivatives for use in interpolation
+      
+          dmet(1,katm1,2)=0.d0
+          dmet(2,katm1,2)=0.d0
+          dmet(3,katm1,2)=0.d0
+          dmet(4,katm1,2)=0.d0
+          do i=5,numpts+4
+            dmet(i,katm1,2)=-(dble(i)*buffer(4)+buffer(2))*
+     x        dmet(i,katm1,2)
+          enddo          
+          
+        else if(ktype.eq.3)then
+          
+c     embedding function arrays
+          
+          fmet(1,katm1,1)=buffer(1)
+          fmet(2,katm1,1)=buffer(2)
+          fmet(3,katm1,1)=buffer(3)
+          fmet(4,katm1,1)=buffer(4)
+          
+          do i=5,mxgrid
+            
+            if(i-4.gt.numpts)then
+              fmet(i,katm1,1)=0.d0
+            else
+              fmet(i,katm1,1)=buffer(i)*engunit
+              buffer(i)=buffer(i)*engunit
+            endif
+            
+          enddo
+          
+c     calculate derivative of embedding function
+          
+          call metal_deriv(katm1,fmet,buffer)
+          
+        endif
+        
+      enddo
+
+      if(idnode.eq.0)close (ntable)
+      
+      if(idnode.eq.0)write(nrite,'(/,/,1x,a)')
+     x  'potential tables read from TABEAM file'
+      
+      return
+      end subroutine mettab
+
+      subroutine metal_deriv(ityp,vvv,buffer)
+
+c**********************************************************************
+c
+c     calculate numerical derivatives of tabulated EAM metal potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith march 2006
+c
+c**********************************************************************
+      
+      implicit none
+      
+      integer ityp,i,npt
+      real(8) vvv,buffer,delmet,aa0,aa1,aa2,aa3,aa4,d1y,d2y,d3y,d4y
+      real(8) f0,f1,f2,f3,f4
+
+      dimension vvv(mxgrid,mxmet,2),buffer(mxbuff)
+      
+c     interpolation parameters
+      
+      vvv(1,ityp,2)=buffer(1)
+      vvv(2,ityp,2)=buffer(2)
+      vvv(3,ityp,2)=buffer(3)
+      vvv(4,ityp,2)=buffer(4)
+      
+c     construct interpolation table
+
+      delmet=buffer(4)
+      npt=nint(buffer(1))-2
+      do i=7,npt
+
+        aa0=buffer(i)
+        f0=buffer(i-2)/aa0
+        f1=buffer(i-1)/aa0
+        f2=1.d0
+        f3=buffer(i+1)/aa0
+        f4=buffer(i+2)/aa0
+        
+c     calculate numerical differences for 5-point interpolation
+        
+        d1y=(f1-f0)
+        d2y=(f2-f1)-(f1-f0)
+        d3y=(f3-f0)+3.d0*(f1-f2)
+        d4y=(f4-f3)+3.d0*(f2-f3)+3.d0*(f2-f1)+(f0-f1)
+        
+c     calculate polynomial coefficients
+        
+        aa0=aa0/delmet
+        aa4=d4y/24.d0
+        aa3=(d3y+12.d0*aa4)/6.d0
+        aa2=(d2y+6.d0*aa3-14.d0*aa4)/2.d0
+        aa1=d1y+3.d0*aa2-7.d0*aa3+15.d0*aa4
+        
+c     calculate derivatives
+        
+        vvv(i,ityp,2)=aa1*aa0
+        
+c     derivatives at extremes of range
+        
+        if(i.eq.7)then
+          
+          vvv(5,ityp,2)=(aa1-4.d0*aa2+12.d0*aa3-32.d0*aa4)*aa0
+          vvv(6,ityp,2)=(aa1-2.d0*aa2+3.d0*aa3-4.d0*aa4)*aa0
+          
+        else if(i.eq.npt)then
+          
+          vvv(npt+1,ityp,2)=(aa1+2.d0*aa2+3.d0*aa3+4.d0*aa4)*aa0
+          vvv(npt+2,ityp,2)=(aa1+4.d0*aa2+12.d0*aa3+32.d0*aa4)*aa0
+          
+        endif
+          
+      enddo
+      
+c     set derivatives to zero beyond end point of function
+      
+      do i=npt+3,mxgrid
+        vvv(i,ityp,2)=0.d0
+      enddo
+      
+      return
+      end subroutine metal_deriv
+
+      subroutine abort_eamtable_read(idnode,ntable)
+
+c***********************************************************************
+c     
+c     dl_poly error exit subroutine for reading TABEAM file
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith   mar 2006
+c     
+c***********************************************************************
+
+      implicit none
+      integer idnode,ntable
+
+      if(idnode.eq.0)close (ntable)
+      
+      call error(idnode,29)
+      
+      end subroutine abort_eamtable_read
+      
+      end module metal_module
diff -urN dl_class_1.9.orig/srcmod/neu_coul_module.f dl_class_1.9/srcmod/neu_coul_module.f
--- dl_class_1.9.orig/srcmod/neu_coul_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/neu_coul_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,731 @@
+      module neu_coul_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining neutral group coulomb terms
+c     copyright - daresbury laboratory
+c     
+c     author  - w. smith     aug 2006
+c     adapted - p.-a. cazade oct 2007 : solvation, free energy etc
+c     adapted - w. smith     jan 2011 : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use ewald_module
+      use metafreeze_module
+      use pair_module
+      use setup_module
+      use solvation_module
+      
+      contains
+      
+      subroutine coul0neu
+     x  (lsolva,lfree,lexcite,ik,engcpe,vircpe,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     1/r potential, no truncation or damping.
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994
+c     adapted for solvation, free energy and excitation
+c     - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lexcite,lselect,lskip,idrive,jdrive
+      integer ik,m,iatm,jatm,kkk
+      real(8) engcpe,vircpe,epsq,chgprd,rsq,rrr,coul,reps,fcoul
+      real(8) fx,fy,fz
+      real(8) strs(6),strs_loc(6)
+      
+      lskip=(lfree.or.lexcite)
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      reps=r4pie0/epsq
+      do m=1,ik
+        
+c     atomic index and charge product
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+
+        if(lmetadyn)then
+
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+
+        endif
+
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        chgprd=chge(jatm)*chge(iatm)*reps
+        
+        if(abs(chgprd).gt.1.d-10)then
+          
+          rsq=rsqdf(m)
+          rrr=sqrt(rsq)
+          
+c     calculate coulomb energy and force
+          
+          coul=chgprd/rrr
+          fcoul=coul/rsq
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set double index
+          
+          if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+              
+c     calculate solvation energy
+                  
+              if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre-coul
+              cou_vir=cou_vir+coul
+              coul=lambda1*coul
+              fcoul=lambda1*fcoul
+              
+            elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre+coul
+              cou_vir=cou_vir-coul
+              coul=lambda2*coul
+              fcoul=lambda2*fcoul
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential energy and virial
+          
+            engcpe=engcpe+coul
+            vircpe=vircpe-coul
+            
+c     calculate solvation energy
+          
+            if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+            
+c     calculate forces
+            
+            fx=fcoul*xdf(m)
+            fy=fcoul*ydf(m)
+            fz=fcoul*zdf(m)
+            
+            fxx(iatm)=fxx(iatm)+fx
+            fyy(iatm)=fyy(iatm)+fy
+            fzz(iatm)=fzz(iatm)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+          endif
+          
+c     metadynamics local definitions
+
+          if(lmetadyn.and.(idrive.or.jdrive))then
+            
+c     local energy and virial
+          
+            eng_loc=eng_loc+coul
+            vir_loc=vir_loc-coul
+            
+c     local forces
+            
+            fxx_loc(iatm)=fxx_loc(iatm)+fx
+            fyy_loc(iatm)=fyy_loc(iatm)+fy
+            fzz_loc(iatm)=fzz_loc(iatm)+fz
+            
+            fxx_loc(jatm)=fxx_loc(jatm)-fx
+            fyy_loc(jatm)=fyy_loc(jatm)-fy
+            fzz_loc(jatm)=fzz_loc(jatm)-fz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xdf(m)*fx
+            strs_loc(2)=strs_loc(2)+xdf(m)*fy
+            strs_loc(3)=strs_loc(3)+xdf(m)*fz
+            strs_loc(4)=strs_loc(4)+ydf(m)*fy
+            strs_loc(5)=strs_loc(5)+ydf(m)*fz
+            strs_loc(6)=strs_loc(6)+zdf(m)*fz
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+
+      return
+      end subroutine coul0neu
+      
+      subroutine coul2neu
+     x  (lsolva,lfree,lexcite,ik,engcpe,vircpe,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a distance dependant dielectric `constant'.
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994
+c     adapted for solvation, free energy and excitation
+c     - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lexcite,lselect,lskip,idrive,jdrive
+      integer ik,m,iatm,jatm,kkk
+      real(8) engcpe,vircpe,epsq,fx,fy,fz,chgprd,rrsq,coul,egamma
+      real(8) strs(6),strs_loc(6)
+      
+      lskip=(lfree.or.lexcite)
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic index and charge product
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+
+        if(lmetadyn)then
+
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+
+        endif
+
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        chgprd=chge(iatm)*chge(jatm)*r4pie0/epsq
+        
+        if(abs(chgprd).gt.1.d-10)then
+          
+c     calculate potential energy
+          
+          rrsq=1.d0/rsqdf(m)
+          coul=chgprd*rrsq          
+          egamma=2.d0*coul*rrsq
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set double index
+          
+          if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+              
+c     calculate solvation energy
+                  
+              if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre-coul
+              cou_vir=cou_vir+2.d0*coul
+              coul=lambda1*coul
+              egamma=lambda1*egamma
+              
+            elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre+coul
+              cou_vir=cou_vir-2.d0*coul
+              coul=lambda2*coul
+              egamma=lambda2*egamma
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential energy and Virial
+            
+            engcpe=engcpe+coul
+            vircpe=vircpe-2.d0*coul
+          
+c     calculate solvation energy
+          
+            if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+            
+c     calculate forces
+            
+            fx=egamma*xdf(m)
+            fy=egamma*ydf(m)
+            fz=egamma*zdf(m)
+            
+            fxx(iatm)=fxx(iatm)+fx
+            fyy(iatm)=fyy(iatm)+fy
+            fzz(iatm)=fzz(iatm)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+          endif
+          
+c     metadynamics local definitions
+
+          if(lmetadyn.and.(idrive.or.jdrive))then
+            
+c     local energy and virial
+
+            eng_loc=eng_loc+coul
+            vir_loc=vir_loc-2.d0*coul
+          
+c     local forces
+            
+            fxx_loc(iatm)=fxx_loc(iatm)+fx
+            fyy_loc(iatm)=fyy_loc(iatm)+fy
+            fzz_loc(iatm)=fzz_loc(iatm)+fz
+            
+            fxx_loc(jatm)=fxx_loc(jatm)-fx
+            fyy_loc(jatm)=fyy_loc(jatm)-fy
+            fzz_loc(jatm)=fzz_loc(jatm)-fz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xdf(m)*fx
+            strs_loc(2)=strs_loc(2)+xdf(m)*fy
+            strs_loc(3)=strs_loc(3)+xdf(m)*fz
+            strs_loc(4)=strs_loc(4)+ydf(m)*fy
+            strs_loc(5)=strs_loc(5)+ydf(m)*fz
+            strs_loc(6)=strs_loc(6)+zdf(m)*fz
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine coul2neu
+      
+      subroutine coul3neu
+     x  (lsolva,lfree,lexcite,ik,engcpe,vircpe,epsq,rcut,alpha)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     reaction field  potential
+c     Ref: M Neumann, J Chem Phys, 82, 5633, (1985)
+c     adapted for fennell-gezelter coulombic model
+c     by w.smith june 2007
+c     Ref: CJ Fennell and JD Gezelter, J Chem Phys, 
+c     124, 234104, (2006)
+c     adapted for solvation, free energy and excitation
+c               - p.-a. cazade oct 2007
+c     
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester february 1995
+c     stress tensor - t.forester   feb 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lexcite,lselect,lskip,newjob,idrive,jdrive
+      integer ik,m,iatm,jatm,kkk
+      real(8) engcpe,vircpe,rcut,epsq,vcon,fcon,rdr,ppp,erc1,fer1
+      real(8) rcsq,b0,rfld0,rfld1,rfld2,chgprd,rsq,coul,omega,fcoul
+      real(8) fx,fy,fz,rrr,alpha,a1,a2,a3,a4,a5,pp,tt,exp1
+      real(8) strs(6),strs_loc(6)
+
+      save newjob,b0,rfld0,rfld1,rfld2,vcon,fcon
+
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      data newjob/.true./
+      
+      if(newjob)then
+        
+c     reaction field terms
+        
+        b0=2.d0*(epsq-1.d0)/(2.d0*epsq+1.d0)
+        rfld0=b0/rcut**3
+        rfld1=(1.d0+b0*0.5d0)/rcut
+        rfld2=rfld0*0.5d0
+        
+c     screened coulomb terms
+        
+        tt=1.d0/(1.d0+pp*alpha*rcut)
+        exp1=exp(-(alpha*rcut)**2)
+        erc1=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rcut
+        fer1=(erc1+2.d0*(alpha/sqrpi)*exp1)/(rcut*rcut)
+        vcon=erc1+rfld2*rcut**2-rfld1
+        fcon=rcut*fer1-rfld0*rcut
+        
+      endif
+      
+      lskip=(lfree.or.lexcite)
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0     
+      
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic index and charge product
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+
+        if(lmetadyn)then
+
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+
+        endif
+
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        chgprd=chge(jatm)*chge(iatm)*r4pie0
+        if(abs(chgprd).gt.1.d-10)then
+          
+c     calculate interatomic distance
+          
+          rsq=rsqdf(m)
+          rrr=sqrt(rsq)
+          
+c     error function terms
+          
+          tt=1.d0/(1.d0+pp*alpha*rrr)
+          exp1=exp(-(alpha*rrr)**2)
+          erc1=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rrr
+          fer1=(erc1+2.d0*(alpha/sqrpi)*exp1)/rsq
+          
+c     calculate potential energy
+          
+          omega=erc1-vcon+fcon*(rrr-rcut)
+          coul=chgprd*(omega+rfld2*rsq-rfld1)
+          
+c     calculate forces
+          
+          fcoul=chgprd*(fer1-fcon/rrr-rfld0)
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set double index
+          
+          if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+              
+c     calculate solvation energy
+                  
+              if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre-coul
+              cou_vir=cou_vir+fcoul*rsq
+              coul=lambda1*coul
+              fcoul=lambda1*fcoul
+              
+            elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre+coul
+              cou_vir=cou_vir-fcoul*rsq
+              coul=lambda2*coul
+              fcoul=lambda2*fcoul
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate coulombic energy and virial
+            
+            engcpe=engcpe+coul
+            vircpe=vircpe-fcoul*rsq
+            
+c     calculate solvation energy
+            
+            if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+            
+c     calculate coulombic force
+            
+            fx=fcoul*xdf(m)
+            fy=fcoul*ydf(m)
+            fz=fcoul*zdf(m)
+            
+            fxx(iatm)=fxx(iatm)+fx
+            fyy(iatm)=fyy(iatm)+fy
+            fzz(iatm)=fzz(iatm)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+          endif
+          
+c     metadynamics local definitions
+
+          if(lmetadyn.and.(idrive.or.jdrive))then
+            
+c     local energy and virial
+
+            eng_loc=eng_loc+coul
+            vir_loc=vir_loc-fcoul*rsq
+          
+c     local forces
+            
+            fxx_loc(iatm)=fxx_loc(iatm)+fx
+            fyy_loc(iatm)=fyy_loc(iatm)+fy
+            fzz_loc(iatm)=fzz_loc(iatm)+fz
+            
+            fxx_loc(jatm)=fxx_loc(jatm)-fx
+            fyy_loc(jatm)=fyy_loc(jatm)-fy
+            fzz_loc(jatm)=fzz_loc(jatm)-fz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xdf(m)*fx
+            strs_loc(2)=strs_loc(2)+xdf(m)*fy
+            strs_loc(3)=strs_loc(3)+xdf(m)*fz
+            strs_loc(4)=strs_loc(4)+ydf(m)*fy
+            strs_loc(5)=strs_loc(5)+ydf(m)*fz
+            strs_loc(6)=strs_loc(6)+zdf(m)*fz
+            
+          endif
+
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine coul3neu
+      
+      end module neu_coul_module
diff -urN dl_class_1.9.orig/srcmod/nlist_builders_module.f dl_class_1.9/srcmod/nlist_builders_module.f
--- dl_class_1.9.orig/srcmod/nlist_builders_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/nlist_builders_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,2216 @@
+      module nlist_builders_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining neighbourlist builder routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use exclude_module
+      use pair_module
+      use setup_module
+      use utility_module
+      
+      contains
+      
+      subroutine nlist_driver
+     x  (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x  nneut,keyfce,rcut,delr,tstep)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine to select and implement neighbour list 
+c     builders for short range force calculations
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith june 2006
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,loglnk,newjob,ltad
+      integer natms,idnode,mxnode,imcon,nneut,keyfce
+      real(8) rcut,delr,tstep
+      
+      save newjob
+      
+      data newjob/.true./
+      
+c     skip if no pair force calculations required
+      
+      if(keyfce.gt.0)then
+        
+c     test for updating the Verlet list
+        
+        if(ltad)then
+          
+          call vertest2(newlst,idnode,mxnode,natms,imcon,delr,tstep)
+          
+        else
+          
+          call vertest(newlst,idnode,mxnode,natms,delr,tstep)
+          
+        endif
+        
+c     set up nonbonded interaction (verlet) list
+        
+        newlst=(newjob.or.newlst)
+        
+        if(newlst)then
+          
+          if(.not.lneut)then
+            
+            if(lnsq)then 
+              
+c     calculate distant interactions explicitly
+              
+              call parlst_nsq(newlst,natms,idnode,mxnode,imcon,rcut)
+              
+            elseif(loglnk)then
+              
+c     ignore real space distant interactions
+              
+              call parlink
+     x          (newlst,natms,idnode,mxnode,imcon,rcut,delr)
+              
+            else
+              
+              call parlst
+     x          (newlst,natms,idnode,mxnode,imcon,rcut,delr)
+              
+            endif
+            
+          else
+            
+            if(.not.loglnk)then 
+              
+              call parneulst
+     x          (newlst,lneut,nneut,idnode,mxnode,imcon,rcut,
+     x          delr)
+              
+            else
+              
+              call parlinkneu
+     x          (newlst,natms,nneut,idnode,mxnode,imcon,
+     x          rcut,delr)
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      endif
+      
+      newjob=.false.
+      
+      return
+      end subroutine nlist_driver
+      
+      subroutine parlst(newlst,natms,idnode,mxnode,imcon,rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on the brode-ahlrichs scheme
+c     frozen atoms taken into account
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w.smith    march 1992
+c     modified  - t.forester october 1993
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,lfrzi,ldo
+      integer natms,idnode,mxnode,imcon,ibig,last,mpm2
+      integer npm2,idum,i,m,ii,j
+      real(8) rcut,delr,rclim,rsq
+      
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     check size of work array
+        
+        if(mxxdf.lt.(natms+1)/2)then
+          if(idnode.eq.0) write(nrite,*) 'mxxdf must be greater than ',
+     x      (natms+1)/2
+          call  error(idnode,474)
+        endif
+        
+c     set control variables
+        
+        last=natms
+        lchk=.true.
+        mpm2=natms/2
+        npm2=(natms-1)/2
+        
+c     set cutoff radius
+        
+        rclim=(rcut+delr)**2
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          noxatm(i)=1
+          
+        enddo
+        
+c     outer loop over atoms
+        
+        do m=1,mpm2
+          
+          if(m.gt.npm2)last=mpm2
+          
+c     inner loop over atoms
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+            ii=ii+1
+            xdf(ii)=xxx(i)-xxx(j)
+            ydf(ii)=yyy(i)-yyy(j)
+            zdf(ii)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     apply minimum image convention
+          
+          call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+          
+c     allocate atoms to neighbour list
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+            lfrzi=(lstfrz(i).ne.0)
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+            ii=ii+1
+            
+c     reject atoms in excluded pair list
+            
+            if((nexatm(ii).gt.0).and.(lexatm(ii,noxatm(ii)).eq.j))
+     x        then
+              
+              noxatm(ii)=min(noxatm(ii)+1,nexatm(ii))
+              
+c     reject frozen atom pairs
+              
+            else
+              
+              ldo=.true.
+              if(lfrzi)ldo=(lstfrz(j).eq.0)
+              
+              if(ldo)then
+                
+c     calculate interatomic distance
+                
+                if(imcon.eq.6)then
+                  
+                  rsq=xdf(ii)*xdf(ii)+ydf(ii)*ydf(ii)
+                  
+                else
+                  
+                  rsq=xdf(ii)*xdf(ii)+ydf(ii)*ydf(ii)+zdf(ii)*zdf(ii)
+                  
+                endif
+                
+c     running check of neighbour list array capacity
+                
+                if(rsq.lt.rclim)then
+                  
+                  lentry(ii)=lentry(ii)+1
+                  
+                  if(lentry(ii).gt.mxlist)then
+                    
+                    lchk=.false.
+                    ibig=max(lentry(ii),ibig)
+                    
+                  endif
+                  
+c     compile neighbour list array
+                  
+                  if(lchk)then
+                    
+                    list(ii,lentry(ii))=j
+                    
+                  endif
+                  
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be at least  ',ibig
+            write(nrite,*) ' mxlist is currently ',mxlist
+          endif
+          call error(idnode,110)
+          
+        endif
+        
+c     check all excluded atoms are accounted for
+        
+        do i=1,ii
+          
+          if(nexatm(i).gt.0.and.noxatm(i).ne.nexatm(i))lchk=.false.
+          
+        enddo
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk) call error(idnode,160)
+        
+      endif
+      
+      return
+      end subroutine parlst
+      
+      subroutine parlink(newlst,natms,idnode,mxnode,imcon,rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on link-cell method.
+c     frozen atoms taken into account
+c     
+c     to be used with the link version of exclude :exclude_link
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester september 1993.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,linc,newjob,lfrzi,ldo
+      integer natms,idnode,mxnode,imcon,idum,nix,niy,niz,fail
+      integer i,ibig,irat,nsbcll,ilx,ily,ilz,ncells,ix,iy,iz,j,icell
+      integer ic,ii,kc,ik,jx,jy,jz,jc,ixl
+      real(8) rcut,delr,rcsq,xm,ym,zm,det,xdc,ydc,zdc,tx,ty,tz
+      real(8) cx,cy,cz,sxd,syd,szd,xd,yd,zd,rsq
+      
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension nix(508),niy(508),niz(508)
+      
+      save newjob
+      data newjob/.true./
+      
+      data nix/0,1,0,0,-1,1,0,-1,1,0,-1,1,-1,1,2,0,0,-2,2,-1,1,0,-2,2,0,
+     x 0,-1,1,0,-1,1,-2,2,-2,2,-1,1,-1,1,-1,1,-2,2,0,-2,2,0,-2,2,-2,2,
+     x -1,1,-2,2,-2,2,-1,1,-2,2,-2,2,3,0,0,-3,3,-1,1,0,-3,3,0,0,-1,1,0,
+     x -1,1,-3,3,-3,3,-1,1,-1,1,-1,1,-3,3,-2,2,0,-3,3,0,0,-2,2,0,-2,2,
+     x -3,3,-3,3,-2,2,-1,1,-3,3,-3,3,-1,1,-1,1,-2,2,-2,2,-1,1,-2,2,-3,3,
+     x -3,3,-2,2,-2,2,-2,2,-3,3,0,-3,3,0,-3,3,-3,3,-1,1,-3,3,-3,3,-1,1,
+     x -3,3,-3,3,-2,2,-3,3,-3,3,-2,2,-3,3,-3,3,4,0,0,-4,4,-1,1,0,-4,4,0,
+     x 0,-1,1,0,-1,1,-4,4,-4,4,-1,1,-1,1,-1,1,-4,4,-2,2,0,-4,4,0,0,-2,2,
+     x 0,-2,2,-4,4,-4,4,-2,2,-1,1,-4,4,-4,4,-1,1,-1,1,-2,2,-2,2,-1,1,-2,
+     x 2,-4,4,-4,4,-2,2,-2,2,-2,2,-4,4,-3,3,0,-4,4,0,0,-3,3,0,-3,3,-4,4,
+     x -4,4,-3,3,-1,1,-4,4,-4,4,-1,1,-1,1,-3,3,-3,3,-1,1,-3,3,-4,4,-4,4,
+     x -3,3,-2,2,-4,4,-4,4,-2,2,-2,2,-3,3,-3,3,-2,2,-3,3,-4,4,-4,4,-3,3,
+     x -3,3,-3,3,-4,4,0,-4,4,0,-4,4,-4,4,-1,1,-4,4,-4,4,-1,1,-4,4,-4,4,
+     x -2,2,-4,4,-4,4,-2,2,-4,4,-4,4,-3,3,-4,4,-4,4,-3,3,5,0,0,-5,5,-1,
+     x 1,0,-5,5,0,0,-1,1,0,-1,1,-5,5,-5,5,-1,1,-1,1,-1,1,-5,5,-2,2,0,-5,
+     x 5,0,0,-2,2,0,-2,2,-5,5,-5,5,-2,2,-1,1,-5,5,-5,5,-1,1,-1,1,-2,2,
+     x -2,2,-1,1,-2,2,-5,5,-5,5,-2,2,-2,2,-2,2,-5,5,-3,3,0,-5,5,0,0,-3,
+     x 3,0,-3,3,-5,5,-5,5,-3,3,-1,1,-5,5,-5,5,-1,1,-1,1,-3,3,-3,3,-1,1,
+     x -3,3,-5,5,-5,5,-3,3,-2,2,-5,5,-5,5,-2,2,-2,2,-3,3,-3,3,-2,2,-3,3,
+     x -5,5,-5,5,-3,3,-3,3,-3,3/
+      data niy/  0,0,1,0,1,1,-1,0,0,1,-1,-1,1,1,0,2,0,1,1,2,2,-2,0,0,2,
+     x -1,0,0,1,-2,-2,-1,-1,1,1,2,2,-1,-1,1,1,2,2,-2,0,0,2,-2,-2,2,2,-2,
+     x -2,-1,-1,1,1,2,2,-2,-2,2,2,0,3,0,1,1,3,3,-3,0,0,3,-1,0,0,1,-3,-3,
+     x -1,-1,1,1,3,3,-1,-1,1,1,2,2,3,3,-3,0,0,3,-2,0,0,2,-3,-3,-2,-2,2,
+     x 2,3,3,-3,-3,-1,-1,1,1,3,3,-2,-2,-1,-1,1,1,2,2,-3,-3,-2,-2,2,2,3,
+     x 3,-2,-2,2,2,3,3,-3,0,0,3,-3,-3,3,3,-3,-3,-1,-1,1,1,3,3,-3,-3,3,3,
+     x -3,-3,-2,-2,2,2,3,3,-3,-3,3,3,0,4,0,1,1,4,4,-4,0,0,4,-1,0,0,1,-4,
+     x -4,-1,-1,1,1,4,4,-1,-1,1,1,2,2,4,4,-4,0,0,4,-2,0,0,2,-4,-4,-2,-2,
+     x 2,2,4,4,-4,-4,-1,-1,1,1,4,4,-2,-2,-1,-1,1,1,2,2,-4,-4,-2,-2,2,2,
+     x 4,4,-2,-2,2,2,3,3,4,4,-4,0,0,4,-3,0,0,3,-4,-4,-3,-3,3,3,4,4,-4,
+     x -4,-1,-1,1,1,4,4,-3,-3,-1,-1,1,1,3,3,-4,-4,-3,-3,3,3,4,4,-4,-4,
+     x -2,-2,2,2,4,4,-3,-3,-2,-2,2,2,3,3,-4,-4,-3,-3,3,3,4,4,-3,-3,3,3,
+     x 4,4,-4,0,0,4,-4,-4,4,4,-4,-4,-1,-1,1,1,4,4,-4,-4,4,4,-4,-4,-2,-2,
+     x 2,2,4,4,-4,-4,4,4,-4,-4,-3,-3,3,3,4,4,0,5,0,1,1,5,5,-5,0,0,5,-1,
+     x 0,0,1,-5,-5,-1,-1,1,1,5,5,-1,-1,1,1,2,2,5,5,-5,0,0,5,-2,0,0,2,-5,
+     x -5,-2,-2,2,2,5,5,-5,-5,-1,-1,1,1,5,5,-2,-2,-1,-1,1,1,2,2,-5,-5,
+     x -2,-2,2,2,5,5,-2,-2,2,2,3,3,5,5,-5,0,0,5,-3,0,0,3,-5,-5,-3,-3,3,
+     x 3,5,5,-5,-5,-1,-1,1,1,5,5,-3,-3,-1,-1,1,1,3,3,-5,-5,-3,-3,3,3,5,
+     x 5,-5,-5,-2,-2,2,2,5,5,-3,-3,-2,-2,2,2,3,3,-5,-5,-3,-3,3,3,5,5,-3,
+     x -3,3,3/
+      data niz/0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,2,0,0,0,0,1,1,1,1,2,2,2,
+     x 2,1,1,1,1,1,1,1,1,2,2,2,2,0,0,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,
+     x 2,2,2,0,0,3,0,0,0,0,1,1,1,1,3,3,3,3,1,1,1,1,1,1,1,1,3,3,3,3,0,0,
+     x 0,0,2,2,2,2,3,3,3,3,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,
+     x 3,3,2,2,2,2,2,2,2,2,3,3,3,3,0,0,3,3,3,3,1,1,1,1,3,3,3,3,3,3,3,3,
+     x 2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,0,0,4,0,0,0,0,1,1,1,1,4,4,4,4,1,
+     x 1,1,1,1,1,1,1,4,4,4,4,0,0,0,0,2,2,2,2,4,4,4,4,1,1,1,1,1,1,1,1,2,
+     x 2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,4,4,4,4,0,0,0,0,3,
+     x 3,3,3,4,4,4,4,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,2,
+     x 2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,4,
+     x 4,4,4,0,0,4,4,4,4,1,1,1,1,4,4,4,4,4,4,4,4,2,2,2,2,4,4,4,4,4,4,4,
+     x 4,3,3,3,3,4,4,4,4,4,4,4,4,0,0,5,0,0,0,0,1,1,1,1,5,5,5,5,1,1,1,1,
+     x 1,1,1,1,5,5,5,5,0,0,0,0,2,2,2,2,5,5,5,5,1,1,1,1,1,1,1,1,2,2,2,2,
+     x 2,2,2,2,5,5,5,5,5,5,5,5,2,2,2,2,2,2,2,2,5,5,5,5,0,0,0,0,3,3,3,3,
+     x 5,5,5,5,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,5,5,5,5,5,5,5,5,2,2,2,2,
+     x 2,2,2,2,3,3,3,3,3,3,3,3,5,5,5,5,5,5,5,5,3,3,3,3,3,3,3,3,5,5,5,5/
+      
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1890)
+      
+      if(newlst)then
+        
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x    call error(idnode,300)
+        lchk=.true.
+        ibig=0
+        
+c     zero link arrays
+        
+        do i=1,natms
+          link(i)=0
+        enddo
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          
+        enddo
+        
+c     real space cut off 
+        
+        rcsq=(rcut+delr)**2
+        
+c     create mock cell vector for non-periodic system
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+c     find maximum x,y,z postions
+          
+          xm=0.d0
+          ym=0.d0
+          zm=0.d0
+          
+          do i=1,natms
+            
+            xm=max(xm,abs(xxx(i)))
+            ym=max(ym,abs(yyy(i)))
+            zm=max(zm,abs(zzz(i)))
+            
+          enddo
+          
+          if(imcon.eq.0)then
+            
+            cell(1)=max(2.d0*xm+rcut+delr,3.d0*(rcut+delr))
+            cell(5)=max(2.d0*ym+rcut+delr,3.d0*(rcut+delr))
+            cell(2)=0.d0
+            cell(3)=0.d0
+            cell(4)=0.d0
+            cell(6)=0.d0
+            cell(7)=0.d0
+            cell(8)=0.d0
+            
+          endif
+          
+          cell(9)=max(2.d0*zm+rcut+delr,3.d0*(rcut+delr),cell(9))
+          
+        endif
+        
+        call dcell(cell,celprp)
+        call invert(cell,rcell,det)
+        
+c     ratio of link cell length to cut off diameter - max value is 5
+        
+c     irat=nint((rcut+delr)/rlink)
+c     irat=min(max(irat,1),5)
+        
+        irat=1
+        
+        
+c     number of subcells
+        
+        if (irat.eq.1)then 
+          
+          nsbcll=14
+          
+        elseif(irat.eq.2)then
+          
+          nsbcll=63
+          
+        elseif(irat.eq.3)then
+          
+          nsbcll=156
+          
+        elseif(irat.eq.4)then
+          
+          nsbcll=307
+          
+        elseif(irat.eq.5)then
+          
+          nsbcll=508
+          
+        endif
+        
+        ilx=int(celprp(7)*dble(irat)/(rcut+delr))
+        ily=int(celprp(8)*dble(irat)/(rcut+delr))
+        ilz=int(celprp(9)*dble(irat)/(rcut+delr))
+        
+c     check there are enough link cells
+        
+        linc=.true.
+        if(ilx.lt.2*irat+1)linc=.false.
+        if(ily.lt.2*irat+1)linc=.false.
+        if(ilz.lt.2*irat+1)linc=.false.
+        if(.not.linc) call error(idnode,305)
+        ncells=ilx*ily*ilz
+        if(ncells.gt.mxcell) call error(idnode,392)
+        
+c     calculate link cell indices
+        
+        do i=1,ncells
+          
+          lct(i)=0
+          
+        enddo
+        
+c     link-cell cutoff for reduced space
+        
+        xdc=dble(ilx)
+        ydc=dble(ily)
+        zdc=dble(ilz)
+        
+c     reduced space coordinates
+        if(newjob)then
+          
+          newjob=.false.
+          call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+          
+          if(mxnode.gt.1)  call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+        endif
+        
+        do i=1,natms
+          
+          tx=xxx(i)
+          ty=yyy(i)
+          tz=zzz(i)
+          
+          uxx(i)=(rcell(1)*tx+rcell(4)*ty+rcell(7)*tz)+0.5d0
+          uyy(i)=(rcell(2)*tx+rcell(5)*ty+rcell(8)*tz)+0.5d0
+          uzz(i)=(rcell(3)*tx+rcell(6)*ty+rcell(9)*tz)+0.5d0
+          
+        enddo
+        
+c     link neighbours 
+        
+        do i=1,natms
+          
+          ix=min(int(xdc*uxx(i)),ilx-1)
+          iy=min(int(ydc*uyy(i)),ily-1)
+          iz=min(int(zdc*uzz(i)),ilz-1)
+          
+          icell=1+ix+ilx*(iy+ily*iz)
+          
+          j=lct(icell)
+          lct(icell)=i
+          link(i)=j
+          
+        enddo
+        
+c     set control variables for loop over subcells
+        
+        ix=1
+        iy=1
+        iz=1
+        
+c     primary loop over subcells
+        
+        do ic=1,ncells
+          
+          ii=lct(ic)
+          if(ii.gt.0)then
+            
+c     secondary loop over subcells
+            
+            ik=0
+            
+            do kc=1,nsbcll
+              
+              i=ii
+              
+              cx=0.d0
+              cy=0.d0
+              cz=0.d0
+              jx=ix+nix(kc)
+              jy=iy+niy(kc)
+              jz=iz+niz(kc)
+              
+c     minimum image convention
+              
+              if(jx.gt.ilx)then
+                
+                jx=jx-ilx
+                cx=1.d0
+                
+              elseif(jx.lt.1)then
+                
+                jx=jx+ilx
+                cx=-1.d0
+                
+              endif
+              
+              if(jy.gt.ily)then
+                
+                jy=jy-ily
+                cy=1.d0
+                
+              elseif(jy.lt.1)then
+                
+                jy=jy+ily
+                cy=-1.d0
+                
+              endif
+              
+              if(jz.gt.ilz)then
+                
+                jz=jz-ilz
+                cz=1.d0
+                
+              elseif(jz.lt.1)then
+                
+                jz=jz+ilz
+                cz=-1.d0
+                
+              endif
+              
+c     index of neighbouring cell
+              
+              jc=jx+ilx*((jy-1)+ily*(jz-1))
+              j=lct(jc)
+              
+c     ignore if empty
+              
+              if(j.gt.0)then
+                
+                do while(i.ne.0)
+                  
+c     test if site is of interest to this node
+                  
+                  if(mod(i-1,mxnode).eq.idnode)then
+                    
+                    
+c     i's index for this processor
+                    ik=((i-1)/mxnode)+1
+                    
+c     test if i is a frozen atom
+                    
+                    lfrzi=(lstfrz(i).ne.0)
+                    
+                    if(ic.eq.jc) j=link(i)
+                    if(j.gt.0)then
+                      
+                      do while(j.ne.0)
+                        
+c     test of frozen atom pairs
+                        
+                        ldo=.true.
+                        if(lfrzi)ldo=(lstfrz(j).eq.0)
+                        
+                        if(ldo)then
+                          
+c     distance in real space : minimum image applied
+                          
+                          sxd=uxx(j)-uxx(i)+cx
+                          syd=uyy(j)-uyy(i)+cy
+                          szd=uzz(j)-uzz(i)+cz
+                          
+                          xd=cell(1)*sxd+cell(4)*syd+cell(7)*szd
+                          yd=cell(2)*sxd+cell(5)*syd+cell(8)*szd
+                          zd=cell(3)*sxd+cell(6)*syd+cell(9)*szd
+                          
+                          if(imcon.eq.6)then
+                            
+                            rsq=xd**2+yd**2
+                            
+                          else
+                            
+                            rsq=xd**2+yd**2+zd**2
+                            
+                          endif
+                          
+c     test of distance
+                          if(rcsq.gt.rsq)then
+                            
+c     test for excluded atom 
+                            
+                            linc=.true.
+                            do ixl=1,nexatm(ik)
+                              
+                              if(lexatm(ik,ixl).eq.j) linc=.false.
+                              
+                            enddo
+                            
+                            if(linc)then
+                              
+                              lentry(ik)=lentry(ik)+1
+                              
+                              if(lentry(ik).gt.mxlist)then
+                                
+                                ibig=max(ibig,lentry(ik))
+                                lchk=.false.
+                                
+                              else
+                                
+                                list(ik,lentry(ik))=j
+                                
+                              endif
+                              
+                            endif
+                            
+                          endif
+                          
+                        endif
+                        
+                        j=link(j)
+                        
+                      enddo
+                      
+                    endif
+                    
+                  endif
+                  
+                  j=lct(jc)
+                  i=link(i)
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+          ix=ix+1
+          if(ix.gt.ilx)then
+            
+            ix=1
+            iy=iy+1
+            
+            if(iy.gt.ily)then
+              
+              iy=1
+              iz=iz+1
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be >=  ',ibig
+            write(nrite,*) ' mxlist is currenty ',mxlist
+          endif
+          call error(idnode,106)
+          
+        endif
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (uxx,uyy,uzz,stat=fail)
+      
+      return
+      end subroutine parlink
+      
+      subroutine parneulst(newlst,lneut,nneut,idnode,mxnode,imcon,
+     x  rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on the brode-ahlrichs scheme
+c     frozen atoms taken into account
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - t.forester   april   1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,lneut,safe,lfrzi
+      integer nneut,idnode,mxnode,imcon,idum,fail,mpm2,npm2,ibig
+      integer i,ill,ia,im,jmlast,jmwrap,nuei1,nuei2,ii,jm1,jm,jj0,jj2
+      integer j,ii1
+      real(8) rcut,delr,rclim,fi,rrr,rcl1
+      
+      logical, allocatable :: lms(:)
+      dimension fi(3)
+      
+      data fail/0/
+      
+C     DIR$ CACHE_ALIGN fi
+      
+c     allocate work arrays
+      
+      allocate (lms(mxneut),stat=fail)
+      if(fail.ne.0)call error(idnode,1910)
+      
+      if(newlst.and.lneut)then
+        
+c     set control variables
+        
+        safe=.true. 
+        lchk= .true.
+        mpm2=(nneut+2)/2
+        npm2=(nneut+1)/2 
+        
+c     set cutoff radius
+        
+        rcl1=(rcut+delr)
+        rclim=(rcut+delr)**2
+        ibig=0
+        ill=0
+        
+c     construct pair force neighbour list: neutral groups
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          
+        enddo
+        
+        
+c     outer loop over groups
+        
+        ia=0
+        
+        do im=idnode+1,nneut,mxnode
+          
+          ia=ia+1 
+          if(im.ge.mpm2) mpm2=npm2
+          
+          lms(1)=.false.
+          do j=2,mpm2
+            lms(j)=.true.
+          enddo
+          
+          jmlast=min(nneut,im+mpm2-1)
+          jmwrap=max(0,im+mpm2-1-nneut)
+          
+c     loop over atomic pairs
+          
+          nuei1=neulst(im)
+          nuei2=neulst(im+1)-1
+          
+          do i=nuei1,nuei2
+            
+            fi(1)=xxx(i)
+            fi(2)=yyy(i)
+            fi(3)=zzz(i)
+            lfrzi=(lstfrz(i).eq.0)
+            
+            ii=0
+            jm1=1
+            do jm=im+1,jmlast
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    xdf(ii)=fi(1)-xxx(j)
+                    ydf(ii)=fi(2)-yyy(j)
+                    zdf(ii)=fi(3)-zzz(j)
+                    
+                  else
+                    
+                    ibig=max(ibig,ii)
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+            do jm=1,jmwrap
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    xdf(ii)=fi(1)-xxx(j)
+                    ydf(ii)=fi(2)-yyy(j)
+                    zdf(ii)=fi(3)-zzz(j)
+                    
+                  else
+                    
+                    safe=.false.
+                    ibig=max(ibig,ii)
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+c     apply minimum image convention
+            
+            ii1=min(ii,mxxdf)
+            call images(imcon,0,1,ii1,cell,xdf,ydf,zdf)
+            
+c     search for those in cutoff
+            
+            ii=0
+            jm1=1
+            do jm=im+1,jmlast
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    if(lms(jm1))then
+                      
+                      if(lfrzi)then
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      elseif(lstfrz(j).eq.0)then 
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      endif
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+            do jm=1,jmwrap
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    if(lms(jm1))then
+                      
+                      if(lfrzi)then
+                        
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      elseif(lstfrz(j).eq.0)then
+                        
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      endif
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+c     compile neighbour list for ia
+c     with running check of neighbour list array capacity
+          
+          jm1=0
+          do jm=im,jmlast
+            
+            jm1=jm1+1
+            if(.not.lms(jm1))then
+              
+              lentry(ia)=lentry(ia)+1
+              if(lentry(ia).le.mxlist)then
+                
+                list(ia,lentry(ia))=jm
+                
+              else
+                
+                ill=max(ill,lentry(ia))
+                lchk=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          do jm=1,jmwrap
+            
+            jm1=jm1+1
+            if(.not.lms(jm1))then
+              
+              lentry(ia)=lentry(ia)+1
+              if(lentry(ia).le.mxlist)then
+                
+                list(ia,lentry(ia))=jm
+                
+              else
+                
+                ill=max(ill,lentry(ia))
+                lchk=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        if(.not.lchk)then
+          
+          call gimax(ill,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be at least  ',ill
+            write(nrite,*) ' mxlist is currently ',mxlist
+          endif
+          call error(idnode,108)
+          
+        endif   
+        
+c     terminate job if work arrays exceeded
+        
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*)'mxxdf must be at least ',ibig
+            write(nrite,*)'mxxdf is currently ',mxxdf
+          endif
+          call  error(idnode,476)
+        endif
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(lms,stat=fail)
+      
+      return
+      end subroutine parneulst
+      
+      subroutine parlinkneu
+     x  (newlst,natms,nneut,idnode,mxnode,imcon,rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on link-cell method with neutral groups
+c     frozen atoms taken into account
+c     
+c     to be used with the link version of exclude :excludeneu_link
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1996
+c     author    - t. forester january 1996.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,linc,newjob,lfrzi,ldo,swop
+      integer natms,nneut,idnode,mxnode,imcon,idum,fail,ibig
+      integer nix,niy,niz,i,irat,nsbcll,ilx,ily,ilz,ncells,ix,iy,iz
+      integer icell,j,ic,ii,kc,jx,jy,jz,jc,ineu,ik,jneu,ineua,jneua
+      integer ika,jneua1,i1,j1
+      real(8) rcut,delr,rcsq,xm,ym,zm,det,xdc,ydc,zdc,tx,ty,tz
+      real(8) cx,cy,cz,sxd,syd,szd,rsq,xd,yd,zd
+      
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension nix(14),niy(14),niz(14)
+      
+      save newjob
+      
+      data newjob/.true./
+      data nix/0,1,0,0,-1,1,0,-1,1,0,-1,1,-1,1/
+      data niy/ 0,0,1,0,1,1,-1,0,0,1,-1,-1,1,1/
+      data niz/0,0,0,1,0,0,1,1,1,1,1,1,1,1/
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1900)
+      
+      lchk=.true.
+      ibig=0
+      if(newlst)then
+        
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x    call error(idnode,300)
+        
+c     zero link arrays
+        
+        do i=1,natms
+          
+          link(i)=0
+          
+        enddo
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          
+        enddo
+        
+c     real space cut off 
+        
+        rcsq=(rcut+delr)**2
+c     
+c     create mock cell vector for non-periodic system
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+c     find maximum x,y,z postions
+          
+          xm=0.d0
+          ym=0.d0
+          zm=0.d0
+          
+          do i=1,natms
+            
+            xm=max(xm,abs(xxx(i)))
+            ym=max(ym,abs(yyy(i)))
+            zm=max(zm,abs(zzz(i)))
+            
+          enddo
+          
+          if(imcon.eq.0)then
+            
+            cell(1)=max(2.d0*xm+rcut+delr,3.d0*(rcut+delr))
+            cell(5)=max(2.d0*ym+rcut+delr,3.d0*(rcut+delr))
+            cell(2)=0.d0
+            cell(3)=0.d0
+            cell(4)=0.d0
+            cell(6)=0.d0
+            cell(7)=0.d0
+            cell(8)=0.d0
+            
+          endif
+          
+          cell(9)=max(2.d0*zm+rcut+delr,3.d0*(rcut+delr),cell(9))
+          
+        endif
+        
+        call dcell(cell,celprp)
+        call invert(cell,rcell,det)
+        
+c     ratio of link cell length to cut off diameter 
+        
+        irat=1
+        
+c     number of subcells
+        
+        nsbcll=14
+        
+        ilx=int(celprp(7)*dble(irat)/(rcut+delr))
+        ily=int(celprp(8)*dble(irat)/(rcut+delr))
+        ilz=int(celprp(9)*dble(irat)/(rcut+delr))
+c     
+c     check there are enough link cells
+        
+        linc=.false.
+        if(ilx.lt.2*irat+1) linc=.true.
+        if(ily.lt.2*irat+1) linc=.true.
+        if(ilz.lt.2*irat+1) linc=.true.
+        if(linc) call error(idnode,305)
+        
+        ncells=ilx*ily*ilz
+        if(ncells.gt.mxcell)then
+          
+          if(idnode.eq.0) write(nrite,*) 'mxcell must be >= ',ncells
+          call  error(idnode,392)
+          
+        endif
+        
+c     calculate link cell indices
+        
+        do i=1,ncells
+          
+          lct(i)=0
+          
+        enddo
+        
+c     link-cell cutoff for reduced space
+        
+        xdc=dble(ilx)
+        ydc=dble(ily)
+        zdc=dble(ilz)
+        
+c     reduced space coordinates
+        if(newjob)then
+          
+          newjob=.false.
+          call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+          
+          if(mxnode.gt.1)  call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+        endif
+        
+        do i=1,natms
+          
+          tx=xxx(i)
+          ty=yyy(i)
+          tz=zzz(i)
+          
+          uxx(i)=(rcell(1)*tx+rcell(4)*ty+rcell(7)*tz)+0.5d0
+          uyy(i)=(rcell(2)*tx+rcell(5)*ty+rcell(8)*tz)+0.5d0
+          uzz(i)=(rcell(3)*tx+rcell(6)*ty+rcell(9)*tz)+0.5d0
+          
+        enddo
+        
+c     link neighbours 
+        
+        do i=1,natms
+          
+          ix=min(int(xdc*uxx(i)),ilx-1)
+          iy=min(int(ydc*uyy(i)),ily-1)
+          iz=min(int(zdc*uzz(i)),ilz-1)
+          
+          icell=1+ix+ilx*(iy+ily*iz)
+          
+          j=lct(icell)
+          lct(icell)=i
+          link(i)=j
+          
+        enddo
+        
+c     set control variables for loop over subcells
+        
+        ix=1
+        iy=1
+        iz=1
+        
+c     primary loop over subcells
+        
+        do ic=1,ncells
+          
+          ii=lct(ic)
+          if(ii.gt.0)then
+            
+c     secondary loop over subcells
+            
+            do kc=1,nsbcll
+              
+              i=ii
+              
+              cx=0.d0
+              cy=0.d0
+              cz=0.d0
+              jx=ix+nix(kc)
+              jy=iy+niy(kc)
+              jz=iz+niz(kc)
+              
+c     minimum image convention
+              
+              if(jx.gt.ilx)then
+                
+                jx=jx-ilx
+                cx=1.d0
+                
+              elseif(jx.lt.1)then
+                
+                jx=jx+ilx
+                cx=-1.d0
+                
+              endif
+              
+              if(jy.gt.ily)then
+                
+                jy=jy-ily
+                cy=1.d0
+                
+              elseif(jy.lt.1)then
+                
+                jy=jy+ily
+                cy=-1.d0
+                
+              endif
+              
+              if(jz.gt.ilz)then
+                
+                jz=jz-ilz
+                cz=1.d0
+                
+              elseif(jz.lt.1)then
+                
+                jz=jz+ilz
+                cz=-1.d0
+                
+              endif
+              
+c     index of neighbouring cell
+              
+              jc=jx+ilx*((jy-1)+ily*(jz-1))
+              j=lct(jc)
+              
+c     ignore if empty
+              
+              if(j.gt.0)then
+                
+                do while(i.ne.0)
+                  
+c     test if site is of interest to this node
+                  
+                  ineu=lstneu(i)
+                  ik=0
+                  
+c     i's  group index for this processor
+                  
+                  if(mod(ineu-1,mxnode).eq.idnode)
+     x              ik=((ineu-1)/mxnode)+1
+                  
+c     test if i is a frozen atom
+                  
+                  lfrzi=(lstfrz(i).ne.0)
+                  
+                  if(ic.eq.jc) j=link(i)
+                  if(j.gt.0)then
+                    
+                    do while(j.ne.0)
+                      
+                      jneu=lstneu(j)
+                      
+c     swop tests for switching of group indices,
+c     ldo for 'doing' interaction
+                      
+                      swop=.false.
+                      ldo=(ik.gt.0)
+                      jneua=jneu
+                      ineua=ineu
+                      ika=ik
+                      
+c     keep only Brode-Ahlrichs pairs
+                      
+                      if(jneua.ge.ineua)then
+                        
+                        if(jneua-ineua.gt.nneut/2)then 
+                          
+                          swop=(mod(jneu-1,mxnode).eq.idnode)
+                          if(swop)then 
+                            ldo=((nneut+ineua-jneua).le.(nneut-1)/2)
+                          else
+                            ldo=.false.
+                          endif
+                          
+                        endif
+                        
+                      elseif(nneut+jneua-ineua.gt.(nneut-1)/2)then
+                        
+                        swop=(mod(jneu-1,mxnode).eq.idnode)
+                        if(swop)then
+                          ldo=((ineua-jneua).le.nneut/2)
+                        else
+                          ldo=.false.
+                        endif
+                        
+                      endif
+                      
+                      if(swop.and.ldo)then
+                        jneua=ineu
+                        ineua=jneu
+                        ika=((jneu-1)/mxnode)+1
+                      endif
+                      
+c     test of frozen atom pairs
+                      
+                      if(lfrzi.and.ldo)ldo=(lstfrz(j).eq.0)
+                      
+c     check we haven't already included this group in the list ...
+                      
+                      jneua1=0
+                      do while
+     x                  (ldo.and.jneua1.lt.min(lentry(ika),mxlist))
+                        
+                        jneua1=jneua1+1
+                        if(list(ika,jneua1).eq.jneua) ldo=.false.
+                        
+                      enddo
+                      
+                      if(ldo)then
+                        
+c     distance in real space : minimum image applied
+                        
+                        sxd=uxx(j)-uxx(i)+cx
+                        syd=uyy(j)-uyy(i)+cy
+                        szd=uzz(j)-uzz(i)+cz
+                        
+                        xd=cell(1)*sxd+cell(4)*syd+cell(7)*szd
+                        yd=cell(2)*sxd+cell(5)*syd+cell(8)*szd
+                        zd=cell(3)*sxd+cell(6)*syd+cell(9)*szd
+                        
+                        rsq=xd*xd+yd*yd+zd*zd
+                        
+c     test of distance
+                        
+                        if(rsq.lt.rcsq)then
+                          
+                          lentry(ika)=lentry(ika)+1
+                          if(lentry(ika).gt.mxlist)then
+                            
+                            ibig=max(ibig,lentry(ika))
+                            lchk=.false.
+                            
+                          else
+                            
+                            list(ika,lentry(ika))=jneua
+                            
+                          endif
+                          
+                        endif
+                        
+                      endif
+                      
+                      j=link(j)
+                      
+                    enddo
+                    
+                  endif
+                  
+                  j=lct(jc)
+                  i=link(i)
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+          ix=ix+1
+          if(ix.gt.ilx)then
+            
+            ix=1
+            iy=iy+1
+            
+            if(iy.gt.ily)then
+              
+              iy=1
+              iz=iz+1
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*)'mxlist must be at least ',ibig
+            write(nrite,*)'mxlist is currently ',mxlist
+          endif
+          call error(idnode,107)
+          
+        endif
+        
+c     sort list into order ..
+c     use link as a work array
+        
+        ik=0
+        do i=1+idnode,nneut,mxnode
+          
+          ik=ik+1
+          do j=1,lentry(ik)
+            
+            link(j)=list(ik,j)
+            
+          enddo
+          call shellsort(lentry(ik),link)
+          
+c     ensure Brode-Ahlrichs ordering
+          
+          i1=lentry(ik)+1
+          j1=0
+          do j=1,lentry(ik)
+            
+            if(link(j).ge.i)then
+              
+              j1=j1+1
+              list(ik,j1)=link(j)
+              i1=min(i1,j)
+              
+            endif
+            
+          enddo
+          
+          do j=1,i1-1
+            
+            j1=j1+1
+            list(ik,j1)=link(j)
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays 
+      
+      deallocate (uxx,uyy,uzz,stat=fail)
+      
+      return
+      end subroutine parlinkneu
+      
+      subroutine parlst_nsq
+     x  (newlst,natms,idnode,mxnode,imcon,rcut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on the brode-ahlrichs scheme
+c     frozen atom option included
+c     
+c     to be used with multiple_nsq
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester march 1994     
+c     adapted   - w.smith aug 2008 - solvation, excitation etc
+c     
+c     stress tensor : t.forester may 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst
+      integer natms,idnode,mxnode,imcon,ibig,i,last,mpm2
+      integer npm2,m,ii,j,idum
+      real(8) rcut,rclim,rsq,rrr
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     check size of work array
+        
+        if(mxxdf.lt.(natms+1)/2)then
+          if(idnode.eq.0) write(nrite,*) 'mxxdf must be greater than ',
+     x      (natms+1)/2
+          call  error(idnode,475)
+        endif
+        
+c     set control variables
+        
+        last=natms
+        lchk=.true.
+        mpm2=natms/2
+        npm2=(natms-1)/2
+        
+c     set cutoff radius - ignore border width
+        
+        rclim=(rcut)**2
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          noxatm(i)=1
+          
+        enddo
+        
+c     outer loop over atoms
+        
+        do m=1,mpm2
+          
+          if(m.gt.npm2)last=mpm2
+          
+c     inner loop over atoms
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+c     calculate interatomic displacements
+            
+            ii=ii+1
+            xdf(ii)=xxx(i)-xxx(j)
+            ydf(ii)=yyy(i)-yyy(j)
+            zdf(ii)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     apply minimum image convention
+          
+          call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+          
+c     allocate atoms to neighbour list
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+            ii=ii+1
+            if((nexatm(ii).gt.0).and.(lexatm(ii,noxatm(ii)).eq.j))
+     x        then
+              
+              noxatm(ii)=min(noxatm(ii)+1,nexatm(ii))
+              
+            elseif(lstfrz(i).eq.0.or.lstfrz(j).eq.0)then
+              
+c     reject frozen atoms and calculate interatomic distance
+              
+              rsq=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+              
+c     running check of neighbour list array capacity
+              
+              if(rsq.lt.rclim)then
+                
+                lentry(ii)=lentry(ii)+1
+                
+                if(lentry(ii).gt.mxlist)then
+                  
+                  ibig=max(ibig,lentry(ii))
+                  lchk=.false.
+                  
+                endif
+                
+c     compile neighbour list array
+                
+                if(lchk)then
+                  
+                  list(ii,lentry(ii))=j
+                  
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1)call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gisum(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be >=  ',ibig
+            write(nrite,*) ' mxlist is currenty ',mxlist
+          endif
+          call error(idnode,109)
+          
+        endif
+        
+c     check all excluded atoms are accounted for
+        
+        do i=1,ii
+          
+          if(nexatm(i).gt.0.and.noxatm(i).ne.nexatm(i))lchk=.false.
+          
+        enddo
+        
+        if(mxnode.gt.1)call gstate(lchk)
+        
+        if(.not.lchk) call error(idnode,160)
+        
+      endif  
+      
+      return
+      end subroutine parlst_nsq
+      
+      subroutine primlst(idnode,mxnode,natms,imcon,rprim)
+      
+c*********************************************************************
+c     
+c     dlpoly routine to split interaction list into primary and 
+c     secondary neighbours for use with multiple timestep method
+c     
+c     copyright daresbury laboratory
+c     author - t. forester february 1993
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      integer idnode,mxnode,natms,imcon,ii,k,j,i
+      real(8) rprim,rprim2,rsq
+      
+      rprim2=rprim*rprim
+      ii=0
+      
+      do i=1+idnode,natms,mxnode
+        
+        ii=ii+1
+        
+        do j=1,lentry(ii)
+          
+          k=iabs(list(ii,j))
+          xdf(j)=xxx(i)-xxx(k)
+          ydf(j)=yyy(i)-yyy(k)
+          zdf(j)=zzz(i)-zzz(k)
+          
+        enddo           
+        
+c     apply minimum image convention
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     assign atoms as primary or secondary
+        
+        
+        do j=1,lentry(ii)
+          
+c     calculate interatomic distance
+          
+          rsq=xdf(j)**2+ydf(j)**2+zdf(j)**2
+          
+          if(rsq.lt.rprim2)then
+            
+c     compile primary neighbour list array  : -ve indices
+            
+            list(ii,j)=-iabs(list(ii,j))
+            
+          else
+            
+c     compile secondary neighbour list array : +ve indices
+            
+            list(ii,j)=iabs(list(ii,j))
+            
+          endif
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine primlst
+      
+      subroutine prneulst(newlst,imcon,idnode,mxnode,nneut,rprim)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to partition neutral group list into 
+c     primary and secondary groups
+c     loops over group ineu
+c     
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester april 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lchk,ldo
+      integer imcon,idnode,mxnode,nneut,ineu,ia,jj,ibig,ii
+      integer jj0,jneu,j,i,idum
+      real(8) rprim,rclim,xi,yi,zi,rrr
+      
+      lchk=.true.
+      
+      if(newlst)then
+        
+c     set primary cutoff limit
+        
+        rclim=rprim*rprim
+        
+c     set list to negative - signal for seconary shell
+        
+        ia=0
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+          do jj=1,lentry(ia)
+            
+            list(ia,jj)=-abs(list(ia,jj))
+            
+          enddo
+          
+        enddo
+        
+c     loop over neutral group ineu sites
+        
+        lchk=.true.
+        ibig=0
+        
+        ia=0
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+          ii=0
+          do i=neulst(ineu),neulst(ineu+1)-1
+            
+            xi=xxx(i)
+            yi=yyy(i)
+            zi=zzz(i)
+            
+            do jj=1,lentry(ia)
+              
+              jneu=-list(ia,jj)
+              jj0=neulst(jneu)
+              
+              if(ineu.eq.jneu) jj0=i+1
+              
+c     loop over jneu sites
+              
+              do j=jj0,neulst(jneu+1)-1
+                
+                ii=ii+1
+                if(ii.le.mxxdf)then
+                  xdf(ii)=xi-xxx(j)
+                  ydf(ii)=yi-yyy(j)
+                  zdf(ii)=zi-zzz(j)
+                else
+                  lchk=.false.
+                  ibig=ii
+                endif
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+c     apply minimum image convention
+          
+          ii=min(ii,mxxdf)
+          call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+          
+c     allocate groups to primary or secondary shell
+c     on basis of closest atom-atom interactions
+          
+          ii=0
+          do i=neulst(ineu),neulst(ineu+1)-1
+            
+            do jj=1,lentry(ia)
+              
+              jneu=list(ia,jj)
+              ldo=(jneu.lt.0)
+              if(ldo)then
+                jneu=-jneu
+                jj0=neulst(jneu)
+                if(ineu.eq.jneu) jj0=i+1
+                
+c     loop over jneu sites
+                
+                do j=jj0,neulst(jneu+1)-1
+                  
+                  if(ldo)then 
+                    
+                    ii=min(ii+1,mxxdf)
+                    
+                    if(abs(xdf(ii)).lt.rprim)then
+                      if(abs(ydf(ii)).lt.rprim)then
+                        if(abs(zdf(ii)).lt.rprim)then
+                          
+c     calculate interatomic distance
+                          
+                          rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                          
+c     put in primary list if found any interaction close enough
+                          
+                          if(rrr.le.rclim)then
+                            ldo=.false.
+                            list(ia,jj)=jneu
+                          endif
+                          
+                        endif
+                      endif
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+        enddo
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) 'mxxdf must be at least ',ibig
+            write(nrite,*) 'mxxdf is currently     ',mxxdf
+          endif
+          call  error(idnode,477)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine prneulst
+      
+      subroutine vertest(newlst,idnode,mxnode,natms,delr,tstep)
+      
+c*********************************************************************
+c     
+c     DL_POLY subroutime to test for updating of Verlet list
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1993
+c     author -       t. forester may 1993
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,newjob
+      integer idnode,mxnode,natms,i,j,k,moved,ibuff,fail
+      real(8) rmax,dr,delr,tstep
+      
+      real(8), allocatable :: xold(:),yold(:),zold(:)
+      
+      save newjob,xold,yold,zold
+      
+      data newjob/.true./,fail/0/
+      
+      if((natms+mxnode-1)/mxnode.gt.msatms) call error(idnode,112)
+      
+      if(newjob)then
+        
+c     set up initial arrays 
+        
+        allocate (xold(msatms),yold(msatms),zold(msatms),stat=fail)
+        if(fail.ne.0)call error(idnode,1930)
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xold(j)=0.d0
+          yold(j)=0.d0
+          zold(j)=0.d0
+          
+        enddo
+        
+        newjob=.false.
+        newlst=.true.
+        
+      else
+        
+c     integrate velocities 
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xold(j)=xold(j)+vxx(i)
+          yold(j)=yold(j)+vyy(i)
+          zold(j)=zold(j)+vzz(i)
+          
+        enddo
+        
+c     maximum displacement 
+        
+        rmax=(delr/2.d0)**2
+        
+c     test atomic displacements
+        
+        moved=0
+        
+        do k=1,j
+          
+          dr=tstep**2*(xold(k)**2+yold(k)**2+zold(k)**2)
+          if(dr.gt.rmax) moved=moved+1
+          
+        enddo
+        
+c     global sum of moved atoms
+        
+        if(mxnode.gt.1) call gisum(moved,1,ibuff)
+        
+c     test for new verlet list
+        
+        newlst=(moved.ge.2)
+        
+c     update stored positions
+        
+        if(newlst)then
+          
+          do k=1,j
+            
+            xold(k)=0.d0
+            yold(k)=0.d0
+            zold(k)=0.d0
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine vertest
+      
+      subroutine vertest2(newlst,idnode,mxnode,natms,imcon,delr,tstep)
+      
+c*********************************************************************
+c     
+c     DL_POLY subroutime to test for updating of Verlet list
+c     replicated data version (version 2)
+c     
+c     copyright daresbury laboratory
+c     author -       w.smith    2007
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,newjob
+      integer idnode,mxnode,natms,imcon,i,j,k,moved,ibuff,fail
+      real(8) rmax,dr,delr,tstep
+      
+      real(8), allocatable :: xold(:),yold(:),zold(:)
+      real(8), allocatable :: xdif(:),ydif(:),zdif(:)
+      
+      save newjob,xold,yold,zold
+      
+      data newjob/.true./,fail/0/
+      
+      if((natms+mxnode-1)/mxnode.gt.msatms) call error(idnode,112)
+      
+c     set up initial arrays 
+      
+      allocate (xdif(msatms),ydif(msatms),zdif(msatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1930)
+      
+      if(newjob)then
+        
+        allocate (xold(msatms),yold(msatms),zold(msatms),stat=fail)
+        if(fail.ne.0)call error(idnode,1930)
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xold(j)=xxx(i)
+          yold(j)=yyy(i)
+          zold(j)=zzz(i)
+          
+        enddo
+        
+        newjob=.false.
+        newlst=.true.
+        
+      else
+        
+c     calculate atomic shifts
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xdif(j)=xxx(i)-xold(j)
+          ydif(j)=yyy(i)-yold(j)
+          zdif(j)=zzz(i)-zold(j)
+          
+        enddo
+        
+c     minimum image calculation
+        
+        call images(imcon,0,1,j,cell,xdif,ydif,zdif)
+        
+c     maximum displacement 
+        
+        rmax=(delr/2.d0)**2
+        
+c     test atomic displacements
+        
+        moved=0
+        
+        do k=1,j
+          
+          dr=(xdif(k)**2+ydif(k)**2+zdif(k)**2)
+          if(dr.gt.rmax)moved=moved+1
+          
+        enddo
+        
+c     global sum of moved atoms
+        
+        if(mxnode.gt.1) call gisum(moved,1,ibuff)
+        
+c     test for new verlet list
+        
+        newlst=(moved.ge.2)
+        
+c     update stored positions
+        
+        if(newlst)then
+          
+          j=0
+          do i=idnode+1,natms,mxnode
+            
+            j=j+1
+            xold(j)=xxx(i)
+            yold(j)=yyy(i)
+            zold(j)=zzz(i)
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     deallocate arrays
+      
+      deallocate(xdif,ydif,zdif,stat=fail)
+      
+      return
+      end subroutine vertest2
+      
+      end module nlist_builders_module
diff -urN dl_class_1.9.orig/srcmod/optimiser_module.f dl_class_1.9/srcmod/optimiser_module.f
--- dl_class_1.9.orig/srcmod/optimiser_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/optimiser_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1144 @@
+      module optimiser_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining structural optimiser routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: ggx(:),ggy(:),ggz(:)
+      real(8), allocatable :: hhx(:),hhy(:),hhz(:)
+      real(8), allocatable :: oxx(:),oyy(:),ozz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      
+      save hhx,hhy,hhz
+      
+      contains
+      
+      subroutine optimisation_selector
+     x  (loptim,stropt,lzero,idnode,mxnode,natms,imcon,ntcons,
+     x  nscons,ngrp,ntfree,keystr,keytol,engcfg,tstep,opttol)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for selecting and running a nominated 
+c     structure optimisation algorithm using energy minimisation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith june 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical loptim,stropt,lzero
+      integer idnode,mxnode,natms,imcon,nscons,ngrp,ntfree,keystr
+      integer keytol,ntcons
+      real(8) engcfg,tstep,opttol,hnorm,grad0,grad1,ff1,sgn
+      
+      save grad0,grad1,ff1,sgn,hnorm
+
+      stropt=.false.
+      
+      if(loptim)then
+        
+c     conjugate gradient structure optimisation
+        
+        call strucopt
+     x    (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x    imcon,ngrp,ntfree,tstep,opttol,engcfg,hnorm,grad0,grad1,
+     x    ff1,sgn)
+        
+      else if(lzero)then
+        
+c     zero kelvin structure optimisation 
+        
+        call zero_kelvin
+     x    (stropt,idnode,mxnode,imcon,natms,ngrp,ntfree,opttol)
+        
+      endif
+      
+      return
+      end subroutine optimisation_selector
+
+      subroutine zero_kelvin
+     x  (stropt,idnode,mxnode,imcon,natms,ngrp,ntfree,opttol)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for zero Kelvin temperature optimization
+c     if velocity.Force < 0 then velocity is set to zero in 
+c     preparation for integration of equations of motion
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester     march 1994
+c     amended t.forester    dec 1994 : block data
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical stropt
+      integer idnode,mxnode,imcon,natms,ngrp,ntfree,fail,i
+      integer iatm0,iatm1,igrp1,igrp2,ifre1,ifre2,jr,ig,j,id
+      real(8) dot,fsq,fcomx,fcomy,fcomz,trx,try,trz,tax,tay,taz
+      real(8) rot,ggg,opttol
+      
+      dimension rot(9)
+
+      data fail/0/
+
+c     allocate work arrays
+
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1920)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     check for convergence of forces 
+      
+      ggg=0.d0
+      do i=iatm0,iatm1
+        ggg=ggg+fxx(i)**2+fyy(i)**2+fzz(i)**2
+      enddo
+      
+      if(mxnode.gt.1)then
+        buffer(1)=ggg
+        call gdsum(buffer(1),1,buffer(2))
+        ggg=buffer(1)
+      endif
+      
+c     check convergence condition for forces
+      
+      if(opttol.ge.abs(ggg)/dble(natms))then
+        
+        stropt=.true.
+        return
+        
+      endif
+
+      if(ngrp.eq.0) then
+
+c     take component of velocity in direction of force
+        
+        do i=iatm0,iatm1
+
+          dot=vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          if(dot.lt.0.d0) then
+
+            vxx(i)=0.d0
+            vyy(i)=0.d0
+            vzz(i)=0.d0
+
+          else
+
+c     take component of velocity in direction of force
+
+            fsq=(fxx(i)**2+fyy(i)**2+fzz(i)**2)
+            fsq=dot/max(1.d-10,fsq)
+            vxx(i)=fxx(i)*fsq
+            vyy(i)=fyy(i)*fsq
+            vzz(i)=fzz(i)*fsq
+
+          endif
+          
+        enddo
+        
+      else
+
+c     block indices for groups and free atoms
+
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+
+        do j=ifre1,ifre2
+
+c     reset atomic velocities 
+          
+          i=lstfre(j)
+          
+          dot=vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          if(dot.lt.0.d0) then
+
+            vxx(i)=0.d0
+            vyy(i)=0.d0
+            vzz(i)=0.d0
+
+          else
+
+c     take component of velocity in direction of force
+
+            fsq=(fxx(i)**2+fyy(i)**2+fzz(i)**2)
+            fsq=dot/max(1.d-10,fsq)
+            vxx(i)=fxx(i)*fsq
+            vyy(i)=fyy(i)*fsq
+            vzz(i)=fzz(i)*fsq
+            
+          endif
+          
+        enddo
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     reset rigid body velocites (linear and angular)
+          
+          fcomx=0.d0
+          fcomy=0.d0
+          fcomz=0.d0
+
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+
+c     forces on com
+            
+            fcomx=fcomx+fxx(i)
+            fcomy=fcomy+fyy(i)
+            fcomz=fcomz+fzz(i)
+            
+          enddo
+          
+          dot=gvxx(ig)*fcomx+gvyy(ig)*fcomy+gvzz(ig)*fcomz
+          if(dot.lt.0.d0) then
+
+            gvxx(ig)=0.d0
+            gvyy(ig)=0.d0
+            gvzz(ig)=0.d0
+
+          else
+
+c     take component of velocity in direction of force
+
+            fsq=(fcomx**2+fcomy**2+fcomz**2)
+            fsq=dot/max(1.d-10,fsq)
+            gvxx(ig)=fcomx*fsq
+            gvyy(ig)=fcomy*fsq
+            gvzz(ig)=fcomz*fsq
+
+          endif
+
+        enddo
+
+c     site to com distances
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          do j=1,numgsit(lstgtp(ig))
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxt(jr)=xxx(i)-gcmx(ig)
+            yyt(jr)=yyy(i)-gcmy(ig)
+            zzt(jr)=zzz(i)-gcmz(ig)
+            
+          enddo
+          
+        enddo
+
+c     minimum images
+        
+        call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+
+c     calculate torques in lab frame
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          trx=0.d0
+          try=0.d0
+          trz=0.d0
+          
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            trx=trx+yyt(jr)*fzz(i)-zzt(jr)*fyy(i)
+            try=try+zzt(jr)*fxx(i)-xxt(jr)*fzz(i)
+            trz=trz+xxt(jr)*fyy(i)-yyt(jr)*fxx(i)
+            
+          enddo
+          
+          rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+          rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+          rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+          rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+          rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+          rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+          rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+          rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+          rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+
+c     transform to body fixed frame
+          
+          tax=(trx*rot(1)+try*rot(4)+trz*rot(7))*rotinx(id,2)
+          tay=(trx*rot(2)+try*rot(5)+trz*rot(8))*rotiny(id,2)
+          taz=(trx*rot(3)+try*rot(6)+trz*rot(9))*rotinz(id,2)
+          
+          dot=omx(ig)*tax+omy(ig)*tay+omz(ig)*taz
+          if(dot.le.0.d0) then
+
+            omx(ig)=0.d0
+            omy(ig)=0.d0
+            omz(ig)=0.d0
+
+          else
+
+c     take component of velocity in direction of torque
+            
+            fsq=(tax**2+tay**2+taz**2)
+            fsq=dot/max(1.d-10,fsq)
+            omx(ig)=tax*fsq
+            omy(ig)=tay*fsq
+            omz(ig)=taz*fsq
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine zero_kelvin
+
+      subroutine strucopt
+     x  (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x  imcon,ngrp,ntfree,tstep,opttol,fnew,hnorm,grad0,grad1,
+     x  ff1,sgn)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for optimising molecular structures
+c     based on conjugate gradient method
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    dec 2005
+c     
+c     note. basis of minimisation criterion :
+c           keytol=0 : absolute force
+c           keytol=1 : absolute energy
+c           keytol=2 : absolute displacement
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=8
+      
+      logical stropt,newjob,engchk
+      integer keystr,keytol,idnode,mxnode,natms,i,j,k
+      integer iatm0,iatm1,fail,ngrp,ntcons,nscons,jr
+      integer imcon,ig,jf,id,ntfree,igrp1,igrp2,ifre1,ifre2
+      real(8) hnorm,grad0,grad1,grad2,ff1,stride,tstep,step
+      real(8) ggg,fnew,fff,gam2,sgn,opttol,dischk
+            
+      dimension fail(nnn)
+            
+      save iatm0,iatm1,igrp1,igrp2,engchk,ifre1,ifre2,newjob
+      
+      data newjob/.true./,engchk/.false./
+      
+c     define initial data
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      if(newjob)then
+        allocate(hhx(mxatms),hhy(mxatms),hhz(mxatms),stat=fail(1))
+      endif        
+      allocate(ggx(mxatms),ggy(mxatms),ggz(mxatms),stat=fail(2))
+      allocate(oxx(mxatms),oyy(mxatms),ozz(mxatms),stat=fail(3))
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(4))
+      if(ngrp.gt.0)then
+        
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(6))
+        
+      endif
+      if(ntcons.gt.0)then
+        
+        if(ngrp.eq.0)
+     x    allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(dxx(mxatms),dyy(mxatms),dzz(mxatms),stat=fail(7))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(8))
+        
+      endif
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1925)
+      enddo
+        
+      if(newjob)then
+        
+c     define atoms for this node
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+        newjob=.false.
+        
+      endif
+      
+c     step length for relaxation
+      
+      if(ntcons.gt.0)then
+        step=tstep**2
+      else
+        step=10.d0*tstep**2
+      endif
+      
+c     current system configuration energy
+      
+      fff=fnew
+      
+c     initialise conjugate gradient position arrays
+      
+      do i=1,natms
+        
+        oxx(i)=xxx(i)
+        oyy(i)=yyy(i)
+        ozz(i)=zzz(i)
+        ggx(i)=0.d0
+        ggy(i)=0.d0
+        ggz(i)=0.d0
+        
+      enddo
+      
+c     define constraint bonds
+      
+      if(ntcons.gt.0)then
+        
+c     calculate constraint bond vector
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+c     calculate pseudo forces for constraint bonds
+        
+        call pseudo_shake(nscons,natms,mxnode,fff)
+        
+        do i=1,natms
+          
+          ggx(i)=fxx(i)+ggx(i)
+          ggy(i)=fyy(i)+ggy(i)
+          ggz(i)=fzz(i)+ggz(i)
+          
+        enddo
+      
+      else
+        
+        do i=1,natms
+          
+          ggx(i)=fxx(i)
+          ggy(i)=fyy(i)
+          ggz(i)=fzz(i)
+          
+        enddo
+        
+      endif
+      
+c     calculate pseudo forces for rigid bodies
+      
+      if(ngrp.gt.0)call torque_split
+     x  (ngrp,idnode,mxnode,imcon,ggx,ggy,ggz,txx,tyy,tzz,
+     x  uxx,uyy,uzz,dtx,dty,dtz) 
+
+c     determine magnitude of 3N force vector
+      
+      ggg=0.d0
+      
+      if(ngrp.eq.0)then
+        
+        do i=iatm0,iatm1
+          ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+        enddo
+        
+      else
+        
+        do jf=ifre1,ifre2
+          
+          i=lstfre(jf)
+          ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+          
+        enddo
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+            
+          enddo
+        
+        enddo
+        
+      endif
+      
+      if(mxnode.gt.1)then
+        buffer(1)=ggg
+        call gdsum(buffer(1),1,buffer(2))
+        ggg=buffer(1)
+      endif
+      ggg=sqrt(ggg)
+      
+c     check convergence condition for forces
+      
+      if(keytol.eq.0.and.opttol.ge.abs(ggg)/dble(natms))stropt=.true.
+      
+      if(keystr.eq.0) then
+        
+c     set original search direction
+        
+        ff1=fff
+        hnorm=ggg
+        grad0=ggg
+        grad1=ggg
+        
+        if(ngrp.eq.0)then
+          
+          do i=iatm0,iatm1
+            
+            hhx(i)=ggx(i)
+            hhy(i)=ggy(i)
+            hhz(i)=ggz(i)
+            oxx(i)=oxx(i)+step*hhx(i)
+            oyy(i)=oyy(i)+step*hhy(i)
+            ozz(i)=ozz(i)+step*hhz(i)
+            
+          enddo
+          
+        else
+          
+          do jf=ifre1,ifre2
+            
+            i=lstfre(jf)
+            hhx(i)=ggx(i)
+            hhy(i)=ggy(i)
+            hhz(i)=ggz(i)
+            
+          enddo
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              hhx(i)=ggx(i)
+              hhy(i)=ggy(i)
+              hhz(i)=ggz(i)
+              
+            enddo
+            
+          enddo
+          
+          call turn_rigid_body
+     x      (igrp1,igrp2,ifre1,ifre2,step,hhx,hhy,hhz,
+     x      uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+          
+        endif
+        
+        keystr=1
+        sgn=1.d0
+        
+      elseif(keystr.eq.1)then
+        
+c     check convergence condition for energy
+
+        if(engchk.and.keytol.eq.1.and.
+     x    opttol.ge.abs(fff-ff1))stropt=.true.
+        engchk=.false.
+        
+c     line search along chosen direction
+        
+        ff1=fff
+        grad2=grad1
+        grad1=0.d0
+        do i=iatm0,iatm1
+          grad1=grad1+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+        enddo
+        if(mxnode.gt.1)then
+          buffer(1)=grad1
+          call gdsum(buffer(1),1,buffer(2))
+          grad1=buffer(1)
+        endif
+        grad1=sgn*grad1/hnorm
+        
+c     linear extrapolation to minimum
+        
+        stride=sgn*step
+        if(grad1.lt.0.d0)then
+          
+          keystr=2
+          stride=sgn*step*grad1/(grad2-grad1)
+          
+        endif
+        
+        if(ngrp.eq.0)then
+          
+          do i=iatm0,iatm1
+            
+            oxx(i)=oxx(i)+stride*hhx(i)
+            oyy(i)=oyy(i)+stride*hhy(i)
+            ozz(i)=ozz(i)+stride*hhz(i)
+            
+          enddo
+          
+        else
+
+          call turn_rigid_body
+     x      (igrp1,igrp2,ifre1,ifre2,stride,hhx,hhy,hhz,
+     x      uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+          
+        endif
+        
+      elseif(keystr.eq.2)then
+        
+c     construct conjugate search vector
+        
+        ff1=fff
+        gam2=(ggg/grad0)**2
+        hnorm=0.d0
+        grad0=ggg
+        grad1=0.d0
+        do i=iatm0,iatm1
+          
+          hhx(i)=ggx(i)+gam2*hhx(i)
+          hhy(i)=ggy(i)+gam2*hhy(i)
+          hhz(i)=ggz(i)+gam2*hhz(i)
+          hnorm=hnorm+hhx(i)**2+hhy(i)**2+hhz(i)**2
+          grad1=grad1+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+          
+        enddo
+        if(mxnode.gt.1)then
+          
+          buffer(1)=hnorm
+          buffer(2)=grad1
+          call gdsum(buffer(1),2,buffer(3))
+          hnorm=buffer(1)
+          grad1=buffer(2)
+          
+        endif
+        hnorm=sqrt(hnorm)
+        grad1=grad1/hnorm
+        sgn=sign(1.d0,grad1)
+        grad1=sgn*grad1
+        stride=sgn*step
+
+        if(ngrp.eq.0)then
+          
+          do i=iatm0,iatm1
+            
+            oxx(i)=oxx(i)+stride*hhx(i)
+            oyy(i)=oyy(i)+stride*hhy(i)
+            ozz(i)=ozz(i)+stride*hhz(i)
+            
+          enddo
+        
+        else
+
+          call turn_rigid_body
+     x      (igrp1,igrp2,ifre1,ifre2,stride,hhx,hhy,hhz,
+     x      uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+          
+        endif
+
+        engchk=.true.
+        keystr=1
+        
+      endif 
+      
+c     merge coordinate arrays
+      
+      if(mxnode.gt.1)then
+        
+        if(ngrp.eq.0)then
+          
+          call merge
+     x      (idnode,mxnode,natms,mxbuff,oxx,oyy,ozz,buffer)
+          
+        else
+          
+          call merge1
+     x      (idnode,mxnode,natms,lstme,oxx,oyy,ozz,buffer)
+          
+        endif
+        
+      endif
+      
+c     reassign atomic positions and calculate max displacement
+      
+      dischk=0.d0
+      do i=1,natms
+        
+        dischk=max(dischk,(xxx(i)-oxx(i))**2+
+     x    (yyy(i)-oyy(i))**2+(zzz(i)-ozz(i))**2)
+
+        xxx(i)=oxx(i)
+        yyy(i)=oyy(i)
+        zzz(i)=ozz(i)
+        
+      enddo
+      
+c     check convergence condition for position
+
+      if(keytol.eq.2.and.keystr.gt.0.and.
+     x  opttol.ge.sqrt(dischk))stropt=.true.
+      
+c     deallocate working arrays
+      
+      deallocate(ggx,ggy,ggz,dtx,dty,dtz,oxx,oyy,ozz,stat=fail(1))
+      if(ngrp.gt.0)then
+        deallocate(txx,tyy,tzz,uxx,uyy,uzz,stat=fail(2))
+      endif
+      if(ntcons.gt.0)then
+        
+        deallocate(dxx,dyy,dzz,xxt,yyt,zzt,stat=fail(3))
+        if(ngrp.eq.0)deallocate(txx,tyy,tzz,stat=fail(4))
+        
+      endif
+      
+      return
+      end subroutine strucopt
+      
+      subroutine pseudo_shake(nscons,natms,mxnode,fff)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine treating rigid bonds as stiff harmonic bonds
+c     suitable for conjugate gradient minimisation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      real(8), parameter :: harm=1.d6
+
+      integer i,j,k,natms,nscons,mxnode
+      real(8) fff,engbnd,dis,rrr,gamma
+      
+c     calculate energy and force
+      
+      engbnd=0.d0
+      
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+        dis=prmcon(listcon(k,1))
+        rrr=sqrt(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+        engbnd=engbnd+0.5d0*harm*(rrr-dis)**2
+        gamma=harm*(rrr-dis)/rrr
+        ggx(i)=ggx(i)-dxx(k)*gamma
+        ggy(i)=ggy(i)-dyy(k)*gamma
+        ggz(i)=ggz(i)-dzz(k)*gamma
+        
+        ggx(j)=ggx(j)+dxx(k)*gamma
+        ggy(j)=ggy(j)+dyy(k)*gamma
+        ggz(j)=ggz(j)+dzz(k)*gamma
+        
+      enddo
+      
+c     global sum of pseudo forces
+
+      call global_sum_forces(natms,mxnode,ggx,ggy,ggz)
+      if(mxnode.gt.1)then
+        buffer(1)=engbnd
+        call gdsum(buffer(1),1,buffer(2))
+        engbnd=buffer(1)
+      endif
+      fff=fff+engbnd
+      
+      return
+      end subroutine pseudo_shake
+
+      subroutine torque_split
+     x  (ngrp,idnode,mxnode,imcon,ggx,ggy,ggz,txx,tyy,tzz,
+     x  uxx,uyy,uzz,dtx,dty,dtz) 
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for resolving torques into equivalent atomic
+c     forces suitable for conjugate gradient minimisation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,ig,id,jr,jrs,ngrp,igrp1,igrp2,idnode,imcon,mxnode
+
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,trq,txx,tyy,tzz
+      real(8) ggx,ggy,ggz,tmp,taq,scale
+      real(8) uxx,uyy,uzz,dtx,dty,dtz
+
+      dimension ggx(mxatms),ggy(mxatms),ggz(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      dimension dtx(mxatms),dty(mxatms),dtz(mxatms)
+      
+c     group block indices
+        
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     calculate centres of mass of rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     working com is first site in group
+        
+        i=lstrgd(jr+1)
+        txx(ig)=xxx(i)
+        tyy(ig)=yyy(i)
+        tzz(ig)=zzz(i)
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          uxx(jr)=xxx(i)-txx(ig)
+          uyy(jr)=yyy(i)-tyy(ig)
+          uzz(jr)=zzz(i)-tzz(ig)
+          
+        enddo
+        
+      enddo
+      
+c     minimum image from working com
+      
+      call images(imcon,0,1,jr,cell,uxx,uyy,uzz)
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        gcmx(ig)=0.d0
+        gcmy(ig)=0.d0
+        gcmz(ig)=0.d0
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          gcmx(ig)=gcmx(ig)+weight(i)*uxx(jr)
+          gcmy(ig)=gcmy(ig)+weight(i)*uyy(jr)
+          gcmz(ig)=gcmz(ig)+weight(i)*uzz(jr)
+          
+        enddo
+        
+c     final centre of mass
+        
+        gcmx(ig)=gcmx(ig)/gmass(id)+txx(ig)
+        gcmy(ig)=gcmy(ig)/gmass(id)+tyy(ig)
+        gcmz(ig)=gcmz(ig)/gmass(id)+tzz(ig)
+        
+      enddo
+      
+c     calculate atom displacements from rigid body com
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+        
+c     resolve rigid body forces and torques to orthogonal atomic basis 
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+c     calculate net force on rigid body          
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+ggx(i)
+          fmy=fmy+ggy(i)
+          fmz=fmz+ggz(i)
+          
+        enddo
+        fmx=fmx/dble(numgsit(id))
+        fmy=fmy/dble(numgsit(id))
+        fmz=fmz/dble(numgsit(id))
+
+c     calculate torque on rigid body
+        
+        jr=jrs
+        tqx=0.d0
+        tqy=0.d0
+        tqz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx=tqx+dty(jr)*ggz(i)-dtz(jr)*ggy(i)
+          tqy=tqy+dtz(jr)*ggx(i)-dtx(jr)*ggz(i)
+          tqz=tqz+dtx(jr)*ggy(i)-dty(jr)*ggx(i)
+          
+        enddo
+        
+c     magnitude of torque
+        
+        trq=sqrt(tqx**2+tqy**2+tqz**2)
+        
+c     construct unit vectors for new site forces
+        
+        jr=jrs
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          txx(i)=dty(jr)*tqz-tqy*dtz(jr)
+          tyy(i)=dtz(jr)*tqx-tqz*dtx(jr)
+          tzz(i)=dtx(jr)*tqy-tqx*dty(jr)
+          tmp=sqrt(txx(i)**2+tyy(i)**2+tzz(i)**2)
+          if(tmp.gt.1.d-10)then
+            
+            txx(i)=txx(i)/tmp
+            tyy(i)=tyy(i)/tmp
+            tzz(i)=tzz(i)/tmp
+          
+          else
+            
+            txx(i)=0.d0
+            tyy(i)=0.d0
+            tzz(i)=0.d0
+            
+          endif
+          
+        enddo
+        
+c     construct unit vectors for site location
+        
+        jr=jrs
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          uxx(i)=(tyy(i)*tqz-tqy*tzz(i))/trq
+          uyy(i)=(tzz(i)*tqx-tqz*txx(i))/trq
+          uzz(i)=(txx(i)*tqy-tqx*tyy(i))/trq
+          
+        enddo
+        
+c     scale unit vectors to working lengths
+        
+        jr=jrs
+        taq=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          tmp=dtx(jr)*uxx(i)+dty(jr)*uyy(i)+dtz(jr)*uzz(i)
+          taq=taq+tmp**2
+          txx(i)=tmp*txx(i)
+          tyy(i)=tmp*tyy(i)
+          tzz(i)=tmp*tzz(i)
+          uxx(i)=tmp*uxx(i)
+          uyy(i)=tmp*uyy(i)
+          uzz(i)=tmp*uzz(i)
+          
+        enddo
+        
+c     calculate force scale factor
+        
+        scale=trq/taq
+        
+c     final site forces
+        
+        jr=jrs
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          txx(i)=scale*txx(i)
+          tyy(i)=scale*tyy(i)
+          tzz(i)=scale*tzz(i)
+          ggx(i)=fmx
+          ggy(i)=fmy
+          ggz(i)=fmz
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine torque_split
+
+      subroutine turn_rigid_body
+     x  (igrp1,igrp2,ifre1,ifre2,step,hhx,hhy,hhz,
+     x  uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for updating positions of atoms in a rigid body
+c     during a conjugate gradient minimisation
+c     
+c     copyright daresbury laboratory
+c     author w.smith       may  2006
+c     
+c     note: coz=cos(theta)-1
+c           zin=sin(theta)/theta
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,jr,jf,ig,id,igrp1,igrp2,ifre1,ifre2
+      real(8) step,hhx,hhy,hhz,uxx,uyy,uzz,txx,tyy,tzz
+      real(8) oxx,oyy,ozz,uuu,ttt,the2,coz,zin
+
+      dimension hhx(mxatms),hhy(mxatms),hhz(mxatms)
+      dimension oxx(mxatms),oyy(mxatms),ozz(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      
+c     update free atom positions
+
+      do jf=ifre1,ifre2
+        
+        i=lstfre(jf)
+        oxx(i)=oxx(i)+step*hhx(i)
+        oyy(i)=oyy(i)+step*hhy(i)
+        ozz(i)=ozz(i)+step*hhz(i)
+        
+      enddo
+      
+c     update rigid body atoms
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          uuu=uxx(i)**2+uyy(i)**2+uzz(i)**2
+          if(uuu.gt.1.d-10)then
+            
+            ttt=txx(i)**2+tyy(i)**2+tzz(i)**2
+            the2=(ttt/uuu)*step**2
+            
+            coz=-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-
+     x        the2/132.d0)/90.d0)/56.d0)/30.d0)/12.d0)/2.d0
+            zin=-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-
+     x        the2/156.d0)/110.d0)/72.d0)/42.d0)/20.d0)/6.d0+1.d0
+            
+            oxx(i)=oxx(i)+coz*uxx(i)+step*(hhx(i)+zin*txx(i))
+            oyy(i)=oyy(i)+coz*uyy(i)+step*(hhy(i)+zin*tyy(i))
+            ozz(i)=ozz(i)+coz*uzz(i)+step*(hhz(i)+zin*tzz(i))
+            
+          else
+            
+            oxx(i)=oxx(i)+step*hhx(i)
+            oyy(i)=oyy(i)+step*hhy(i)
+            ozz(i)=ozz(i)+step*hhz(i)
+            
+          endif
+          
+        enddo
+        
+      enddo
+
+      return
+      end subroutine turn_rigid_body
+      
+      end module optimiser_module
diff -urN dl_class_1.9.orig/srcmod/pair_module.f dl_class_1.9/srcmod/pair_module.f
--- dl_class_1.9.orig/srcmod/pair_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/pair_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,46 @@
+      module pair_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining atom pair data
+c     copyright - daresbury laboratory
+c     author    - w. smith    mar 2004
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+
+      implicit none
+
+      integer, allocatable :: ilist(:),jlist(:)
+      real(8), allocatable :: xdf(:),ydf(:),zdf(:)
+      real(8), allocatable :: rsqdf(:)
+
+      save ilist,jlist,xdf,ydf,zdf,rsqdf
+
+      contains
+
+      subroutine alloc_pair_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=6
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      allocate (ilist(mxxdf),stat=fail(1))
+      allocate (jlist(mxxdf),stat=fail(2))
+      allocate (xdf(mxxdf),stat=fail(3))
+      allocate (ydf(mxxdf),stat=fail(4))
+      allocate (zdf(mxxdf),stat=fail(5))
+      allocate (rsqdf(mxxdf),stat=fail(6))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1940)
+      enddo
+
+      end subroutine alloc_pair_arrays
+
+      end module pair_module
diff -urN dl_class_1.9.orig/srcmod/parse_module.f dl_class_1.9/srcmod/parse_module.f
--- dl_class_1.9.orig/srcmod/parse_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/parse_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,585 @@
+      module parse_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining parsing arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2004
+c     
+c***********************************************************************
+
+      integer, parameter :: lenrec=150
+      character*1 record(lenrec)
+      save record
+
+      contains
+
+      subroutine getrec(safe,idnode,ifile)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine to read a character string on one node
+c     and broadcast it to all other nodes
+c     
+c     copyright daresbury laboratory 1994
+c     author w.smith december 1994
+c     
+c*********************************************************************
+
+      implicit none
+      
+      logical safe
+
+      character*150 line
+      integer export,import,idnode,ifile,i
+      dimension export(lenrec),import(lenrec)
+      
+      safe=.true.
+      
+      call gsync()
+      
+      if(idnode.eq.0)then
+        
+        read(ifile,'(a150)',end=100)line
+
+        do i=1,lenrec
+
+          record(i)=line(i:i)
+          export(i)=ichar(line(i:i))
+          
+        enddo
+        
+        call gstate(safe)
+        call gisum(export,lenrec,import)
+        
+        return
+        
+  100   safe=.false.
+        
+        call gstate(safe)
+        
+      else
+        
+        call gstate(safe)
+        if(.not.safe)return
+
+        do i=1,lenrec
+
+          export(i)=0
+
+        enddo
+
+        call gisum(export,lenrec,import)
+        
+        do i=1,lenrec
+          
+          record(i)=char(export(i))
+          
+        enddo
+        
+        return
+        
+      endif
+      
+      end subroutine getrec
+
+      integer function intstr(word,len,lst)
+
+c***********************************************************************
+c     
+c     dl_poly function for extracting integers from a 
+c     character string
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith may 1994.
+c     
+c     parameters:
+c     word   - input character string
+c     len    - working length of character string
+c     lst    - location of space character at end of
+c     integer string
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical flag,count,final
+      character*1 n,word,ksn
+      integer lst,len,j,isn
+
+      dimension n(0:9),word(len)
+      data n/'0','1','2','3','4','5','6','7','8','9'/
+
+      isn=1
+      lst=0
+      ksn='+'
+      intstr=0
+      flag=.false.
+      final=.false.
+      count=.false.
+      
+      do while(lst.lt.len.and.(.not.final))
+
+        lst=lst+1
+        flag=.false.
+
+        do j=0,9
+          
+          if(n(j).eq.word(lst))then
+            
+            intstr=10*intstr+j
+            count=.true.
+            flag=.true.
+            
+          endif
+          
+        enddo
+
+        if(count.and.(.not.flag))final=.true.
+        if(flag.and.ksn.eq.'-')isn=-1
+        ksn=word(lst)
+
+      enddo
+
+      intstr=isn*intstr
+
+      do j=lst,len
+        word(j-lst+1)=word(j)
+      enddo
+      do j=len-lst+2,len
+        word(j)=' '
+      enddo
+
+      return
+      end function intstr
+
+      real(8) function dblstr(word,len,lst)
+
+c***********************************************************************
+c     
+c     dl_poly function for extracting double precisions from a 
+c     character string. 
+c     modified from dl_poly function intstr
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith may 1994.
+c     modified  - t. forester april 1994
+c     
+c     parameters:
+c     word   - input character string
+c     len    - working length of character string
+c     lst    - location of space character at end of
+c     double precision string
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 n,word,ksn,dot,d,e
+      logical flag,ldot,start,final
+      integer len,lst,iexp,idum,i,j,fail
+      real(8) sn,ten,one
+      dimension n(0:9),word(len)
+      character*1, allocatable :: work(:)
+
+      data n/'0','1','2','3','4','5','6','7','8','9'/
+      data dot/'.'/
+      data d/'d'/
+      data e/'e'/
+      
+      allocate(work(len),stat=fail)
+
+      lst=0
+      sn=1.d0
+      ksn='+'
+      ten=10.d0
+      one=1.d0
+      
+      dblstr=0.d0
+      iexp=0
+      idum=0
+      start=.false.
+      ldot=.false.
+      final=.false.
+
+      do while(lst.lt.len.and.(.not.final))
+        
+        lst=lst+1
+        flag=.false.
+        
+        do j=0,9
+          
+          if(n(j).eq.word(lst))then
+            
+            dblstr=ten*dblstr+one*dble(j)
+            flag=.true.
+            start=.true.
+            
+          endif
+          
+        enddo
+        
+        if(dot.eq.word(lst))then
+          
+          flag=.true.
+          ten=1.d0
+          ldot=.true.
+          start=.true.
+          
+        endif
+
+        if(flag.and.ksn.eq.'-') sn=-1.d0
+        if(ldot) one=one/10.d0
+        ksn=word(lst)
+        if(ksn.eq."D")ksn="d"
+        if(ksn.eq."E")ksn="e"
+        
+        if(start)then
+          
+          if(d.eq.ksn.or.e.eq.ksn)then
+            
+            do i=1,len-lst
+              work(i)=word(i+lst)
+            enddo
+            iexp=intstr(work,len-lst,idum)
+            final=.true.
+
+          endif
+
+          if(.not.flag)final=.true.
+          
+        endif
+        
+      enddo
+      
+      dblstr=sn*dblstr*(10.d0**iexp)
+      lst=lst+idum
+      
+      do j=lst,len
+        word(j-lst+1)=word(j)
+      enddo
+      do j=len-lst+2,len
+        word(j)=' '
+      enddo
+
+      deallocate(work,stat=idum)
+
+      return
+      end function dblstr
+
+      subroutine strip(string,imax)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to strip blanks from start of a string
+c     maximum length is 255 characters
+c     
+c     copyright daresbury laboratory 1993
+c     author   t.forester       july 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer i,imax,j
+      character*1 string(imax)
+      
+      do i=1,imax
+
+        if(string(1).eq.' ')then
+
+          do j=1,imax-1
+
+            string(j)=string(j+1)
+
+          enddo
+
+          string(imax)=' '
+
+        endif
+
+      enddo
+
+      return
+      end subroutine strip
+
+      subroutine lowcase(string,length)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to lowercase a string of up to 255 characters.
+c     Transportable to non-ASCII machines
+c     
+c     copyright daresbury laboratory 1993
+c     author    t. forester     july 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*1 string(*)
+      character*1 letter
+      integer i,length
+
+      do i=1,min(255,length)
+
+        letter=string(i)
+
+        if(letter.eq.'A')then
+          letter='a'
+        else if(letter.eq.'B')then
+          letter='b'
+        else if(letter.eq.'C')then
+          letter='c'
+        else if(letter.eq.'D')then
+          letter='d'
+        else if(letter.eq.'E')then
+          letter='e'
+        else if(letter.eq.'F')then
+          letter='f'
+        else if(letter.eq.'G')then
+          letter='g'
+        else if(letter.eq.'H')then
+          letter='h'
+        else if(letter.eq.'I')then
+          letter='i'
+        else if(letter.eq.'J')then
+          letter='j'
+        else if(letter.eq.'K')then
+          letter='k'
+        else if(letter.eq.'L')then
+          letter='l'
+        else if(letter.eq.'M')then
+          letter='m'
+        else if(letter.eq.'N')then
+          letter='n'
+        else if(letter.eq.'O')then
+          letter='o'
+        else if(letter.eq.'P')then
+          letter='p'
+        else if(letter.eq.'Q')then
+          letter='q'
+        else if(letter.eq.'R')then
+          letter='r'
+        else if(letter.eq.'S')then
+          letter='s'
+        else if(letter.eq.'T')then
+          letter='t'
+        else if(letter.eq.'U')then
+          letter='u'
+        else if(letter.eq.'V')then
+          letter='v'
+        else if(letter.eq.'W')then
+          letter='w'
+        else if(letter.eq.'X')then
+          letter='x'
+        else if(letter.eq.'Y')then
+          letter='y'
+        else if(letter.eq.'Z')then
+          letter='z'
+        endif
+
+        string(i)=letter
+
+      enddo
+
+      return
+      end subroutine lowcase
+
+      subroutine copystring(oldstr,newstr,length)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to copy one string into another
+c     
+c     copyright daresbury laboratory
+c     author    w. smith    jan 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*1 newstr(*),oldstr(*)
+      integer i,length
+
+      do i=1,length
+
+        newstr(i)=oldstr(i)
+
+      enddo
+
+      return
+      end subroutine copystring
+
+      logical function findstring(seek,string,here)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to find an explicit string in an input record
+c     note: variable `seek' is a character string while variable
+c    `string' is a character*1 array i.e. code is application specific
+c
+c     copyright daresbury laboratory
+c     author    w.smith   jan   2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer i,n,m,here
+      character*(*) seek
+      character*1 string(lenrec)
+
+      m=lenrec
+      n=len(seek)
+      findstring=.false.
+
+      here=0
+      do while(here.le.m-n.and.(.not.findstring))
+
+        findstring=.true.
+
+        do i=1,n
+          if(seek(i:i).ne.string(here+i))findstring=.false.
+        enddo
+
+        here=here+1
+
+      enddo
+
+      return
+      end function findstring
+
+      subroutine striptext(string,length,nwords)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to strip leading text from a data record
+c     
+c     copyright daresbury laboratory
+c     author   w.smith jan 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical final
+      integer length,nwords,i,j,k
+      character*1 string(length)
+      
+      do k=1,nwords
+
+        i=0
+        final=.false.
+        
+        do while(.not.final.and.i.lt.length)
+          
+          i=i+1
+          
+          if(string(1).eq.' ')then
+            
+            final=.true.
+            
+          else
+            
+            do j=1,length-1
+              
+              string(j)=string(j+1)
+              
+            enddo
+            
+            string(length)=' '
+            
+          endif
+          
+        enddo
+        
+      enddo
+
+      return
+      end subroutine striptext
+
+      subroutine getword(word,string,len1,len2)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to fetch an 8 character word from a string
+c     while ignoring leading blanks
+c
+c     copyright daresbury laboratory
+c     author   w.smith jan 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical final
+      character*8 word
+      integer len1,len2,i,j,k
+      character*1 wrdseq(len1),string(len2)
+      
+      do i=1,len1
+        wrdseq(i)=' '
+      enddo
+
+      i=0
+      k=0
+      final=.false.
+      
+      do while(.not.final.and.i.lt.len2)
+        
+        i=i+1
+        
+        if(string(1).eq.' ')then
+          
+          if(k.gt.0)final=.true.
+          
+        else
+          
+          k=k+1
+          wrdseq(k)=string(1)
+          if(k.eq.len1)final=.true.
+
+        endif
+        
+        do j=1,len2-1
+          
+          string(j)=string(j+1)
+          
+        enddo
+        
+        string(len2)=' '
+          
+      enddo
+      
+      word=mkwd8(wrdseq)
+
+      return
+      end subroutine getword
+
+      character*8 function mkwd8(string)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to make an 8 character word from a string
+c
+c     copyright daresbury laboratory
+c     author   w.smith nov 2006
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer i
+      character*1 string(*)
+      
+      do i=1,8
+         mkwd8(i:i)=string(i)
+      enddo
+      
+      return
+      end function mkwd8
+      
+      end module parse_module
+
+
diff -urN dl_class_1.9.orig/srcmod/pass_tools.f dl_class_1.9/srcmod/pass_tools.f
--- dl_class_1.9.orig/srcmod/pass_tools.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/pass_tools.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,318 @@
+      subroutine passcon
+     x     (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x     listin,listot,listcon,lstfrz)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine for passing information about bond 
+c     constraints between nodes
+c     
+c     parallel replicated data version assuming direct node-node
+c     connection (i.e. this version may be intel specific)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith august 1992.
+c     MPI version t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+
+      logical safe,lshmov
+      integer idnode,mxnode,natms,nscons,lashap,lishap,listme,ierr
+      integer listin,listot,listcon,lstfrz,i,j,k,jdnode,idum
+
+      dimension listme(mxatms),listin(mxatms),listot(mxatms)
+      dimension lishap(mxlshp),lashap(mxproc),listcon(mxcons,3)
+      dimension lstfrz(mxatms)
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU define MPI_SEND MPI_SEND_
+CMPIU define MPI_IRECV MPI_IRECV_
+CMPIU define MPI_WAIT MPI_WAIT_
+
+      if(mxproc.lt.mxnode)call error(idnode,102)
+      
+      safe=.true.
+
+      do i=1,natms
+         
+         listme(i)=0
+         
+      enddo
+      
+      do k=1,nscons
+         
+         i=listcon(k,2)
+         j=listcon(k,3)
+         listme(i)=listme(i)+1
+         listme(j)=listme(j)+1
+         
+      enddo
+      
+      if(mxnode.gt.1)then
+         
+         j=0
+         call gsync()
+         do k=1,mxnode-1
+            
+            jdnode=mod(idnode+mxnode-k,mxnode)
+
+            call MPI_IRECV(listin,natms,MPI_INTEGER,
+     x        MPI_ANY_SOURCE,Passcon_tag+k,MPI_COMM_WORLD,request,ierr)
+            
+            call MPI_SEND(listme,natms,MPI_INTEGER,jdnode,
+     x           Passcon_tag+k,MPI_COMM_WORLD,ierr)
+
+            call MPI_WAIT(request,status,ierr)
+
+            do i=1,natms
+               
+               if((listme(i).gt.0).and.(listin(i).gt.0.and.
+     x              lstfrz(i).eq.0))then
+                  
+                  j=j+1
+                  if(j.gt.mxlshp)then
+
+                     safe=.false.
+
+                  else
+
+                     lishap(j)=i
+
+                  endif
+                  
+               endif
+               
+            enddo
+            
+            lashap(k)=j
+            
+         enddo
+         
+      endif
+
+c     check for global error condition
+
+      if(mxnode.gt.1) call gstate(safe)
+
+      if(.not.safe)call error(idnode,103)
+
+      if(mxnode.gt.1) then
+         call gisum(j,1,idum)
+         if(idnode.eq.0) write(nrite,'(/,a,14x,i10)')
+     x     ' shared atoms from passcon',j/2
+         lshmov = (j.gt.0)
+      endif
+
+c     keep record of all atoms subject to constraints
+      
+      do i=1,natms
+         
+         if(listme(i).gt.0)then
+            
+            listot(i)=1
+            
+         else
+            
+            listot(i)=0
+            
+         endif
+         
+      enddo
+      
+      if(mxnode.gt.1)call gisum(listot,natms,listin)
+      
+      return
+      end
+
+      subroutine passpmf
+     x  (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for passing information about PMF
+c     constraints between nodes
+c     
+c     parallel replicated data version assuming direct node-node
+c     connection (i.e. this version may be intel specific)
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t.forester august 1995.
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf
+      integer npmf,i,j,k
+
+      dimension listpm(mxpmf),listin(mxatms),lstpmt(mxpmf)
+      dimension lstpmf(mxspmf,mspmf),npmf(2)
+
+      if(mxproc.lt.mxnode)call error(idnode,102)
+      if(mxpmf.lt.natms) call error(idnode,490)
+
+      do i=1,natms
+        
+        listpm(i)=0
+        
+      enddo
+      
+      do k=1,nspmf
+        
+        do j = 1,npmf(1)+npmf(2)
+
+          i=lstpmf(j,k)
+          listpm(i)= 1
+          
+        enddo
+
+      enddo
+c     
+c     keep record of all atoms subject to pmf constraints
+      
+      do i=1,natms
+        
+        if(listpm(i).gt.0)then
+          
+          lstpmt(i)=1
+          
+        else
+          
+          lstpmt(i)=0
+          
+        endif
+        
+      enddo
+      
+      if(mxnode.gt.1)call gisum(lstpmt,natms,listin)
+      
+      return
+      end
+
+      subroutine passquat
+     x  (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x  listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,numgsit)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for passing information about rigid body 
+c     atoms involved in bond constraints between nodes
+c     
+c     parallel replicated data version assuming direct node-node
+c     connection
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester december 1995.
+c     
+c***********************************************************************
+      
+      use setup_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+
+      logical lcnb,safe
+      integer idnode,mxnode,natms,ngrp,nscons,ntpmls,listin
+      integer listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp
+      integer numgsit,igrp1,igrp2,i,jr,igrp,itmols,imols,lgrp,id
+      integer jj,ik,j,k
+      
+      dimension listin(mxatms)
+      dimension listcon(mxcons,3),lstcsit(2*mxcons)
+      dimension lstout(mxatms),lstrgd(mxgatm)
+      dimension nummols(mxtmls),numgrp(mxtmls),numgsit(mxungp)
+      dimension lstgtp(mxgrp)
+
+      integer status(MPI_STATUS_SIZE)
+      
+      if(mxproc.lt.mxnode)call error(idnode,102)
+      
+c     block indices for groups
+      
+      igrp1 = (idnode*ngrp)/mxnode + 1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+      
+c     locate site indices of atoms in constraints
+
+      do i = 1,natms
+        listin(i) = 0
+      enddo
+
+c     loop over molecule types
+
+      jr = 0 
+      igrp = 0
+      do itmols=1,ntpmls
+
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if((igrp.ge.igrp1).and.(igrp.le.igrp2)) then
+                
+              id = lstgtp(igrp)
+              do jj = 1,numgsit(id)
+                  
+                jr = jr +1
+                i = lstrgd(jr)
+                listin(i) = jj
+
+              enddo
+            endif
+          enddo
+        enddo
+      enddo
+
+      if(mxnode.gt.1) call gisum(listin,natms,lstout)
+
+      safe = .true.
+      ik = 0
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+        if(listin(i).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(i)
+          safe = .false.
+        endif
+
+        if(listin(j).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(j)
+          safe = .false.
+        endif
+
+      enddo
+
+c     lcnb flags bodies connected by constraints
+
+      if(mxnode.gt.1) call gstate(safe)
+      lcnb = (.not.safe)
+      
+      return
+      end
+
+
+
diff -urN dl_class_1.9.orig/srcmod/pmf_module.f dl_class_1.9/srcmod/pmf_module.f
--- dl_class_1.9.orig/srcmod/pmf_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/pmf_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1911 @@
+      module pmf_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining potential of mean force arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use ensemble_tools_module
+      use lf_motion_module
+      use lf_rotation1_module
+      use parse_module
+      use property_module
+      use setup_module
+      use shake_module
+      use vv_motion_module
+      use utility_module
+      
+      implicit none
+      
+      integer npmf
+      real(8) prmpmf,pmfnrm
+      real(8), allocatable :: pmfwght(:)
+      integer, allocatable :: numpmf(:)
+      integer, allocatable :: indpmf(:)
+      integer, allocatable :: listpm(:)
+      integer, allocatable :: lstpmt(:)
+      integer, allocatable :: lstpmf(:,:)
+      
+      dimension npmf(2),pmfnrm(2)
+      
+      save npmf,prmpmf,pmfnrm,pmfwght,numpmf,indpmf,listpm
+      save lstpmt,lstpmf
+      
+      contains
+      
+      subroutine alloc_pmf_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for allocating pmf arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=6
+      
+      integer i,idnode,fail
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (pmfwght(mxspmf),stat=fail(1))
+      allocate (indpmf(mxspmf),stat=fail(2))
+      allocate (numpmf(mxtmls),stat=fail(3))
+      allocate (listpm(mxpmf),stat=fail(4))
+      allocate (lstpmt(mxpmf),stat=fail(5))
+      allocate (lstpmf(mxspmf,mspmf),stat=fail(6))
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1210)
+      enddo
+      
+      do i=1,mxtmls
+        numpmf(i)=0
+      enddo
+      
+      end subroutine alloc_pmf_arrays
+      
+      subroutine define_pmf(safe,idnode,itmols,nspmf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining pmf units
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer idnode,itmols,nspmf,ipmf,jpmf,iatm1,idum
+      real(8) wght
+      
+      numpmf(itmols)=1
+      prmpmf=dblstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,' PMF      bondlength :',
+     x    5x,f20.10)") prmpmf
+        write(nrite,
+     x    "(/,/,12x,'unit, site and weight details:'
+     x    ,/,/,16x,'unit',6x,'index',5x,'weight')")
+      endif
+      
+      do ipmf=1,2
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        call strip(record,lenrec)
+        call lowcase(record,lenrec)
+        if(.not.findstring('pmf unit',record,idum))
+     x    call error(idnode,462)
+        npmf(ipmf)=intstr(record,lenrec,idum)
+        
+        do jpmf=1,npmf(ipmf)
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)return
+          
+          iatm1=intstr(record,lenrec,idum)
+          wght=dblstr(record,lenrec,idum)
+          if(wght.le.1.d-10) wght=1.d0
+          
+          nspmf=nspmf+1
+          
+          if(nspmf.gt.mxspmf) call error(idnode,460)
+          
+          indpmf(nspmf)=iatm1
+          pmfwght(nspmf)=wght
+          
+          if(idnode.eq.0) then
+            
+            if(jpmf.eq.1) then
+              write(nrite,"(16x,i5,i10,f12.6)")
+     x          ipmf,indpmf(nspmf),pmfwght(nspmf)
+            else
+              write(nrite,"(21x,i10,f12.6)")
+     x          indpmf(nspmf),pmfwght(nspmf)
+            endif
+            
+          endif
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine define_pmf
+      
+      subroutine pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,xxa,yya,zza,
+     x  dxp,dyp,dzp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing vectors for PMF calculations
+c     
+c     copyright - daresbury laboratory
+c     adapted by w.smith october 2005
+c     original by t.forester aug 1995
+c     
+c     set variable img true for PBC shifted vectors
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical img
+      integer nspmf,imcon,k,jj,kk,ipmf,i,i1,i2
+      
+      real(8) xxx(mxatms),yyy(mxatms),zzz(mxatms)
+      real(8) xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      real(8) xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf)
+      real(8) dxp(mspmf),dyp(mspmf),dzp(mspmf),cell(9)
+      
+      do k=1,nspmf
+        
+        jj=0
+        kk=0
+        
+c     calculate difference vectors
+        
+        do ipmf=1,2
+          
+          i1=lstpmf(jj+1,k)
+          
+c     position difference vectors
+          
+          do i=1,npmf(ipmf)
+            
+            jj=jj+1
+            i2=lstpmf(jj,k)
+            xxt(i)=xxx(i2)-xxx(i1)
+            yyt(i)=yyy(i2)-yyy(i1)
+            zzt(i)=zzz(i2)-zzz(i1)
+            
+          enddo
+          
+c     correct for periodic images - assume less than half box length
+          
+          if(img)call images(imcon,0,1,npmf(ipmf),cell,xxt,yyt,zzt)
+          
+c     create weighted coordinate
+          
+          xxa(ipmf,k)=0.d0
+          yya(ipmf,k)=0.d0
+          zza(ipmf,k)=0.d0
+          
+          do i=1,npmf(ipmf)
+            
+            kk=kk+1
+            xxa(ipmf,k)=xxa(ipmf,k)+pmfwght(kk)*xxt(i)
+            yya(ipmf,k)=yya(ipmf,k)+pmfwght(kk)*yyt(i)
+            zza(ipmf,k)=zza(ipmf,k)+pmfwght(kk)*zzt(i)
+            
+          enddo
+          
+          xxa(ipmf,k)=xxa(ipmf,k)/pmfnrm(ipmf)+xxx(i1)
+          yya(ipmf,k)=yya(ipmf,k)/pmfnrm(ipmf)+yyy(i1)
+          zza(ipmf,k)=zza(ipmf,k)/pmfnrm(ipmf)+zzz(i1)
+          
+        enddo
+        
+        dxp(k)=xxa(2,k)-xxa(1,k)
+        dyp(k)=yya(2,k)-yya(1,k)
+        dzp(k)=zza(2,k)-zza(1,k)
+        
+      enddo
+      
+c     periodic boundary condition for pmf vectors
+      
+      if(img)call images(imcon,0,1,nspmf,cell,dxp,dyp,dzp)
+      
+      return
+      end subroutine pmf_vectors
+      
+      subroutine pmflf
+     x  (safe,safep,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x  ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics. Verlet leapfrog With RD-SHAKE
+c     and PMF_SHAKE - for potential of mean force calculations.
+c     
+c     parallel replicated data version : block data
+c     adapted from dl_poly routine nve_1.f
+c     
+c     copyright - daresbury laboratory 1995
+c     author  - t.forester aug 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=8
+      
+      logical safe,lshmov,safep,unsafe,img
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,nspmf,ntpmf
+      integer fail,iatm0,iatm1,i,j,k,jj,ii,ipmf,icyc
+      real(8) engke,tolnce,tstep,vircon,virpmf,strpmf,summas
+      real(8) rstep,viracc,strkin,strcon
+      
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: xxa(:,:),yya(:,:),zza(:,:)
+      real(8), allocatable :: dxp(:),dyp(:),dzp(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      dimension strpmf(9),strcon(9),strkin(9),summas(2),fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(1))
+      allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(2))
+      allocate(xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(3))
+      allocate(uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(4))
+      allocate(xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf),stat=fail(5))
+      allocate(dxp(mspmf),dyp(mspmf),dzp(mspmf),stat=fail(6))
+      allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+      allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(8))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1220)
+      enddo
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     constraint virials
+      
+      vircon=0.d0
+      virpmf=0.d0
+      
+c     temporary stress tensor accumulators
+      
+      do i=1,9
+        
+        strcns(i)=0.d0
+        strpmf(i)=0.d0
+        
+      enddo
+      
+c     store initial values of position
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      do k=1,nscons
+        
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition for bond vectors
+      
+      call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+c     calculate mass terms for PMF units
+      
+      jj=0
+      do ipmf=1,2
+        
+        summas(ipmf)=0.d0
+        pmfnrm(ipmf)=0.d0
+        
+        do i=1,npmf(ipmf)
+          
+          jj=jj+1
+          ii=lstpmf(jj,1)
+          summas(ipmf)=summas(ipmf)+weight(ii)
+          pmfnrm(ipmf)=pmfnrm(ipmf)+pmfwght(jj)
+          
+        enddo
+        
+      enddo
+      
+c     calculate PMF bond constraints and store initial positions
+      
+      img=.true.
+      call pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,
+     x  xxa,yya,zza,dxp,dyp,dzp)
+      
+c     move atoms by leapfrog algorithm
+      
+      safe=(ntcons.eq.0)
+      safep=(ntpmf.eq.0)
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        
+c     update velocities
+        
+        uxx(i)=vxx(i)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyy(i)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzz(i)+tstep*rmass(i)*fzz(i)
+        
+c     update positions
+        
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+      
+c     RDSHAKE procedure 
+      
+      if(ntcons.gt.0.or.ntpmf.gt.0) then
+        
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+c     apply constraint corrections - iteratively
+        
+        icyc=0
+        unsafe=.true.
+        
+        do while(unsafe.and.icyc.lt.mxshak)
+          
+          icyc=icyc+1
+          
+c     apply bond constraints
+          
+          viracc=0.d0
+          if(ntcons.gt.0)call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     apply pmf constraints
+          
+          viracc=0.d0
+          if(ntpmf.gt.0)call pmf_shake
+     x      (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x      viracc,xxt,yyt,zzt,strcon,summas,dxp,dyp,dzp,
+     x      xxa,yya,zza)
+          
+          virpmf=virpmf+viracc
+          do i=1,9
+            strpmf(i)=strpmf(i)+strcon(i)
+          enddo
+          
+          unsafe=(.not.(safe.and.safep.and.abs(viracc).lt.1.d-10))
+          
+        enddo
+        
+        safep=.not.unsafe
+        
+c     calculate velocity correction
+        
+        j=0
+        rstep=1.d0/tstep
+        do i=iatm0,iatm1
+          
+c     update corrected velocity
+          
+          j=j+1
+          uxx(i)=(xxx(i)-xxo(j))*rstep
+          uyy(i)=(yyy(i)-yyo(j))*rstep
+          uzz(i)=(zzz(i)-zzo(j))*rstep
+          
+c     calculate the corrected forces
+          
+          fxx(i)=(uxx(i)-vxx(i))*weight(i)*rstep
+          fyy(i)=(uyy(i)-vyy(i))*weight(i)*rstep
+          fzz(i)=(uzz(i)-vzz(i))*weight(i)*rstep
+          
+        enddo
+        
+      endif
+      
+c     calculate velocity at full time step
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=0.5d0*(vxx(i)+uxx(i))
+        vyy(i)=0.5d0*(vyy(i)+uyy(i))
+        vzz(i)=0.5d0*(vzz(i)+uzz(i))
+        
+      enddo
+      
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+      
+      call kinstress(natms,idnode,mxnode,strkin)
+      
+c     total contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strpmf(i)+strcns(i)+strkin(i)
+      enddo
+      
+c     add pmf and constraint virials
+      
+      vircon=vircon+virpmf
+      
+c     restore half step velocity
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(dxx,dyy,dzz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(uxx,uyy,uzz,dxp,dyp,dzp,stat=fail(2))
+      deallocate(txx,tyy,tzz,xxo,yyo,zzo,stat=fail(3))
+      deallocate(dxt,dyt,dzt,xxa,yya,zza,stat=fail(4))
+      
+      return
+      end subroutine pmflf
+      
+      subroutine pmflfq_1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x  vircon,safep,nspmf,ntpmf,virpmf)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=14
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newjob,safep,unsafe,img
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer fail,i,igrp,igrp1,igrp2,idum,ifre1,ifre2,j,ifre
+      integer jg,ig,k,id,jr,nspmf,ntpmf,jj,ii,ipmf,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) strkin,rot,rstep,rtsq,engtrn,vaa,vbb,vcc,virpmf
+      real(8) trx,try,trz,delx,dely,delz,engfke,viracc
+      real(8) strgrp,tqx,tqy,tqz,fmx,fmy,fmz
+      real(8) strpmf,strcon,summas
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      
+      
+      real(8), allocatable :: xxa(:,:),yya(:,:),zza(:,:)
+      real(8), allocatable :: dxp(:),dyp(:),dzp(:)
+      
+      dimension strkin(9),strgrp(9),rot(9),fail(nnn)
+      
+      dimension strpmf(9),strcon(9),summas(2)
+      
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(12))
+      
+      allocate(xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf),stat=fail(13))
+      allocate(dxp(mspmf),dyp(mspmf),dzp(mspmf),stat=fail(14))
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1500)
+      enddo
+      
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      
+c     constraint virials
+      
+      vircon=0.d0
+      virpmf=0.d0
+      
+c     temporary stress tensor accumulators
+      
+      do i=1,9
+        
+        strcns(i)=0.d0
+        strpmf(i)=0.d0
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition for bond vectors
+      
+      call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+c     calculate mass terms for PMF units
+      
+      jj=0
+      do ipmf=1,2
+        
+        summas(ipmf)=0.d0
+        pmfnrm(ipmf)=0.d0
+        
+        do i=1,npmf(ipmf)
+          
+          jj=jj+1
+          ii=lstpmf(jj,1)
+          summas(ipmf)=summas(ipmf)+weight(ii)
+          pmfnrm(ipmf)=pmfnrm(ipmf)+pmfwght(jj)
+          
+        enddo
+        
+      enddo
+      
+c     calculate PMF bond constraints and store initial positions
+      
+      img=.true.
+      call pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,
+     x  xxa,yya,zza,dxp,dyp,dzp)
+      
+c     move atoms by leapfrog algorithm
+      
+      safe=(ntcons.eq.0)
+      safep=(ntpmf.eq.0)
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     integrate 'free' particles
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+c     advance velocity by leapfrog
+        
+        uxx(i)=vxo(j)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyo(j)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzo(j)+tstep*rmass(i)*fzz(i)
+        
+c     advance position by leapfrog
+        
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+      
+      if(ntcons.gt.0.or.ntpmf.gt.0) then
+        
+c     store integrated positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          j=j+1
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+          
+        enddo
+        
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     apply constraint corrections - iteratively
+        
+        icyc=0
+        unsafe=.true.
+        
+        do while(unsafe.and.icyc.lt.mxshak)
+          
+          icyc=icyc+1
+          
+c     apply bond constraints
+          
+          viracc=0.d0
+          if(ntcons.gt.0)call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     apply pmf constraints
+          
+          viracc=0.d0
+          if(ntpmf.gt.0)call pmf_shake
+     x      (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x      viracc,xxt,yyt,zzt,strcon,summas,dxp,dyp,dzp,
+     x      xxa,yya,zza)
+          
+          virpmf=virpmf+viracc
+          do i=1,9
+            strpmf(i)=strpmf(i)+strcon(i)
+          enddo
+          
+          unsafe=(.not.(safe.and.safep.and.abs(viracc).lt.1.d-10))
+          
+        enddo
+        
+        safep=.not.unsafe
+        
+c     calculate force and velocity corrections
+        
+        j=0
+        rstep=1.d0/tstep
+        rtsq=1.d0/tstep**2
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     calculate force correction
+          
+          fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+          fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+          fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+          
+c     calculate velocity correction
+          
+          uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+          uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+          uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+          
+        enddo
+        
+c     end of shake corrections
+        
+      endif
+      
+c     estimate full step velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+        vxx(i)=0.5d0*(uxx(i)+vxo(j))
+        vyy(i)=0.5d0*(uyy(i)+vyo(j))
+        vzz(i)=0.5d0*(uzz(i)+vzo(j))
+        
+      enddo
+      
+c     calculate new kinetic energy at current timestep
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+      
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+      
+c     restore free atom half step velocity
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+      
+c     *************  Rigid body motion ****************************
+      
+c     translational rigid body motion
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     calculate net force on rigid body
+        
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+          
+        enddo
+        
+c     advance velocity by leapfrog
+        
+        uxx(ig)=gvxx(ig)+fmx*tstep/gmass(id)
+        uyy(ig)=gvyy(ig)+fmy*tstep/gmass(id)
+        uzz(ig)=gvzz(ig)+fmz*tstep/gmass(id)
+        
+c     advance position by leapfrog
+        
+        gcmx(ig)=gcmx(ig)+tstep*uxx(ig)
+        gcmy(ig)=gcmy(ig)+tstep*uyy(ig)
+        gcmz(ig)=gcmz(ig)+tstep*uzz(ig)
+        
+c     estimate velocity at full time step
+        
+        gvxx(ig)=0.5d0*(gvxx(ig)+uxx(ig))
+        gvyy(ig)=0.5d0*(gvyy(ig)+uyy(ig))
+        gvzz(ig)=0.5d0*(gvzz(ig)+uzz(ig))
+        
+      enddo
+      
+c     calculate rigid body translational kinetic energy
+      
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     total translational kinetic energy
+      
+      engke=engtrn+engfke
+      
+c     calculate ridid body kinetic stress tensor
+      
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+      
+c     restore rigid body half timestep velocity
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=uxx(ig)
+        gvyy(ig)=uyy(ig)
+        gvzz(ig)=uzz(ig)
+        
+      enddo
+      
+c     calculate rigid body contribution to stress tensor
+      
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+      
+c     calculate torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx=0.d0
+        tqy=0.d0
+        tqz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx=tqx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy=tqy+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz=tqz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+c     store current angular velocity
+        
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+        
+c     iterate angular velocity for time step n (e. yezdimer)
+        
+        do i=1,5
+          
+          trx=(tqx*rot(1)+tqy*rot(4)+tqz*rot(7))*rotinx(id,2)
+     x      +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*rotinx(id,2)
+          try=(tqx*rot(2)+tqy*rot(5)+tqz*rot(8))*rotiny(id,2)
+     x      +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*rotiny(id,2)
+          trz=(tqx*rot(3)+tqy*rot(6)+tqz*rot(9))*rotinz(id,2)
+     x      +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*rotinz(id,2)
+          
+          delx=tstep*trx
+          dely=tstep*try
+          delz=tstep*trz
+          
+c     improved angular velocity at time step n
+          
+          opx(jg)=omx(ig)+delx*pt5
+          opy(jg)=omy(ig)+dely*pt5
+          opz(jg)=omz(ig)+delz*pt5
+          
+        enddo
+        
+c     angular velocity at time step n+1/2
+        
+        uxx(ig)=omx(ig)+delx
+        uyy(ig)=omy(ig)+dely
+        uzz(ig)=omz(ig)+delz
+        
+c     angular velocity at time step n+1  (needed for quat algorithm)
+        
+        oqx(jg)=omx(ig)+delx*1.5d0
+        oqy(jg)=omy(ig)+dely*1.5d0
+        oqz(jg)=omz(ig)+delz*1.5d0
+        
+c     angular velocity at timestep n
+        
+        omx(ig)=omx(ig)+pt5*delx
+        omy(ig)=omy(ig)+pt5*dely
+        omz(ig)=omz(ig)+pt5*delz
+        
+      enddo
+      
+c     rotational kinetic energy
+      
+      engrot=getkinr(ngrp,idnode,mxnode)
+      
+c     restore half step angular velocity
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+        omx(ig)=uxx(ig)
+        omy(ig)=uyy(ig)
+        omz(ig)=uzz(ig)
+        
+      enddo
+      
+c     assign new quaternions
+      
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)+
+     x    strpmf(i)
+      enddo
+      
+c     add pmf and constraint virials
+      
+      vircon=vircon+virpmf
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+      
+c     new atomic positions for atoms in rigid bodies - relative to c.o.m
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x      +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x      +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x      +gcmz(ig)
+          
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+          
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     deallocate work arrays
+      
+      deallocate(opx,opy,opz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(oqx,oqy,oqz,dtx,dty,dtz,stat=fail(2))
+      deallocate(dxx,dyy,dzz,uxx,uyy,uzz,stat=fail(3))
+      deallocate(txx,tyy,tzz,dxt,dyt,dzt,stat=fail(4))
+      deallocate(xxo,yyo,zzo,xx1,yy1,zz1,stat=fail(5))
+      deallocate(vxo,vyo,vzo,gcxo,gcyo,gczo,stat=fail(6))
+      deallocate(dxp,dyp,dzp,xxa,yya,zza,stat=fail(7))
+      
+      return
+      end subroutine pmflfq_1
+      
+      subroutine pmf_shake
+     x  (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x  virpmf,xxt,yyt,zzt,strpmf,summas,dxp,dyp,dzp,
+     x  xxa,yya,zza)
+      
+c***********************************************************************
+c     
+c     dlpoly constraint subroutine for potential of mean force calc.
+c     accummulates constraint force to maintain reaction coordinate
+c     
+c     assume bond vectors dxp,dyp,dzp are input
+c     dxp=(sum) wght*xxx(i,1) - (sum) wght*xxx(j,2) etc
+c     
+c     copyright daresbury laboratory 1995
+c     author t.forester august 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safep,img
+      integer idnode,mxnode,imcon,natms,nspmf,fail,icyc,k,jj
+      integer ii,i,ipmf
+      real(8) tstep,tolnce,virpmf,xxt,yyt,zzt,strpmf,summas
+      real(8) dxp,dyp,dzp,xxa,yya,zza,amt,strs1,strs2,strs3,strs5
+      real(8) strs6,strs9,tstep2,dis,omega2,eps,gamma,gammi
+      
+      dimension dxp(mspmf),dyp(mspmf),dzp(mspmf)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf)
+      dimension amt(2),strpmf(9),summas(2)
+      
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:),dsq(:)
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),dsq(mspmf),
+     x  stat=fail)
+      if(fail.ne.0)call error(idnode,1230)
+      
+      if(mxcons.lt.nspmf) call error(idnode,492)
+      if(mspmf .lt.nspmf) call error(idnode,458)
+      
+c     timestep squared
+      
+      tstep2=tstep*tstep
+      
+c     accumulators for strpmf tensor
+      
+      virpmf=0.d0
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+      
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      safep=.false.
+      
+      do while(.not.safep.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+c     calculate bond constraint length
+        
+        img=.true.
+        call pmf_vectors
+     x    (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,
+     x    xxa,yya,zza,dxt,dyt,dzt)
+        
+        amt(1)= tstep2/summas(1)
+        amt(2)=-tstep2/summas(2)
+        
+        eps=0.d0
+        dis=prmpmf
+        omega2=dis*dis
+        
+        do k=1,nspmf
+          
+          dsq(k)=dxt(k)**2+dyt(k)**2+dzt(k)**2
+          eps=max(eps,abs((omega2-dsq(k))/(2.0d0*dis)))
+          
+        enddo
+        
+c     check convergence condition
+        
+        safep=(eps.le.tolnce)
+        
+c     bypass calculations if converged
+        
+        if(.not.safep)then
+          
+          do k=1,nspmf
+            
+            gamma=(omega2-dsq(k))/(-2.d0*(amt(2)-amt(1))*
+     x        (dxp(k)*dxt(k)+dyp(k)*dyt(k)+dzp(k)*dzt(k)))
+            
+c     accumulate pmf virial
+            
+            virpmf=virpmf+gamma*(dxp(k)**2+dyp(k)**2+dzp(k)**2)
+            
+            strs1=strs1-gamma*dxp(k)*dxp(k)
+            strs2=strs2-gamma*dxp(k)*dyp(k)
+            strs3=strs3-gamma*dxp(k)*dzp(k)
+            strs5=strs5-gamma*dyp(k)*dyp(k)
+            strs6=strs6-gamma*dyp(k)*dzp(k)
+            strs9=strs9-gamma*dzp(k)*dzp(k)
+            
+c     improve approximate atomic positions
+            
+            jj=0
+            do ipmf=1,2
+              
+              gammi=-gamma*amt(ipmf)
+              
+              do ii=1,npmf(ipmf)
+                
+                jj=jj+1
+                i=lstpmf(jj,k)
+                
+                xxx(i)=xxx(i)+dxp(k)*gammi
+                yyy(i)=yyy(i)+dyp(k)*gammi
+                zzz(i)=zzz(i)+dzp(k)*gammi
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     complete strpmf tensor
+      
+      strpmf(1)=strs1
+      strpmf(2)=strs2
+      strpmf(3)=strs3
+      strpmf(4)=strs2
+      strpmf(5)=strs5
+      strpmf(6)=strs6
+      strpmf(7)=strs3
+      strpmf(8)=strs6
+      strpmf(9)=strs9
+      
+c     splice coordinate arrays across nodes
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=virpmf
+        call gdsum(buffer(1),1,buffer(2))
+        virpmf=buffer(1)
+        call gdsum(strpmf,9,buffer)
+        call splice 
+     x    (idnode,natms,listpm,lstpmt,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(dxt,dyt,dzt,dsq,stat=fail)
+      
+      return
+      end subroutine pmf_shake
+      
+      subroutine pmfvv
+     x  (safe,safep,lshmov,isw,idnode,mxnode,imcon,natms,nscons,
+     x  ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics. Velocity Verlet With PMF_RATTLE
+c     for potential of mean force calculations.
+c     
+c     copyright - daresbury laboratory
+c     adapted by w.smith october 2005
+c     original by t.forester aug 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=7
+      
+      logical safe,lshmov,safep,unsafe,newjob,img
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,nspmf,ntpmf
+      integer isw,mxtop
+      integer fail,iatm0,iatm1,i,j,k,jj,i1,ipmf,icyc
+      real(8) engke,tolnce,tstep,vircon,virpmf,strcon,summas
+      real(8) viracc,strpmf,strkin
+      
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxp(:),dyp(:),dzp(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxa(:,:),yya(:,:),zza(:,:)
+      
+      dimension strcon(9),strpmf(9),strkin(9),summas(2),fail(nnn)
+      save summas,newjob,strpmf
+      data newjob/.true./
+      
+c     set default safety flags
+      
+      safe=(ntcons.eq.0)
+      safep=(ntpmf.eq.0)
+      if(safe.and.safep)return
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      mxtop=max(mxcons,mspmf)
+      allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(1))
+      allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(2))
+      allocate(dxp(mspmf),dyp(mspmf),dzp(mspmf),stat=fail(3))
+      allocate(dxt(mxtop),dyt(mxtop),dzt(mxtop),stat=fail(4))
+      allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+      allocate(xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf),stat=fail(6))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1220)
+      enddo
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     calculate mass terms for PMF units
+      
+      if(newjob)then
+        
+        jj=0
+        do ipmf=1,2
+          
+          summas(ipmf)=0.d0
+          pmfnrm(ipmf)=0.d0
+          
+          do i=1,npmf(ipmf)
+            
+            jj=jj+1
+            i1=lstpmf(jj,1)
+            summas(ipmf)=summas(ipmf)+weight(i1)
+            pmfnrm(ipmf)=pmfnrm(ipmf)+pmfwght(jj)
+            
+          enddo
+          
+        enddo
+        
+        newjob=.false.
+        
+      endif
+      
+c     construct current bond vectors
+      
+      do k=1,nscons
+        
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition for bond vectors
+      
+      call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+c     calculate PMF bond constraints and store initial positions
+      
+      img=.true.
+      call pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,xxa,yya,zza,
+     x  dxp,dyp,dzp)
+      
+c     update velocities
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+        
+      enddo
+      
+      if(mxnode.gt.1)
+     x  call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+      
+      if(isw.eq.1)then
+        
+c     constraint virials
+        
+        vircon=0.d0
+        virpmf=0.d0
+        
+c     temporary stress tensor accumulators
+        
+        do i=1,9
+          
+          strcns(i)=0.d0
+          strpmf(i)=0.d0
+          
+        enddo
+        
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     apply constraint corrections - iteratively
+      
+      icyc=0
+      unsafe=.true.
+      
+      do while(unsafe.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+        if(isw.eq.1)then
+          
+c     apply bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcon)
+            
+            vircon=vircon+viracc
+            do i=1,9
+              strcns(i)=strcns(i)+strcon(i)
+            enddo
+            
+          endif
+          
+c     apply pmf constraints
+          
+          if(ntpmf.gt.0)then
+            
+            safep=.false.
+            call pmf_rattle_r
+     x        (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x        viracc,summas,xxt,yyt,zzt,xxa,yya,zza,dxp,dyp,dzp,
+     x        dxt,dyt,dzt,strcon)
+            
+            virpmf=virpmf+viracc
+            do i=1,9
+              strpmf(i)=strpmf(i)+strcon(i)
+            enddo
+            
+          endif
+          
+          unsafe=(.not.(safe.and.safep.and.abs(viracc).le.1.d-10))
+          
+        endif
+        
+        if(isw.eq.2)then
+          
+c     apply rattle velocity constraints
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_v
+     x        (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x        dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+            
+          endif
+          
+c     apply pmf velocity constraints
+          
+          if(ntpmf.gt.0)then
+            
+            safep=.false.
+            call pmf_rattle_v
+     x        (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x        summas,dxp,dyp,dzp,xxt,yyt,zzt,xxa,yya,zza,dxt,dyt,dzt)
+            
+          endif
+          
+          unsafe=(.not.(safe.and.safep))
+          
+        endif
+        
+      enddo
+      
+      safep=(.not.unsafe)
+      
+c     periodic boundary condition
+      
+      if(isw.eq.1)call images
+     x  (imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+      if(isw.eq.2)then
+        
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        
+c     total contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strpmf(i)+strcns(i)+strkin(i)
+        enddo
+        
+c     add pmf and constraint virials
+        
+        vircon=vircon+virpmf
+        
+      endif
+      
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(isw.eq.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(dxx,dyy,dzz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(dxp,dyp,dzp,dxt,dyt,dzt,stat=fail(2))
+      deallocate(txx,tyy,tzz,xxa,yya,zza,stat=fail(3))
+      
+      return
+      end subroutine pmfvv
+      
+      subroutine pmf_rattle_r
+     x  (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x  virpmf,summas,xxt,yyt,zzt,xxa,yya,zza,dxp,dyp,dzp,
+     x  dxt,dyt,dzt,strpmf)
+      
+c***********************************************************************
+c     
+c     dlpoly constraint subroutine for potential of mean force calc.
+c     accumulates constraint force to maintain reaction coordinate.
+c     velocity verlet adaptation
+c     
+c     assume bond vectors dxp,dyp,dzp are input
+c     dxp=(sum) wght*xxx(i,1) - (sum) wght*xxx(j,2) etc
+c     
+c     copyright daresbury laboratory
+c     adapted by w.smith october 2005
+c     original t.forester august 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safep,img
+      integer idnode,mxnode,imcon,natms,nspmf,icyc,k,jj
+      integer i1,i,ipmf
+      real(8) tstep,tolnce,virpmf,xxt,yyt,zzt,strpmf,summas,gamma
+      real(8) dxp,dyp,dzp,xxa,yya,zza,amt,tstep2,dis,omega2,eps,gammi
+      real(8) strs1,strs2,strs3,strs5,strs6,strs9,dxt,dyt,dzt,dsq
+      
+      dimension dxp(mspmf),dyp(mspmf),dzp(mspmf)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf)
+      dimension amt(2),strpmf(9),summas(2)
+      
+c     timestep squared
+      
+      tstep2=tstep*tstep
+      
+c     pmf virial
+      
+      virpmf=0.d0
+      
+c     accumulators for stress tensor
+      
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+      
+c     array bound check
+      
+      if(mxcons.lt.nspmf) call error(idnode,492)
+      if(mspmf .lt.nspmf) call error(idnode,458)
+      
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      img=.true.
+      safep=.false.
+      dis=prmpmf
+      omega2=dis*dis
+      amt(1)= tstep2/summas(1)
+      amt(2)=-tstep2/summas(2)
+      
+      do while(.not.safep.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+        call pmf_vectors
+     x    (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,xxa,yya,zza,
+     x    dxt,dyt,dzt)
+        
+c     check convergence
+        
+        eps=0.d0
+        
+        do k=1,nspmf
+          
+          dsq=dxt(k)**2+dyt(k)**2+dzt(k)**2
+          eps=max(eps,abs((omega2-dsq)/dis))
+          
+        enddo
+        
+        eps=eps*0.5d0
+        
+c     verification of convergence
+        
+        safep=(eps.lt.tolnce)
+        
+c     bypass calculations if converged
+        
+        if(.not.safep)then
+          
+          do k=1,nspmf
+            
+            dsq=dxt(k)**2+dyt(k)**2+dzt(k)**2
+            gamma=(omega2-dsq)/(-(amt(2)-amt(1))*
+     x        (dxp(k)*dxt(k)+dyp(k)*dyt(k)+dzp(k)*dzt(k)))
+            
+c     accumulate pmf virial
+            
+            virpmf=virpmf+gamma*(dxp(k)**2+dyp(k)**2+dzp(k)**2)
+            
+            strs1=strs1-gamma*dxp(k)*dxp(k)
+            strs2=strs2-gamma*dxp(k)*dyp(k)
+            strs3=strs3-gamma*dxp(k)*dzp(k)
+            strs5=strs5-gamma*dyp(k)*dyp(k)
+            strs6=strs6-gamma*dyp(k)*dzp(k)
+            strs9=strs9-gamma*dzp(k)*dzp(k)
+            
+c     improve approximate atomic positions and velocities
+            
+            jj=0
+            do ipmf=1,2
+              
+              gammi=-0.5d0*gamma*amt(ipmf)
+              
+              do i1=1,npmf(ipmf)
+                
+                jj=jj+1
+                i=lstpmf(jj,k)
+                
+                xxx(i)=xxx(i)+dxp(k)*gammi
+                yyy(i)=yyy(i)+dyp(k)*gammi
+                zzz(i)=zzz(i)+dzp(k)*gammi
+                vxx(i)=vxx(i)+dxp(k)*gammi/tstep
+                vyy(i)=vyy(i)+dyp(k)*gammi/tstep
+                vzz(i)=vzz(i)+dzp(k)*gammi/tstep
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      strpmf(1)=strs1
+      strpmf(2)=strs2
+      strpmf(3)=strs3
+      strpmf(4)=strs2
+      strpmf(5)=strs5
+      strpmf(6)=strs6
+      strpmf(7)=strs3
+      strpmf(8)=strs6
+      strpmf(9)=strs9
+      
+c     splice coordinate and velocity arrays across nodes
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=virpmf
+        call gdsum(buffer(1),1,buffer(2))
+        virpmf=buffer(1)
+        call gdsum(strpmf,9,buffer)
+        call splice 
+     x    (idnode,natms,listpm,lstpmt,xxx,yyy,zzz,buffer)
+        call splice 
+     x    (idnode,natms,listpm,lstpmt,vxx,vyy,vzz,buffer)
+        
+      endif
+      
+      return
+      end subroutine pmf_rattle_r
+      
+      subroutine pmf_rattle_v
+     x  (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,summas,
+     x  dxp,dyp,dzp,vxt,vyt,vzt,vxa,vya,vza,vxp,vyp,vzp)
+      
+c***********************************************************************
+c     
+c     dlpoly constraint subroutine for potential of mean force calc.
+c     accumulates velocity correction for second constraint condition
+c     velocity verlet adaptation
+c     
+c     assume bond vectors dxp,dyp,dzp are input
+c     dxp=(sum) wght*xxx(i,1) - (sum) wght*xxx(j,2) etc
+c     
+c     copyright daresbury laboratory
+c     author w.smith october 2005
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safep,img
+      integer idnode,mxnode,imcon,natms,nspmf,icyc,k,jj
+      integer i1,i,ipmf
+      real(8) tstep,tolnce,summas,gamma,vxt,vyt,vzt,vxa,vya,vza
+      real(8) vxp,vyp,vzp,dxp,dyp,dzp,amt,omega,eps,gammi,tolvel
+      
+      dimension dxp(mspmf),dyp(mspmf),dzp(mspmf)
+      dimension vxp(mspmf),vyp(mspmf),vzp(mspmf)
+      dimension vxt(mxatms),vyt(mxatms),vzt(mxatms)
+      dimension vxa(2,mspmf),vya(2,mspmf),vza(2,mspmf)
+      dimension amt(2),summas(2)
+      
+c     constraint convergence tolerance
+      
+      tolvel=tolnce/tstep
+      
+c     array bound check
+      
+      if(mxcons.lt.nspmf) call error(idnode,492)
+      if(mspmf .lt.nspmf) call error(idnode,458)
+      
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      img=.false.
+      safep=.false.
+      amt(1)= 0.5d0*tstep/summas(1)
+      amt(2)=-0.5d0*tstep/summas(2)
+      
+      do while(.not.safep.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+        call pmf_vectors
+     x    (img,nspmf,imcon,cell,vxx,vyy,vzz,vxt,vyt,vzt,vxa,vya,vza,
+     x    vxp,vyp,vzp)
+        
+c     check convergence
+        
+        eps=0.d0
+        do k=1,nspmf
+          
+          omega=dxp(k)*vxp(k)+dyp(k)*vyp(k)+dzp(k)*vzp(k)
+          eps=max(eps,abs(omega)/prmpmf)
+          
+        enddo
+        
+c     verification of convergence
+        
+        safep=(eps.lt.tolvel)
+        
+c     bypass calculations if converged
+        
+        if(.not.safep)then
+          
+          do k=1,nspmf
+            
+            omega=dxp(k)*vxp(k)+dyp(k)*vyp(k)+dzp(k)*vzp(k)
+            gamma=omega/((amt(2)-amt(1))*
+     x        (dxp(k)**2+dyp(k)**2+dzp(k)**2))
+            
+c     improve approximate atomic velocities
+            
+            jj=0
+            do ipmf=1,2
+              
+              gammi=-gamma*amt(ipmf)
+              
+              do i1=1,npmf(ipmf)
+                
+                jj=jj+1
+                i=lstpmf(jj,k)
+                
+                vxx(i)=vxx(i)+dxp(k)*gammi
+                vyy(i)=vyy(i)+dyp(k)*gammi
+                vzz(i)=vzz(i)+dzp(k)*gammi
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     splice velocity arrays across nodes
+      
+      if(mxnode.gt.1)call splice 
+     x  (idnode,natms,listpm,lstpmt,vxx,vyy,vzz,buffer)
+      
+      return
+      end subroutine pmf_rattle_v
+      
+      end module pmf_module
diff -urN dl_class_1.9.orig/srcmod/property_module.f dl_class_1.9/srcmod/property_module.f
--- dl_class_1.9.orig/srcmod/property_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/property_module.f	2014-02-27 13:49:34.000000000 +0100
@@ -0,0 +1,1318 @@
+      module property_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation property data
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use pair_module
+      use setup_module
+      use site_module
+      use tether_module
+      use utility_module
+      use vdw_module
+
+      implicit none
+
+      real(8), allocatable :: rdf(:,:),zdens(:,:)
+      real(8), allocatable :: stpval(:),sumval(:)
+      real(8), allocatable :: ssqval(:),zumval(:)
+      real(8), allocatable :: ravval(:),stkval(:,:)
+      real(8), allocatable :: xx0(:),yy0(:),zz0(:)
+      real(8), allocatable :: amsd(:)
+
+      save rdf,zdens,stpval,sumval,ssqval,xx0,yy0,zz0
+      save zumval,ravval,stkval
+
+      contains
+      
+      subroutine alloc_prp_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=6
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (zdens(mxzdn,mxatyp),stat=fail(1))
+      allocate (rdf(mxrdf,mxxtyp),amsd(mxatyp),stat=fail(2))
+      allocate (stpval(mxnstk),sumval(mxnstk),stat=fail(3))
+      allocate (ssqval(mxnstk),zumval(mxnstk),stat=fail(4))
+      allocate (ravval(mxnstk),stkval(mxstak,mxnstk),stat=fail(5))
+      allocate (xx0(mxatms),yy0(mxatms),zz0(mxatms),stat=fail(6))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1740)
+      enddo
+
+      end subroutine alloc_prp_arrays
+
+      subroutine result
+     x  (ltad,lbpd,lgofr,lpgr,lzden,idnode,imcon,keyens,mxnode,natms,
+     x  levcfg,nzden,nstep,ntpatm,numacc,numrdf,keybpd,chip,chit,conint,
+     x  rcut,tstep,engcfg,volm,virtot,vircom,zlen,tboost,chit_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing simulation summary and
+c     saving the restart data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*1 hms,dec
+      logical lgofr,lpgr,lzden,check,ltad,lbpd,goprint
+      
+      integer idnode,imcon,keyens,mxnode,natms,nzden,nstep,ntpatm
+      integer levcfg,numacc,numrdf,keybpd,i,iadd,io,j
+      real(8) chip,chit,conint,rcut,tstep,volm,timelp,avvol,zlen,dc
+      real(8) engcfg,virtot,vircom,prntim,simtim,tboost,chit_shl
+
+c     save restart data
+      
+      call revive
+     x  (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x  numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x  tboost,chit_shl)
+
+c     for TAD and BPD system averages not generally meaningful 
+c     useful only for BPD in configurational sampling mode
+      
+      goprint=.not.(ltad.or.(lbpd.and.keybpd.gt.1))
+      
+      if(goprint)then
+        
+c     calculate final fluctuations
+        
+        do i=1,mxnstk
+          ssqval(i)=sqrt(max(0.d0,ssqval(i)))
+        enddo
+        
+c     final averages and fluctuations
+        
+        call timchk(0,timelp)
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,
+     x      "(/,/,1x,'run terminated after',i8,' steps.',
+     x      ' final averages calculated over',i8,' steps.',/,/)") 
+     x      nstep,numacc
+          write(nrite,"(1x,120('-'),
+     x      /,/,1x,'    step',5x,'eng_tot',4x,'temp_tot',5x,'eng_cfg',
+     x      5x,'eng_vdw',5x,'eng_cou',5x,'eng_bnd',5x,'eng_ang',5x,
+     x      'eng_dih',5x,'eng_tet',/,1x,'time    ',5x,' eng_pv',4x,
+     x      'temp_rot',5x,'vir_cfg',5x,'vir_vdw',5x,'vir_cou',5x,
+     x      'vir_bnd',5x,'vir_ang',5x,'vir_con',5x,'vir_tet',/,
+     x      1x,'cpu time',6x,'volume',4x,'temp_shl',5x,'eng_shl',
+     x      5x,'vir_shl',7x,'alpha',8x,'beta',7x,'gamma',5x,'vir_pmf',
+     x      7x,'press',/,/,
+     x      1x,120('-'))")          
+          
+          call get_prntime(hms,timelp,prntim)
+          call get_simtime(dec,nstep,tstep,simtim)
+          write(nrite,'(1x,i8,1p,9e12.4,/,1x,0p,f7.3,a1,1p,9e12.4,
+     x      /,1x,0p,f7.3,a1,1p,9e12.4)') 
+     x      nstep,(sumval(i),i=1,9),
+     x      simtim,dec,(sumval(i),i=10,18),
+     x      prntim,hms,(sumval(i),i=19,27)
+          write(nrite,"(/,1x,' r.m.s. ',1p,9e12.4,/,1x,'fluctn. ',
+     x      1p,9e12.4,/,9x,9e12.4)") (ssqval(i),i=1,27)
+          write(nrite,"(1x,120('-'))")
+          
+c     write out bias potential boost factor
+          
+          if(lbpd)write(nrite,"(/,/,1x,
+     x      'calculated bias potential boost factor',1p,e16.8)")tboost
+          
+          if(numacc.gt.0)then
+            iadd=27
+            
+c     write out estimated diffusion coefficients
+            
+            if(numacc.gt.0)then
+              
+              write(nrite,"(/,/,12x,'Approximate 3D Diffusion',
+     x          '  coefficients (10^-9 m^2 / s)',/,/,12x,'atom',7x,
+     x          ' D ')")
+              
+              do i=1,ntpatm
+                
+                iadd=iadd+1
+                dc=(ravval(iadd)-sumval(iadd))/
+     x            (3.d0*dble(numacc-min(mxnstk,numacc-1))*tstep)*10.d0
+                if(dc.lt.1d-10) dc=0.d0
+                if(lbpd)dc=dc/tboost
+                write(nrite,'(12x,a8,1p,e13.4)') unqatm(i),dc
+                
+              enddo
+              
+            endif
+            
+c     print out average pressure tensor
+            
+            write(nrite,"(/,/,16x,'Average pressure tensor',
+     x        39x,'r.m.s. fluctuations ',/)")
+            
+            do i=iadd,iadd+6,3
+              write(nrite,'(9x,1p,3e12.4,24x,3e12.4)')
+     x          (sumval(i+j),j=1,3),(ssqval(i+j),j=1,3)
+            enddo
+            iadd=iadd+9
+            
+            write(nrite,'(/,12x,a,1p,e12.4)') 'trace/3. ',
+     x        (sumval(iadd)+sumval(iadd-4)+sumval(iadd-8))/3.d0
+            
+c     write out mean cell vectors for npt 
+            
+            if(keyens.gt.3.and.(keyens.le.7))then
+              
+              write(nrite,"(/,/,17x,'Average cell vectors',
+     x          41x,'r.m.s. fluctuations ',/)")
+              
+              do i=iadd,iadd+6,3
+                write(nrite,'(3f20.10,9x,1p,3e12.4)')
+     x            (sumval(i+j),j=1,3),(ssqval(i+j),j=1,3)
+              enddo
+              iadd=iadd+9
+              
+            endif
+            
+c     write out remaining registers
+            
+            check=.false.
+            do i=iadd+1,mxnstk
+              
+              if((abs(sumval(i)).gt.1.d-10).or.
+     x          (abs(ssqval(i)).gt.1.d-10)) check=.true.
+              
+            enddo
+            
+            if(check)then
+              
+              write(nrite,"(/,/,12x,
+     x          'Remaining non-zero statistics registers ',/,/,12x,
+     x          'Register',7x,'Average value',8x,'r.m.s. fluc.')")
+              
+              do i=iadd+1,mxnstk
+                
+                if((abs(sumval(i)).gt.1.d-10).or.
+     x            (abs(ssqval(i)).gt.1.d-10))
+     x            write(nrite,'(10x,i10,2f20.10)') i,sumval(i),ssqval(i)
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+c     print out sample of final configuration 
+          
+          write(nrite,"(/,/,1x,'sample of final configuration',/)")
+          write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x      7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',7x,'fx(i)',7x,
+     x      'fy(i)',7x,'fz(i)',/,/)")
+          io=(natms+19)/20
+          
+          do i=1,natms,io
+            
+            write(nrite,"(1x,i6,1p,3e12.4,3e12.4,3e12.4)") 
+     x        i,xxx(i),yyy(i),zzz(i),vxx(i),vyy(i),vzz(i),
+     x        fxx(i),fyy(i),fzz(i)
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     bypass printing averages for certain tad and bpd options
+      
+      if(goprint)then
+        
+c     average volume
+        
+        avvol=sumval(19)
+        if(imcon.eq.0.or.imcon.eq.6)then
+          avvol=4.d0*pi/3.d0*rcut**3
+          volm=avvol
+        endif
+        
+c     calculate and print radial distribution functions
+        
+        if(lgofr.and.lpgr.and.(numrdf.gt.0))then 
+          
+c     scale densities for average volume
+          
+          do i=1,ntpatm
+            dens(i)=dens(i)*(volm/avvol)
+          enddo
+          
+          call rdf1
+     x      (lpgr,idnode,mxnode,ntpatm,numrdf,avvol,rcut)
+          
+        endif
+        
+        if(lzden.and.lpgr.and.(nzden.gt.0))then 
+          call zden1(lpgr,idnode,mxnode,ntpatm,nzden,avvol,zlen)
+        endif
+        
+        if(imcon.eq.0)volm=0.d0
+        
+      endif
+      
+c     print final time check
+        
+      call timchk(1,timelp)
+        
+      return
+      end subroutine result
+
+      subroutine diffsn0(idnode,natms,mxnode,tstep)
+
+c***********************************************************************
+c     
+c     DL_POLY routine for calculating displacements of sites from
+c     t=0 positions
+c     
+c     use diffsn1 for mean squared displacements
+c     
+c     parallel version - replicated data.
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author - t. forester      june 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical newjob 
+      integer idnode,natms,mxnode,iatm1,iatm2,i
+      real(8) tstep
+
+      save newjob,iatm1,iatm2
+      data newjob/.true./
+
+      if(newjob)then
+
+        newjob=.false.
+        iatm1=(idnode*natms)/mxnode+1
+        iatm2=((idnode+1)*natms)/mxnode
+
+      endif
+
+      do i=iatm1,iatm2
+
+        xx0(i)=xx0(i)+vxx(i)*tstep
+        yy0(i)=yy0(i)+vyy(i)*tstep
+        zz0(i)=zz0(i)+vzz(i)*tstep
+        
+      enddo
+      
+      return
+      end subroutine diffsn0
+
+      subroutine diffsn1(idnode,natms,ntpatm,mxnode)
+      
+c***********************************************************************
+c     
+c     DL_POLY routine for calculating mean squared displacements
+c     
+c     displacements calculated in diffsn0
+c     
+c     parallel version - replicated data.
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author - t. forester      june 1993
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical newjob
+      integer idnode,natms,ntpatm,mxnode,iatm1,iatm2,k,i
+
+      save newjob,iatm1,iatm2
+
+      data newjob/.true./
+
+      if(newjob)then
+
+        newjob=.false.
+        iatm1=(idnode*natms)/mxnode+1
+        iatm2=((idnode+1)*natms)/mxnode
+
+      endif
+
+c     running sum of squared displacements
+      
+      do k=1,ntpatm
+        
+        amsd(k)=0.d0
+        
+      enddo
+      
+c     calculate square of displacements for each atom type
+
+      do i=iatm1,iatm2
+        
+        k=ltype(i)
+        amsd(k)=amsd(k)+xx0(i)**2+yy0(i)**2+zz0(i)**2
+        
+      enddo
+      
+c     global sum - replicated data strategy
+      
+      if(mxnode.gt.1)then
+        
+        do k=1,ntpatm
+          
+          buffer(k+ntpatm)=amsd(k)
+          
+        enddo
+        
+        call  gdsum(buffer(1+ntpatm),ntpatm,buffer(1))
+        
+        do k=1,ntpatm
+          
+          amsd(k)=buffer(k+ntpatm)
+          
+        enddo
+        
+      endif
+      
+c     mean squared displacement
+      
+      do k=1,ntpatm
+        
+        amsd(k)=amsd(k)/dble(max(numtyp(k),1))
+        
+      enddo
+      
+      return
+      end subroutine diffsn1
+
+      subroutine rdf0(iatm,ik,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating statistic for radial
+c     distribution functions.
+c     double precision accumulators
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,ik,m,jatm,ll,k
+      real(8) rcut,rcsq,rdelr,ai,aj,rsq,rrr
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut*rcut
+
+c     grid interval for rdf tables
+
+      rdelr=dble(mxrdf)/rcut
+
+c     set up atom iatm type
+
+      ai=ltype(iatm) 
+
+c     start of primary loop for rdf accumulation
+
+      do m=1,ik
+
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+
+        aj=ltype(jatm)
+        if(ai.gt.aj)then
+          k=int(ai*(ai-1.d0)*0.5d0+aj+0.5d0)
+        else
+          k=int(aj*(aj-1.d0)*0.5d0+ai+0.5d0)
+        endif
+
+c     apply truncation of potential
+        
+        rsq=rsqdf(m)
+        
+        if(rcsq.gt.rsq)then
+
+          rrr=sqrt(rsq)
+          ll=Min(1+Int(rrr*rdelr),mxrdf)
+
+c     accumulate statistics
+
+          rdf(ll,k)=rdf(ll,k)+1.d0
+
+        endif
+        
+      enddo
+      
+      return
+      end subroutine rdf0
+
+      subroutine rdf1
+     x   (lpgr,idnode,mxnode,ntpatm,numrdf,volm,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating radial distribution functions
+c     from accumulated data.
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntpatm,numrdf,ia,ib,k,j
+      real(8) volm,factor,sum,rrr,dvol,gofr,rcut,delrdf
+      
+      logical lpgr,zero
+
+      if(idnode.eq.0) write(nrite,
+     x   "(/,/,12X,'RADIAL DISTRIBUTION FUNCTIONS',/,/,
+     x   'calculated using ',i10,' configurations')") numrdf
+
+      if(lpgr)then
+        
+c     open RDF file and write headers
+        
+        if(idnode.eq.0)then
+          
+          open(nrdfdt,file='RDFDAT')
+          
+          write(nrdfdt,'(80a1)')cfgname
+          write(nrdfdt,'(2i10)')mxxtyp,mxrdf
+          
+        endif
+
+c     default bin width
+        
+        delrdf=rcut/dble(mxrdf)
+        
+c     construct rdf tables
+        
+        do ia=1,ntpatm
+          
+          do ib=ia,ntpatm
+            
+            k=(ib*(ib-1))/2+ia
+            
+            if(idnode.eq.0)then
+                
+              write(nrite,
+     x         "(/,'g(r)  :',2a8,/,/,8x,'r',6x,'g(r)',9x,'n(r)',/)") 
+     x           unqatm(ia),unqatm(ib)
+              write(nrdfdt,'(2a8)')unqatm(ia),unqatm(ib)
+              
+            endif
+              
+c     global sum of data on all nodes
+            
+            if(mxnode.gt.1) call gdsum(rdf(1,k),mxrdf,buffer)
+            
+c     normalisation factor 
+            
+            factor=volm*dens(ia)*dens(ib)*dble(numrdf)
+            if((ia.eq.ib).and.(volm*dens(ia).gt.1.d0)) 
+     x         factor=factor*0.5d0
+            
+c     running integration of rdf
+            
+            sum=0.d0
+              
+c     loop over distances
+              
+            zero=.true.
+            
+            do j=1,mxrdf
+              
+              if(zero.and.(j.lt.mxrdf-3)) 
+     x          zero=(rdf(j+2,k).le.0.d0)
+              
+              rrr=(dble(j)-0.5d0)*delrdf
+              dvol=4.d0*pi*(delrdf*rrr*rrr+(delrdf**3)/12.d0)
+              
+              gofr=rdf(j,k)/(factor*dvol)
+              sum=sum+gofr*dvol*dens(ib)
+              
+c     print out information
+                
+              if(idnode.eq.0)then
+                
+                write(nrdfdt,"(1p,2e14.6)")rrr,gofr
+                if(.not.zero)
+     x             write(nrite,"(f10.4,1p,2e14.6)")rrr,gofr,sum
+                
+              endif
+              
+            enddo
+              
+          enddo
+          
+        enddo
+        
+        if(idnode.eq.0)close (nrdfdt)
+        
+      endif
+      
+      return
+      end subroutine rdf1
+
+      subroutine static
+     x  (lbpd,lzeql,idnode,intsta,imcon,keyens,natms,nstack,
+     x  nstep,nsteql,ntpatm,numacc,mxnode,nblock,keybpd,numbpd,
+     x  consv,degfre,degrot,engang,engbnd,engcpe,engdih,enginv,
+     x  engke,engrot,engsrp,engunit,engcfg,stpeng,stpeth,stpprs,
+     x  stptmp,stpvir,stpvol,tstep,virbnd,engfbp,vircom,vircon,
+     x  vircpe,virsrp,engfld,virfld,engtbp,virtbp,virpmf,virshl,
+     x  engshl,engtet,virtet,degshl,shlke,virang,width,engmet,
+     x  virmet,engter,virter,boost,tboost)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating periodic data during the
+c     molecular dynamics simulation and computing the rolling averages
+c     
+c     copyright daresbury laboratory 1992
+c     
+c     author - w. smith       august 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical lbpd,lzeql,newjob
+      integer idnode,intsta,imcon,keyens,natms,nstack,nstep,j
+      integer nsteql,ntpatm,numacc,mxnode,i,iadd,k,kstak
+      integer nblock,keybpd,numbpd
+      real(8) consv,degfre,degrot,engang,engbnd,engcpe,engdih
+      real(8) enginv,engke,engrot,engsrp,engunit,engcfg,stpeng
+      real(8) stpeth,stpprs,stptmp,stpvir,stpvol,tstep,virbnd
+      real(8) engfbp,vircom,vircon,vircpe,virsrp,engfld,virfld
+      real(8) engtbp,virtbp,virpmf,virshl,engshl,engtet,virtet
+      real(8) degshl,shlke,virang,width,sclnv1,sclnv2,stprot
+      real(8) stpcns,stpshl,zistk,engmet,virmet,engter,virter
+      real(8) tbold,aterm,bterm,cterm,boost,tboost
+
+      save newjob
+      
+      data newjob/.true./
+
+c     open statistics file for append
+      
+      if(newjob.and.idnode.eq.0.and.intsta.gt.0)then
+
+        open(nstats,file='STATIS',position='append')
+        newjob=.false.
+        
+      endif
+      
+      if(idnode.eq.0.and.nstep.eq.intsta.and.intsta.gt.0)then
+        
+        write(nstats,'(80a1)') cfgname
+        if(abs(engunit-9648.530821d0).le.1.d-10) write(nstats,
+     x    "(' ENERGY UNITS=electron Volts ')")
+        if(abs(engunit-9648530.821d0).le.1.d-10) write(nstats,
+     x    "(' ENERGY UNITS=kilo electron Volts ')")
+        if(abs(engunit-418.4d0).le.1.d-10)       write(nstats,
+     x    "(' ENERGY UNITS=kcal/mol ')")
+        if(abs(engunit-1.d2).le.1.d-10)          write(nstats,
+     x    "(' ENERGY UNITS=kjoule/mol ')")
+        if(abs(engunit-boltz).lt.1.d-10)         write(nstats,
+     x    "(' ENERGY UNITS=kelvin ')")
+        if(abs(engunit-1.d0).lt.1.d-10)          write(nstats,
+     x    "(' ENERGY UNITS=DL_POLY Internal Units ')")
+        
+      endif
+      
+c     calculate cell volume and minimum cell half-width
+      
+      if(imcon.eq.0)then
+        
+        width=0.d0
+        
+        stpvol=0.d0
+        do i=1,10
+           celprp(i)=0.d0
+        enddo
+        
+      else
+        
+        call dcell(cell,celprp)
+        stpvol=celprp(10)
+        width=min(celprp(7),celprp(8),celprp(9))/2.d0
+        
+        if(imcon.eq.4)then
+
+          stpvol=0.5d0*celprp(10)
+          width=sqrt(3.d0)*cell(1)/4.d0
+
+        elseif(imcon.eq.5)then
+        
+          stpvol=0.5d0*celprp(10)
+          width=cell(1)/2.d0
+
+        elseif(imcon.eq.6)then
+
+          width=min(celprp(7),celprp(8))/2.d0
+
+        elseif(imcon.eq.7)then
+        
+          stpvol=0.5d0*celprp(10)
+
+        endif
+        
+      endif
+
+c     energetic properties of system
+      
+      stpvir=virsrp+vircpe+virbnd+vircon+vircom+virtbp+virang
+     x  +virshl+virtet+virter+virmet+virfld
+      stpeng=engcfg+engke+engrot
+      stprot=2.d0*engrot/(boltz*max(1.d0,degrot))
+      stpshl=2.d0*shlke/(boltz*max(1.d0,degshl))
+      stptmp=2.d0*(engke+engrot)/(boltz*degfre)
+      stpprs=0.d0
+      if(imcon.gt.0)stpprs=(2.d0*engke-stpvir)/(3.d0*stpvol)
+      stpeth=stpeng+stpprs*stpvol
+      stpcns=stpeng+consv
+      
+c     convert pressure to units of katm
+      
+      stpprs=stpprs*prsunt
+      
+c     calculate mean squared displacements 
+c     atomic displacements from origin of production run
+      
+      if((.not.lzeql).or.(nstep.gt.nsteql))then
+
+        call diffsn0(idnode,natms,mxnode,tstep)
+        call diffsn1(idnode,natms,ntpatm,mxnode)
+        
+      endif
+
+c     zero statistics arrays
+      
+      if((nstep.le.0).or.(numacc.eq.0))then
+        
+        numacc=0
+        
+        do i=1,mxnstk
+          
+          stpval(i)=0.d0
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          
+        enddo
+        
+        do i=1,mxatms
+          
+          xx0(i)=0.d0
+          yy0(i)=0.d0
+          zz0(i)=0.d0
+          
+        enddo
+        
+      endif
+      
+c     store current values in statistics array
+      
+      stpval(1) =stpcns/engunit
+      stpval(2) =stptmp
+      stpval(3) =engcfg/engunit
+      stpval(4) =(engsrp+engmet+engter)/engunit
+      stpval(5) =engcpe/engunit
+      stpval(6) =engbnd/engunit
+      stpval(7) =(engang+engtbp)/engunit
+      stpval(8) =(engdih+enginv+engfbp)/engunit
+      stpval(9) =engtet/engunit
+      stpval(10)=stpeth/engunit
+      stpval(11)=stprot
+      stpval(12)=stpvir/engunit
+      stpval(13)=(virsrp+virmet+virter)/engunit
+      stpval(14)=vircpe/engunit
+      stpval(15)=virbnd/engunit
+      stpval(16)=(virtbp+virang)/engunit
+      stpval(17)=vircon/engunit
+      stpval(18)=virtet/engunit
+      stpval(19)=stpvol
+      stpval(20)=stpshl
+      stpval(21)=engshl/engunit
+      stpval(22)=virshl/engunit
+      stpval(23)=acos(celprp(6))*180.d0/pi
+      stpval(24)=acos(celprp(5))*180.d0/pi
+      stpval(25)=acos(celprp(4))*180.d0/pi
+      stpval(26)=virpmf/engunit
+      stpval(27)=stpprs
+
+      iadd=27
+
+c     mean squared displacements 
+      
+      if((.not.lzeql).or.(nstep.gt.nsteql))then
+        
+        do k=1,ntpatm
+          
+          stpval(iadd+k)=amsd(k)
+          
+        enddo
+        
+      endif
+
+      iadd=iadd+ntpatm
+
+c     stress tensor
+
+      if(abs(stpvol).le.1.d-10) stpvol=1.d0
+      do i=1,9
+        stpval(iadd+i)=stress(i)*prsunt/(stpvol)
+      enddo
+      iadd=iadd+9
+
+c     cell vectors
+      
+      if(keyens.gt.3.and.(keyens.le.7))then
+        do i=1,9
+          stpval(iadd+i)=cell(i)
+        enddo
+        iadd=iadd+9
+      endif
+
+c     check on number of variables for stack - 
+      
+      if(iadd.gt.mxnstk) call error(idnode,170)
+
+c     accumulate totals over steps
+      
+      numacc=numacc+1
+      sclnv2=1.d0/dble(numacc)
+      sclnv1=dble(numacc-1)/dble(numacc)
+      
+      if(lbpd.and.keybpd.eq.1)then
+        
+c     calculate true thermodynamic averages in bias potential system
+c     note integers numacc and numbpd should be equal in this case
+        
+        tbold=tboost*dble(numbpd)/dble(numbpd-1)-boost/dble(numbpd-1)
+        cterm=0.d0
+        do i=1,mxnstk
+          
+          aterm=sumval(i)*tbold
+          bterm=ssqval(i)*tbold**2
+          if(tbold.gt.0.d0)cterm=(bterm+aterm**2)/tbold
+          ssqval(i)=(sclnv1*(sclnv1*bterm+boost*sclnv2*(cterm+
+     x      (tbold*stpval(i)-2.d0*aterm)*stpval(i))))/tboost**2
+          sumval(i)=(sclnv1*aterm+boost*sclnv2*stpval(i))/tboost
+          
+        enddo
+        
+      else
+        
+c     calculate true thermodynamic averages in normal system
+
+        do i=1,mxnstk
+          
+          ssqval(i)=sclnv1*(ssqval(i)+sclnv2*(stpval(i)-sumval(i))**2)
+          sumval(i)=sclnv1*sumval(i)+sclnv2*stpval(i)
+          
+        enddo
+        
+      endif
+      
+c     write statistics file
+      
+      if(idnode.eq.0.and.intsta.gt.0)then
+
+        if(mod(nstep,intsta).eq.0)then
+        
+          write(nstats,'(i10,1p,e14.6,0p,i10,/,(1p,5e14.6))')
+     x       nstep,nstep*tstep,iadd,(stpval(k),k=1,iadd)
+          call flush(nstats)
+c$$$c     write option for Excel spreadsheet
+c$$$          write(nstats,'(i10,1p,e14.6,0p,i10,300(1p,5e14.6))')
+c$$$     x      nstep,nstep*tstep,iadd,(stpval(k),k=1,iadd)
+
+        endif
+        
+      endif
+      
+c     zero rolling average accumulators
+      
+      if(nstep.le.0)then
+        
+        numacc=0
+        
+        do i=1,mxnstk
+          
+          zumval(i)=0.d0
+          
+          do j=1,mxstak
+            
+            stkval(j,i)=0.d0
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+c     store quantities in stack
+      
+      kstak=mod(nstep-1,nstack)+1
+      
+      if(nstep.gt.nstack)then
+        
+        do i=1,mxnstk
+          
+          zumval(i)=zumval(i)-stkval(kstak,i)
+          
+        enddo
+        
+      endif
+      
+      do i=1,mxnstk
+        
+        stkval(kstak,i)=stpval(i)
+        zumval(i)=zumval(i)+stpval(i)
+        
+      enddo
+      
+c     calculate rolling averages
+      
+      zistk=min(nstack,nstep)
+      
+      do i=1,mxnstk
+        
+        ravval(i)=zumval(i)/zistk
+        
+      enddo
+      
+c     zero accumulators during equilibration period
+      
+      if(lzeql.and.nstep.le.nsteql)then
+        
+        numacc=0
+        do i=1,mxnstk
+          
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          
+        enddo
+        
+      endif
+
+c     close statistics file at regular intervals
+      
+      if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+        
+        if(idnode.eq.0)close (nstats)
+        newjob=.true.
+        
+      endif
+      
+      return
+      end subroutine static
+
+      subroutine revive
+     x  (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x  numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x  tboost,chit_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing restart files at job termination
+c     or at selected intervals in simulation
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     
+c***********************************************************************
+     
+      implicit none
+      
+      logical lgofr,lzden
+      integer idnode,imcon,mxnode,natms,nstep,nzden,numacc,numrdf
+      integer levcfg,nsum,nbuff,i,j
+      real(8) chip,chit,conint,tstep,engcfg,rmxnode,virtot,vircom
+      real(8) tboost,chit_shl
+
+      if(mxnode.gt.1)then
+
+c     merge displacement data
+
+        call merge(idnode,mxnode,natms,mxbuff,xx0,yy0,zz0,buffer)
+
+c     globally sum rdf information before saving
+        
+        if(lgofr)then
+
+c     maximum rdfs that can be summed in each step
+          
+          nsum=mxbuff/mxrdf
+          if(nsum.eq.0) call error(idnode,200)
+          
+          nbuff=nsum*mxrdf
+          
+          do i=1,mxxtyp,nsum
+            
+            if((mxxtyp+1-i).lt.nsum) nbuff=(mxxtyp+1-i)*mxrdf
+            call  gdsum(rdf(1,i),nbuff,buffer)
+            
+          enddo
+          
+        endif
+
+c     globally sum zden information before saving
+        
+        if(lzden)then
+
+c     maximum zdfs that can be summed in each step
+          
+          nsum=mxbuff/mxzdn
+          if(nsum.eq.0) call error(idnode,200)
+          
+          nbuff=nsum*mxzdn
+          
+          do i =1,mxatyp,nsum
+            
+            if((mxatyp+1-i).lt.nsum) nbuff=(mxatyp+1-i)*mxzdn
+            call  gdsum(zdens(1,i),nbuff,buffer)
+            
+          enddo
+          
+        endif
+        
+      endif
+
+c     node 0 handles i/o
+
+      if(idnode.eq.0)then
+
+c     write configuration data to new configuration file
+
+        call config_write('REVCON',levcfg,imcon,natms,engcfg)
+
+c     write accumulator data to dump file
+        
+        open(nrest,file='REVIVE',form='unformatted')
+        
+        write(nrest) dble(nstep),dble(numacc),dble(numrdf),chit,
+     x    chip,conint,dble(nzden),tboost,chit_shl
+        write(nrest) virtot,vircom,eta,strcns,strbod
+        write(nrest) stpval
+        write(nrest) sumval
+        write(nrest) ssqval
+        write(nrest) zumval
+        write(nrest) ravval
+        write(nrest) stkval
+        write(nrest) xx0,yy0,zz0
+        write(nrest) xxs,yys,zzs
+        if(lgofr) write(nrest) rdf
+        if(lzden) write(nrest) zdens
+        
+        close (nrest)
+
+      endif
+
+c     divide rdf data between nodes
+      
+      rmxnode=1.d0/dble(mxnode)
+      
+      if(lgofr)then
+        
+        do i=1,mxxtyp
+          
+          do j=1,mxrdf
+            
+            rdf(j,i)=rdf(j,i)*rmxnode
+            
+          enddo
+          
+        enddo
+        
+      endif
+
+c     divide zdensity data between nodes
+
+      if(lzden)then
+        
+        do i=1,mxatyp
+          
+          do j=1,mxzdn
+            
+            zdens(j,i)=zdens(j,i)*rmxnode
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine revive
+
+      subroutine zden0(idnode,natms,mxnode,nzden,zlen)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating statistic for density profile
+c     zlen=length of cell in z direction
+c     
+c     double precision accumulators
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,nzden,iatm,ll,k
+      real(8) zlen,zleno2,rzdn
+
+c     accumulator
+
+      nzden=nzden+1
+
+c     half of z length
+
+      zleno2=zlen*0.5d0
+
+c     grid interval for density profiles
+
+      rzdn=dble(mxzdn)/zlen
+
+c     set up atom iatm type
+
+      do iatm=idnode+1,natms,mxnode
+
+        k =ltype(iatm) 
+
+        ll=int((zzz(iatm)+zleno2)*rzdn+1.0d0)
+
+c     accumulate statistic
+
+        if(ll.gt.0.and.ll.le.mxzdn)zdens(ll,k)=zdens(ll,k)+1.d0
+
+      enddo
+      
+      return
+      end subroutine zden0
+
+      subroutine zden1
+     x  (lpgr,idnode,mxnode,ntpatm,nzden,volm,zlen)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating Z density profile
+c     from accumulated data.
+c     double precision version
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lpgr
+      integer idnode,mxnode,ntpatm,nzden,k,j
+      real(8) volm,zlen,delzdn,dvolz,factor,sum,rrr,rho
+
+      if(idnode.eq.0) write(nrite,
+     x  "(/,/,12X,'Z DENSITY PROFILES',/,/,
+     x  'calculated using ',i10,' configurations')") nzden
+      
+      if(lpgr)then
+
+c     open Z density file and write headers
+
+        if(idnode.eq.0)then
+
+          open(nzdndt,file='ZDNDAT')
+
+          write(nzdndt,'(80a1)')cfgname
+          write(nzdndt,'(2i10)')ntpatm,mxzdn
+
+        endif
+
+c     volume of z strip (arbitrary)
+
+        delzdn=zlen/dble(mxzdn)
+        dvolz=(volm/zlen)*delzdn
+        
+c     normalisation factor 
+        
+        nzden=max(nzden,1)
+        factor=1.d0/(dble(nzden)*dvolz)
+
+        do k=1,ntpatm
+          
+          if(idnode.eq.0)then
+
+             write(nrite,
+     x      "(/,'rho(r)  :',a8,/,/,8x,'r',6x,'rho',9x,'n(r)',/)")
+     x      unqatm(k)
+             write(nzdndt,'(a8)')unqatm(k)
+
+          endif
+
+c     global sum of data on all nodes
+          
+          if(mxnode.gt.1)call gdsum(zdens(1,k),mxzdn,buffer)
+
+c     running integration of z-density
+          
+          sum=0.d0
+
+c     loop over distances
+          
+          do j=1,mxzdn
+            
+            rrr=(dble(j)-0.5d0)*delzdn-zlen*0.5d0
+            rho=zdens(j,k)*factor
+            sum=sum+rho*dvolz
+
+c     print out information
+            
+            if(idnode.eq.0)then
+
+              write(nrite,"(f10.4,1p,2e14.6)") rrr,rho,sum
+              write(nzdndt,"(1p,2e14.6)") rrr,rho
+
+            endif
+            
+          enddo
+          
+        enddo
+        
+        if(idnode.eq.0)close (nzdndt)
+
+      endif
+      
+      return
+      end subroutine zden1
+
+      subroutine rdf0neu(ik,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating statistic for radial
+c     distribution functions.
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     amended     t. forester    april 1994
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer ik,m,iatm,jatm,ll,k
+      real(8) rcut,a0,a1,a2,a3,a4,a5,rcsq,rrcsq,sqlim,rdelr
+      real(8) ai,aj,rsq,rrr,sss
+      
+      data a0,a1,a2,a3,a4,a5/.0837557783d0,2.9399054d0,-7.8475201d0,
+     x  14.1328992d0,-12.6228528d0,4.32084948d0/
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      rrcsq=1.d0/rcsq
+      sqlim=0.01d0*rcsq
+      
+c     grid interval for rdf tables
+      
+      rdelr=dble(mxrdf)/rcut
+
+c     start of primary loop for rdf accumulation
+      
+      do m=1,ik
+        
+c     atomic and potential function indices
+        
+        iatm=ilist(m)
+        ai=ltype(iatm)
+        
+        jatm=jlist(m) 
+        aj=ltype(jatm)
+        
+        if(ai.gt.aj)then
+          ll=int(ai*(ai-1.d0)*0.5d0+aj+0.5d0)
+          k=lstvdw(ll)
+        else
+          ll=int(aj*(aj-1.d0)*0.5d0+ai+0.5d0)
+          k=lstvdw(ll)
+        endif
+        
+        rsq=rsqdf(m)
+        
+        if(rcsq.gt.rsq)then
+          
+c     determine interpolation panel for rdf table
+          
+          if(rsq.lt.sqlim)then
+            
+            rrr=sqrt(rsq)
+            
+          else
+
+c     interpolate square-root by polynomial plus newton-raphson
+            
+            sss=rsq*rrcsq
+            rrr=1.d0/
+     x        (a0 +sss*(a1+sss*(a2+sss*(a3+sss*(a4+sss*a5)))))
+            rrr=0.5d0*rrr*(3.d0-sss*rrr*rrr)
+            rrr=0.5d0*rrr*(3.d0-sss*rrr*rrr)
+            rrr=0.5d0*rrr*(3.d0-sss*rrr*rrr)*sss*rcut
+            
+          endif
+          
+          ll=int(rrr*rdelr+0.999999d0)
+
+c     accumulate statistics
+          
+          rdf(ll,k)=rdf(ll,k)+1.d0
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine rdf0neu
+      
+      end module property_module
diff -urN dl_class_1.9.orig/srcmod/rigid_body_module.f dl_class_1.9/srcmod/rigid_body_module.f
--- dl_class_1.9.orig/srcmod/rigid_body_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/rigid_body_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,243 @@
+      module rigid_body_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining rigid body arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      
+      implicit none
+      
+      real(8), allocatable :: omx(:),omy(:),omz(:)
+      real(8), allocatable :: gcmx(:),gcmy(:),gcmz(:)
+      real(8), allocatable :: gvxx(:),gvyy(:),gvzz(:),gmass(:)
+      real(8), allocatable :: q0(:),q1(:),q2(:),q3(:)
+      real(8), allocatable :: gxx(:,:),gyy(:,:),gzz(:,:)
+      real(8), allocatable :: rotinx(:,:),rotiny(:,:),rotinz(:,:)
+      integer, allocatable :: lstrgd(:),numgsit(:),lstgtp(:)
+      integer, allocatable :: listyp(:),lstgst(:,:),lstfre(:)
+      integer, allocatable :: lstme(:),lstbod(:),lstcsit(:)
+      
+      save omx,omy,omz,gcmx,gcmy,gcmz,gvxx,gvyy,gvzz,gmass
+      save q0,q1,q2,q3,gxx,gyy,gzz,rotinx,rotiny,rotinz
+      save lstrgd,numgsit,lstgtp,listyp,lstgst,lstfre,lstme
+      save lstbod,lstcsit
+      
+      contains
+      
+      subroutine alloc_rgbdy_arrays(idnode)
+      
+      implicit none
+      
+      integer, parameter :: nnn=12
+      
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (omx(mxgrp),omy(mxgrp),omz(mxgrp),stat=fail(1))
+      allocate (gcmx(mxgrp),gcmy(mxgrp),gcmz(mxgrp),stat=fail(2))
+      allocate (gvxx(mxgrp),gvyy(mxgrp),gvzz(mxgrp),stat=fail(3))
+      allocate (q0(mxgrp),q1(mxgrp),q2(mxgrp),q3(mxgrp),stat=fail(4))
+      allocate (gxx(mxungp,mxngp),gyy(mxungp,mxngp),stat=fail(5))
+      allocate (gzz(mxungp,mxngp),gmass(mxungp),stat=fail(6))
+      allocate (rotinx(mxungp,2),rotiny(mxungp,2),stat=fail(7))
+      allocate (rotinz(mxungp,2),lstgtp(mxgrp),stat=fail(8))
+      allocate (lstrgd(mxgatm),numgsit(mxungp),stat=fail(9))
+      allocate (listyp(mxungp),lstgst(mxungp,mxngp),stat=fail(10))
+      allocate (lstfre(mxatms),lstme(mxatms),stat=fail(11))
+      allocate (lstbod(mxatms),lstcsit(2*mxcons),stat=fail(12))
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1013)
+      enddo
+      
+      end subroutine alloc_rgbdy_arrays
+      
+      subroutine define_rigid_body
+     x  (safe,lghost,idnode,itmols,ngrp,natmsr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining rigid bodies
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     adapted   - p-a cazade  oct 2007,  solvation, excitation etc.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lghost,site_test
+      integer idnode,itmols,ngrp,ntmp,idum,igrp
+      integer j,site,natmsr
+      
+      ngrp_ghost=0
+      ntmp=intstr(record,lenrec,idum)
+      numgrp(itmols)=numgrp(itmols)+ntmp
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,'number of rigid units    ',
+     x    6x,i10)") ntmp
+        write(nrite,"(/,' rigid body details:',/,/,21x,
+     x    6x,'unit',3x,'indices',/) ")
+      endif
+      
+      do igrp=1,numgrp(itmols)
+        
+        ngrp=ngrp+1
+        site_test=.true.
+        
+        if(ngrp.gt.mxungp) call error(idnode,301)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        numgsit(ngrp)=intstr(record,lenrec,idum)
+        if(numgsit(ngrp).gt.mxngp) 
+     x    call error (idnode,302)
+        
+        listyp(ngrp)=ngrp
+        
+        do j=1,numgsit(ngrp)
+          
+          site=intstr(record,lenrec,idum)
+          
+          if(site.eq.0)then
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)return
+            site=intstr(record,lenrec,idum)
+            
+          endif
+          
+          lstgst(ngrp,j)=site
+          
+          if(lghost)then
+            
+            if(site_test)then
+              
+              if(site+natmsr.ge.ind_fre(3))then
+                
+                site_test=.false.
+                ngrp_ghost=ngrp_ghost+1
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(21x,10i10,100(/,21x,10i10))")
+     x    listyp(ngrp),(lstgst(ngrp,j),j=1,
+     x    numgsit(ngrp))
+        
+      enddo
+      
+      numgrp(itmols)=numgrp(itmols)-ngrp_ghost
+      ngrp=ngrp-ngrp_ghost
+        
+      return
+      end subroutine define_rigid_body
+      
+      subroutine bodystress
+     x  (idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to calculate rigid body contributions to the 
+c     stress tensor
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   aug 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer i,j,ig,id,jr,igrp1,igrp2,idnode,mxnode,ngrp
+      real(8) vircom,strbod,dtx,dty,dtz
+      
+      dimension dtx(mxatms),dty(mxatms),dtz(mxatms),strbod(9)
+      
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     zero stress tensor accumulators
+      
+      vircom=0.d0
+      do i=1,9
+        strbod(i)=0.d0
+      enddo
+      
+c     convert atomic virial to molecular
+c     note convention: virial(atom-atom)=-sum(Ri.Fi)
+c     : virial(com-com)=-sum(Rcom.Fcom) so
+c     virial(com-com)=virial(atom-atom)+sum((Ri-Rcom).Fi)
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          vircom=vircom+
+     x      (dtx(jr)*fxx(i)+dty(jr)*fyy(i)+dtz(jr)*fzz(i))
+          
+c     stress tensor : rigid body contributions
+          
+          strbod(1)=strbod(1)-dtx(jr)*fxx(i)
+          strbod(2)=strbod(2)-dtx(jr)*fyy(i)
+          strbod(3)=strbod(3)-dtx(jr)*fzz(i)
+          strbod(4)=strbod(4)-dty(jr)*fxx(i)
+          strbod(5)=strbod(5)-dty(jr)*fyy(i)
+          strbod(6)=strbod(6)-dty(jr)*fzz(i)
+          strbod(7)=strbod(7)-dtz(jr)*fxx(i)
+          strbod(8)=strbod(8)-dtz(jr)*fyy(i)
+          strbod(9)=strbod(9)-dtz(jr)*fzz(i)
+          
+        enddo
+        
+      enddo
+      
+      if(mxnode.gt.1)then
+        
+        call gdsum(strbod,9,buffer)
+        buffer(1)=vircom
+        call gdsum(buffer(1),1,buffer(2))
+        vircom=buffer(1)
+        
+      endif
+      
+c     symmetrise stress tensor
+      
+      strbod(2)=0.5d0*(strbod(2)+strbod(4))
+      strbod(4)=strbod(2)
+      strbod(3)=0.5d0*(strbod(3)+strbod(7))
+      strbod(7)=strbod(3)
+      strbod(6)=0.5d0*(strbod(6)+strbod(8))
+      strbod(8)=strbod(6)
+      
+      return
+      end subroutine bodystress
+      
+      end module rigid_body_module
diff -urN dl_class_1.9.orig/srcmod/serial.f dl_class_1.9/srcmod/serial.f
--- dl_class_1.9.orig/srcmod/serial.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/serial.f	2015-11-09 14:15:45.064258843 +0100
@@ -0,0 +1,543 @@
+      subroutine initcomms()
+
+c*********************************************************************
+c
+c     dummy initcomms routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      return
+      end
+
+      integer*8 function get_comms()
+c*********************************************************************
+c
+c     dummy machine routine for serial DL_POLY with PLUMED
+c
+c********************************************************************
+
+      implicit none
+
+      get_comms=0
+
+      return
+      end
+
+      subroutine machine(idnode,mxnode)
+
+c*********************************************************************
+c
+c     dummy machine routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode
+
+      idnode=0
+      mxnode=1
+
+      return
+      end
+
+      integer function mynode()
+
+c*********************************************************************
+c
+c     dummy mynode routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      mynode=0
+
+      return
+      end
+
+      integer function nodedim()
+
+c*********************************************************************
+c
+c     dummy nodedim routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      nodedim=0
+
+      return
+      end
+
+      integer function numnodes()
+
+c*********************************************************************
+c
+c     dummy numnodes routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      numnodes=1
+
+      return
+      end
+
+      subroutine csend(msgtag,buf,length,pe,idum)
+
+c*********************************************************************
+c
+c     dummy csend routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      integer msgtag,length,pe,idum
+
+      real(8) buf(*)
+
+      return
+      end
+      
+      subroutine crecv(msgtag,buf,length)
+
+c*********************************************************************
+c
+c     dummy crecv routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer msgtag,length
+      real(8) buf(*)
+
+      return
+      end
+
+      subroutine gisum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy isum for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer nnn
+      integer aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gdsum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+
+      implicit none
+
+      integer nnn
+      real(8) aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gimax(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer nnn
+      integer aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gstate(check)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+
+      implicit none
+
+      logical check
+
+      return
+      end
+
+      subroutine gsync()
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      return
+      end
+
+      subroutine exitcomms()
+
+c*********************************************************************
+c
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      stop
+      end
+
+      subroutine merge(idnode,mxnode,natms,nbuff,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+      implicit none
+
+      integer idnode,mxnode,natms,nbuff
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms
+      integer lstme(*)
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine merge4(idnode,mxnode,ngrp,nbuff,q0,q1,q2,q3,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ngrp,nbuff
+      real(8) q0(*),q1(*),q2(*),q3(*),buffer(*)
+
+      return
+      end
+
+      subroutine shlmerge(idnode,mxnode,ntshl)
+      
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntshl
+
+      return
+      end
+
+      subroutine shmove
+     x     (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode, mxnode, natms
+      integer lishap(*),lashap(*)
+      real(8) xxt(*),yyt(*),zzt(*),txx(*),tyy(*),tzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine splice
+     x      (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,natms
+      integer listme(*),listot(*)
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine passcon
+     x     (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x     listin,listot,listcon,lstfrz)
+      
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical lshmov
+      integer idnode,mxnode,natms,nscons,i,j,k
+      integer lashap(mxproc),lishap(mxlshp),listme(mxatms)
+      integer listin(mxatms),listot(mxatms),listcon(mxcons,3)
+      integer lstfrz(mxatms)
+      
+      do i=1,natms
+         listme(i)=0
+      enddo
+      
+      do k=1,nscons
+         
+         i=listcon(k,2)
+         j=listcon(k,3)
+         listme(i)=listme(i)+1
+         listme(j)=listme(j)+1
+         
+      enddo
+
+c     keep record of all atoms subject to constraints
+      
+      do i=1,natms
+         
+         if(listme(i).gt.0)then
+            listot(i)=1
+         else
+            listot(i)=0
+         endif
+         
+      enddo
+      
+      return
+      end
+
+      subroutine passpmf
+     x  (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use error_module
+      use setup_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nspmf,i,j,k
+      integer listpm(mxpmf),listin(mxatms),lstpmt(mxpmf)
+      integer lstpmf(mxspmf,mspmf),npmf(2)
+
+      if(mxpmf.lt.natms) call error(idnode,490)
+
+      do i=1,natms
+        listpm(i)=0
+      enddo
+      
+      do k=1,nspmf
+        
+        do j = 1,npmf(1)+npmf(2)
+
+          i=lstpmf(j,k)
+          listpm(i)= 1
+          
+        enddo
+
+      enddo
+
+c     keep record of all atoms subject to pmf constraints
+      
+      do i=1,natms
+        
+        if(listpm(i).gt.0)then
+          lstpmt(i)=1
+        else
+          lstpmt(i)=0
+        endif
+        
+      enddo
+      
+      return
+      end
+
+      subroutine passquat
+     x  (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x  listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,numgsit)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical lcnb
+      integer idnode,mxnode,natms,ngrp,nscons,ntpmls,jj,id,igrp1,igrp2
+      integer i,j,k,jr,igrp,itmols,imols,ik,lgrp
+      integer listin(mxatms),listcon(mxcons,3),lstrgd(mxgatm)
+      integer lstout(mxatms),lstcsit(2*mxcons),numgsit(mxungp)
+      integer lstgtp(mxgrp),nummols(mxtmls),numgrp(mxtmls)
+      
+c     block indices for groups
+      
+      igrp1 = (idnode*ngrp)/mxnode + 1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+      
+c     locate site indices of atoms in constraints
+
+      do i = 1,natms
+        listin(i) = 0
+      enddo
+
+c     loop over molecule types
+
+      jr = 0 
+      igrp = 0
+      do itmols=1,ntpmls
+
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if((igrp.ge.igrp1).and.(igrp.le.igrp2)) then
+                
+              id = lstgtp(igrp)
+              do jj = 1,numgsit(id)
+                  
+                jr = jr +1
+                i = lstrgd(jr)
+                listin(i) = jj
+
+              enddo
+            endif
+          enddo
+        enddo
+      enddo
+
+      lcnb = .true.
+      ik = 0
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+        if(listin(i).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(i)
+          lcnb = .false.
+        endif
+
+        if(listin(j).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(j)
+          lcnb = .false.
+        endif
+
+      enddo
+
+c     lcnb flags bodies connected by constraints
+
+      lcnb = (.not.lcnb)
+      
+      return
+      end
+
diff -urN dl_class_1.9.orig/srcmod/serial.f.preplumed dl_class_1.9/srcmod/serial.f.preplumed
--- dl_class_1.9.orig/srcmod/serial.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/serial.f.preplumed	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,529 @@
+      subroutine initcomms()
+
+c*********************************************************************
+c
+c     dummy initcomms routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      return
+      end
+
+      subroutine machine(idnode,mxnode)
+
+c*********************************************************************
+c
+c     dummy machine routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode
+
+      idnode=0
+      mxnode=1
+
+      return
+      end
+
+      integer function mynode()
+
+c*********************************************************************
+c
+c     dummy mynode routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      mynode=0
+
+      return
+      end
+
+      integer function nodedim()
+
+c*********************************************************************
+c
+c     dummy nodedim routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      nodedim=0
+
+      return
+      end
+
+      integer function numnodes()
+
+c*********************************************************************
+c
+c     dummy numnodes routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      numnodes=1
+
+      return
+      end
+
+      subroutine csend(msgtag,buf,length,pe,idum)
+
+c*********************************************************************
+c
+c     dummy csend routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      integer msgtag,length,pe,idum
+
+      real(8) buf(*)
+
+      return
+      end
+      
+      subroutine crecv(msgtag,buf,length)
+
+c*********************************************************************
+c
+c     dummy crecv routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer msgtag,length
+      real(8) buf(*)
+
+      return
+      end
+
+      subroutine gisum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy isum for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer nnn
+      integer aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gdsum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+
+      implicit none
+
+      integer nnn
+      real(8) aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gimax(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer nnn
+      integer aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gstate(check)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+
+      implicit none
+
+      logical check
+
+      return
+      end
+
+      subroutine gsync()
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      return
+      end
+
+      subroutine exitcomms()
+
+c*********************************************************************
+c
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      stop
+      end
+
+      subroutine merge(idnode,mxnode,natms,nbuff,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+      implicit none
+
+      integer idnode,mxnode,natms,nbuff
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms
+      integer lstme(*)
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine merge4(idnode,mxnode,ngrp,nbuff,q0,q1,q2,q3,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ngrp,nbuff
+      real(8) q0(*),q1(*),q2(*),q3(*),buffer(*)
+
+      return
+      end
+
+      subroutine shlmerge(idnode,mxnode,ntshl)
+      
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntshl
+
+      return
+      end
+
+      subroutine shmove
+     x     (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode, mxnode, natms
+      integer lishap(*),lashap(*)
+      real(8) xxt(*),yyt(*),zzt(*),txx(*),tyy(*),tzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine splice
+     x      (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,natms
+      integer listme(*),listot(*)
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine passcon
+     x     (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x     listin,listot,listcon,lstfrz)
+      
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical lshmov
+      integer idnode,mxnode,natms,nscons,i,j,k
+      integer lashap(mxproc),lishap(mxlshp),listme(mxatms)
+      integer listin(mxatms),listot(mxatms),listcon(mxcons,3)
+      integer lstfrz(mxatms)
+      
+      do i=1,natms
+         listme(i)=0
+      enddo
+      
+      do k=1,nscons
+         
+         i=listcon(k,2)
+         j=listcon(k,3)
+         listme(i)=listme(i)+1
+         listme(j)=listme(j)+1
+         
+      enddo
+
+c     keep record of all atoms subject to constraints
+      
+      do i=1,natms
+         
+         if(listme(i).gt.0)then
+            listot(i)=1
+         else
+            listot(i)=0
+         endif
+         
+      enddo
+      
+      return
+      end
+
+      subroutine passpmf
+     x  (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use error_module
+      use setup_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nspmf,i,j,k
+      integer listpm(mxpmf),listin(mxatms),lstpmt(mxpmf)
+      integer lstpmf(mxspmf,mspmf),npmf(2)
+
+      if(mxpmf.lt.natms) call error(idnode,490)
+
+      do i=1,natms
+        listpm(i)=0
+      enddo
+      
+      do k=1,nspmf
+        
+        do j = 1,npmf(1)+npmf(2)
+
+          i=lstpmf(j,k)
+          listpm(i)= 1
+          
+        enddo
+
+      enddo
+
+c     keep record of all atoms subject to pmf constraints
+      
+      do i=1,natms
+        
+        if(listpm(i).gt.0)then
+          lstpmt(i)=1
+        else
+          lstpmt(i)=0
+        endif
+        
+      enddo
+      
+      return
+      end
+
+      subroutine passquat
+     x  (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x  listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,numgsit)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical lcnb
+      integer idnode,mxnode,natms,ngrp,nscons,ntpmls,jj,id,igrp1,igrp2
+      integer i,j,k,jr,igrp,itmols,imols,ik,lgrp
+      integer listin(mxatms),listcon(mxcons,3),lstrgd(mxgatm)
+      integer lstout(mxatms),lstcsit(2*mxcons),numgsit(mxungp)
+      integer lstgtp(mxgrp),nummols(mxtmls),numgrp(mxtmls)
+      
+c     block indices for groups
+      
+      igrp1 = (idnode*ngrp)/mxnode + 1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+      
+c     locate site indices of atoms in constraints
+
+      do i = 1,natms
+        listin(i) = 0
+      enddo
+
+c     loop over molecule types
+
+      jr = 0 
+      igrp = 0
+      do itmols=1,ntpmls
+
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if((igrp.ge.igrp1).and.(igrp.le.igrp2)) then
+                
+              id = lstgtp(igrp)
+              do jj = 1,numgsit(id)
+                  
+                jr = jr +1
+                i = lstrgd(jr)
+                listin(i) = jj
+
+              enddo
+            endif
+          enddo
+        enddo
+      enddo
+
+      lcnb = .true.
+      ik = 0
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+        if(listin(i).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(i)
+          lcnb = .false.
+        endif
+
+        if(listin(j).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(j)
+          lcnb = .false.
+        endif
+
+      enddo
+
+c     lcnb flags bodies connected by constraints
+
+      lcnb = (.not.lcnb)
+      
+      return
+      end
+
diff -urN dl_class_1.9.orig/srcmod/setup_module.f dl_class_1.9/srcmod/setup_module.f
--- dl_class_1.9.orig/srcmod/setup_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/setup_module.f	2011-07-11 17:09:10.000000000 +0200
@@ -0,0 +1,1664 @@
+      module setup_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining default array sizes
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c     note the following internal units apply everywhere
+c     
+c     unit of time      (to)    =          1 x 10**(-12) seconds
+c     unit of length    (lo)    =          1 x 10**(-10) metres
+c     unit of mass      (mo)    = 1.6605402  x 10**(-27) kilograms
+c     unit of charge    (qo)    = 1.60217733 x 10**(-19) coulombs
+c     unit of energy    (eo)    = 1.6605402  x 10**(-23) joules
+c     unit of pressure  (po)    = 1.6605402  x 10**(  7) pascals
+c     
+c*********************************************************************
+      
+      use parse_module
+      
+      implicit none
+      
+c     FIXED PARAMETERS
+      
+c     standard pi values
+      
+      real(8), parameter :: pi=3.141592653589793d0
+      real(8), parameter :: sqrpi=1.7724538509055159d0
+      
+c     conversion factor for coulombic terms in internal units
+c     i.e. (unit(charge)**2/(4 pi eps0 unit(length))/unit(energy)
+      
+      real(8), parameter :: r4pie0=138935.4835d0
+      
+c     boltzmann constant in internal units
+      
+      real(8), parameter :: boltz=8.31451115d-1
+      
+c     planck's constant in internal units
+      
+      real(8), parameter :: hbar=6.350780719d0
+      
+c     conversion factor for pressure from internal units to katm
+      
+      real(8), parameter :: prsunt=0.163882576d0
+      
+c     main input channel
+      
+      integer, parameter :: nread=5
+      
+c     main output channel
+      
+      integer, parameter :: nrite=6
+      
+c     force field input channel
+      
+      integer, parameter :: nfield=9
+      
+c     configuration file input channel
+      
+      integer, parameter :: nconf=10
+      
+c     statistical data file output channel
+      
+      integer, parameter :: nstats=20
+      
+c     trajectory history file channel
+      
+      integer, parameter :: nhist=21
+      
+c     acummulators restart dump file
+      
+      integer, parameter :: nrest=22
+      
+c     tabulated potential file channel
+      
+      integer, parameter :: ntable=23
+      
+c     rdf file channel number
+      
+      integer, parameter :: nrdfdt=24
+      
+c     z density file channel number
+      
+      integer, parameter :: nzdndt=25
+      
+c     hyperdynamics reference basin file
+      
+      integer, parameter :: nbsn=30
+      
+c     neb reaction path profile file
+      
+      integer, parameter :: npro=31
+      
+c     hyperdynamics events journal file
+      
+      integer, parameter :: nevnt=33
+      
+c     hyperdynamics tracking file
+      
+      integer, parameter :: ntrk=32
+      
+c     hyperdynamics restart file
+      
+      integer, parameter :: nhrs=35
+      
+c     free energy data file
+      
+      integer, parameter :: nfrnwr=41
+      
+c     solvation data file
+      
+      integer, parameter :: nsolwr=43
+      
+c     data dumping interval in event of system crash
+      
+      integer, parameter :: ndump=1000
+      
+c     maximum number of neb calculations
+      
+      integer, parameter :: maxneb=10
+      
+c     array allocation parameters (set by subroutine parset)
+      
+      integer kmaxa,kmaxb,kmaxc,minnode,msatms,msbad,msgrp
+      integer mspmf,msteth,mxangl,mxatms,mxbond,mxbuff,mxcell
+      integer mxcons,mxdihd,mxewld,mxexcl,mxfbp,mxfld,mxgatm,mxgrid
+      integer mxgrp,mxinv,mxlist,mxlshp,mxneut,mxngp,mxnstk,mxpang
+      integer mxpbnd,mxpdih,mxpfbp,mxpinv,mxpmf,mxproc,mxptbp,mxpvdw
+      integer mxrdf,mxzdn,mxshl,mxsite,mxspmf,mxstak,mxtang,mxtbnd
+      integer mxtbp,mxtcon,mxtdih,mxteth,mxtinv,mxtmls,mxtshl,mxungp
+      integer mxvdw,mxxdf,mx2tbp,mx3fbp,mxebuf,mxquat,mxshak,mxspl
+      integer kmaxd,kmaxe,kmaxf,mxspme,mxftab,mxhko,mxegrd,mxhke
+      integer mxmet,mxsmet,mxpmet,mxter,mxpter,mxatyp,mxxtyp
+      integer mxtmls_fre,mxewld_fre,mxebuf_fre,mxatms_fre,mxatyp_exc
+      integer mxtmls_exc,mxtmls_sol,mxebuf_sol,mxatms_sol
+      
+      save kmaxa,kmaxb,kmaxc,minnode,msatms,msbad,msgrp
+      save mspmf,msteth,mxangl,mxatms,mxbond,mxbuff,mxcell
+      save mxcons,mxdihd,mxewld,mxexcl,mxfbp,mxfld,mxgatm,mxgrid
+      save mxgrp,mxinv,mxlist,mxlshp,mxneut,mxngp,mxnstk,mxpang
+      save mxpbnd,mxpdih,mxpfbp,mxpinv,mxpmf,mxproc,mxptbp,mxpvdw
+      save mxrdf,mxzdn,mxshl,mxsite,mxspmf,mxstak,mxtang,mxtbnd
+      save mxtbp,mxtcon,mxtdih,mxteth,mxtinv,mxtmls,mxtshl,mxungp
+      save mxvdw,mxxdf,mx2tbp,mx3fbp,mxebuf,mxquat,mxshak,mxspl
+      save kmaxd,kmaxe,kmaxf,mxspme,mxftab,mxhko,mxegrd,mxhke
+      save mxmet,mxsmet,mxpmet,mxter,mxpter,mxatyp,mxxtyp
+      save mxtmls_fre,mxewld_fre,mxebuf_fre,mxatms_fre,mxatyp_exc
+      save mxtmls_exc,mxtmls_sol,mxebuf_sol,mxatms_sol
+      
+      contains
+      
+      subroutine parset(redirect,idnode,mxnode,buffer)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to determine required array sizes for 
+c     allocation of memory manager
+c     
+c     copyright daresbury laboratory 1997
+c     author - w.smith june 1997
+c     
+c***********************************************************************
+      
+      logical loglnk,lewald,lspme,lhke,nolink,lcshft
+      logical lsolva,lfree,lfrmas,lghost,redirect
+      real(8) cell,celprp,rctbp,rcfbp,volm,xhi,yhi,zhi,rcut,rvdw
+      real(8) densvar,delr,cut,dens,ratio,drdf,dzdn,rcter,buffer
+      real(8) zlen
+      integer imcon,nhko,ilx,ily,ilz,ncells
+      integer idnode,mxnode,mxn1
+      
+      dimension cell(9),celprp(10),buffer(10)
+      
+      lhke=.false.
+      lspme=.false.
+      lewald=.false.
+      lcshft=.false.
+      nolink=.false.
+      redirect=.false.
+      mxtmls_sol=1
+      mxebuf_sol=1
+      mxatms_sol=1
+      mxtmls_fre=1
+      mxewld_fre=1
+      mxebuf_fre=1
+      mxatms_fre=1
+      mxatyp_exc=1
+      mxtmls_exc=1
+
+c     specify maximum and minimum nodes
+      
+      mxproc=mxnode
+      minnode=mxnode
+      
+c     scan the FIELD file data
+      
+      call fldscan(idnode,mxn1,rctbp,rcfbp,rcter)
+      
+c     scan CONFIG file data
+      
+      call cfgscan
+     x  (idnode,nconf,imcon,volm,xhi,yhi,zhi,cell,buffer)
+      
+c     scan CONTROL file data
+      
+      call conscan
+     x  (redirect,lewald,lspme,lhke,nolink,lcshft,lsolva,lfree,lfrmas,
+     x  lghost,idnode,imcon,nhko,rcut,rvdw,delr,densvar,drdf,dzdn,
+     x  zlen,cell)
+      
+c     set dimension of working coordinate arrays
+      
+      msatms=max(1,(mxatms+minnode-1)/minnode)
+      if(lsolva)mxatms_sol=mxatms
+      if(lfree.or.lghost)mxatms_fre=mxatms
+      
+c     maximum number of molecule types
+      
+      mxtmls=max(mxtmls,1)
+      if(lsolva)mxtmls_sol=mxtmls
+      if(lfree)mxtmls_fre=mxtmls
+      if(lghost)then
+        
+        mxtmls_exc=mxtmls
+        mxtmls_fre=mxtmls
+        
+      endif
+      
+c     maximum number of specified bondlength constraints
+      
+      mxtcon=max(mxtcon,1)
+      
+c     maximum number of chemical bond potentials
+      
+      mxtbnd=max(mxtbnd,1)
+      
+c     maximum number of different bond angle potentials
+      
+      mxtang=max(mxtang,1)
+      
+c     maximum number of different torsional potentials
+      
+      mxtdih=max(mxtdih,1)
+      
+c     maximum number of different inversion potentials
+      
+      mxtinv=max(mxtinv,1)
+      
+c     maximum number of unique rigid body units
+      
+      mxungp=max(mxungp,1)
+      
+c     maximum number of tethered atom potentials
+      
+      mxteth=max(mxteth,1)
+      
+c     maximum number of core-shell units
+      
+      mxshl=max(mxshl,1)
+      
+c     set maximum number of unique atom types
+      
+      mxatyp=max(1,mxatyp)
+      mxxtyp=(mxatyp*(mxatyp+1))/2
+      if(lghost)mxatyp_exc=mxatyp
+      
+c     maximum number of vdw potentials
+      
+      mxvdw=max(mxvdw,1)+1
+      
+c     maximum number of metal potentials
+      
+      mxmet=max(mxmet,1)+1
+      mxsmet=mxatyp
+      
+c     maximum number of tersoff potentials
+      
+      if(mxter.gt.0)then
+        
+        mxter=mxatyp
+        
+      endif
+      
+c     maximum number of three body potentials
+      
+      if(mxtbp.eq.0)then
+        
+        mx2tbp=0
+        
+      else
+        
+        mx2tbp=(mxatyp*(mxatyp+1))/2
+        mxtbp=mx2tbp*mxatyp
+        
+      endif
+      
+c     maximum number of four body potentials
+      
+      if(mxfbp.eq.0)then
+        
+        mx3fbp=0
+        
+      else
+        
+        mx3fbp=(mxatyp*(mxatyp+1)*(mxatyp+2))/6
+        mxfbp=mxatyp*mx3fbp
+        
+      endif
+      
+c     maximum number of angular potential parameters
+
+      mxpang=6
+
+c     maximum number of three body potential parameters
+      
+      mxptbp=mxpang+1
+      
+c     maximum number of four body potential parameters
+      
+      mxpfbp=3
+      
+c     maximum number of parameters for dihedrals
+      
+      mxpdih=5
+      
+c     maximum number of parameters for inversion potentials
+      
+      mxpinv=2
+      
+c     maximum number of parameters for bond potentials
+      
+      mxpbnd=4
+      
+c     maximum number of parameters for vdw potentials
+      
+      mxpvdw=6
+      
+c     maximum number of parameters for metal potentials
+      
+      mxpmet=7
+      
+c     maximum number of parameters for tersoff potential
+      
+      mxpter=11
+      
+c     maximum number of external field parameters
+      
+      mxfld=10
+      
+c     maximum number of excluded atoms per atom
+      
+      mxexcl=max(mxexcl,1)
+      
+c     maximum number of different sites in system
+      
+      mxsite=max(mxsite,1)
+      
+c     maximum number of chemical bonds per node
+      
+      mxbond=max(1,(mxbond+minnode-1)/minnode)
+      
+c     maximum number of bond angles per node
+      
+      mxangl=max(1,(mxangl+minnode-1)/minnode)
+      
+c     maximum number of torsion angles per node
+      
+      mxdihd=max(1,(mxdihd+minnode-1)/minnode)
+      
+c     maximum number of inversion potentials per node
+      
+      mxinv=max(1,(mxinv+minnode-1)/minnode)
+      
+c     maximum number of constraints per node
+      
+      mxcons=max(1,2*((mxcons+minnode-1)/minnode))
+      
+c     maximum number of tethered atoms per node
+      
+      msteth=max(1,(msteth+minnode-1)/minnode)
+      
+c     maximum size for working arrays for bonds, angles, dihedrals
+c     inversion potentials, tethers and core-shell units
+      
+      msbad=max(mxbond,mxangl,mxdihd,mxinv,msteth,mxshl)
+      
+c     maximum number of grid points in potentials arrays
+      
+      if(mxgrid.eq.0)then
+        
+        mxgrid=max(1000,int(rvdw/0.01d0+0.5d0)+4)
+        
+      endif
+      
+      mxegrd=0
+      if(lewald.or.lspme.or.lhke.or.lcshft)mxegrd=mxgrid
+      
+c     maximum dimension of rdf arrays
+      
+      mxrdf=max(128,int(rcut/drdf))
+      
+c     maximum dimension of zdensity arrays
+      
+      mxzdn=max(128,int(zlen/dzdn))
+      
+c     maximum number of rigid groups in system
+      
+      mxgrp=max(mxgrp,1)
+      
+c     maximum number of rigid groups per node
+      
+      msgrp=max(1,(mxgrp+minnode-1)/minnode)
+      
+c     maximum number of sites per rigid unit
+      
+      mxngp=max(mxngp,3)
+      
+c     maximum number of sites in rigid units
+      
+      mxgatm=max(1,mxgatm)
+      
+c     maximum number of timesteps in stack arrays
+      
+      mxstak=max(100,mxstak)
+      
+c     maximum number of variables in stack arrays
+      
+      mxnstk=45+mxatyp
+      
+c     dimension of shake shared atoms array
+      
+      mxlshp=max(mxcons*2,1)
+      
+c     set dimension of working arrays in ewald sum
+      
+      mxewld=1
+      mxebuf=1
+      if(lewald)then
+        
+        mxftab=1
+        mxewld=msatms
+        mxebuf=(2*kmaxa+1)*(2*kmaxb+1)*(2*kmaxc+1)-1
+        if(lfree.or.lghost)mxebuf=3*mxebuf
+        if(mxnode.le.16.and.mxebuf.le.5000)mxebuf=1
+        
+      endif
+      
+c     set dimension of working arrays in spme
+      
+      mxspme=1
+      if(lspme)then
+        
+        mxspme=mxatms
+        mxftab=2*(kmaxd+kmaxe+kmaxf)
+        
+      endif
+      
+c     set dimension of working arrays for HK ewald
+      
+      mxhko=1
+      mxhke=1
+      if(lhke)then
+        
+        mxhko=2
+        mxewld=msatms
+        mxhke=msatms
+        if(nhko.gt.0)mxhko=max(2,nhko)
+        mxebuf=(2*kmaxa+1)*(2*kmaxb+1)-1
+        if(mxnode.le.16.and.mxebuf.le.5000)mxebuf=1
+        
+      endif
+      
+      if(lsolva)mxebuf_sol=mxebuf
+      if(lfree.or.lghost)then
+        
+        mxebuf_fre=mxebuf
+        mxewld_fre=mxewld
+        
+      endif
+
+c     maximum dimension of principal transfer buffer
+      
+      mxbuff=max(6*mxatms,8*(mxcons+1),8*(mxgrp+1),mxnstk*mxstak,
+     x  mxebuf,mxgrid,2*kmaxa*kmaxb*kmaxc,2*kmaxd*kmaxe*kmaxf,
+     x  10000)
+      
+c     maximum size of verlet neighbour/link cell list for each atom
+c     decide if link-cells in use or not
+      
+      cut=rcut+delr
+      dens=dble(mxatms)/volm
+      ratio=1.5d0*dens*(4.d0*pi/3.d0)*cut**3
+      mxlist=min(nint(ratio),(mxatms+1)/2)
+      if(imcon.eq.0) then
+        
+        cell(1)=max(xhi+2.d0*cut,3.d0*cut)
+        cell(5)=max(yhi+2.d0*cut,3.d0*cut)
+        cell(9)=max(zhi+2.d0*cut,3.d0*cut)
+        
+      endif
+      if(imcon.eq.6)then
+        
+        cell(9)=max(zhi+2.d0*cut,3.d0*cut,cell(9))
+        
+      endif
+      
+      if(nolink)then
+        
+        loglnk=.false.
+        
+      else
+        
+        loglnk=.true.
+        call dcell(cell,celprp)
+        ilx=int(celprp(7)/cut)
+        ily=int(celprp(8)/cut)
+        ilz=int(celprp(9)/cut)
+        if(ilx.lt.3.or.ily.lt.3.or.ilz.lt.3)loglnk=.false.
+        ncells=ilx*ily*ilz
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)loglnk=.false.
+        if(mxneut.gt.0.and.ncells.le.36) loglnk=.false.
+        
+      endif
+      
+      mxcell=1
+      if(loglnk)then
+        
+        mxlist=14*nint(1.5d0*dens*celprp(10)/dble(ncells))
+        mxcell=(ilx+2)*(ily+2)*(ilz+2)
+        
+      endif
+      
+      if(mxneut.gt.0)mxlist=(mxneut+1)/2
+      mxlist=2*mxlist
+      if(mxtbp.gt.0.or.mxfbp.gt.0.or.mxter.gt.0)then
+        
+        if(mxtbp.gt.0)cut=min(cut,rctbp)
+        if(mxfbp.gt.0)cut=min(cut,rcfbp)
+        if(mxter.gt.0)cut=min(cut,rcter)
+        ilx=max(3,int(celprp(7)/cut))
+        ily=max(3,int(celprp(8)/cut))
+        ilz=max(3,int(celprp(9)/cut))
+        mxcell=max(mxcell,(ilx+2)*(ily+2)*(ilz+2))
+        
+      endif
+      mxcell=int(dble(mxcell)*densvar/100.d0)
+      mxlist=int(dble(mxlist)*densvar/100.d0)
+      mxlist=max(500,mxlist)
+      
+c     maximum size for coordinate difference arrays
+      
+      mxxdf=max(mxlist,mxatms,mxcons,mxn1*mxn1*(mxneut+1)/2)
+      
+c     maximum number of core-shell unit types
+      
+      mxtshl=max(mxtshl,1)
+      
+c     potential of mean force array parameter
+      
+      mxpmf=max(mxpmf,1)
+      
+c     number of pmf constraints on a processor
+      
+      mspmf=max(1,(mxpmf+minnode-1)/minnode)
+      
+c     maximum number of sites to define pmf units
+      
+      mxspmf=max(mxspmf,1)
+      
+c     maximum iterations in quaternion integration
+      
+      mxquat=100
+      
+c     maximum number of shake cycles
+      
+      mxshak=100
+      
+c     maximum b-spline interpolation order
+      
+      mxspl=12
+      
+c     increment mxneut
+      
+      if(mxneut.gt.0)mxneut=mxneut+1
+      
+      return
+      
+      end subroutine parset
+      
+      subroutine fldscan(idnode,mxn1,rctbp,rcfbp,rcter)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for scanning the field file to determine the
+c     required parameters
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith  november   1994
+c     
+c***********************************************************************
+      
+      integer, parameter :: mmk=1000
+      
+      character*8 name,keyword,chr(mmk)
+      logical check,ltable,lmetab,safe,lneut,loop1,loop2
+      real(8) rctbp,rcter,rcfbp,rct,ppp
+      integer mxn1,nxn1,idnode,nold
+      integer itmols,ksite,numsit,isite,nrept,ifrz,i,j
+      integer ishls,ibonds,numcon,numang,icon,iang,idih,numdih
+      integer numinv,iinv,numgrp,kgrp,numgsit,numteth,iteth
+      integer ipmf,jpmf,npmf,itpvdw,itptbp,itpfbp
+      integer itpter,k,nfld,nummols,idum,numshl,nneu
+      integer numbonds,itpmet,iii,ngrid
+      
+      mxtmls=0
+      mxatms=0
+      mxgrp=0
+      mxtcon=0
+      mxtbnd=0
+      mxtang=0
+      mxtdih=0
+      mxtinv=0
+      mxpmf=0
+      mxspmf=0
+      mxungp=0
+      mxngp=0
+      mxneut=0
+      mxmet=0
+      mxatyp=0
+      mxn1=0
+      nxn1=0
+      nold=-1
+      mxgatm=0
+      mxteth=0
+      msteth=0
+      mxvdw=0
+      mxtbp=0
+      mxter=0
+      mxexcl=0
+      mxsite=0
+      mxbond=0
+      mxcons=0
+      mxangl=0
+      mxdihd=0
+      mxinv=0
+      mxshl=0
+      mxtshl=0
+      mxfbp=0
+      mxgrid=0 
+      rctbp=0.d0
+      rcter=0.d0
+      rcfbp=0.d0
+      safe=.true.
+      loop1=.true.
+      loop2=.true.
+      lneut=.false.
+      ltable=.false.
+      lmetab=.false.
+      
+c     open force field data file
+      
+      if(idnode.eq.0)open (nfield,file='FIELD')
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)call abortscan(52,idnode)
+      
+c     read and process directives from field file
+      
+      do while(loop1)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)call abortscan(52,idnode)
+        call lowcase(record,lenrec)
+        
+        if(findstring('neut',record,idum))then
+          
+          lneut=.true.
+          
+        elseif(findstring('molecu',record,idum))then
+          
+          mxtmls=intstr(record,lenrec,idum)
+          
+          do itmols=1,mxtmls
+            
+            loop2=.true.
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            
+            do while(loop2)
+              
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abortscan(52,idnode)
+              call lowcase(record,lenrec)
+              
+              ksite=0
+              
+              if(findstring('nummol',record,idum))then
+                
+                nummols=intstr(record,lenrec,idum)
+                
+              elseif(findstring('atoms',record,idum))then
+                
+                numsit=intstr(record,lenrec,idum)
+                mxatms=mxatms+numsit*nummols
+                mxsite=mxsite+numsit
+                ksite=0
+                do isite=1,numsit
+                  
+                  if(ksite.lt.numsit)then
+                    
+                    call getrec(safe,idnode,nfield)
+                    if(.not.safe)call abortscan(52,idnode)
+                    
+                    call getword(name,record,8,lenrec)
+                    ppp=dblstr(record,lenrec,idum)
+                    ppp=dblstr(record,lenrec,idum)
+                    nrept=intstr(record,lenrec,idum)
+                    ifrz=intstr(record,lenrec,idum)
+                    nneu=intstr(record,lenrec,idum)
+                    if(nrept.eq.0)nrept=1
+                    if(lneut)then
+                      if(nneu.ne.nold) nxn1=0
+                      nxn1=nxn1+nrept
+                      mxn1=max(mxn1,nxn1)
+                      nold=nneu
+                    endif
+                    
+                    if(mxatyp.eq.0)then
+                      
+                      mxatyp=1
+                      chr(1)=name
+                      
+                    else
+                      
+                      check=.true.
+                      do j=1,mxatyp
+                        
+                        if(name.eq.chr(j))check=.false.
+                        
+                      enddo
+                      if(check)then
+                        
+                        mxatyp=mxatyp+1
+                        if(mxatyp.le.mmk)chr(mxatyp)=name
+                        
+                      endif
+                      
+                    endif
+                    if(nrept.eq.0)nrept=1
+                    ksite=ksite+nrept
+                    
+                  endif
+                  
+                enddo
+                
+                if(mmk.lt.mxatyp)call abortscan(34,idnode)
+                
+                if(lneut)mxneut=mxneut+nneu*nummols
+                
+              elseif(findstring('shell',record,idum))then
+                
+                numshl=intstr(record,40,idum)
+                mxtshl=mxtshl+numshl
+                mxshl=mxshl+nummols*numshl
+                
+                do ishls=1,numshl
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('bonds',record,idum))then
+                
+                numbonds=intstr(record,lenrec,idum)
+                mxtbnd=mxtbnd+numbonds
+                mxbond=mxbond+nummols*numbonds
+                
+                do ibonds=1,numbonds
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('constr',record,idum))then
+                
+                numcon=intstr(record,lenrec,idum)
+                mxtcon=mxtcon+numcon
+                mxcons=mxcons+nummols*numcon
+                
+                do icon=1,numcon
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('angles',record,idum))then
+                
+                numang=intstr(record,lenrec,idum)
+                mxtang=mxtang+numang
+                mxangl=mxangl+nummols*numang
+                
+                do iang=1,numang
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('dihedr',record,idum))then
+                
+                numdih=intstr(record,lenrec,idum)
+                mxtdih=mxtdih+numdih
+                mxdihd=mxdihd+nummols*numdih
+                
+                do idih=1,numdih
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('invers',record,idum))then
+                
+                numinv=intstr(record,lenrec,idum)
+                mxtinv=mxtinv+numinv
+                mxinv=mxinv+nummols*numinv
+                
+                do iinv=1,numinv
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('rigid',record,idum))then
+                
+                numgrp=intstr(record,lenrec,idum)
+                mxungp=mxungp+numgrp
+                mxgrp=mxgrp+numgrp*nummols
+                
+                do kgrp=1,numgrp
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                  numgsit=intstr(record,lenrec,idum)
+                  mxgatm=mxgatm+numgsit*nummols
+                  mxngp=max(mxngp,numgsit)
+                  do j=1,numgsit
+                    
+                    iii=intstr(record,lenrec,idum)
+                    if(iii.eq.0)then
+                      call getrec(safe,idnode,nfield)
+                      if(.not.safe)call abortscan(52,idnode)
+                      iii=intstr(record,lenrec,idum)
+                    endif
+                    
+                  enddo
+                  
+                enddo
+                
+              elseif(findstring('teth',record,idum))then
+                
+                numteth=intstr(record,lenrec,idum)
+                mxteth=mxteth+numteth
+                msteth=msteth+numteth*nummols
+                
+                do iteth=1,numteth
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('pmf',record,idum))then
+                
+                do ipmf=1,2
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  call lowcase(record,lenrec)
+                  npmf=intstr(record,lenrec,idum)
+                  mxspmf=mxspmf+npmf
+                  
+                  do jpmf=1,npmf
+                    
+                    call getrec(safe,idnode,nfield)
+                    if(.not.safe)call abortscan(52,idnode)
+                    
+                  enddo
+                  
+                enddo
+                
+                mxpmf=mxpmf+nummols
+                
+              elseif(findstring('finish',record,idum))then
+                
+                loop2=.false.
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+        elseif(findstring('vdw',record,idum))then
+          
+          if(findstring('tab',record,idum))ltable=.true.
+          mxvdw=intstr(record,lenrec,idum)
+          do itpvdw=1,mxvdw
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call lowcase(record,lenrec)
+            if(findstring('tab',record,idum))ltable=.true.
+            
+          enddo
+          mxvdw=max(mxvdw,(mxatyp*(mxatyp+1))/2)
+          
+          if(ltable)then
+            
+            if(idnode.eq.0)open(ntable,file='TABLE')
+            
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            mxgrid=max(mxgrid,intstr(record,lenrec,idum))
+            
+            close (ntable)
+            
+          endif
+          
+        elseif(findstring('metal',record,idum))then
+          
+          if(findstring('eam',record,idum))lmetab=.true.
+          mxmet=intstr(record,lenrec,idum)
+          do itpmet=1,mxmet
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call lowcase(record,lenrec)
+            if(findstring('eam',record,idum))lmetab=.true.
+            
+          enddo
+          mxmet=max(mxmet,(mxatyp*(mxatyp+1))/2)
+          
+          if(lmetab)then
+            
+            if(idnode.eq.0)open(ntable,file='TABEAM')
+            
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            do i=1,intstr(record,lenrec,idum)
+              
+              call getrec(safe,idnode,ntable)
+              if(.not.safe)call abortscan(24,idnode)
+              ngrid=intstr(record,lenrec,idum)
+              mxgrid=max(mxgrid,ngrid+4)
+              do j=1,(ngrid+3)/4
+                
+                call getrec(safe,idnode,ntable)
+                if(.not.safe)call abortscan(24,idnode)
+                
+              enddo
+              
+            enddo
+            
+            close (ntable)
+            
+          endif
+          
+        elseif(findstring('tbp',record,idum))then
+          
+          mxtbp=intstr(record,lenrec,idum)
+          
+          do itptbp=1,mxtbp
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(keyword,record,4,lenrec)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            rct=dblstr(record,lenrec,idum)
+            rctbp=max(rctbp,rct)
+            
+          enddo
+          
+        elseif(findstring('fbp',record,idum))then
+          
+          mxfbp=intstr(record,lenrec,idum)
+          do itpfbp=1,mxfbp
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(keyword,record,4,lenrec)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            rct=dblstr(record,lenrec,idum)
+            rcfbp=max(rcfbp,rct)
+            
+          enddo
+          
+        elseif(findstring('tersof',record,idum))then
+          
+          mxter=intstr(record,lenrec,idum)
+          
+          do itpter=1,mxter
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            rct=dblstr(record,lenrec,idum)
+            rcter=max(rcter,rct)
+            
+          enddo
+          
+        elseif(findstring('extern',record,idum))then
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)call abortscan(52,idnode)
+          nfld=intstr(record,lenrec,idum)
+          if(nfld.eq.0)nfld=5
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)call abortscan(52,idnode)
+          
+          do k=1,nfld
+            
+            ppp=dblstr(record,lenrec,idum)
+            if(idum.gt.lenrec.and.k.lt.nfld)then
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abortscan(52,idnode)
+            endif
+            
+          enddo
+          
+        elseif(findstring('close',record,idum))then
+          
+          loop1=.false.
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)close (nfield)
+      
+      if(mxpmf.gt.0)mxpmf=mxatms
+      if(mxtcon.gt.0)mxexcl=max(mxexcl,6)
+      if(mxtbnd.gt.0)mxexcl=max(mxexcl,6)
+      if(mxtang.gt.0)mxexcl=max(mxexcl,16)
+      if(mxtdih.gt.0)mxexcl=max(mxexcl,50)
+      if(mxtinv.gt.0)mxexcl=max(mxexcl,50)
+      if(mxneut.gt.0)mxexcl=max(mxexcl,10*mxn1*mxn1)
+      if(mxgrp.gt.0)mxexcl=max(mxexcl,mxngp)
+      
+      return
+      
+      end subroutine fldscan
+      
+      subroutine cfgscan
+     x  (idnode,nconf,imcon,volm,xhi,yhi,zhi,cell,buffer)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for scanning the initial configuration
+c     file to determine the number of atoms present
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith  june       1997
+c     
+c     note: volm is volume containing all particles, not system volume
+c     
+c***********************************************************************
+      
+      character*80 header
+      character*8 name
+      logical lvolm
+      real(8) cell,celprp,buffer,extra,volm,xhi,yhi,zhi
+      real(8) xxx,yyy,zzz,uuu,vvv,www,coz
+      integer idnode,nconf,imcon,i,levcfg
+      dimension cell(9),celprp(10),buffer(10),extra(5)
+      
+      imcon=0
+      xhi=0.d0
+      yhi=0.d0
+      zhi=0.d0
+      volm=0.d0
+      do i=1,9
+        
+        cell(i)=0.d0
+        
+      enddo
+      if(idnode.eq.0)then
+        
+        open (nconf,file='CONFIG')
+        
+c     read the CONFIG file header
+        
+        read(nconf,'(a80)',end=100)header
+        read(nconf,'(2i10)',end=100)levcfg,imcon
+        lvolm=(imcon.eq.0.or.imcon.eq.6)
+        
+c     specify molecular dynamics simulation cell
+        
+        if(imcon.gt.0)then
+          
+          read(nconf,'(3f20.0)',end=100)cell(1),cell(2),cell(3)
+          read(nconf,'(3f20.0)',end=100)cell(4),cell(5),cell(6)
+          read(nconf,'(3f20.0)',end=100)cell(7),cell(8),cell(9)
+          call dcell(cell,celprp)
+          
+        endif
+        
+        if(.not.lvolm)then
+          
+          volm=celprp(10)
+          
+          if(imcon.eq.4)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.5)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.7)then
+            
+            volm=0.5d0*celprp(10)
+            
+          endif
+          
+        endif
+        
+        i=0
+        do while(.true.)
+          
+          i=i+1
+          if(levcfg.eq.0)then
+            
+            read(nconf,'(a8)',end=100) name
+            read(nconf,'(3f20.0)')xxx,yyy,zzz
+            
+          else if(levcfg.eq.1)then
+            
+            read(nconf,'(a8)',end=100) name
+            read(nconf,'(3f20.0)')xxx,yyy,zzz
+            read(nconf,'(3f20.0)')uuu,vvv,www
+            
+          else
+            
+            read(nconf,'(a8)',end=100) name
+            read(nconf,'(3f20.0)')xxx,yyy,zzz
+            read(nconf,'(3f20.0)')uuu,vvv,www
+            read(nconf,'(3f20.0)')uuu,vvv,www
+            
+          endif
+          
+          if(lvolm)then
+            
+            if(i.eq.1)then
+              
+              xhi=abs(xxx)
+              yhi=abs(yyy)
+              zhi=abs(zzz)
+              
+            else
+              
+              xhi=max(xhi,abs(xxx))
+              yhi=max(yhi,abs(yyy))
+              zhi=max(zhi,abs(zzz))
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+  100   continue
+        
+        if(imcon.eq.0)then
+          
+          volm=8.d0*xhi*yhi*zhi
+          
+        else if(imcon.eq.6)then
+          
+          coz=(cell(1)*cell(4)+cell(2)*cell(5)+cell(3)*cell(6))/
+     x      (celprp(1)*celprp(2))
+          volm=2.d0*zhi*celprp(1)*celprp(2)*sqrt(1.d0-coz**2)
+          
+        endif
+        
+        close (nconf)
+        
+      endif
+      
+      extra(1)=dble(imcon)
+      extra(2)=xhi
+      extra(3)=yhi
+      extra(4)=zhi
+      extra(5)=volm
+      call gdsum(extra,5,buffer)
+      call gdsum(cell,9,buffer)
+      imcon=nint(extra(1))
+      xhi=extra(2)
+      yhi=extra(3)
+      zhi=extra(4)
+      volm=extra(5)
+      
+      return
+      
+      end subroutine cfgscan
+      
+      subroutine conscan
+     x  (redirect,lewald,lspme,lhke,nolink,lcshft,lsolva,lfree,lfrmas,
+     x  lghost,idnode,imcon,nhko,rcut,rvdw,delr,densvar,drdf,dzdn,
+     x  zlen,cell)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for scanning the contents of the control file
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith  june       1997
+c     
+c***********************************************************************
+      
+      logical safe,lewald,lspme,lhke,peek,nolink,lcshft,lmetad
+      logical lsolva,lfree,lfrmas,lghost,redirect
+      real(8) cell,celprp,rcut,rvdw,delr,eps,alpha,fac,tol,tol1
+      real(8) densvar,drdf,dzdn,zlen
+      integer nhko,idnode,imcon,idum,jmp
+      integer nlatt,kmax1,kmax2,kmax3,kmaxpow2
+      dimension celprp(10),cell(9)
+      
+      nhko=0
+      mxstak=0
+      kmaxa=0
+      kmaxb=1
+      kmaxc=1
+      kmaxd=1
+      kmaxe=1
+      kmaxf=1
+      rcut=0.d0
+      rvdw=0.d0
+      delr=0.d0
+      drdf=0.05d0
+      dzdn=0.05d0
+      zlen=0.d0
+      densvar=1.d2
+      peek=.true.
+      lhke=.false.
+      lspme=.false.
+      lewald=.false.
+      lcshft=.false.
+      nolink=.false.
+      lghost=.false.
+      lfree=.false.
+      lfrmas=.false.
+      lsolva=.false.
+      lmetad=.false.
+      redirect=.false.
+      
+c     open the simulation input file
+      
+      if(idnode.eq.0)open (nread,file='CONTROL')
+      
+      call getrec(safe,idnode,nread)
+      if(.not.safe)call abortscan(17,idnode)
+      
+      do while(peek)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abortscan(17,idnode)
+        call lowcase(record,lenrec)
+        if(record(1).ne.'#')then
+          
+          if(findstring('stack',record,idum))then
+            
+            mxstak=intstr(record,lenrec,idum)
+            
+          elseif(findstring('no link',record,idum))then
+            
+            nolink=.true.
+            
+          elseif(findstring('metafreeze',record,idum))then
+            
+            lmetad=.true.
+            do while(lmetad)
+              call getrec(safe,idnode,nread)
+              if(.not.safe)call abortscan(17,idnode)
+              call lowcase(record,lenrec)
+              lmetad=.not.findstring('endmet',record,idum)
+            enddo
+            
+          elseif(findstring('redirect',record,idum))then
+            
+            redirect=.true.
+            
+          elseif(findstring('densvar',record,idum))then
+            
+            densvar=dblstr(record,lenrec,idum)
+            
+          elseif(findstring('shift',record,idum).or.
+     x        findstring('reaction',record,idum))then
+            
+            lcshft=.true.
+            
+          elseif(findstring('ewald',record,idum).or.
+     x        findstring('spme',record,idum).or.
+     x        findstring('hke',record,idum))then
+            
+c     read Ewald or HK-Ewald or SPM-Ewald sum parameters
+            
+            lhke=findstring('hke',record,idum)
+            lspme=findstring('spme',record,idum)
+            lewald=findstring('ewald',record,idum)
+            
+            if(findstring('precision',record,idum))then
+              
+              eps=dblstr(record,lenrec,idum)
+              if(lhke) then
+                
+                nhko=intstr(record,lenrec,idum)
+                nlatt=intstr(record,lenrec,idum)
+                nlatt=min(nlatt,2)
+                
+              endif
+              
+              if(rcut.lt.1.d-6)rcut=10.d0
+              
+c     compute alpha and the kmax
+              
+              if(lewald.or.lspme)then
+                
+                call dcell(cell,celprp)
+                eps=min(abs(eps),0.5d0)
+                tol=sqrt(abs(log(eps*rcut)))
+                alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+                tol1=sqrt(-log(eps*rcut*(2.d0*tol*alpha)**2))
+                fac=1.d0
+                if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7) 
+     x            fac=2.d0**(1.d0/3.d0)
+                kmax1=nint(0.25d0+fac*celprp(1)*alpha*tol1/pi)
+                kmax2=nint(0.25d0+fac*celprp(2)*alpha*tol1/pi)
+                kmax3=nint(0.25d0+fac*celprp(3)*alpha*tol1/pi)
+                
+              elseif(lhke)then
+                
+                if(nhko.eq.0)then
+                  if(eps.le.1.d-6)then
+                    alpha=3.46d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=3.14d0/rcut
+                  else
+                    alpha=2.76d0/rcut
+                  endif
+                elseif(nhko.eq.1)then
+                  if(eps.le.1.d-6)then
+                    alpha=4.37d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=4.08d0/rcut
+                  else
+                    alpha=3.75d0/rcut
+                  endif                
+                elseif(nhko.eq.2)then
+                  if(eps.le.1.d-6)then
+                    alpha=5.01d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=4.74d0/rcut
+                  else
+                    alpha=4.44d0/rcut
+                  endif
+                elseif(nhko.eq.3)then
+                  if(eps.le.1.d-6)then
+                    alpha=5.55d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=5.28d0/rcut
+                  else
+                    alpha=5.00d0/rcut
+                  endif
+                endif
+                alpha=alpha/dble(2*nlatt+1)
+                if(abs(cell(9)).lt.1.d-8)cell(9)=1.d0
+                call dcell(cell,celprp)
+                tol=2.d0*alpha*sqrt(abs(log(eps*alpha)))
+                tol1=2.d0*alpha*sqrt(abs(log(eps*alpha*tol)))
+                kmax1=nint(0.25d0+0.5d0*celprp(1)*tol1/pi)
+                kmax2=nint(0.25d0+0.5d0*celprp(2)*tol1/pi)
+                kmax3=1
+                
+              endif
+              
+            else
+              
+              alpha=dblstr(record,lenrec,idum)
+              kmax1=intstr(record,lenrec,idum)
+              kmax2=intstr(record,lenrec,idum)
+              
+              if(lhke)then
+                
+                kmax3=1
+                nhko=intstr(record,lenrec,idum)
+                
+              else
+                
+                kmax3=intstr(record,lenrec,idum)
+                
+              endif
+              
+            endif
+            
+c     for spme double kmax and set to next power of 2, with current
+c     upper limit of 512
+            
+            if(lspme)then
+              
+              kmaxpow2=1
+              do while (kmax1.gt.kmaxpow2.and.kmaxpow2.lt.256)
+                kmaxpow2=kmaxpow2 * 2
+              end do
+              kmaxd=2 * kmaxpow2
+              
+              kmaxpow2=1
+              do while (kmax2.gt.kmaxpow2.and.kmaxpow2.lt.256)
+                kmaxpow2=kmaxpow2 * 2
+              end do
+              kmaxe=2 * kmaxpow2
+              
+              kmaxpow2=1
+              do while (kmax3.gt.kmaxpow2.and.kmaxpow2.lt.256)
+                kmaxpow2=kmaxpow2 * 2
+              end do
+              kmaxf=2 * kmaxpow2
+              
+            elseif(lhke) then
+              
+              kmaxa=kmax1
+              kmaxb=kmax2
+              kmaxc=1
+              
+            else
+              
+              kmaxa=kmax1
+              kmaxb=kmax2
+              kmaxc=kmax3
+              
+            endif
+            
+          elseif(findstring('cut',record,idum))then
+            
+            rcut=dblstr(record,lenrec,idum)
+            
+          elseif(findstring('rvdw',record,idum))then
+            
+            rvdw=dblstr(record,lenrec,idum)
+            
+          elseif(findstring('delr',record,idum))then
+            
+            delr=dblstr(record,100,idum)
+            
+          else if(findstring('rdf',record,idum))then
+            
+            if(.not.findstring('print',record,idum))then
+              
+              jmp=intstr(record,lenrec,idum)
+              drdf=dblstr(record,lenrec,idum)
+              
+            endif
+            
+          else if(findstring('zden',record,idum))then
+            
+            jmp=intstr(record,lenrec,idum)
+            dzdn=dblstr(record,lenrec,idum)
+            zlen=dblstr(record,lenrec,idum)
+            if(dzdn.lt.1.d-8)then
+              
+              dzdn=0.1d0
+              zlen=0.1d0*dble(128)
+              
+            elseif(zlen.lt.1.d-8)then
+              
+              zlen=dzdn*dble(128)
+              
+            endif
+            
+          elseif(findstring('solva',record,idum))then
+            
+            lsolva=.true.
+            
+          elseif(findstring('decomp',record,idum))then
+            
+            lsolva=.true.
+            
+          elseif(findstring('free',record,idum))then
+            
+            lfree=.true.
+            
+          elseif(findstring('excit',record,idum))then
+            
+            lghost=.true.
+            lsolva=.true.
+            
+          elseif(findstring('reset_mass',record,idum))then
+            
+            lfrmas=.true.
+            
+          elseif(findstring('switch',record,idum))then
+            
+            lghost=.true.
+            lsolva=.true.
+            
+          elseif(findstring('finish',record,idum))then
+            
+            peek=.false.
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)close (nread)
+      if(abs(rvdw).le.1.d-10)rvdw=rcut
+      if(drdf.lt.1.d-8)drdf=0.05d0
+      if(dzdn.lt.1.d-8)dzdn=0.05d0
+      
+      return
+      
+      end subroutine conscan
+      
+      subroutine abortscan(key,idnode)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine for controlled exit of file scan
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c*********************************************************************
+      
+      integer key,idnode
+      
+      write(nrite,'(/,/,1x,a,i5)') 
+     x  'DL_POLY terminated due to error ', key
+      
+      if(key.eq.17)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - strange exit from CONTROL file processing'
+        
+      else if(key.eq.52)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - end of FIELD file encountered'
+        
+      else if(key.eq.24)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - end of file encountered in TABLE file'
+        
+      else if(key.eq.34)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - character array memory allocation failure'
+        
+      endif
+      
+      if(idnode.eq.0) then
+        close (nrite)
+        close (nhist)
+        close (nread)
+        close (nconf)
+        close (nstats)
+        close (nrest)
+        close (nfield)
+        close (ntable)
+      endif
+      
+      call gsync()
+      call exitcomms()
+      
+      return
+      end subroutine abortscan
+      
+      subroutine dcell(aaa,bbb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to calculate the dimensional properties of
+c     a simulation cell specified by the input matrix aaa.
+c     the results are returned in the array bbb, with :
+c     
+c     bbb(1 to 3) - lengths of cell vectors
+c     bbb(4 to 6) - cosines of cell angles
+c     bbb(7 to 9) - perpendicular cell widths
+c     bbb(10)     - cell volume
+c     
+c     copyright daresbury laboratory 1992
+c     author - w. smith         july 1992
+c     
+c***********************************************************************
+      
+      real(8) aaa,bbb,axb1,axb2,axb3,bxc1,bxc2,bxc3,cxa1,cxa2,cxa3
+      
+      dimension aaa(9),bbb(10)
+      
+c     calculate lengths of cell vectors
+      
+      bbb(1)=sqrt(aaa(1)*aaa(1)+aaa(2)*aaa(2)+aaa(3)*aaa(3))
+      bbb(2)=sqrt(aaa(4)*aaa(4)+aaa(5)*aaa(5)+aaa(6)*aaa(6))
+      bbb(3)=sqrt(aaa(7)*aaa(7)+aaa(8)*aaa(8)+aaa(9)*aaa(9))
+      
+c     calculate cosines of cell angles
+      
+      bbb(4)=(aaa(1)*aaa(4)+aaa(2)*aaa(5)+aaa(3)*aaa(6))/(bbb(1)*bbb(2))
+      bbb(5)=(aaa(1)*aaa(7)+aaa(2)*aaa(8)+aaa(3)*aaa(9))/(bbb(1)*bbb(3))
+      bbb(6)=(aaa(4)*aaa(7)+aaa(5)*aaa(8)+aaa(6)*aaa(9))/(bbb(2)*bbb(3))
+      
+c     calculate vector products of cell vectors
+      
+      axb1=aaa(2)*aaa(6)-aaa(3)*aaa(5)
+      axb2=aaa(3)*aaa(4)-aaa(1)*aaa(6)
+      axb3=aaa(1)*aaa(5)-aaa(2)*aaa(4)
+      bxc1=aaa(5)*aaa(9)-aaa(6)*aaa(8)
+      bxc2=aaa(6)*aaa(7)-aaa(4)*aaa(9)
+      bxc3=aaa(4)*aaa(8)-aaa(5)*aaa(7)
+      cxa1=aaa(8)*aaa(3)-aaa(2)*aaa(9)
+      cxa2=aaa(1)*aaa(9)-aaa(3)*aaa(7)
+      cxa3=aaa(2)*aaa(7)-aaa(1)*aaa(8)
+      
+c     calculate volume of cell
+      
+      bbb(10)=abs(aaa(1)*bxc1+aaa(2)*bxc2+aaa(3)*bxc3)
+      
+c     calculate cell perpendicular widths
+      
+      bbb(7)=bbb(10)/sqrt(bxc1*bxc1+bxc2*bxc2+bxc3*bxc3)
+      bbb(8)=bbb(10)/sqrt(cxa1*cxa1+cxa2*cxa2+cxa3*cxa3)
+      bbb(9)=bbb(10)/sqrt(axb1*axb1+axb2*axb2+axb3*axb3)
+      
+      return
+      end subroutine dcell
+      
+      end module setup_module
diff -urN dl_class_1.9.orig/srcmod/shake_module.f dl_class_1.9/srcmod/shake_module.f
--- dl_class_1.9.orig/srcmod/shake_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/shake_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,152 @@
+      module shake_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining bond shake arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmcon(:)
+      integer, allocatable :: listcon(:,:),listot(:)
+      integer, allocatable :: numcon(:),lstcon(:,:)
+      integer, allocatable :: listme(:),lishap(:),lashap(:)
+      
+      save prmcon,listcon,listot,numcon,lstcon,listme,lishap,lashap
+      
+      contains
+      
+      subroutine alloc_shake_arrays(idnode)
+      
+      implicit none
+      
+      integer, parameter :: nnn=8
+      
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (prmcon(mxtcon),stat=fail(1))
+      allocate (numcon(mxtmls),stat=fail(2))
+      allocate (lstcon(mxtcon,2),stat=fail(3))
+      allocate (listcon(mxcons,3),stat=fail(4))
+      allocate (listme(mxatms),stat=fail(5))
+      allocate (lishap(mxlshp),stat=fail(6))
+      allocate (lashap(mxproc),stat=fail(7))
+      allocate (listot(mxatms),stat=fail(8))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1070)
+      enddo
+      
+      do i=1,mxtmls
+        numcon(i)=0
+      enddo
+      
+      end subroutine alloc_shake_arrays
+      
+      subroutine define_constraints
+     x  (safe,lghost,idnode,itmols,nconst,nsite,natmsr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining constraints
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     adapted   - p-a cazade  oct 2007,  solvation, excitation etc.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lghost
+      character*1 message(80)
+      integer idnode,itmols,nconst,nsite,ntmp,icnst
+      integer icnst1,iatm1,iatm2,isite1,isite2,idum,i
+      integer isol1,isol2,natmsr
+      
+      ntmp=intstr(record,lenrec,idum)
+      numcon(itmols)=numcon(itmols)+ntmp
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,'number of bond constraints',
+     x    5x,i10)") ntmp
+        write(nrite,"(/,/,1x,'constraint bond details:',
+     x    /,/,21x,5x,'index',5x,'index',2x,'bondlength',/)
+     x    ")
+      endif
+      
+      icnst1 = numcon(itmols)
+      do icnst=1,icnst1
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+        call copystring(record,message,80)
+        iatm1 = intstr(record,lenrec,idum)
+        iatm2 = intstr(record,lenrec,idum)
+        
+c     test for frozen atom pairs(:)
+        
+        isite1 = nsite - numsit(itmols) + iatm1
+        isite2 = nsite - numsit(itmols) + iatm2
+        if(lghost)then
+          
+          isol1=natmsr+iatm1
+          isol2=natmsr+iatm2
+          
+        endif
+        
+        if(lfzsit(isite1)*lfzsit(isite2).ne.0) then
+          
+          numcon(itmols) = numcon(itmols) -1
+          if(idnode.eq.0) write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+          
+        else
+          
+          nconst=nconst+1
+          
+          if(nconst.gt.mxtcon) call error(idnode,40)
+          
+          lstcon(nconst,1)= iatm1
+          lstcon(nconst,2)= iatm2
+          prmcon(nconst)=dblstr(record,lenrec,idum)
+          
+          if(lghost)then
+            
+            if((isol1.ge.ind_fre(3)).or.(isol2.ge.ind_fre(3)))then
+              
+              numcon(itmols)=numcon(itmols)-1
+              ntcons_ghost=ntcons_ghost+1
+              
+            endif
+            
+          endif
+          
+          if(idnode.eq.0) 
+     x      write(nrite,"(21x,2i10,f12.6)")
+     x      lstcon(nconst,1),lstcon(nconst,2),
+     x      prmcon(nconst)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_constraints
+      
+      end module shake_module
diff -urN dl_class_1.9.orig/srcmod/site_module.f dl_class_1.9/srcmod/site_module.f
--- dl_class_1.9.orig/srcmod/site_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/site_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,233 @@
+      module site_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining atomic/site arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use error_module
+      use parse_module
+      use setup_module
+
+      implicit none
+
+      character*1, allocatable :: molnam(:,:)
+      character*8, allocatable :: sitnam(:),unqatm(:)
+      real(8), allocatable :: dens(:),chgsit(:),wgtsit(:)
+      integer, allocatable :: nexsit(:),lfzsit(:),numsit(:),ltpsit(:)
+      integer, allocatable :: nugrp(:),lexsit(:,:),numgrp(:)
+      integer, allocatable :: numtyp(:),numfrz(:),nummols(:)
+
+      save numtyp,numfrz,dens,chgsit,wgtsit,sitnam,unqatm,nexsit
+      save lfzsit,numsit,ltpsit,nugrp,lexsit,numgrp,molnam,nummols
+
+      contains
+
+      subroutine alloc_site_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=16
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+         fail(i)=0
+      enddo
+      allocate (chgsit(mxsite),stat=fail(1))
+      allocate (wgtsit(mxsite),stat=fail(2))
+      allocate (nexsit(mxsite),stat=fail(3))
+      allocate (lfzsit(mxsite),stat=fail(4))
+      allocate (nugrp(mxsite) ,stat=fail(5))
+      allocate (ltpsit(mxsite),stat=fail(6))
+      allocate (numsit(mxtmls),stat=fail(7))
+      allocate (lexsit(mxsite,mxexcl),stat=fail(8))
+      allocate (sitnam(mxsite),stat=fail(9))
+      allocate (unqatm(mxsite),stat=fail(10))
+      allocate (numgrp(mxtmls),stat=fail(11))
+      allocate (numtyp(mxatyp),stat=fail(12))
+      allocate (numfrz(mxatyp),stat=fail(13))
+      allocate (dens(mxatyp),stat=fail(14))
+      allocate (nummols(mxtmls),stat=fail(15))
+      allocate (molnam(40,mxtmls),stat=fail(16))
+      do i=1,nnn
+         if(fail(i).ne.0)call error(idnode,1090)
+      enddo
+
+      do i=1,mxtmls
+         numsit(i)=0
+      enddo
+
+      end subroutine alloc_site_arrays
+
+      subroutine define_atoms
+     x  (safe,lneut,idnode,itmols,nsite,ksite,ntpatm)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for  defining atom types in system
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*8 atom1
+      character*1 message(80)
+      logical lneut,safe,atmchk
+      integer idnode,itmols,nsite,ksite,ntpatm,isite,nrept
+      integer ifrz,neugp,irept,jsite,idum
+      real(8) weight,charge
+
+      numsit(itmols)=intstr(record,lenrec,idum)
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,'number of atoms/sites',
+     x    10x,i10)") numsit(itmols)
+        if(.not.lneut)
+     x    write(nrite,"(/,/,1x,'atomic characteristics:',
+     x    /,/,21x,' site',5x,'name',10x,'mass',8x,
+     x    'charge',4x,'repeat',4x,'freeze'/)")
+        if(lneut)
+     x    write(nrite,"(/,/,1x,'atomic characteristics:',/
+     x    /,21x,' site',5x,'name',10x,'mass',8x,'charge',
+     x    4x,'repeat',4x,'freeze',3x,'chg grp')")
+        
+      endif
+      
+      do isite=1,numsit(itmols)
+        
+        if(ksite.lt.numsit(itmols))then
+
+c     read atom name, site number, mass, charge, freeze option
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)return
+
+          call copystring(record,message,80)
+          call getword(atom1,record,8,lenrec)
+          weight=dblstr(record,lenrec,idum)
+          charge=dblstr(record,lenrec,idum)
+          nrept=intstr(record,lenrec,idum)
+          ifrz =intstr(record,lenrec,idum)
+          neugp=intstr(record,lenrec,idum)
+          if(nrept.eq.0)nrept=1
+          ksite=ksite+nrept
+          
+          if(idnode.eq.0) then
+            
+            if(.not.lneut) then
+
+              write(nrite,
+     x          "(21x,i5,5x,a8,2f12.5,2i10)")
+     x          nsite+1,atom1,weight,charge,nrept,
+     x          ifrz
+
+            else
+
+              write(nrite,
+     x          "(21x,i5,5x,a8,2f12.5,3i10)")
+     x          nsite+1,atom1,weight,charge,nrept,
+     x          ifrz,neugp
+
+            endif
+
+          endif
+          
+          do irept=1,nrept
+            
+            nsite=nsite+1
+            if(nsite.gt.mxsite) call error(idnode,20)
+            
+            sitnam(nsite)=atom1
+            wgtsit(nsite)=weight
+            chgsit(nsite)=charge
+            lfzsit(nsite)=ifrz
+            nugrp(nsite)=neugp
+            
+          enddo
+          
+c     establish list of unique atom types
+          
+          atmchk=.true.
+          
+          do jsite=1,ntpatm
+            
+            if(atom1.eq.unqatm(jsite)) then
+              
+              atmchk=.false.
+              do irept=nsite,nsite-nrept+1,-1
+                
+                ltpsit(irept)=jsite
+                
+              enddo
+              
+            endif
+            
+          enddo
+          
+          if(atmchk)then
+            
+            ntpatm=ntpatm+1
+            if(ntpatm.gt.mxatyp)call error(idnode,14)
+            unqatm(ntpatm)=atom1
+            
+            do irept=nsite,nsite-nrept+1,-1
+              
+              ltpsit(irept)=ntpatm
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_atoms
+
+      subroutine check_syschg(idnode,ntpmls,sumchg)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for checking the system charge
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,ntpmls,jsite,itmols,lsite
+      real(8) sumchg
+
+      jsite=0
+      do itmols=1,ntpmls
+        
+        do lsite=1,numsit(itmols)
+          
+          jsite=jsite+1
+          sumchg=sumchg+dble(nummols(itmols))*chgsit(jsite)
+          
+        enddo
+        
+      enddo
+      
+      if(abs(sumchg).gt.1.0d-6) then
+        
+        call warning(idnode,60,sumchg,0.d0,0.d0)
+        
+      endif
+      
+      return
+      end subroutine check_syschg
+      
+      end module site_module
diff -urN dl_class_1.9.orig/srcmod/solvation_module.f dl_class_1.9/srcmod/solvation_module.f
--- dl_class_1.9.orig/srcmod/solvation_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/solvation_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,996 @@
+      module solvation_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining decomposition of energy arrays
+c     to calculate solvation energies
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      use setup_module
+      use error_module
+      use config_module
+      
+      implicit none
+      
+      logical lcomp(9)
+      
+      integer mxtmls_sol2,mxtmls_sol3,mxtmls_sol4
+      integer ntcons_ghost,ngrp_ghost,nswitch,niswitch
+      integer mxtmls_exc2,mxtmls_exc3,mxtmls_exc4
+      integer nfrn,ifrn,mfree,kfree,ind_fre(4)
+      
+      real(8) pfree,lambda1,lambda2,dlambda,eng_kin_fre
+      real(8) elrc2,virlrc2,engsic0,engsic2,elrc_sav,qfix_fre
+      real(8) virlrc_sav,volm_sav,elrc_fre,elrc_fre_sav,vlrc_fre
+      real(8) qchg0,qchg1,qchg2,ang_fre,bnd_fre,dih_fre
+      real(8) inv_fre,tbp_fre,fbp_fre,cou_fre,elrc2_sav
+      real(8) vdw_fre,eng_cfg_fre,shl_fre,virlrc2_sav,vlrc_fre_sav
+      real(8) qchg_sav,vir_cfg_fre,ang_vir,bnd_vir,dih_vir
+      real(8) inv_vir,tbp_vir,fbp_vir,cou_vir,vdw_vir,shl_vir
+      
+      integer, allocatable :: atm_fre(:)
+      integer, allocatable :: atmolt(:),rigid_sol(:),const_sol(:)
+      integer, allocatable :: lstgot_sol(:),natm_sol(:)
+      
+      real(8), allocatable :: elrc_sol(:),elrc_sol_sav(:),shl_sol(:)
+      real(8), allocatable :: cou_sol(:),vdw_sol(:),bnd_sol(:)
+      real(8), allocatable :: ckc_sol_sum(:),cks_sol_sum(:)
+      real(8), allocatable :: cou_sol_sic(:),ebuf_sol1(:),inv_sol(:)
+      real(8), allocatable :: ang_sol(:),dih_sol(:),en3_sol(:)
+      real(8), allocatable :: qfix_sol(:),ebuf_sol2(:),en4_sol(:)
+      real(8), allocatable :: vdw_sol_lng(:),cou_sol_lng(:)
+      real(8), allocatable :: degfre_sol(:),degrot_sol(:),temp_sol(:)
+      real(8), allocatable :: vxo_sol(:),vyo_sol(:),vzo_sol(:)
+      real(8), allocatable :: ckc1(:),cks1(:),ckc2(:),cks2(:)
+      real(8), allocatable :: ckc_fre_sum(:),cks_fre_sum(:)
+      real(8), allocatable :: ebuf_exc1(:),ebuf_exc2(:)
+      real(8), allocatable :: vxo_fre(:),vyo_fre(:),vzo_fre(:)
+      real(8), allocatable :: elrc_exc(:),elrc_exc_sav(:)
+      real(8), allocatable :: cou_exc(:),vdw_exc(:),bnd_exc(:)
+      real(8), allocatable :: ang_exc(:),dih_exc(:),en4_exc(:)
+      real(8), allocatable :: vdw_exc_lng(:),cou_exc_lng(:)
+      real(8), allocatable :: shl_exc(:),en3_exc(:),inv_exc(:)
+      real(8), allocatable :: qfix_exc(:),cou_exc_sic(:),weight_sav(:)
+      
+      save atmolt,rigid_sol,const_sol,lstgot_sol,natm_sol,elrc_sol
+      save elrc_sol_sav,cou_sol,vdw_sol,bnd_sol,ckc_sol_sum,cks_sol_sum
+      save cou_sol_sic,ebuf_sol1,en4_sol,ang_sol,dih_sol,en3_sol
+      save qfix_sol,ebuf_sol2,shl_sol,vdw_sol_lng,cou_sol_lng,degfre_sol
+      save degrot_sol,inv_sol,temp_sol,vxo_sol,vyo_sol,vzo_sol
+      save mxtmls_sol2,mxtmls_sol3,mxtmls_sol4,lcomp
+      
+      save nfrn,ifrn,mfree,kfree,pfree,lambda1,lambda2,dlambda
+      save eng_kin_fre,elrc2,virlrc2,engsic0,engsic2,cks_fre_sum
+      save virlrc_sav,volm_sav,elrc_fre,elrc_fre_sav,qchg1,qchg2
+      save ang_fre,bnd_fre,dih_fre,inv_fre,tbp_fre,fbp_fre,qchg0
+      save cou_fre,vdw_fre,eng_cfg_fre,elrc2_sav,elrc_sav,vlrc_fre
+      save ang_vir,bnd_vir,dih_vir,inv_vir,tbp_vir,fbp_vir,cou_vir
+      save vdw_vir,shl_vir,vir_cfg_fre,qfix_fre,virlrc2_sav
+      save ind_fre,atm_fre,ckc1,cks1,ckc2,cks2,ckc_fre_sum
+      save ebuf_exc1,ebuf_exc2,vxo_fre,vyo_fre,vzo_fre,vlrc_fre_sav
+      save weight_sav
+      
+      save ntcons_ghost,ngrp_ghost,qchg_sav,nswitch,niswitch
+      save mxtmls_exc2,mxtmls_exc3,mxtmls_exc4
+      save cou_exc,vdw_exc,bnd_exc,ang_exc,dih_exc,en4_exc,vdw_exc_lng
+      save cou_exc_lng,shl_exc,en3_exc,inv_exc,elrc_exc,elrc_exc_sav
+      save qfix_exc,cou_exc_sic
+      
+      contains
+      
+      subroutine alloc_sol_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for allocating solvation module arrays
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=37
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      mxtmls_sol2=((mxtmls_sol+1)*mxtmls_sol)/2
+      mxtmls_sol3=(((mxtmls_sol+3)*mxtmls_sol+2)*mxtmls_sol)/6
+      mxtmls_sol4=((((mxtmls_sol+6)*mxtmls_sol+11)*mxtmls_sol+6)*
+     x  mxtmls_sol)/24
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (cou_sol(mxtmls_sol2),stat=fail(1))
+      allocate (vdw_sol(mxtmls_sol2),stat=fail(2))
+      allocate (shl_sol(mxtmls_sol),stat=fail(3))
+      allocate (ebuf_sol1(mxebuf_sol),stat=fail(4))
+      allocate (cou_sol_sic(mxtmls_sol2),stat=fail(5))
+      allocate (cks_sol_sum(mxtmls_sol),stat=fail(6))
+      allocate (ckc_sol_sum(mxtmls_sol),stat=fail(7))
+      allocate (bnd_sol(mxtmls_sol),stat=fail(8))
+      allocate (ang_sol(mxtmls_sol),stat=fail(9))
+      allocate (dih_sol(mxtmls_sol),stat=fail(10))
+      allocate (atmolt(mxatms_sol),stat=fail(11))
+      allocate (en3_sol(mxtmls_sol3),stat=fail(12))
+      allocate (en4_sol(mxtmls_sol4),stat=fail(13))
+      allocate (qfix_sol(mxtmls_sol),stat=fail(14))
+      allocate (elrc_sol(mxtmls_sol2),stat=fail(15))
+      allocate (elrc_sol_sav(mxtmls_sol2),stat=fail(16))
+      allocate (ebuf_sol2(mxebuf_sol),stat=fail(23))
+      allocate (rigid_sol(mxtmls_sol),stat=fail(24))
+      allocate (const_sol(mxtmls_sol),stat=fail(25))
+      allocate (degfre_sol(mxtmls_sol),stat=fail(26))
+      allocate (degrot_sol(mxtmls_sol),stat=fail(27))
+      allocate (natm_sol(mxtmls_sol),stat=fail(28))
+      allocate (lstgot_sol(mxatms_sol),stat=fail(29))
+      allocate (temp_sol(mxtmls_sol),stat=fail(30))
+      allocate (vxo_sol(mxatms_sol),stat=fail(31))
+      allocate (vyo_sol(mxatms_sol),stat=fail(32))
+      allocate (vzo_sol(mxatms_sol),stat=fail(33))
+      allocate (vdw_sol_lng(mxtmls_sol2),stat=fail(34))
+      allocate (cou_sol_lng(mxtmls_sol2),stat=fail(35))
+      allocate (inv_sol(mxtmls_sol),stat=fail(36))
+      allocate (weight_sav(mxatms_fre),stat=fail(37))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+c     initialise accumulators
+      
+      lcomp(:)=.false.
+      elrc_sol(:)=0.d0
+      cou_sol(:)=0.d0
+      vdw_sol(:)=0.d0
+      en3_sol(:)=0.d0
+      en4_sol(:)=0.d0
+      bnd_sol(:)=0.d0
+      ang_sol(:)=0.d0
+      dih_sol(:)=0.d0
+      inv_sol(:)=0.d0
+      
+      return
+      end subroutine alloc_sol_arrays
+      
+      subroutine solva_temp(idnode,mxnode,natms,keyver)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for solvation module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,ii,idnode,mxnode,natms,keyver
+      real(8) vvx,vvy,vvz
+      
+      temp_sol(:)=0.d0
+      
+      do i=idnode+1,natms,mxnode
+        
+        if(keyver.eq.0)then
+          
+          vvx=0.5d0*(vxx(i)+vxo_sol(i))
+          vvy=0.5d0*(vyy(i)+vyo_sol(i))
+          vvz=0.5d0*(vzz(i)+vzo_sol(i))
+          
+        else
+          
+          vvx=vxx(i)
+          vvy=vyy(i)
+          vvz=vzz(i)
+          
+        endif
+        
+        temp_sol(atmolt(i))=temp_sol(atmolt(i))+weight(i)*
+     x    (vvx*vvx+vvy*vvy+vvz*vvz)/(boltz*degfre_sol(atmolt(i)))
+        
+      enddo
+      
+c     global sum
+      
+      if(mxnode.gt.1)call gdsum(temp_sol,mxtmls_sol,buffer)
+        
+      return
+      end subroutine solva_temp
+      
+      subroutine alloc_free_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine to allocate free energy arrays
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=12
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (ebuf_exc1(mxebuf_fre),stat=fail(1))
+      allocate (ckc1(mxewld_fre),stat=fail(2))
+      allocate (cks1(mxewld_fre),stat=fail(3))
+      allocate (ckc2(mxewld_fre),stat=fail(4))
+      allocate (cks2(mxewld_fre),stat=fail(5))
+      allocate (cks_fre_sum(mxtmls_fre),stat=fail(6))
+      allocate (ckc_fre_sum(mxtmls_fre),stat=fail(7))
+      allocate (atm_fre(mxatms_fre),stat=fail(8))
+      allocate (ebuf_exc2(mxebuf_fre),stat=fail(9))
+      allocate (vxo_fre(mxatms_fre),stat=fail(10))
+      allocate (vyo_fre(mxatms_fre),stat=fail(11))
+      allocate (vzo_fre(mxatms_fre),stat=fail(12))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+      return
+      
+      end subroutine alloc_free_arrays
+      
+      subroutine lrcorrect_fre(lfree,volm,elrc,virlrc)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for free energy module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      logical lfree
+      real(8) volm,elrc,virlrc
+      
+      elrc=elrc_sav*(volm_sav/volm)
+      elrc2=elrc2_sav*(volm_sav/volm)
+      virlrc=virlrc_sav*(volm_sav/volm)
+      virlrc2=virlrc2_sav*(volm_sav/volm)
+      if(lfree)then
+        elrc_fre=elrc_fre_sav*(volm_sav/volm)
+        vlrc_fre=vlrc_fre_sav*(volm_sav/volm)
+      endif
+      
+      end subroutine lrcorrect_fre
+      
+      subroutine free_kinetic(lfrmas,idnode,mxnode,keyver)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for free energy module
+c     calculate kinetic energy difference between states
+c     
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008: parallel version
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lfrmas
+      integer i,idnode,mxnode,keyver
+      real(8) fac
+      
+      fac=dlambda
+      eng_kin_fre=0.d0
+      
+      if(keyver.eq.0)then
+        
+        if(lfrmas)fac=dlambda/lambda1
+        do i=ind_fre(1)+idnode,ind_fre(2),mxnode
+          
+          eng_kin_fre=eng_kin_fre-
+     x      fac*weight(i)*((vxx(i)+vxo_fre(i))**2+
+     x      (vyy(i)+vyo_fre(i))**2+(vzz(i)+vzo_fre(i))**2)
+          
+        enddo
+        
+        if(lfrmas)fac=dlambda/lambda2
+        do i=ind_fre(3)+idnode,ind_fre(4),mxnode
+          
+          eng_kin_fre=eng_kin_fre+
+     x      fac*weight(i)*((vxx(i)+vxo_fre(i))**2+
+     x      (vyy(i)+vyo_fre(i))**2+(vzz(i)+vzo_fre(i))**2)
+          
+        enddo
+        
+        eng_kin_fre=eng_kin_fre/8.d0
+
+      else
+        
+        if(lfrmas)fac=dlambda/lambda1
+        do i=ind_fre(1)+idnode,ind_fre(2),mxnode
+          
+          eng_kin_fre=eng_kin_fre-fac*weight(i)*(vxx(i)**2+
+     x      vyy(i)**2+vzz(i)**2)
+          
+        enddo
+        
+        if(lfrmas)fac=dlambda/lambda2
+        do i=ind_fre(3)+idnode,ind_fre(4),mxnode
+          
+          eng_kin_fre=eng_kin_fre+fac*weight(i)*(vxx(i)**2+
+     x      vyy(i)**2+vzz(i)**2)
+          
+        enddo
+        
+        eng_kin_fre=eng_kin_fre/2.d0
+        
+      endif
+      
+c     global sum
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=eng_kin_fre
+        call gdsum(buffer(1),1,buffer(2))
+        eng_kin_fre=buffer(1)
+        
+      endif
+      
+      return
+      end subroutine free_kinetic
+      
+      subroutine freegen()
+      
+c***********************************************************************
+c     
+c     dl_poly routine for free energy module: select mixing scheme
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,fac1,fac2
+      real(8) sigma1,sigma2,acc,arg,gss,tt,pp,a1,a2,a3,a4,a5,err
+      
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+
+      if(mfree.eq.1)then
+        
+c     linear mixing
+        
+        lambda1=(1.d0-pfree)
+        lambda2=pfree
+        dlambda=1.d0
+        
+      elseif(mfree.eq.2)then
+        
+c     nonlinear mixing
+        
+        lambda1=(1.d0-pfree)**kfree
+        lambda2=(1.d0-(1.d0-pfree)**kfree)
+        dlambda=dble(kfree)*(1.d0-pfree)**(kfree-1)
+        
+      elseif(mfree.eq.3)then
+        
+c     trigonmetric mixing
+        
+        lambda2=0.5d0*(1.d0+sin(pi*(pfree-0.5d0)))
+        lambda1=1.d0-lambda2
+        dlambda=0.5d0*pi*cos(pi*(pfree-0.5d0))
+        
+      elseif(mfree.eq.4)then
+        
+c     error function mixing
+        
+        acc=12.d0
+        arg=2.d0*sqrt(2.302585093*acc)
+        gss=exp(-(arg*(pfree-0.5d0))**2)
+        tt=1.d0/(1.d0+pp*arg*abs(pfree-0.5d0))
+        err=1.d0-tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*gss
+        lambda2=0.5d0*(1.d0+sign(err,(pfree-0.5d0)))
+        lambda1=1.d0-lambda2
+        dlambda=gss*arg/sqrpi
+        
+      elseif(mfree.eq.5)then
+        
+c     polynomial mixing
+        
+        sigma1=0.d0
+        
+        do i=0,kfree-1
+          
+          fac1=1
+          fac2=1
+          
+          do j=0,i-1
+            
+            fac1=fac1*(kfree-1+i-j)
+            fac2=fac2*(i-j)
+            
+          enddo
+          
+          sigma1=sigma1+(dble(fac1/fac2))*pfree**i
+          
+        enddo
+        
+        lambda1=sigma1*(1.d0-pfree)**kfree
+        lambda2=1.d0-lambda1
+        dlambda=sigma1*kfree*(1.d0-pfree)**(kfree-1)
+        
+        sigma2=0.d0
+        
+        do i=1,kfree-1
+          
+          fac1=1
+          fac2=1
+          
+          do j=0,i-1
+            
+            fac1=fac1*(kfree-1+i-j)
+            fac2=fac2*(i-j)
+            
+          enddo
+          
+          sigma2=sigma2+(dble(fac1*i/fac2))*pfree**(i-1)
+          
+        enddo
+        
+        dlambda=dlambda-sigma2*(1.d0-pfree)**kfree
+        
+      else
+        
+c     spline kernel mixing
+        
+        arg=pfree-0.5d0
+        lambda2=2.d0*pfree-8.d0*arg**3*(1.d0-abs(arg))-0.5d0
+        lambda1=1.d0-lambda2
+        dlambda=2.d0+arg**2*(32.d0*abs(arg)-24.d0)
+        
+      endif
+      
+      return
+      end subroutine freegen
+      
+      subroutine free_energy_write(idnode,nstep,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing free energy file at selected
+c     intervals in simulation
+c     
+c     copyright - daresbury  laboratory
+c     author    - p.-a. cazade dec 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newjob
+      integer idnode,natms,nstep
+      real(8) engunit
+      
+      save newjob
+      data newjob/.true./
+      
+      if(idnode.eq.0)then
+          
+c     open the FREENG file if new job or file closed
+        
+        if(newjob)then
+          
+          newjob = .false.
+          open(nfrnwr,file='FREENG',position='append')
+          
+        endif
+        
+        if(nstep.eq.nfrn.or.nstep.eq.ifrn)then
+          
+          write(nfrnwr,'(80a1)')cfgname
+          
+          if(abs(engunit-9648.530821d0).le.1.d-10) write(nfrnwr,
+     x      "(' ENERGY UNITS=electron Volts ')")
+          if(abs(engunit-418.4d0).le.1.d-10)       write(nfrnwr,
+     x      "(' ENERGY UNITS=kcal/mol ')")
+          if(abs(engunit-1.d2).le.1.d-10)          write(nfrnwr,
+     x      "(' ENERGY UNITS=kjoule/mol ')")
+          if(abs(engunit-boltz).lt.1.d-10)         write(nfrnwr,
+     x      "(' ENERGY UNITS=kelvin ')")
+          if(abs(engunit-1.d0).lt.1.d-10)          write(nfrnwr,
+     x      "(' ENERGY UNITS=DL_POLY Internal UNITS ')")
+          
+          write(nfrnwr,'(1p,4e16.8)')pfree,lambda1,lambda2,dlambda
+          
+        endif
+        
+        if(mod(nstep-nfrn,ifrn).eq.0)then
+          
+          write(nfrnwr,"(i10,1p,2e16.8)")
+     x      nstep,eng_cfg_fre/engunit,vir_cfg_fre/engunit
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine free_energy_write
+      
+      subroutine alloc_exi_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine to allocate excited state arrays
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      integer, parameter :: nnn=15
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      mxtmls_exc2=((mxtmls_exc+1)*mxtmls_exc)/2
+      mxtmls_exc3=(((mxtmls_exc+3)*mxtmls_exc+2)*mxtmls_exc)/6
+      mxtmls_exc4=((((mxtmls_exc+6)*mxtmls_exc+11)*mxtmls_exc+6)*
+     x  mxtmls_exc)/24
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (cou_exc(mxtmls_exc2),stat=fail(1))
+      allocate (vdw_exc(mxtmls_exc2),stat=fail(2))
+      allocate (bnd_exc(mxtmls_exc),stat=fail(3))
+      allocate (ang_exc(mxtmls_exc),stat=fail(4))
+      allocate (dih_exc(mxtmls_exc),stat=fail(5))
+      allocate (en3_exc(mxtmls_exc3),stat=fail(6))
+      allocate (en4_exc(mxtmls_exc4),stat=fail(7))
+      allocate (shl_exc(mxtmls_exc),stat=fail(8))
+      allocate (vdw_exc_lng(mxtmls_exc2),stat=fail(9))
+      allocate (cou_exc_lng(mxtmls_exc2),stat=fail(10))
+      allocate (inv_exc(mxtmls_exc),stat=fail(11))
+      allocate (elrc_exc(mxtmls_exc2),stat=fail(12))
+      allocate (elrc_exc_sav(mxtmls_exc2),stat=fail(13))
+      allocate (qfix_exc(mxtmls_exc),stat=fail(14))
+      allocate (cou_exc_sic(mxtmls_exc2),stat=fail(15))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+c     initialise accumulators
+      
+      bnd_exc(:)=0.d0
+      ang_exc(:)=0.d0
+      dih_exc(:)=0.d0
+      inv_exc(:)=0.d0
+      en3_exc(:)=0.d0
+      en4_exc(:)=0.d0
+      elrc_exc(:)=0.d0
+      cou_exc(:)=0.d0
+      vdw_exc(:)=0.d0
+      
+      return
+      end subroutine alloc_exi_arrays
+      
+      subroutine update_ghost(idnode,mxnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excited state module
+c     update the positions of ghost atoms
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,ii,idnode,mxnode
+      
+      if(ind_fre(1).lt.ind_fre(3))then
+        
+        ii=ind_fre(3)
+        
+        do i=ind_fre(1),ind_fre(2)
+          
+          xxx(ii)=xxx(i)
+          yyy(ii)=yyy(i)
+          zzz(ii)=zzz(i)
+          
+          ii=ii+1
+          
+        enddo
+        
+      else
+        
+        ii=ind_fre(1)
+        
+        do i=ind_fre(3),ind_fre(4)
+          
+          xxx(ii)=xxx(i)
+          yyy(ii)=yyy(i)
+          zzz(ii)=zzz(i)
+          
+          ii=ii+1
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine update_ghost
+      
+      subroutine copy_force(idnode,mxnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excited state module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,ii,idnode,mxnode
+      
+      ii=ind_fre(3)
+      
+      do i=ind_fre(1),ind_fre(2)
+        
+        fxx(ii)=fxx(i)
+        fyy(ii)=fyy(i)
+        fzz(ii)=fzz(i)
+        
+        ii=ii+1
+        
+      enddo
+      
+      return
+      end subroutine copy_force
+      
+      subroutine switch(elrc,virlrc)
+c***********************************************************************
+c     
+c     dl_poly routine for switching system in excitation simulation
+c     copyright - daresbury laboratory
+c     author    - w. smith   sep 2008
+c     adapted from p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      real(8) :: swap,elrc,virlrc
+      real(8), allocatable :: cou_sic_swp(:),qfix_swp(:)
+      real(8), allocatable :: elrc_swp(:)
+      
+      allocate(cou_sic_swp(mxtmls_exc2),qfix_swp(mxtmls_exc))
+      allocate(elrc_swp(mxtmls_exc2))
+      
+      swap=elrc
+      elrc=elrc2
+      elrc2=swap
+      
+      swap=engsic0
+      engsic0=engsic2
+      engsic2=swap
+      
+      swap=virlrc
+      virlrc=virlrc2
+      virlrc2=swap
+      
+      swap=elrc_sav
+      elrc_sav=elrc2_sav
+      elrc2_sav=swap
+
+      swap=virlrc_sav
+      virlrc_sav=virlrc2_sav
+      virlrc2_sav=swap
+
+      swap=qchg0
+      qchg0=qchg2
+      qchg2=swap
+      
+      cou_sic_swp(:)=cou_sol_sic(:)
+      cou_sol_sic(:)=cou_exc_sic(:)
+      cou_exc_sic(:)=cou_sic_swp(:)
+      
+      qfix_swp(:)=qfix_sol(:)
+      qfix_sol(:)=qfix_exc(:)
+      qfix_exc(:)=qfix_swp(:)
+      
+      elrc_swp(:)=elrc_sol(:)
+      elrc_sol(:)=elrc_exc(:)
+      elrc_exc(:)=elrc_swp(:)
+      
+      elrc_swp(:)=elrc_sol_sav(:)
+      elrc_sol_sav(:)=elrc_exc_sav(:)
+      elrc_exc_sav(:)=elrc_swp(:)
+      
+      deallocate(elrc_swp,cou_sic_swp,qfix_swp)
+      
+      return
+      
+      end subroutine switch
+      
+      subroutine lrcorrect_sol(lghost,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excited state module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      logical :: lghost
+      real(8) :: volm 
+      
+      elrc_sol(:)=elrc_sol_sav(:)*(volm_sav/volm)
+      if(lghost)elrc_exc(:)=elrc_exc_sav(:)*(volm_sav/volm)
+      
+      return
+      end subroutine lrcorrect_sol
+      
+      subroutine switch_atm(lfrmas)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excitation module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      logical lfrmas
+      integer i,at1_swap,at2_swap
+      
+      at1_swap=ind_fre(1)
+      at2_swap=ind_fre(2)
+      ind_fre(1)=ind_fre(3)
+      ind_fre(2)=ind_fre(4)
+      ind_fre(3)=at1_swap
+      ind_fre(4)=at2_swap
+      
+      if(lfrmas)then
+        
+        do i=ind_fre(1),ind_fre(2)
+          
+          atm_fre(i)=1
+          weight(i)=lambda1*weight_sav(i)
+          
+        enddo
+        
+        do i=ind_fre(3),ind_fre(4)
+          
+          atm_fre(i)=2
+          weight(i)=lambda2*weight_sav(i)
+          
+        enddo
+        
+      else
+        
+        do i=ind_fre(1),ind_fre(2)
+          atm_fre(i)=1
+        enddo
+        
+        do i=ind_fre(3),ind_fre(4)
+          atm_fre(i)=2
+        enddo
+        
+      endif
+      
+      return
+      end subroutine switch_atm
+      
+      subroutine solvation_write
+     x  (lexcite,lswitch,idnode,natms,nstep,nsolva,isolva,
+     x  tstep,engunit,elrc)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing solva file at selected
+c     intervals in simulation
+c     
+c     copyright - daresbury  laboratory
+c     author    - p.-a. cazade jun 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newjob,lexcite,lswitch
+      integer idnode,natms,nstep,nsolva,isolva,i,j,k
+      integer mxtmls2,mxtmls3,mxtmls4
+      real(8) tstep,engunit,elrc
+      character*80 aa,bb,cc,dd
+      
+      save newjob
+      data newjob/.true./
+      
+      mxtmls2=((mxtmls+1)*mxtmls)/2
+      mxtmls3=(((mxtmls+3)*mxtmls+2)*mxtmls)/6
+      mxtmls4=((((mxtmls+6)*mxtmls+11)*mxtmls+6)*mxtmls)/24
+      
+      if(idnode.eq.0)then
+        
+c     open the SOLVAT file if new job or file closed
+        
+        if(newjob)then
+          
+          newjob=.false.
+          open(nsolwr,file='SOLVAT',position='append')
+          
+        endif
+        
+c     write file header block
+        
+        if(nstep.eq.nsolva.or.nstep.eq.isolva)then
+          
+          write(nsolwr,'(80a1)')cfgname
+          
+          if(abs(engunit-9648.530821d0).le.1.d-10)write(nsolwr,
+     x      "('ENERGY UNITS=electron Volts ')")
+          if(abs(engunit-418.4d0).le.1.d-10)      write(nsolwr,
+     x      "('ENERGY UNITS=kcal/mol ')")
+          if(abs(engunit-1.d2).le.1.d-10)         write(nsolwr,
+     x      "('ENERGY UNITS=kjoule/mol ')")
+          if(abs(engunit-boltz).lt.1.d-10)        write(nsolwr,
+     x      "('ENERGY UNITS=kelvin ')")
+          if(abs(engunit-1.d0).lt.1.d-10)         write(nsolwr,
+     x      "('ENERGY UNITS=DL_POLY Internal UNITS ')")
+          
+          write(nsolwr,'(2i10)')natms,mxtmls
+          write(nsolwr,'(1x,11a4)')' lex','lsw',' bnd',' ang',
+     x      ' dih',' inv',' shl',' cou',' vdw',' 3bd',' 4bd'
+          write(nsolwr,'(11l4)')lexcite,lswitch,lcomp
+          
+        endif
+        
+c     write out periodic data
+        
+        if(mod(nstep-nsolva,isolva).eq.0)then
+          
+c     mark start of time step data
+          
+          if(lexcite)then
+            write(nsolwr,'("timestep",i10,f12.5,1p,2e14.6)')
+     x        nstep,tstep,elrc/engunit,elrc2/engunit
+          else
+            write(nsolwr,'("timestep",i10,f12.5,1p,e14.6)')
+     x        nstep,tstep,elrc/engunit
+          endif
+          
+c     write intramolecular data
+          
+          write(nsolwr,'(1p,5e14.6)')temp_sol
+          if(lcomp(1))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')bnd_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')bnd_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')bnd_sol(:)/engunit
+            endif
+          endif
+          if(lcomp(2))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')ang_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')ang_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')ang_sol(:)/engunit
+            endif
+          endif
+          if(lcomp(3))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')dih_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')dih_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')dih_sol(:)/engunit
+            endif
+          endif
+          if(lcomp(4))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')inv_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')inv_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')inv_sol(:)/engunit
+            endif
+          endif
+          
+c     write core-shell data
+          
+          if(lcomp(5))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')shl_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')shl_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')shl_sol(:)/engunit
+            endif
+          endif
+          
+c     write coulombic data
+          
+          if(lcomp(6))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')cou_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')cou_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')cou_sol(:)/engunit
+            endif
+          endif
+          
+c     write vdw data
+          
+          if(lcomp(7))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')vdw_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')vdw_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')vdw_sol(:)/engunit
+            endif
+          endif
+          
+c     write 3-body data
+          
+          if(lcomp(8))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')en3_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')en3_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')en3_sol(:)/engunit
+            endif
+          endif
+          
+c     write 4-body data
+          
+          if(lcomp(9))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')en4_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')en4_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')en4_sol(:)/engunit
+            endif
+          endif
+        
+        endif
+        
+c     close SOLVAT file at regular intervals
+        
+        if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+          
+          close(nsolwr)
+          newjob=.true.
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine solvation_write
+      
+      end module solvation_module
diff -urN dl_class_1.9.orig/srcmod/spme_module.f dl_class_1.9/srcmod/spme_module.f
--- dl_class_1.9.orig/srcmod/spme_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/spme_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1175 @@
+      module spme_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining spme arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use setup_module
+      use utility_module
+
+      implicit none
+
+      real(8), allocatable :: csp(:),qqc(:,:,:),ffttable(:)
+      real(8), allocatable :: bspx(:,:), bspy(:,:), bspz(:,:)
+      real(8), allocatable :: bsdx(:,:), bsdy(:,:), bsdz(:,:)
+      integer, allocatable :: key1(:),key2(:),key3(:)
+      complex(8), allocatable :: ww1(:), ww2(:), ww3(:)
+      complex(8), allocatable :: qqq(:,:,:)
+      complex(8), allocatable :: bscx(:), bscy(:),bscz(:)
+CFFTW      pointer, save :: fplan, bplan
+
+      save csp,qqc,qqq,ww1,ww2,ww3,bscx,bscy,bscz,ffttable
+      save bspx,bspy,bspz,bsdx,bsdy,bsdz,key1,key2,key3
+
+      contains
+
+      subroutine alloc_spme_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=9
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (csp(mxspl),ffttable(mxftab),stat=fail(1))
+      allocate (bspx(mxspme,mxspl),bspy(mxspme,mxspl),stat=fail(2))
+      allocate (bspz(mxspme,mxspl),bsdx(mxspme,mxspl),stat=fail(3))
+      allocate (bsdy(mxspme,mxspl),bsdz(mxspme,mxspl),stat=fail(4))
+      allocate (bscx(kmaxd),bscy(kmaxe),bscz(kmaxf),stat=fail(5))
+      allocate (key1(kmaxd),key2(kmaxe),key3(kmaxf),stat=fail(6))
+      allocate (ww1(kmaxd),ww2(kmaxe),ww3(kmaxf),stat=fail(7))
+      allocate (qqc(kmaxd,kmaxe,kmaxf),stat=fail(8))
+      allocate (qqq(kmaxd,kmaxe,kmaxf),stat=fail(9))
+      do i=1,nnn
+         if(fail(i).ne.0)call error(idnode,1750)
+      enddo
+
+      end subroutine alloc_spme_arrays
+
+      subroutine bspcoe(nospl,kmax1,kmax2,kmax3)
+
+c**********************************************************************
+c     
+c     dl_poly subroutine to calculate B-spline coefficients for 
+c     Euler exponential splines.
+c     
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith july 1998
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nospl,kmax1,kmax2,kmax3,k,i,j
+      complex(8) ccc
+
+c     calculate B-splines at knots
+
+        csp(1)=0.d0
+        csp(2)=1.d0
+        
+        do k=3,nospl
+          
+          csp(k)=0.d0
+          
+          do j=k,2,-1
+            
+            csp(j)=(dble(j-1)*csp(j)+dble(k-j+1)*csp(j-1))/dble(k-1)
+            
+          enddo
+          
+        enddo
+        
+c     calculate B-spline coefficients
+
+      do i=0,kmax1-1
+
+        ccc=(0.d0,0.d0)
+
+        do k=0,nospl-2
+
+          ccc=ccc+csp(k+2)*ww1(mod(i*k,kmax1)+1)
+
+        enddo
+
+        bscx(i+1)=ww1(mod(i*(nospl-1),kmax1)+1)/ccc
+
+      enddo
+
+      do i=0,kmax2-1
+
+        ccc=(0.d0,0.d0)
+
+        do k=0,nospl-2
+
+          ccc=ccc+csp(k+2)*ww2(mod(i*k,kmax2)+1)
+
+        enddo
+
+        bscy(i+1)=ww2(mod(i*(nospl-1),kmax2)+1)/ccc
+
+      enddo
+
+      do i=0,kmax3-1
+
+        ccc=(0.d0,0.d0)
+
+        do k=0,nospl-2
+
+          ccc=ccc+csp(k+2)*ww3(mod(i*k,kmax3)+1)
+
+        enddo
+
+        bscz(i+1)=ww3(mod(i*(nospl-1),kmax3)+1)/ccc
+
+      enddo
+
+      return
+      end subroutine bspcoe
+
+      subroutine bspgen(idnode,mxnode,natms,nospl,txx,tyy,tzz)
+
+c***********************************************************************
+c
+c     dl_poly subroutine to calculate B-splines for SPME method
+c
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith july 1998
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nospl,natms,idnode,mxnode,iatm0,iatm1,i,j,k
+      real(8) aaa,bbb,ccc,txx,tyy,tzz
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      
+c     set up atoms numbers for nodes
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     construct B-splines
+
+      do i=iatm0,iatm1
+
+        bsdx(i,1)=1.d0
+        bsdy(i,1)=1.d0
+        bsdz(i,1)=1.d0
+        bsdx(i,2)=-1.d0
+        bsdy(i,2)=-1.d0
+        bsdz(i,2)=-1.d0
+        bspx(i,1)=txx(i)-int(txx(i))
+        bspy(i,1)=tyy(i)-int(tyy(i))
+        bspz(i,1)=tzz(i)-int(tzz(i))
+        bspx(i,2)=1.d0-txx(i)+int(txx(i))
+        bspy(i,2)=1.d0-tyy(i)+int(tyy(i))
+        bspz(i,2)=1.d0-tzz(i)+int(tzz(i))
+
+      enddo
+      
+      do k=3,nospl
+        
+        do i=iatm0,iatm1
+
+          bspx(i,k)=0.d0
+          bspy(i,k)=0.d0
+          bspz(i,k)=0.d0
+
+        enddo
+        
+        do j=k,2,-1
+
+          if(k.eq.nospl)then
+            
+            do i=iatm0,iatm1
+              
+              bsdx(i,j)=bspx(i,j)-bspx(i,j-1)
+              bsdy(i,j)=bspy(i,j)-bspy(i,j-1)
+              bsdz(i,j)=bspz(i,j)-bspz(i,j-1)
+              
+            enddo
+            
+          endif
+          
+          do i=iatm0,iatm1
+            
+            aaa=txx(i)+dble(j-1)-int(txx(i))
+            bbb=tyy(i)+dble(j-1)-int(tyy(i))
+            ccc=tzz(i)+dble(j-1)-int(tzz(i))
+            bspx(i,j)=(aaa*bspx(i,j)+(dble(k)-aaa)*bspx(i,j-1))/
+     x        dble(k-1)
+            bspy(i,j)=(bbb*bspy(i,j)+(dble(k)-bbb)*bspy(i,j-1))/
+     x        dble(k-1)
+            bspz(i,j)=(ccc*bspz(i,j)+(dble(k)-ccc)*bspz(i,j-1))/
+     x        dble(k-1)
+
+          enddo
+          
+        enddo
+        
+        if(k.eq.nospl)then
+          
+          do i=iatm0,iatm1
+            
+            bsdx(i,1)=bspx(i,1)
+            bsdy(i,1)=bspy(i,1)
+            bsdz(i,1)=bspz(i,1)
+            
+          enddo
+          
+        endif
+        
+        do i=iatm0,iatm1
+
+          bspx(i,1)=(txx(i)-int(txx(i)))*bspx(i,1)/dble(k-1)
+          bspy(i,1)=(tyy(i)-int(tyy(i)))*bspy(i,1)/dble(k-1)
+          bspz(i,1)=(tzz(i)-int(tzz(i)))*bspz(i,1)/dble(k-1)
+
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine bspgen
+
+      subroutine ewald_spme
+     x (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x  engcpe,vircpe,alpha,volm,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using the smoothed particle mesh ewald method
+c     due to Essmann et al J. Chem. Phys. 103 (1995) 8577.
+c     
+c     parallel replicated data version (part 1)
+c     
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith july 1998
+c     additional FFT code - j. geronowicz sept 1999
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical newjob,lconsw
+      
+      integer idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl
+      integer npass,i,nnn,ipass,l,ll,k,kk,j,jj,fail,iatm0,iatm1
+      real(8) engcpe,vircpe,alpha,volm,epsq,omg,bb1,bb2,bb3,qchg
+      real(8) twopi,engsic,rvolm,ralph,shiftx,shifty,shiftz,det,qfix
+      real(8) tx,ty,tz,rcpcut,rcpct2,rkx1,rky1,rkz1,rkx2,rky2,rkz2
+      real(8) rkx3,rky3,rkz3,rksq,akv,eng1,den,scal1,tmp,rclprp
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+CESSL      integer inc2,inc3
+CSGIC      real(8) nauxfft(4)
+
+      dimension omg(9),rclprp(10)
+      complex(8) cpetot,vterm
+      save newjob,engsic,qchg,iatm0,iatm1
+      
+      data newjob/.true./,fail/0/
+CSGIC      data nauxfft/3,0,0,0/
+
+c     allocate temporary arrays
+
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1760)
+
+      npass=1
+      lconsw=.true.
+      twopi=2.d0*pi
+      
+      if(newjob)then
+        
+        newjob=.false.
+        
+c     set up atoms numbers for nodes
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     calculate self interaction correction and net system charge
+        
+        qchg=0.d0
+        engsic=0.d0
+        
+        do i=iatm0,iatm1
+          
+          qchg=qchg+chge(i)
+          engsic=engsic+chge(i)**2
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=qchg
+          buffer(2)=engsic
+          call gdsum(buffer(1),2,buffer(3))
+          qchg  =buffer(1)
+          engsic=buffer(2)
+          
+        endif
+      
+        engsic=-r4pie0/epsq*alpha*engsic/sqrpi
+
+c     initialise the complex exponential arrays
+
+CCRAY        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+CESSL        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+CFFTW        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+CSGIC        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+
+c     initialise the default fft routine
+
+      call dlpfft3(1,1,kmax1,kmax2,kmax3,key1,key2,key3,
+     x  ww1,ww2,ww3,qqq)
+      
+c     calculate B-spline coefficients
+
+        call bspcoe(nospl,kmax1,kmax2,kmax3)
+        
+      endif
+      
+c     initialise coulombic potential energy
+      
+      engcpe=0.d0
+      vircpe=0.d0
+
+c     initalize stress tensor working arrays
+
+      do i = 1,9
+        omg(i) = 0.d0
+      enddo
+
+c     set working parameters
+
+      rvolm=twopi/volm
+      ralph=-0.25d0/alpha**2
+
+c     set switch for TO, RD and HP boundary conditions
+
+      if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7) then
+
+        npass=2
+        lconsw=.false.
+        rvolm=0.5d0*rvolm
+        shiftx=0.5d0*dble(kmax1)
+        shifty=0.5d0*dble(kmax2)
+        shiftz=0.5d0*dble(kmax3)
+        if(imcon.eq.7)shiftz=0.d0
+
+      endif
+
+c     convert cell coordinates to fractional coordinates
+
+      call invert(cell,rcell,det)
+      if(abs(det).lt.1.d-6)call error(idnode,120)
+      
+      do i=iatm0,iatm1
+        
+        txx(i)=dble(kmax1)*(rcell(1)*xxx(i)+rcell(4)*yyy(i)+
+     x    rcell(7)*zzz(i)+0.5d0)
+        tyy(i)=dble(kmax2)*(rcell(2)*xxx(i)+rcell(5)*yyy(i)+
+     x    rcell(8)*zzz(i)+0.5d0)
+        tzz(i)=dble(kmax3)*(rcell(3)*xxx(i)+rcell(6)*yyy(i)+
+     x    rcell(9)*zzz(i)+0.5d0)
+
+      enddo
+      
+c     construct B-splines for atoms
+      
+      call bspgen(idnode,mxnode,natms,nospl,txx,tyy,tzz)
+      
+c     zero 3D charge array
+      
+      nnn=kmaxd*kmaxe*kmaxf
+      call set_block(nnn,0.d0,qqc)
+      
+c     construct 3D charge array
+      
+      do ipass=1,npass
+        
+        do i=iatm0,iatm1
+          
+          do l=1,nospl
+            
+            ll=int(tzz(i))-l+2
+            if(ll.gt.kmax3)ll=1
+            if(ll.lt.1)ll=ll+kmax3
+            do k=1,nospl
+              
+              kk=int(tyy(i))-k+2
+              if(kk.gt.kmax2)kk=1
+              if(kk.lt.1)kk=kk+kmax2
+              
+              do j=1,nospl
+                
+                jj=int(txx(i))-j+2
+                if(jj.gt.kmax1)jj=1
+                if(jj.lt.1)jj=jj+kmax1
+                
+                qqc(jj,kk,ll)=qqc(jj,kk,ll)+
+     x            chge(i)*bspx(i,j)*bspy(i,k)*bspz(i,l)
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        enddo
+        
+        if(.not.lconsw)then
+
+          do i=iatm0,iatm1
+
+            tx=txx(i)-shiftx
+            ty=tyy(i)-shifty
+            tz=tzz(i)-shiftz
+            txx(i)=txx(i)-sign(shiftx,tx)
+            tyy(i)=tyy(i)-sign(shifty,ty)
+            tzz(i)=tzz(i)-sign(shiftz,tz)
+
+          enddo
+
+        endif
+        
+      enddo
+
+c     global sum of charge array
+        
+      if(mxnode.gt.1) call gdsum(qqc,nnn,buffer)
+        
+c     load charge array into complex array for FFT
+
+      call cpy_rtc(nnn,qqc,qqq)
+
+c     calculate inverse 3D FFT of charge array (in place).
+      
+CFFTW      call fftwnd_f77_one(fplan,qqq,0)
+
+CESSL      inc2=kmaxd
+CESSL      inc3=kmaxd*kmaxe
+CESSL      call dcft3(qqq,inc2,inc3,qqq,inc2,inc3,kmax1,kmax2,kmax3,
+CESSL     x  -1,1.d0,buffer,mxbuff)
+
+CSGIC      call zzfft3d( -1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CSGIC     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+
+CCRAY      call ccfft3d( -1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CCRAY     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+      
+      call dlpfft3(0,1,kmax1,kmax2,kmax3,key1,key2,key3,
+     x  ww1,ww2,ww3,qqq)
+      
+c     set reciprocal space cutoff
+
+      call dcell(rcell,rclprp)
+
+      rcpcut=0.5d0*min(dble(kmax1)*rclprp(7),dble(kmax2)*rclprp(8),
+     x  dble(kmax3)*rclprp(9))
+      rcpcut=rcpcut*1.05d0*twopi
+      rcpct2=rcpcut**2
+      
+c     calculate convolution of charge array with gaussian function
+
+      do l=1,kmax3
+
+        ll=l-1
+        if(l.gt.kmax3/2)ll=l-kmax3-1
+        tmp=twopi*dble(ll)
+        rkx1=tmp*rcell(3)
+        rky1=tmp*rcell(6)
+        rkz1=tmp*rcell(9)
+        bb3=real(bscz(l)*conjg(bscz(l)))
+
+        do k=1,kmax2
+
+          kk=k-1
+          if(k.gt.kmax2/2)kk=k-kmax2-1
+          tmp=twopi*dble(kk)
+          rkx2=rkx1+tmp*rcell(2)
+          rky2=rky1+tmp*rcell(5)
+          rkz2=rkz1+tmp*rcell(8)
+          bb2=bb3*real(bscy(k)*conjg(bscy(k)))
+          
+          do j=1,kmax1
+
+            jj=j-1
+            if(j.gt.kmax1/2)jj=j-kmax1-1
+            tmp=twopi*dble(jj)
+            rkx3=rkx2+tmp*rcell(1)
+            rky3=rky2+tmp*rcell(4)
+            rkz3=rkz2+tmp*rcell(7)
+            bb1=bb2*real(bscx(j)*conjg(bscx(j)))
+                
+            rksq=rkx3*rkx3+rky3*rky3+rkz3*rkz3
+
+            if(rksq.gt.1.d-6.and.rksq.le.rcpct2)then
+
+              vterm=bb1*exp(ralph*rksq)/rksq*qqq(j,k,l)
+              akv=2.d0*(1.d0/rksq-ralph)*real(vterm*conjg(qqq(j,k,l)))
+              omg(1)=omg(1)-rkx3*rkx3*akv
+              omg(5)=omg(5)-rky3*rky3*akv
+              omg(9)=omg(9)-rkz3*rkz3*akv
+              omg(2)=omg(2)-rkx3*rky3*akv
+              omg(3)=omg(3)-rkx3*rkz3*akv
+              omg(6)=omg(6)-rky3*rkz3*akv
+              qqq(j,k,l)=vterm
+
+            else
+
+              qqq(j,k,l)=(0.d0,0.d0)
+
+            endif
+
+          enddo
+
+        enddo
+
+      enddo
+      
+CFFTW      call fftwnd_f77_one(bplan,qqq,0)
+CESSL      call dcft3(qqq,inc2,inc3,qqq,inc2,inc3,kmax1,kmax2,kmax3,
+CESSL     x  1,1.d0,buffer,mxbuff)
+
+CSGIC      call zzfft3d( 1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CSGIC     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+
+CCRAY      call ccfft3d( 1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CCRAY     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+
+      call dlpfft3(0,-1,kmax1,kmax2,kmax3,key1,key2,key3,
+     x  ww1,ww2,ww3,qqq)
+
+c     calculate atomic forces
+      
+      call spme_for
+     x  (idnode,mxnode,nospl,natms,kmax1,kmax2,kmax3,rvolm,
+     x  epsq,txx,tyy,tzz)
+
+c     complete product of charge array and its gaussian convolution
+
+      call ele_prd(nnn,qqq,qqc,qqq)
+      
+c     correction for charged systems
+
+      qfix=-(0.5d0*pi*r4pie0/epsq)*((qchg/alpha)**2/volm)/
+     x  dble(mxnode)
+      
+c     calculate total energy
+
+      call scl_csum(nnn,cpetot,qqq)
+
+      eng1=real(cpetot)
+      den=1.d0/dble(npass)
+      engcpe=engcpe+(den*rvolm*r4pie0*eng1/epsq+engsic)/
+     x   dble(mxnode)+qfix
+
+c     calculate stress tensor (symmetrical)
+
+      scal1=den*rvolm*r4pie0/(epsq*dble(mxnode))
+      stress(1) = stress(1)+scal1*(omg(1)+eng1)+qfix
+      stress(2) = stress(2)+scal1*omg(2)
+      stress(3) = stress(3)+scal1*omg(3)
+      stress(4) = stress(4)+scal1*omg(2)
+      stress(5) = stress(5)+scal1*(omg(5)+eng1)+qfix
+      stress(6) = stress(6)+scal1*omg(6)
+      stress(7) = stress(7)+scal1*omg(3)
+      stress(8) = stress(8)+scal1*omg(6)
+      stress(9) = stress(9)+scal1*(omg(9)+eng1)+qfix
+
+c     virial term
+
+      vircpe=vircpe-scal1*(omg(1)+omg(5)+omg(9)+3.d0*eng1)-3.d0*qfix
+      
+c     deallocate temporary arrays
+
+      deallocate (txx,tyy,tzz,stat=fail)
+      
+      return
+      end subroutine ewald_spme
+
+      subroutine spme_for
+     x  (idnode,mxnode,nospl,natms,kmax1,kmax2,kmax3,rvolm,
+     x  epsq,txx,tyy,tzz)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using smoothed particle mesh ewald method
+c     
+c     parallel replicated data version (part 1)
+c     
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith oct 1998
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,nospl,natms,kmax1,kmax2,kmax3,i,ll
+      integer iatm0,iatm1,kk,k,j,jj,l
+      real(8) rvolm,epsq,txx,tyy,tzz,fff,fac,bdx,bdy,bdz
+      real(8) det,qsum
+
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension fff(3)
+
+      fac=-2.d0*rvolm*r4pie0/epsq
+      call invert(cell,rcell,det)
+
+c     set up atom numbers for nodes
+
+      iatm0 = (idnode*natms)/mxnode + 1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+c     calculate forces
+
+      do i=iatm0,iatm1
+
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+
+        do l=1,nospl
+          
+          ll=int(tzz(i))-l+2
+          if(ll.gt.kmax3)ll=1
+          if(ll.lt.1)ll=ll+kmax3
+          
+          do k=1,nospl
+            
+            kk=int(tyy(i))-k+2
+            if(kk.gt.kmax2)kk=1
+            if(kk.lt.1)kk=kk+kmax2
+            
+            do j=1,nospl
+              
+              jj=int(txx(i))-j+2
+              if(jj.gt.kmax1)jj=1
+              if(jj.lt.1)jj=jj+kmax1
+              
+              qsum=real(qqq(jj,kk,ll))
+              bdx=qsum*bsdx(i,j)*bspy(i,k)*bspz(i,l)*dble(kmax1)
+              bdy=qsum*bspx(i,j)*bsdy(i,k)*bspz(i,l)*dble(kmax2)
+              bdz=qsum*bspx(i,j)*bspy(i,k)*bsdz(i,l)*dble(kmax3)
+              
+              fxx(i)=fxx(i)+fac*chge(i)*(bdx*rcell(1)+bdy*rcell(2)+
+     x          bdz*rcell(3))
+              fyy(i)=fyy(i)+fac*chge(i)*(bdx*rcell(4)+bdy*rcell(5)+
+     x          bdz*rcell(6))
+              fzz(i)=fzz(i)+fac*chge(i)*(bdx*rcell(7)+bdy*rcell(8)+
+     x          bdz*rcell(9))
+              
+            enddo
+            
+          enddo
+          
+        enddo
+
+      enddo
+
+c     remove COM drift arising from SPME approximations
+
+      fff(1)=0.d0
+      fff(2)=0.d0
+      fff(3)=0.d0
+
+      do i=iatm0,iatm1
+
+        fff(1)=fff(1)+fxx(i)
+        fff(2)=fff(2)+fyy(i)
+        fff(3)=fff(3)+fzz(i)
+
+      enddo
+
+      if(mxnode.gt.1)call gdsum(fff,3,buffer)
+
+      fff(1)=fff(1)/dble(natms)
+      fff(2)=fff(2)/dble(natms)
+      fff(3)=fff(3)/dble(natms)
+
+      do i=iatm0,iatm1
+
+        fxx(i)=fxx(i)-fff(1)
+        fyy(i)=fyy(i)-fff(2)
+        fzz(i)=fzz(i)-fff(3)
+
+      enddo
+      
+      return
+      end subroutine spme_for
+
+      subroutine dlpfft3
+     x  (ind,isw,ndiv1,ndiv2,ndiv3,key1,key2,key3,ww1,ww2,ww3,aaa)
+
+c***********************************************************************
+c     
+c     dl-poly 3D fast fourier transform routine (in place)
+c     
+c     copyright daresbury laboratory 1998
+c     author w smith july 1998
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lkx,lky,lkz
+      integer ind,isw,ndiv1,ndiv2,ndiv3,key1,key2,key3,i,idm,kkk
+      integer nu1,nu2,nu3,iii,jjj,j,jj2,num,l,kk1,k12,k
+      real(8) tpi,arg
+
+      dimension key1(ndiv1),key2(ndiv2),key3(ndiv3)
+      complex(8) ww1(ndiv1),ww2(ndiv2),ww3(ndiv3)
+      complex(8) ttt,aaa(ndiv1,ndiv2,ndiv3)
+      save nu1,nu2,nu3
+
+      data tpi/6.283185307179586d0/
+      
+      if(ind.gt.0)then
+
+c     check FFT array dimensions
+
+        idm=1
+        lkx=.true.
+        lky=.true.
+        lkz=.true.
+
+        do i=1,30
+          
+          idm=2*idm
+
+          if(idm.eq.ndiv1)then
+
+            lkx=.false.
+            nu1=i
+
+          endif
+          if(idm.eq.ndiv2)then
+
+            lky=.false.
+            nu2=i
+
+          endif
+          if(idm.eq.ndiv3)then
+
+            lkz=.false.
+            nu3=i
+
+          endif
+          
+        enddo
+        
+        if(lkx.or.lky.or.lkz)then
+          
+          write(*,*)'error - FFT array not 2**N'
+          stop
+          
+        endif
+        
+c     set reverse bit address arrays
+        
+        do kkk=1,ndiv1
+
+          iii=0
+          jjj=kkk-1
+
+          do j=1,nu1
+
+            jj2=jjj/2
+            iii=2*(iii-jj2)+jjj
+            jjj=jj2
+
+          enddo
+
+          key1(kkk)=iii+1
+
+        enddo
+        
+        do kkk=1,ndiv2
+
+          iii=0
+          jjj=kkk-1
+
+          do j=1,nu2
+
+            jj2=jjj/2
+            iii=2*(iii-jj2)+jjj
+            jjj=jj2
+
+          enddo
+
+          key2(kkk)=iii+1
+
+        enddo
+        
+        do kkk=1,ndiv3
+
+          iii=0
+          jjj=kkk-1
+
+          do j=1,nu3
+
+            jj2=jjj/2
+            iii=2*(iii-jj2)+jjj
+            jjj=jj2
+
+          enddo
+
+          key3(kkk)=iii+1
+
+        enddo
+        
+c     initialise complex exponential factors
+        
+        ww1(1)=(1.d0,0.d0)
+
+        do i=1,ndiv1/2
+
+          arg=(tpi/dble(ndiv1))*dble(i)
+          ww1(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+          ww1(ndiv1+1-i)=conjg(ww1(i+1))
+
+        enddo
+        
+        ww2(1)=(1.d0,0.d0)
+
+        do i=1,ndiv2/2
+
+          arg=(tpi/dble(ndiv2))*dble(i)
+          ww2(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+          ww2(ndiv2+1-i)=conjg(ww2(i+1))
+
+        enddo
+        
+        ww3(1)=(1.d0,0.d0)
+
+        do i=1,ndiv3/2
+
+          arg=(tpi/dble(ndiv3))*dble(i)
+          ww3(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+          ww3(ndiv3+1-i)=conjg(ww3(i+1))
+
+        enddo
+        
+        return
+
+      endif
+
+c     take conjugate of exponentials if required
+      
+      if(isw.lt.0)then
+        
+        do i=1,ndiv1
+
+          ww1(i)=conjg(ww1(i))
+
+        enddo
+
+        do i=1,ndiv2
+
+          ww2(i)=conjg(ww2(i))
+
+        enddo
+
+        do i=1,ndiv3
+
+          ww3(i)=conjg(ww3(i))
+
+        enddo
+        
+      endif
+      
+c     perform fourier transform in X direction
+      
+      kkk=0
+      num=ndiv1/2
+      
+      do l=1,nu1
+
+        do while(kkk.lt.ndiv1)
+
+          do i=1,num
+            
+            iii=key1(kkk/num+1)
+            kk1=kkk+1
+            k12=kk1+num
+            
+            do j=1,ndiv2
+              
+              do k=1,ndiv3
+                
+                ttt=aaa(k12,j,k)*ww1(iii)
+                aaa(k12,j,k)=aaa(kk1,j,k)-ttt
+                aaa(kk1,j,k)=aaa(kk1,j,k)+ttt
+                
+              enddo
+              
+            enddo
+            
+            kkk=kkk+1
+            
+          enddo
+          
+          kkk=kkk+num
+          
+        enddo
+        
+        kkk=0
+        num=num/2
+
+      enddo
+      
+c     unscramble the fft using bit address array
+      
+      do kkk=1,ndiv1
+
+        iii=key1(kkk)
+
+        if(iii.gt.kkk)then
+
+          do j=1,ndiv2
+
+            do k=1,ndiv3
+
+              ttt=aaa(kkk,j,k)
+              aaa(kkk,j,k)=aaa(iii,j,k)
+              aaa(iii,j,k)=ttt
+
+            enddo
+
+          enddo
+
+        endif
+
+      enddo
+      
+c     perform fourier transform in Y direction
+      
+      kkk=0
+      num=ndiv2/2
+
+      do l=1,nu2
+
+        do while(kkk.lt.ndiv2)
+
+          do i=1,num
+            
+            iii=key2(kkk/num+1)
+            kk1=kkk+1
+            k12=kk1+num
+            
+            do j=1,ndiv1
+              
+              do k=1,ndiv3
+                
+                ttt=aaa(j,k12,k)*ww2(iii)
+                aaa(j,k12,k)=aaa(j,kk1,k)-ttt
+                aaa(j,kk1,k)=aaa(j,kk1,k)+ttt
+                
+              enddo
+              
+            enddo
+            
+            kkk=kkk+1
+            
+          enddo
+          
+          kkk=kkk+num
+          
+        enddo
+
+        kkk=0
+        num=num/2
+
+      enddo
+      
+c     unscramble the fft using bit address array
+      
+      do kkk=1,ndiv2
+
+        iii=key2(kkk)
+
+        if(iii.gt.kkk)then
+
+          do j=1,ndiv1
+
+            do k=1,ndiv3
+
+              ttt=aaa(j,kkk,k)
+              aaa(j,kkk,k)=aaa(j,iii,k)
+              aaa(j,iii,k)=ttt
+
+            enddo
+
+          enddo
+
+        endif
+
+      enddo
+      
+c     perform fourier transform in Z direction
+      
+      kkk=0
+      num=ndiv3/2
+
+      do l=1,nu3
+
+        do while(kkk.lt.ndiv3)
+
+          do i=1,num
+
+            iii=key3(kkk/num+1)
+            kk1=kkk+1
+            k12=kk1+num
+            
+            do j=1,ndiv1
+              
+              do k=1,ndiv2
+                
+                ttt=aaa(j,k,k12)*ww3(iii)
+                aaa(j,k,k12)=aaa(j,k,kk1)-ttt
+                aaa(j,k,kk1)=aaa(j,k,kk1)+ttt
+                
+              enddo
+              
+            enddo
+            
+            kkk=kkk+1
+            
+          enddo
+          
+          kkk=kkk+num
+          
+        enddo
+
+        kkk=0
+        num=num/2
+
+      enddo
+      
+c     unscramble the fft using bit address array
+      
+      do kkk=1,ndiv3
+
+        iii=key3(kkk)
+
+        if(iii.gt.kkk)then
+
+          do j=1,ndiv1
+
+            do k=1,ndiv2
+
+              ttt=aaa(j,k,kkk)
+              aaa(j,k,kkk)=aaa(j,k,iii)
+              aaa(j,k,iii)=ttt
+
+            enddo
+
+          enddo
+
+        endif
+
+      enddo
+      
+c     restore exponentials to unconjugated values if necessary
+      
+      if(isw.lt.0)then
+        
+        do i=1,ndiv1
+
+          ww1(i)=conjg(ww1(i))
+
+        enddo
+        
+        do i=1,ndiv2
+
+          ww2(i)=conjg(ww2(i))
+
+        enddo
+        
+        do i=1,ndiv3
+
+          ww3(i)=conjg(ww3(i))
+
+        enddo
+        
+      endif
+      
+      return
+      end subroutine dlpfft3
+
+      subroutine spl_cexp(ndiv1,ndiv2,ndiv3,ww1,ww2,ww3)
+
+c***********************************************************************
+c     
+c     dl-poly routine to create complex exponential arrays for
+c     b-splines
+c     
+c     copyright daresbury laboratory 1998
+c     author w smith oct 1998
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer ndiv1,ndiv2,ndiv3,i
+      real(8) tpi,arg
+      complex(8) ww1(ndiv1),ww2(ndiv2),ww3(ndiv3)
+
+      data tpi/6.283185307179586d0/
+
+c     initialise complex exponential factors
+      
+      ww1(1)=(1.d0,0.d0)
+
+      do i=1,ndiv1/2
+
+        arg=(tpi/dble(ndiv1))*dble(i)
+        ww1(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+        ww1(ndiv1+1-i)=conjg(ww1(i+1))
+
+      enddo
+      
+      ww2(1)=(1.d0,0.d0)
+
+      do i=1,ndiv2/2
+
+        arg=(tpi/dble(ndiv2))*dble(i)
+        ww2(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+        ww2(ndiv2+1-i)=conjg(ww2(i+1))
+
+      enddo
+      
+      ww3(1)=(1.d0,0.d0)
+
+      do i=1,ndiv3/2
+
+        arg=(tpi/dble(ndiv3))*dble(i)
+        ww3(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+        ww3(ndiv3+1-i)=conjg(ww3(i+1))
+
+      enddo
+      
+      return
+      end subroutine spl_cexp
+      
+      end module spme_module
diff -urN dl_class_1.9.orig/srcmod/temp_scalers_module.f dl_class_1.9/srcmod/temp_scalers_module.f
--- dl_class_1.9.orig/srcmod/temp_scalers_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/temp_scalers_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,768 @@
+      module temp_scalers_module
+
+c***********************************************************************
+c     
+c     dl_poly module for temperature scaling routines
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use core_shell_module
+      use error_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use utility_module
+      
+      contains
+
+      subroutine quench(imcon,idnode,mxnode,natms,nscons,tolnce)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for quenching the bond energies in the 
+c     initial structure of a molecule defined by constraints
+c     
+c     copyright - daresbury laboratory 1992
+c     author w.smith november 1992
+c     
+c*********************************************************************
+
+      implicit none
+
+      logical safe
+      integer imcon,idnode,mxnode,natms,nscons,i,j,k,icyc
+      integer fail
+      real(8) tolnce,ddd,esig,vvv,ww1,ww2
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+
+      dimension fail(3)
+
+      data fail/0,0,0/
+
+c     allocate work arrays
+
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(3))
+
+      do i=1,3
+         if(fail(i).ne.0)call error(idnode,1770)
+      enddo
+
+c     calculate bond vectors
+
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+        dxt(k)=xxx(i)-xxx(j)
+        dyt(k)=yyy(i)-yyy(j)
+        dzt(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+      call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+      
+c     normalise bond vectors
+      
+      do k=1,nscons
+        
+        ddd=sqrt(dxt(k)**2+dyt(k)**2+dzt(k)**2)
+        
+        dxt(k)=dxt(k)/ddd
+        dyt(k)=dyt(k)/ddd
+        dzt(k)=dzt(k)/ddd
+        
+      enddo
+      
+c     start of quenching cycle
+      
+      icyc=0
+      safe=.false.
+      do while(.not.safe.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+
+c     initialise velocity correction arrays
+        
+        do i=1,natms
+          
+          uxx(i)=0.d0
+          uyy(i)=0.d0
+          uzz(i)=0.d0
+          
+        enddo
+        
+c     calculate velocity corrections and error
+        
+        esig=0.d0
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          vvv=dxt(k)*(vxx(i)-vxx(j))+dyt(k)*(vyy(i)-vyy(j))+
+     x      dzt(k)*(vzz(i)-vzz(j))
+          
+          esig=max(esig,abs(vvv))
+          
+          ww1=weight(j)*vvv/(weight(i)+weight(j))
+          ww2=weight(i)*vvv/(weight(i)+weight(j))
+          uxx(i)=uxx(i)-ww1*dxt(k)
+          uyy(i)=uyy(i)-ww1*dyt(k)
+          uzz(i)=uzz(i)-ww1*dzt(k)
+          uxx(j)=uxx(j)+ww2*dxt(k)
+          uyy(j)=uyy(j)+ww2*dyt(k)
+          uzz(j)=uzz(j)+ww2*dzt(k)
+          
+        enddo
+
+        safe=(esig.lt.tolnce)
+        
+        if(mxnode.gt.1)call gstate(safe)
+        
+        if(.not.safe)then
+          
+c     transport velocity adjustments to other nodes
+          
+          if(mxnode.gt.1)then
+            
+            call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,uxx,uyy,uzz,
+     x        xxt,yyt,zzt,buffer)
+            
+          endif
+          
+c     update velocities
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            vxx(i)=vxx(i)+uxx(i)/dble(listme(i))
+            vyy(i)=vyy(i)+uyy(i)/dble(listme(i))
+            vzz(i)=vzz(i)+uzz(i)/dble(listme(i))
+            vxx(j)=vxx(j)+uxx(j)/dble(listme(j))
+            vyy(j)=vyy(j)+uyy(j)/dble(listme(j))
+            vzz(j)=vzz(j)+uzz(j)/dble(listme(j))
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     error exit if quenching fails
+      
+      if(.not.safe)call error(idnode,70)
+      
+c     splice velocity arrays across nodes
+      
+      if(mxnode.gt.1) call splice
+     x  (idnode,natms,listme,listot,vxx,vyy,vzz,buffer)
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,stat=fail(1))
+      deallocate (uxx,uyy,uzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,stat=fail(3))
+      
+      return
+      end subroutine quench
+
+      subroutine quatqnch(idnode,imcon,mxnode,natms,ngrp)
+
+c***********************************************************************
+c     
+c     dlpoly subroutine to convert atomic velocities to rigid body 
+c     c.o.m. and angular velocity
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1993.
+c     author   - t.forester nov 1993.
+c     amended  - t.forester dec 1994 : block data.
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,imcon,mxnode,natms,ngrp,fail,ig,jr,id
+      integer igrp1,igrp2,i,j
+      real(8) rot,wxx,wyy,wzz
+
+      dimension rot(9)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+
+      data fail/0/
+      
+c     allocate work arrays 
+
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1780)
+
+c     block indices for groups
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     translate atomic velocites to com velocity & angular velocity
+
+      jr=0
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=0.d0
+        gvyy(ig)=0.d0
+        gvzz(ig)=0.d0
+        omx(ig)=0.d0
+        omy(ig)=0.d0
+        omz(ig)=0.d0
+
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+
+          jr =jr+1
+          i =lstrgd(jr)
+
+c     centre of mass momentum
+
+          gvxx(ig)=gvxx(ig)+weight(i)*vxx(i)
+          gvyy(ig)=gvyy(ig)+weight(i)*vyy(i)
+          gvzz(ig)=gvzz(ig)+weight(i)*vzz(i)
+
+c     distance to c.o.m of molecule
+
+          xxt(jr)=xxx(i)-gcmx(ig)
+          yyt(jr)=yyy(i)-gcmy(ig)
+          zzt(jr)=zzz(i)-gcmz(ig)
+
+        enddo
+
+c     centre of mass velocity
+
+        gvxx(ig)=gvxx(ig)/gmass(id)
+        gvyy(ig)=gvyy(ig)/gmass(id)
+        gvzz(ig)=gvzz(ig)/gmass(id)
+
+      enddo
+
+      call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+
+      jr=0
+      do ig=igrp1,igrp2
+
+c     rotational matrix
+
+        rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+        rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+        rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+        rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+        rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+        rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+        rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+        rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+        rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+        
+c     angular momentum accumulators
+
+        wxx=0.d0
+        wyy=0.d0
+        wzz=0.d0
+
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+
+          jr =jr+1
+          i =lstrgd(jr)
+
+          wxx=wxx+weight(i)*(yyt(jr)*vzz(i)-zzt(jr)*vyy(i))
+          wyy=wyy+weight(i)*(zzt(jr)*vxx(i)-xxt(jr)*vzz(i))
+          wzz=wzz+weight(i)*(xxt(jr)*vyy(i)-yyt(jr)*vxx(i))
+
+        enddo
+
+c     angular velocity in body fixed frame
+
+        omx(ig)=(rot(1)*wxx+rot(4)*wyy+rot(7)*wzz)*rotinx(id,2)
+        omy(ig)=(rot(2)*wxx+rot(5)*wyy+rot(8)*wzz)*rotiny(id,2)
+        omz(ig)=(rot(3)*wxx+rot(6)*wyy+rot(9)*wzz)*rotinz(id,2)
+        
+        jr=jr-numgsit(id)
+        do j=1,numgsit(id)
+          
+          jr=jr +1
+          i=lstrgd(jr)
+          
+c     site velocity in body frame 
+
+          wxx=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          wyy=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          wzz=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+
+          vxx(i)=rot(1)*wxx+rot(2)*wyy+rot(3)*wzz+gvxx(ig)
+          vyy(i)=rot(4)*wxx+rot(5)*wyy+rot(6)*wzz+gvyy(ig)
+          vzz(i)=rot(7)*wxx+rot(8)*wyy+rot(9)*wzz+gvzz(ig)
+
+        enddo
+
+      enddo
+
+      if(mxnode.gt.1)then
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,omx,omy,omz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine quatqnch
+
+      subroutine vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for scaling the velocity arrays to the
+c     desired temperature
+c     
+c     zeroes angular momentum in non-periodic system.
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1992.
+c     author - w.smith july 1992
+c     amended - t.forester oct 1993
+c     amended - t.forester dec 1994 : block data
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,imcon,natms,ngrp,iatm1,iatm2,i
+      real(8) sigma,roti,rotinv,cmx,cmy,cmz,cmvx,cmvy,cmvz,sysmas
+      real(8) amx,amy,amz,det,scale,rsq,wxx,wyy,wzz,sumke
+
+      dimension roti(9),rotinv(9)
+
+c     block indices
+
+      iatm1=(idnode*natms)/mxnode+1
+      iatm2=((idnode+1)*natms)/mxnode
+
+c     calculate centre of mass position and motion of the system
+      
+      cmx=0.d0
+      cmy=0.d0
+      cmz=0.d0
+      cmvx=0.d0
+      cmvy=0.d0
+      cmvz=0.d0
+      sysmas=0.d0
+      
+      do i=iatm1,iatm2
+        
+        if(lstfrz(i).eq.0.and.weight(i).gt.1.d-6)then
+
+          cmx=cmx+weight(i)*xxx(i)
+          cmy=cmy+weight(i)*yyy(i)
+          cmz=cmz+weight(i)*zzz(i)
+          sysmas=sysmas+weight(i)
+          cmvx=cmvx+vxx(i)*weight(i)
+          cmvy=cmvy+vyy(i)*weight(i)
+          cmvz=cmvz+vzz(i)*weight(i)
+          
+        endif
+
+      enddo
+      
+      if(mxnode.gt.1)then
+        buffer(8)=sysmas
+        buffer(9)=cmx
+        buffer(10)=cmy
+        buffer(11)=cmz
+        buffer(12)=cmvx
+        buffer(13)=cmvy
+        buffer(14)=cmvz
+        call gdsum(buffer(8),7,buffer(1))
+        sysmas= buffer(8) 
+        cmx=buffer(9) 
+        cmy=buffer(10) 
+        cmz=buffer(11) 
+        cmvx=buffer(12) 
+        cmvy=buffer(13) 
+        cmvz=buffer(14) 
+      endif
+
+      cmx=cmx/sysmas
+      cmy=cmy/sysmas
+      cmz=cmz/sysmas
+      
+      cmvx=cmvx/sysmas
+      cmvy=cmvy/sysmas
+      cmvz=cmvz/sysmas
+      
+c     remove centre of mass motion  
+      
+      do i=1,natms
+        
+        if(lstfrz(i).eq.0.and.weight(i).gt.1.d-6)then
+
+          vxx(i)=vxx(i)-cmvx
+          vyy(i)=vyy(i)-cmvy
+          vzz(i)=vzz(i)-cmvz
+          
+        else
+
+          vxx(i)=0.d0
+          vyy(i)=0.d0
+          vzz(i)=0.d0
+
+        endif
+
+      enddo
+      
+c     zero angular momentum about centre of mass - non-periodic system
+      
+      if(imcon.eq.0)then
+
+c     move to centre of mass origin
+        
+        do i=1,natms
+          
+          xxx(i)=xxx(i)-cmx
+          yyy(i)=yyy(i)-cmy
+          zzz(i)=zzz(i)-cmz
+          
+        enddo
+        
+c     angular momentum accumulators
+        
+        amx=0.d0
+        amy=0.d0
+        amz=0.d0
+
+c     rotational inertia accumulators
+        
+        do i=1,9
+          roti(i)=0.d0
+        enddo
+        
+        do i=iatm1,iatm2
+          
+          amx=amx+weight(i)*(yyy(i)*vzz(i)-zzz(i)*vyy(i))
+          amy=amy+weight(i)*(zzz(i)*vxx(i)-xxx(i)*vzz(i))
+          amz=amz+weight(i)*(xxx(i)*vyy(i)-yyy(i)*vxx(i))
+          
+          rsq=xxx(i)**2+yyy(i)**2+zzz(i)**2
+          roti(1)=roti(1)+weight(i)*(xxx(i)*xxx(i)-rsq)
+          roti(2)=roti(2)+weight(i)* xxx(i)*yyy(i)
+          roti(3)=roti(3)+weight(i)* xxx(i)*zzz(i)
+          roti(5)=roti(5)+weight(i)*(yyy(i)*yyy(i)-rsq)
+          roti(6)=roti(6)+weight(i)* yyy(i)*zzz(i)
+          roti(9)=roti(9)+weight(i)*(zzz(i)*zzz(i)-rsq)
+          
+        enddo
+
+c     complete rotational inertia matrix
+        
+        roti(4)=roti(2)
+        roti(7)=roti(3)
+        roti(8)=roti(6)
+
+c     global sum
+
+        if(mxnode.gt.1)then
+          buffer(13)=amx
+          buffer(14)=amy
+          buffer(15)=amz
+          do i=1,9
+            buffer(15+i)=roti(i)
+          enddo
+          call gdsum(buffer(13),12,buffer(1))
+          amx=buffer(13) 
+          amy=buffer(14) 
+          amz=buffer(15) 
+          do i=1,9
+            roti(i)=buffer(15+i)
+          enddo
+        endif
+
+c     invert rotational inertia matrix
+        
+        call invert (roti,rotinv,det)
+
+c     correction to angular velocity
+        
+        wxx=rotinv(1)*amx+rotinv(2)*amy+rotinv(3)*amz
+        wyy=rotinv(4)*amx+rotinv(5)*amy+rotinv(6)*amz
+        wzz=rotinv(7)*amx+rotinv(8)*amy+rotinv(9)*amz
+
+c     correction to linear velocity
+        
+        do i=1,natms
+
+          if(lstfrz(i).eq.0.and.weight(i).gt.1.d-6)then
+
+            vxx(i)=vxx(i)+(wyy*zzz(i)-wzz*yyy(i))
+            vyy(i)=vyy(i)+(wzz*xxx(i)-wxx*zzz(i))
+            vzz(i)=vzz(i)+(wxx*yyy(i)-wyy*xxx(i))
+            
+          endif
+
+        enddo
+
+c     reset positions to original reference frame
+        
+        do i=1,natms
+          
+          xxx(i)=xxx(i)+cmx
+          yyy(i)=yyy(i)+cmy
+          zzz(i)=zzz(i)+cmz
+          
+        enddo
+        
+      endif
+
+c     calculate temperature 
+
+      sumke=0.d0
+      
+      do i=iatm1,iatm2
+
+        sumke=sumke+weight(i)*
+     x    (vxx(i)**2+vyy(i)**2+vzz(i)**2)
+
+      enddo
+
+      sumke=0.5d0*sumke
+      if(mxnode.gt.1)then
+        buffer(1)=sumke
+        call gdsum(buffer(1),1,buffer(2))
+        sumke=buffer(1)
+      endif
+
+c     apply temperature scaling
+      
+      scale=1.d0
+      if(sumke.gt.1.d-6)scale=sqrt(sigma/sumke)
+      
+      do i=1,natms
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+
+      if(ngrp.gt.0)then
+        call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+
+      endif
+      
+      return
+      end subroutine vscaleg
+
+      subroutine shlqnch(idnode,mxnode,ntshl,temp)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine for quenching the internal bond energies
+c     in ions defined by shell model
+c     
+c     copyright - daresbury laboratory 1994
+c     author w.smith july  1994
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntshl,ishl1,ishl2,i,j,k,m
+      real(8) temp,pke,rmu,dvx,dvy,dvz,tmx,tmy,tmz,scl
+
+c     permitted core-shell internal kinetic energy 
+      
+      pke=boltz*temp*1.d-4
+
+c     block indices
+
+      ishl1 = (idnode*ntshl)/mxnode+1
+      ishl2 = ((idnode+1)*ntshl)/mxnode
+
+c     calculate core and shell velocities from total momentum
+      
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+
+        rmu=(weight(i)*weight(j))/(weight(i)+weight(j))
+        
+        if(rmu.gt.0.d0)then
+          
+          dvx=vxx(j)-vxx(i)
+          dvy=vyy(j)-vyy(i)
+          dvz=vzz(j)-vzz(i)
+          
+          scl=sqrt(pke/(rmu*(dvx*dvx+dvy*dvy+dvz*dvz)))
+          
+          tmx=weight(i)*vxx(i)+weight(j)*vxx(j)
+          tmy=weight(i)*vyy(i)+weight(j)*vyy(j)
+          tmz=weight(i)*vzz(i)+weight(j)*vzz(j)
+          
+          vxx(i)=tmx/(weight(i)+weight(j))-scl*rmu*dvx/weight(i)
+          vxx(j)=tmx/(weight(i)+weight(j))+scl*rmu*dvx/weight(j)
+          vyy(i)=tmy/(weight(i)+weight(j))-scl*rmu*dvy/weight(i)
+          vyy(j)=tmy/(weight(i)+weight(j))+scl*rmu*dvy/weight(j)
+          vzz(i)=tmz/(weight(i)+weight(j))-scl*rmu*dvz/weight(i)
+          vzz(j)=tmz/(weight(i)+weight(j))+scl*rmu*dvz/weight(j)
+          
+        endif
+        
+      enddo
+
+      if(mxnode.gt.1) call shlmerge(idnode,mxnode,ntshl)
+      
+      return
+      end subroutine shlqnch
+      
+      subroutine regauss
+     x  (idnode,imcon,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntshl,keyshl,sigma,temp,tolnce)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for resetting the system velocities
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2007
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,imcon,mxnode,natms,ngrp,nscons
+      integer ntcons,ntshl,i,k,keyshl
+      real(8) temp,tolnce,sigma,rsq
+      
+c     set atomic velocities from gaussian distribution
+
+      call gauss(natms,vxx,vyy,vzz)
+      
+      do i=1,natms
+        
+        rsq=sqrt(rmass(i))
+        vxx(i)=vxx(i)*rsq
+        vyy(i)=vyy(i)*rsq
+        vzz(i)=vzz(i)*rsq
+        
+      enddo
+      
+      if(ntcons.gt.0)call quench
+     x  (imcon,idnode,mxnode,natms,nscons,tolnce)
+      
+      if(ngrp.gt.0)call quatqnch
+     x  (idnode,imcon,mxnode,natms,ngrp)
+      
+      if(keyshl.eq.1)then
+        
+        do k=1,4
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          call shlqnch(idnode,mxnode,ntshl,temp)
+          
+        enddo
+        
+      else
+        
+        call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+        
+      endif
+      
+      return
+      end subroutine regauss
+      
+      subroutine impact(khit,natms,idnode,mxnode,ehit,xhit,yhit,zhit)
+      
+c*********************************************************************
+c     
+c     DLPOLY routinue for impacting a selected atom with a specified
+c     recoil energy
+c     
+c     copyright daresbury laboratory
+c     author w.smith september 2007
+c     
+c*********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      
+      implicit none
+      
+      integer i,khit,natms,idnode,mxnode,iatm0,iatm1
+      real(8) ehit,vxo,vyo,vzo,xhit,yhit,zhit,fac,smass,vel
+      
+c     store original particle velocity
+      
+      vxo=vxx(khit)
+      vyo=vyy(khit)
+      vzo=vzz(khit)
+      
+c     determine recoil velocity
+      
+      vel=sqrt(2.d0*ehit/(weight(khit)*(xhit**2+yhit**2+zhit**2)))
+      
+c     reassign particle velocity
+      
+      vxx(khit)=vel*xhit
+      vyy(khit)=vel*yhit
+      vzz(khit)=vel*zhit
+      
+c     determine system mass
+      
+      smass=getmass(natms,idnode,mxnode)
+      
+c     calculate net system velocity
+      
+      vxo=(vxx(khit)-vxo)*weight(khit)/smass
+      vyo=(vyy(khit)-vyo)*weight(khit)/smass
+      vzo=(vzz(khit)-vzo)*weight(khit)/smass
+      
+c     reset system net velocity to zero
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)-vxo
+        vyy(i)=vyy(i)-vyo
+        vzz(i)=vzz(i)-vzo
+        
+      enddo
+      
+      if(mxnode.gt.1)
+     x  call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+      
+      return
+      end subroutine impact
+      
+      end module temp_scalers_module
diff -urN dl_class_1.9.orig/srcmod/tersoff_module.f dl_class_1.9/srcmod/tersoff_module.f
--- dl_class_1.9.orig/srcmod/tersoff_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/tersoff_module.f	2011-04-16 16:13:06.000000000 +0200
@@ -0,0 +1,1011 @@
+      module tersoff_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining tersoff potential arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    dec 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use utility_module
+
+      implicit none
+
+      logical, allocatable :: filter(:)
+      integer, allocatable :: lstter(:),ltpter(:),lattsf(:)
+      real(8), allocatable :: prmter(:,:),prmter2(:,:)
+      real(8), allocatable :: vmbp(:,:,:),gmbp(:,:,:)
+      real(8), allocatable :: xtf(:),ytf(:),ztf(:),rtf(:)
+      real(8), allocatable :: ert(:),eat(:),grt(:),gat(:)
+      real(8), allocatable :: scr(:),gcr(:),gam(:),gvr(:)
+
+      save xtf,ytf,ztf,rtf,ert,eat,grt,gat,scr,gcr,gam,filter
+      save prmter,prmter2,lstter,ltpter,lattsf,vmbp,gmbp
+
+      contains
+      
+      subroutine alloc_ter_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=20
+
+      integer i,fail,idnode,npairs
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      npairs=(mxter*(mxter+1))/2
+      allocate (prmter(mxter,mxpter),stat=fail(1))
+      allocate (prmter2(2,npairs),stat=fail(2))
+      allocate (lstter(mxter),stat=fail(3))
+      allocate (ltpter(mxter),stat=fail(4))
+      allocate (lattsf(mxatms),stat=fail(5))
+      allocate (xtf(mxatms),stat=fail(6))
+      allocate (ytf(mxatms),stat=fail(7))
+      allocate (ztf(mxatms),stat=fail(8))
+      allocate (rtf(mxatms),stat=fail(9))
+      allocate (ert(mxatms),stat=fail(10))
+      allocate (eat(mxatms),stat=fail(11))
+      allocate (grt(mxatms),stat=fail(12))
+      allocate (gat(mxatms),stat=fail(13))
+      allocate (scr(mxatms),stat=fail(14))
+      allocate (gcr(mxatms),stat=fail(15))
+      allocate (gam(mxatms),stat=fail(16))
+      allocate (gvr(mxatms),stat=fail(17))
+      allocate (vmbp(mxgrid,npairs,3),stat=fail(18))
+      allocate (gmbp(mxgrid,npairs,3),stat=fail(19))
+      allocate (filter(mxsite),stat=fail(20))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1945)
+      enddo
+
+      end subroutine alloc_ter_arrays
+
+      subroutine define_tersoff
+     x  (safe,lunits,lmols,idnode,ntpter,ntpatm,rctter,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining tersoff potentials
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom0,atom1
+      character*1 message(80)
+      integer fail,idnode,ntpter,ntpatm,i,idum,j,itpter
+      integer keypot,jtpatm,k,katm0,katm1,icross,npairs,ktyp
+      real(8) rctter,engunit
+      real(8), allocatable :: parpot(:)
+      data fail/0/
+
+      allocate (parpot(mxpter),stat=fail)
+      if(fail.ne.0)call error(idnode,1955)
+
+      ntpter=intstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified tersoff ',
+     x    'atom potentials',i10)") ntpter
+        write(nrite,"(/,/,16x,'atom    ',3x,' key',30x,
+     x    'parameters'/,/)")
+        
+      endif      
+      if(ntpter.gt.mxter) call error(idnode,88)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      rctter=0.d0
+
+      do i=1,mxter
+        lstter(i)=-1
+      enddo
+
+      do i=1,mxsite
+        filter(i)=.false.
+      enddo
+
+      k=0
+      do i=1,mxter
+        do j=1,i
+
+          k=k+1
+          prmter2(1,k)=0.d0
+          prmter2(2,k)=0.d0
+
+        enddo
+      enddo
+      
+      do itpter=1,ntpter
+        
+        do i=1,mxpter
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call getword(atom0,record,8,lenrec)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+
+        if(keyword(1:4).eq.'ters') then
+
+          keypot=1
+
+        else
+
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,1972)
+
+        endif
+
+        parpot(1)=dblstr(record,lenrec,idum)  ! A_i
+        parpot(2)=dblstr(record,lenrec,idum)  ! a_i
+        parpot(3)=dblstr(record,lenrec,idum)  ! B_i
+        parpot(4)=dblstr(record,lenrec,idum)  ! b_i
+        parpot(5)=dblstr(record,lenrec,idum)  ! R_i
+
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        parpot(6)=dblstr(record,lenrec,idum)    ! S_i
+        parpot(7)=dblstr(record,lenrec,idum)    ! beta_i
+        parpot(8)=dblstr(record,lenrec,idum)    ! eta_i
+        parpot(9)=dblstr(record,lenrec,idum)    ! c_i
+        parpot(10)=dblstr(record,lenrec,idum)   ! d_i
+        parpot(11)=dblstr(record,lenrec,idum)   ! h_i
+        
+        if(idnode.eq.0) then
+
+          write(nrite,"(16x,a8,2x,a4,2x,1p,5e13.5)") 
+     x      atom0,keyword(1:4),(parpot(j),j=1,5)
+          write(nrite,"(32x,1p,5e13.5)")(parpot(j),j=6,mxpter)
+
+        endif
+        
+        katm0=0
+        
+        do jtpatm=1,ntpatm
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+        enddo
+        
+        if(katm0.eq.0)call error(idnode,92)
+
+        filter(katm0)=.true.
+        
+c     convert parameters to internal units
+        
+        if(keypot.eq.1)then
+          
+          parpot(1)=parpot(1)*engunit
+          parpot(3)=parpot(3)*engunit
+
+        endif
+        if(lstter(katm0).gt.-1) call error(idnode,21)
+        lstter(katm0)=itpter
+        ltpter(itpter)=keypot
+
+c     calculate max tersoff cutoff
+        
+        rctter=max(rctter,parpot(6))
+        
+c     store tersoff single atom potential parameters
+        
+        do i=1,mxpter
+          prmter(itpter,i)=parpot(i)
+        enddo
+
+      enddo
+
+      if(rctter.lt.1.d-6)call error(idnode,1953)
+      
+c     start processing double atom potential parameters
+
+      npairs=(ntpter*(ntpter+1))/2
+
+      if(idnode.eq.0)then
+
+        write(nrite,"(/,/,1x,'number of tersoff ',
+     x    'cross terms',i10)") npairs
+        write(nrite,"(/,/,16x,'atom    ','atom    ',10x,
+     x    'parameters'/,/)")
+
+      endif
+
+      do icross=1,npairs
+
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call getword(atom0,record,8,lenrec)
+        call getword(atom1,record,8,lenrec)
+
+        parpot(1)=dblstr(record,lenrec,idum)  ! chi_ij
+        parpot(2)=dblstr(record,lenrec,idum)  ! omega_ij
+
+        katm0=0
+        katm1=0
+        
+        do jtpatm=1,ntpatm
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+        enddo
+        
+        if(katm0.eq.0.or.katm1.eq.0)call error(idnode,92)
+        
+        filter(katm0)=.true.
+        filter(katm1)=.true.
+        
+        ktyp=loc2(lstter(katm0),lstter(katm1))
+        prmter2(1,ktyp)=parpot(1)
+        prmter2(2,ktyp)=parpot(2)
+
+        if(idnode.eq.0)write(nrite,"(16x,a8,a8,1p,2e13.5)") 
+     x     atom0,atom1,(parpot(j),j=1,2)
+
+      enddo
+
+c     generate tersoff interpolation arrays
+
+      call tergen(ntpatm,rctter)
+
+      return
+      end subroutine define_tersoff
+
+      subroutine tergen(ntpatm,rctter)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating potential energy and 
+c     force arrays for tersoff forces only
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith dec 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer ntpatm,katm0,katm1,ipt,jpt,kpt,i
+      real(8) dlrpot,rctter,baij,saij,bbij,sbij,rij,sij,att,arg
+      real(8) rrr,rep
+      
+c     define grid resolution for potential arrays
+      
+      dlrpot=rctter/dble(mxgrid-4)
+
+c     construct arrays for all types of short ranged  potential
+      
+      do katm0=1,ntpatm
+
+        if(filter(katm0))then
+          
+          ipt=lstter(katm0)
+          
+          do katm1=1,katm0
+            
+            if(filter(katm1))then
+              
+              jpt=lstter(katm1)
+              
+              if((ltpter(ipt).eq.1).and.(ltpter(jpt).eq.1))then
+                
+                kpt=loc2(ipt,jpt)
+                
+c     define tersoff parameters
+                
+                baij=sqrt(prmter(ipt,1)*prmter(jpt,1))
+                saij=0.5d0*(prmter(ipt,2)+prmter(jpt,2))
+                bbij=sqrt(prmter(ipt,3)*prmter(jpt,3))
+                sbij=0.5d0*(prmter(ipt,4)+prmter(jpt,4))
+                rij=sqrt(prmter(ipt,5)*prmter(jpt,5))
+                sij=sqrt(prmter(ipt,6)*prmter(jpt,6))
+                
+c     store potential cutoff
+                
+                vmbp(1,kpt,1)=sij
+                
+c     calculate screening function
+                
+                do i=2,mxgrid
+                  
+                  rrr=dble(i)*dlrpot
+                  
+                  if(rrr.le.rij)then
+                    
+                    vmbp(i,kpt,1)=1.d0
+                    gmbp(i,kpt,1)=0.d0
+                    
+                  else
+                    
+                    arg=pi*(rrr-rij)/(sij-rij)
+                    vmbp(i,kpt,1)=0.5d0*(1.d0+cos(arg))
+                    gmbp(i,kpt,1)=0.5d0*pi*rrr*sin(arg)/(sij-rij)
+                    
+                  endif
+                  
+                enddo
+                
+c     calculate screened repulsion function
+                
+                do i=2,mxgrid
+                  
+                  rrr=dble(i)*dlrpot
+                  
+                  rep=baij*exp(-saij*rrr)
+                  vmbp(i,kpt,2)=rep*vmbp(i,kpt,1)
+                  gmbp(i,kpt,2)=rep*(gmbp(i,kpt,1)+
+     x              saij*rrr*vmbp(i,kpt,1))
+                  
+                enddo
+                
+c     calculate screened attraction function
+                
+                do i=2,mxgrid
+                  
+                  rrr=dble(i)*dlrpot
+                  
+                  att=bbij*exp(-sbij*rrr)
+                  vmbp(i,kpt,3)=att*vmbp(i,kpt,1)
+                  gmbp(i,kpt,3)=att*(gmbp(i,kpt,1)+
+     x              sbij*rrr*vmbp(i,kpt,1))
+                  
+                enddo
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        endif
+        
+      enddo
+          
+      return
+      end subroutine tergen
+
+      subroutine tersoff
+     x  (idnode,mxnode,natms,imcon,rctter,engter,virter)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating potential and forces 
+c     due to a tersoff potential
+c
+c     Note: the subroutine converts coordinates to reduced units
+c     to avoid a call to images.f. The link cell algorithm used
+c     here necessitates a parallelepiped, cubic or orthorhombic
+c     cell geometry
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith dec 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      integer idnode,mxnode,natms,imcon,nix,niy,niz,i,j,nbx
+      integer nby,nbz,ncells,l,ix,iy,iz,k,icell,kk,jx,jy,jz,jcell,iter
+      integer limit,ii,iatm
+      real(8) rctter,engter,virter,xm,ym,zm,det,cprp
+      real(8) xdc,ydc,zdc,sxx,syy,szz,strs
+
+      dimension nix(27),niy(27),niz(27),cprp(10),strs(6)
+
+      data nix/ 0,-1,-1,-1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 1,
+     x  1, 1, 1, 0, 0, 1,-1, 1, 0,-1, 1, 0,-1/
+      data niy/ 0, 0,-1, 1, 1, 0, 0, 0,-1,-1,-1, 1, 1, 1,
+     x  0, 1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1/
+      data niz/ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     x  0, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1/
+      
+c     flag for undefined potentials
+
+      safe=.true.
+
+c     initialise potential energy and virial
+
+      engter=0.d0
+      virter=0.d0
+
+c     create mock cell vectors for non-periodic system
+
+      if(imcon.eq.0) then
+
+        xm=0.d0
+        ym=0.d0
+        zm=0.d0
+
+        do i=1,natms
+
+          xm=max(xm,abs(xxx(i)))
+          ym=max(ym,abs(yyy(i)))
+          zm=max(zm,abs(zzz(i)))
+
+        enddo
+
+        cell(1)=2.d0*xm+rctter
+        cell(2)=0.d0
+        cell(3)=0.d0
+        cell(4)=0.d0
+        cell(5)=2.d0*ym+rctter
+        cell(6)=0.d0
+        cell(7)=0.d0
+        cell(8)=0.d0
+        cell(9)=2.d0*zm+rctter
+        
+      endif
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+
+c     check for appropriate boundary conditions
+      
+      if(imcon.gt.3)call error(idnode,1974)
+      call invert(cell,rcell,det)
+      call dcell(cell,cprp)
+
+c     calculate link cell numbers
+      
+      nbx=int(cprp(7)/(rctter+1.d-6))
+      nby=int(cprp(8)/(rctter+1.d-6))
+      nbz=int(cprp(9)/(rctter+1.d-6))
+      if(nbx.lt.3.or.nby.lt.3.or.nbz.lt.3)then
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,'(a,3i5)')
+     x      'tersoff link cell decomposition is',nbx,nby,nbz
+          
+        endif
+        
+        call error(idnode,1977)
+        
+      endif
+      ncells=nbx*nby*nbz
+
+      if(ncells.gt.mxcell) then
+        
+        if(idnode.eq.0) then
+
+          write(nrite,'(a,i6)')
+     x      'number of required link cells in tersoff.f is ',ncells
+          write(nrite,'(a,i6)')
+     x      'number of  default link cells in tersoff.f is ',mxcell
+          call error(idnode,1976)
+
+        endif
+
+      endif
+
+c     transform atomic coordinates and construct link cells
+      
+      do l=1,ncells
+        
+        lct(l)=0
+        lst(l)=0
+        
+      enddo
+      
+      xdc=dble(nbx)
+      ydc=dble(nby)
+      zdc=dble(nbz)
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          syy=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          szz=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+          xxx(i)=sxx
+          yyy(i)=syy
+          zzz(i)=szz
+          
+          ix=min(int(xdc*(sxx+0.5d0)),nbx-1)
+          iy=min(int(ydc*(syy+0.5d0)),nby-1)
+          iz=min(int(zdc*(szz+0.5d0)),nbz-1)
+          k=1+ix+nbx*(iy+nby*iz)
+          lst(k)=lst(k)+1
+          link(i)=lct(k)
+          lct(k)=i
+          
+        endif
+        
+      enddo
+
+c     loop over central atoms of angles
+      
+      ix=0
+      iy=1
+      iz=1
+      do icell=1,ncells
+
+        ix=ix+1
+        if(ix.gt.nbx)then
+          ix=1
+          iy=iy+1
+          if(iy.gt.nby)then
+            iy=1
+            iz=iz+1
+          endif
+        endif
+
+c     construct mini-list of neighbour cell contents
+
+        k=0
+        do kk=1,27
+
+          jx=ix+nix(kk)
+          jy=iy+niy(kk)
+          jz=iz+niz(kk)
+          
+          if(jx.gt.nbx)jx=1
+          if(jy.gt.nby)jy=1
+          if(jz.gt.nbz)jz=1
+          if(jx.lt.1)jx=jx+nbx
+          if(jy.lt.1)jy=jy+nby
+          if(jz.lt.1)jz=jz+nbz
+          
+          jcell=jx+nbx*(jy-1+nby*(jz-1))
+          j=lct(jcell)
+          
+          do ii=1,lst(jcell)
+
+            k=k+1
+            lattsf(k)=j
+            j=link(j)
+            
+          enddo
+          
+        enddo
+
+        limit=k
+        
+        do ii=1,lst(icell)
+          
+          iatm=lattsf(ii)
+          iter=lstter(ltype(iatm))
+
+          if(mod(iatm,mxnode).eq.idnode.and.iter.ge.0)then
+
+c     construct working arrays by interpolation
+
+            call terint(iatm,limit,rctter)
+
+c     calculate three body (attractive) terms
+
+            call tersoff3(ii,limit,engter,virter,strs)
+
+          endif
+          
+        enddo
+
+      enddo
+      
+c     calculate stress tensor
+              
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,1978)
+
+c     global sum of three body potential and virial
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=engter
+        buffer(2)=virter
+        call gdsum(buffer(1),2,buffer(3))
+        engter=buffer(1)
+        virter=buffer(2)
+
+      endif
+
+c    remove effect of double counting
+
+      engter=0.5d0*engter
+      virter=0.5d0*virter
+
+c     restore coordinate array to original representation
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=xxx(i)
+          syy=yyy(i)
+          szz=zzz(i)
+          
+          xxx(i)=cell(1)*sxx+cell(4)*syy+cell(7)*szz
+          yyy(i)=cell(2)*sxx+cell(5)*syy+cell(8)*szz
+          zzz(i)=cell(3)*sxx+cell(6)*syy+cell(9)*szz
+          
+        endif
+        
+      enddo
+
+c     restore cell vector
+
+      if(imcon.eq.0) then
+        cell(1)=0.d0
+        cell(5)=0.d0
+        cell(9)=0.d0
+      endif
+      
+      return
+      end subroutine tersoff
+
+      subroutine terint(iatm,limit,rctter)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing working arrays for
+c     a tersoff potential using interpolation
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith dec 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,jatm,jj,limit,iter,jter,jjter,ll
+      real(8) rctter,sxij,syij,szij,ppp,t1,t2,rdr
+      real(8) vk0,vk1,vk2,gk0,gk1,gk2
+     
+      rdr=dble(mxgrid-4)/rctter
+      iter=lstter(ltype(iatm))
+
+c    initialise working arrays
+            
+      do jj=1,limit
+        
+        xtf(jj)=0.d0
+        ytf(jj)=0.d0
+        ztf(jj)=0.d0
+        rtf(jj)=0.d0
+        ert(jj)=0.d0
+        eat(jj)=0.d0
+        grt(jj)=0.d0
+        gat(jj)=0.d0
+        scr(jj)=0.d0
+        gcr(jj)=0.d0
+        
+      enddo
+
+c    construct working arrays
+      
+      do jj=1,limit
+        
+        jatm=lattsf(jj)
+        jter=lstter(ltype(jatm))
+        
+        if(jatm.ne.iatm.and.jter.ge.0)then
+          
+          sxij=xxx(jatm)-xxx(iatm)
+          sxij=sxij-nint(sxij)
+          syij=yyy(jatm)-yyy(iatm)
+          syij=syij-nint(syij)
+          szij=zzz(jatm)-zzz(iatm)
+          szij=szij-nint(szij)
+          
+          xtf(jj)=cell(1)*sxij+cell(4)*syij+cell(7)*szij
+          ytf(jj)=cell(2)*sxij+cell(5)*syij+cell(8)*szij
+          ztf(jj)=cell(3)*sxij+cell(6)*syij+cell(9)*szij
+          rtf(jj)=sqrt(xtf(jj)**2+ytf(jj)**2+ztf(jj)**2)
+          xtf(jj)=xtf(jj)/rtf(jj)
+          ytf(jj)=ytf(jj)/rtf(jj)
+          ztf(jj)=ztf(jj)/rtf(jj)
+            
+          jjter=loc2(iter,jter)
+          if(rtf(jj).le.vmbp(1,jjter,1))then
+            
+            ll=int(rdr*rtf(jj))
+            ppp=rtf(jj)*rdr-dble(ll)
+            
+c    interpolate screening function
+            
+            vk0=vmbp(ll,jjter,1)
+            vk1=vmbp(ll+1,jjter,1)
+            vk2=vmbp(ll+2,jjter,1)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            scr(jj)=t1+(t2-t1)*ppp*0.5d0
+            
+c    interpolate derivative of screening function
+            
+            gk0=gmbp(ll,jjter,1)
+            gk1=gmbp(ll+1,jjter,1)
+            gk2=gmbp(ll+2,jjter,1)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            gcr(jj)=-(t1+(t2-t1)*ppp*0.5d0)/rtf(jj)
+            
+c    interpolate repulsive component of energy
+            
+            vk0=vmbp(ll,jjter,2)
+            vk1=vmbp(ll+1,jjter,2)
+            vk2=vmbp(ll+2,jjter,2)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            ert(jj)=t1+(t2-t1)*ppp*0.5d0
+            
+c    interpolate derivative of repulsive function
+            
+            gk0=gmbp(ll,jjter,2)
+            gk1=gmbp(ll+1,jjter,2)
+            gk2=gmbp(ll+2,jjter,2)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            grt(jj)=-(t1+(t2-t1)*ppp*0.5d0)/rtf(jj)
+            
+c    interpolate attractive component of energy
+            
+            vk0=vmbp(ll,jjter,3)
+            vk1=vmbp(ll+1,jjter,3)
+            vk2=vmbp(ll+2,jjter,3)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            eat(jj)=t1+(t2-t1)*ppp*0.5d0
+            
+c    interpolate derivative of attractive function
+            
+            gk0=gmbp(ll,jjter,3)
+            gk1=gmbp(ll+1,jjter,3)
+            gk2=gmbp(ll+2,jjter,3)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            gat(jj)=-(t1+(t2-t1)*ppp*0.5d0)/rtf(jj)
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine terint
+
+      subroutine tersoff3(ii,limit,engter,virter,strs)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating three body contributions
+c     to a tersoff potential and tersoff potential, virial and
+c     atomic forces
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith dec 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical flag
+      integer iatm,jatm,katm,limit,ii,jj,kk
+      integer iter,jter,kter,jjter,kkter
+      real(8) cost,gtheta,ci,di,hi,gamma,gam_j,gam_k,eterm,gterm,strs
+      real(8) fxa,fya,fza,fxc,fyc,fzc,engter,virter,vterm,gam_ij,bi,ei
+
+      dimension strs(6)
+      
+      iatm=lattsf(ii)
+      iter=lstter(ltype(iatm))
+
+      bi=prmter(iter,7)
+      ei=prmter(iter,8)
+      ci=prmter(iter,9)
+      di=prmter(iter,10)
+      hi=prmter(iter,11)
+
+      do jj=1,limit
+        
+        jatm=lattsf(jj)
+        jter=lstter(ltype(jatm))
+        if(jter.ge.0.and.iatm.ne.jatm)then
+          
+          jjter=loc2(iter,jter)
+          if(rtf(jj).le.vmbp(1,jjter,1))then
+            
+            flag=.false.
+            
+c     potential energy and virial terms
+            
+            vterm=0.d0
+            eterm=0.d0
+            
+c     initialise work  arrays
+            
+            do kk=1,limit
+
+              gam(kk)=0.d0
+              gvr(kk)=0.d0
+              
+            enddo
+
+c     calculate bond factor
+
+            do kk=1,limit
+              
+              katm=lattsf(kk)
+              kter=lstter(ltype(katm))
+              if(kter.ge.0.and.iatm.ne.katm.and.jatm.ne.katm)then
+                
+                kkter=loc2(iter,kter)
+                
+                if(rtf(kk).le.vmbp(1,kkter,1))then
+                
+                  cost=(xtf(jj)*xtf(kk)+ytf(jj)*ytf(kk)+ztf(jj)*ztf(kk))
+                  gtheta=1.d0+(ci/di)**2-ci**2/(di**2+(hi-cost)**2)
+                  eterm=eterm+gtheta*prmter2(2,kkter)*scr(kk)
+                  vterm=vterm+gtheta*prmter2(2,kkter)*gcr(kk)*rtf(kk)
+                  gvr(kk)=2.d0*ci**2*(hi-cost)/(di**2+(hi-cost)**2)**2
+                  gam(kk)=gtheta
+                  flag=.true.
+
+                endif
+                
+              endif
+              
+            enddo
+            
+            if(flag)then
+              
+c     tersoff energy and virial
+
+              gam_ij=prmter2(1,jjter)*(1.d0+(bi*eterm)**ei)**(-0.5d0/ei)
+              gamma=0.5d0*prmter2(1,jjter)*bi*(bi*eterm)**(ei-1.d0)*
+     x          eat(jj)*(1.d0+(bi*eterm)**ei)**(-0.5d0/ei-1.d0)
+              engter=engter+ert(jj)-gam_ij*eat(jj)
+              virter=virter+gamma*vterm+(grt(jj)-gam_ij*gat(jj))*rtf(jj)
+
+c     calculate 3-body forces
+              
+              do kk=1,limit
+                
+                katm=lattsf(kk)
+                kter=lstter(ltype(katm))
+                if(kter.ge.0.and.iatm.ne.katm.and.jatm.ne.katm)then
+                  
+                  kkter=loc2(iter,kter)
+                  if(rtf(kk).le.vmbp(1,kkter,1))then
+                    
+                    gam_j=0.5d0*gamma*prmter2(2,kkter)*scr(kk)*gvr(kk)
+                    gam_k=0.5d0*gamma*prmter2(2,kkter)*gcr(kk)*gam(kk)
+                    
+c     calculate contribution to atomic forces
+                    
+                    cost=(xtf(jj)*xtf(kk)+ytf(jj)*ytf(kk)+
+     x                ztf(jj)*ztf(kk))
+                    
+                    fxa=gam_j*(xtf(kk)-xtf(jj)*cost)/rtf(jj)
+                    fya=gam_j*(ytf(kk)-ytf(jj)*cost)/rtf(jj)
+                    fza=gam_j*(ztf(kk)-ztf(jj)*cost)/rtf(jj)
+                    
+                    fxc=gam_j*(xtf(jj)-xtf(kk)*cost)/rtf(kk)-
+     x                gam_k*xtf(kk)
+                    fyc=gam_j*(ytf(jj)-ytf(kk)*cost)/rtf(kk)-
+     x                gam_k*ytf(kk)
+                    fzc=gam_j*(ztf(jj)-ztf(kk)*cost)/rtf(kk)-
+     x                gam_k*ztf(kk)
+                    
+                    fxx(jatm)=fxx(jatm)+fxa
+                    fyy(jatm)=fyy(jatm)+fya
+                    fzz(jatm)=fzz(jatm)+fza
+                    
+                    fxx(iatm)=fxx(iatm)-(fxa+fxc)
+                    fyy(iatm)=fyy(iatm)-(fya+fyc)
+                    fzz(iatm)=fzz(iatm)-(fza+fzc)
+                    
+                    fxx(katm)=fxx(katm)+fxc
+                    fyy(katm)=fyy(katm)+fyc
+                    fzz(katm)=fzz(katm)+fzc
+                    
+c     calculate contributions to stress tensor
+                    
+                    strs(1)=strs(1)+(fxa*xtf(jj)*rtf(jj)+
+     x                fxc*xtf(kk)*rtf(kk))
+                    strs(2)=strs(2)+(fxa*ytf(jj)*rtf(jj)+
+     x                fxc*ytf(kk)*rtf(kk))
+                    strs(3)=strs(3)+(fxa*ztf(jj)*rtf(jj)+
+     x                fxc*ztf(kk)*rtf(kk))
+                    strs(4)=strs(4)+(fya*ytf(jj)*rtf(jj)+
+     x                fyc*ytf(kk)*rtf(kk))
+                    strs(5)=strs(5)+(fya*ztf(jj)*rtf(jj)+
+     x                fyc*ztf(kk)*rtf(kk))
+                    strs(6)=strs(6)+(fza*ztf(jj)*rtf(jj)+
+     x                fzc*ztf(kk)*rtf(kk))
+
+                  endif
+                  
+                endif
+                
+              enddo
+            
+            else
+              
+              gam_ij=prmter2(1,jjter)
+              engter=engter+ert(jj)-gam_ij*eat(jj)
+              virter=virter+(grt(jj)-gam_ij*gat(jj))*rtf(jj)
+
+            endif
+
+c     calculate two body force terms
+            
+            gterm=0.5d0*(grt(jj)-gam_ij*gat(jj))
+            fxx(iatm)=fxx(iatm)+xtf(jj)*gterm
+            fyy(iatm)=fyy(iatm)+ytf(jj)*gterm
+            fzz(iatm)=fzz(iatm)+ztf(jj)*gterm
+            fxx(jatm)=fxx(jatm)-xtf(jj)*gterm
+            fyy(jatm)=fyy(jatm)-ytf(jj)*gterm
+            fzz(jatm)=fzz(jatm)-ztf(jj)*gterm
+            
+c     calculate contributions to stress tensor
+            
+            strs(1)=strs(1)-gterm*rtf(jj)*xtf(jj)*xtf(jj)
+            strs(2)=strs(2)-gterm*rtf(jj)*xtf(jj)*ytf(jj)
+            strs(3)=strs(3)-gterm*rtf(jj)*xtf(jj)*ztf(jj)
+            strs(4)=strs(4)-gterm*rtf(jj)*ytf(jj)*ytf(jj)
+            strs(5)=strs(5)-gterm*rtf(jj)*ytf(jj)*ztf(jj)
+            strs(6)=strs(6)-gterm*rtf(jj)*ztf(jj)*ztf(jj)
+
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine tersoff3
+      
+      end module tersoff_module
diff -urN dl_class_1.9.orig/srcmod/tether_module.f dl_class_1.9/srcmod/tether_module.f
--- dl_class_1.9.orig/srcmod/tether_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/tether_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,447 @@
+      module tether_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining tether potential arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use utility_module
+
+      implicit none
+
+      real(8), allocatable :: prmtet(:,:)
+      integer, allocatable :: listtet(:,:)
+      integer, allocatable :: numteth(:),keytet(:),lsttet(:)
+      real(8), allocatable :: xxs(:),yys(:),zzs(:)
+
+      save prmtet,lsttet,listtet,numteth,keytet,xxs,yys,zzs
+
+      contains
+      
+      subroutine alloc_tet_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=8
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (prmtet(mxteth,mxpbnd),stat=fail(1))
+      allocate (numteth(mxtmls),stat=fail(2))
+      allocate (keytet(mxteth),stat=fail(3))
+      allocate (lsttet(mxteth),stat=fail(4))
+      allocate (listtet(msteth,2),stat=fail(5))
+      allocate (xxs(mxatms),stat=fail(6))
+      allocate (yys(mxatms),stat=fail(7))
+      allocate (zzs(mxatms),stat=fail(8))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1260)
+      enddo
+
+      do i=1,mxtmls
+         numteth(i)=0
+      enddo
+
+      end subroutine alloc_tet_arrays
+
+      subroutine define_tethers
+     x  (safe,idnode,itmols,nteth,nsite,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining tether bonds
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      real(8) engunit
+      integer idnode,itmols,nteth,nsite,ntmp,iteth,iteth1,idum
+      integer iatm1,isite1,j,i
+
+      ntmp=intstr(record,lenrec,idum)
+      numteth(itmols)=numteth(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of tethered atoms ',
+     x    6x,i10)")ntmp
+        write(nrite,"(/,' tethered atom details:',/,/,
+     x    21x,7x,'key',6x,'atom',19x,'parameters',/) ")
+      endif
+
+      iteth1=numteth(itmols)
+      do iteth=1,iteth1
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        call strip(record,lenrec)
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+
+        iatm1=intstr(record,lenrec,idum)
+
+c     test for frozen atom 
+
+        isite1=nsite-numsit(itmols)+iatm1
+        
+        if(lfzsit(isite1).ne.0)then
+
+          numteth(itmols)=numteth(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+
+        else
+
+          nteth=nteth+1
+          if(nteth.gt.mxteth)call error(idnode,62)
+          
+          if(keyword(1:4).eq.'harm')then
+            keytet(nteth)=1
+          elseif(keyword(1:4).eq.'rhrm')then
+            keytet(nteth)=2
+          elseif(keyword(1:4).eq.'quar')then
+            keytet(nteth)=3
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,450)
+          endif
+
+          lsttet(nteth)=iatm1
+          prmtet(nteth,1)=dblstr(record,lenrec,idum)
+          prmtet(nteth,2)=dblstr(record,lenrec,idum)
+          prmtet(nteth,3)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,i10,1p,9e12.4)")
+     x      keyword(1:4),lsttet(nteth),
+     x      (prmtet(nteth,j),j=1,mxpbnd)
+
+c     convert energy units to internal units
+          
+          if(abs(keytet(nteth)).eq.1)then
+            prmtet(nteth,1)=prmtet(nteth,1)*engunit
+          elseif(abs(keytet(nteth)).eq.2)then
+            prmtet(nteth,1)=prmtet(nteth,1)*engunit
+          elseif(abs(keytet(nteth)).eq.3)then
+            prmtet(nteth,1)=prmtet(nteth,1)*engunit
+            prmtet(nteth,2)=prmtet(nteth,2)*engunit
+            prmtet(nteth,3)=prmtet(nteth,3)*engunit
+          endif
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine define_tethers
+
+      subroutine tethfrc
+     x  (idnode,mxnode,imcon,natms,nstep,ntteth,engtet,virtet)
+
+c***********************************************************************
+c     
+c     dl_poly routine to tether atoms to initial positions
+c     includes stress tensor
+c     
+c     replicated data version : block data
+c     
+c     copyright daresbury laboratory 1994
+c     author     t.forester feb 1994
+c     amended    t.forester dec 1994 : block data
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      integer idnode,mxnode,imcon,natms,nstep,ntteth,i,ii,ia,kk
+      integer itet1,itet2,fail
+
+      real(8) engtet,virtet,rab
+      real(8) rrab,omega,gamma
+
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+
+      data safe/.true./
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail)
+      if(fail.ne.0)call error(idnode,1270)
+
+c     set up reference positions at start of job
+
+      if(nstep.le.1)then
+
+        do i=1,natms
+
+          xxs(i)=xxx(i)
+          yys(i)=yyy(i)
+          zzs(i)=zzz(i)
+
+        enddo
+
+      endif
+
+c     check size of work arrays
+
+      if((ntteth-mxnode+1)/mxnode.gt.msbad) call error(idnode,420)
+
+c     block indices
+
+      itet1=(idnode*ntteth)/mxnode+1
+      itet2=((idnode+1)*ntteth)/mxnode
+      
+      ii=0
+      do i=itet1,itet2
+
+        ii=ii+1
+
+c     atomic index
+
+        ia= listtet(ii,2)
+
+c     tether vector
+
+        xdab(ii)=xxx(ia)-xxs(ia)
+        ydab(ii)=yyy(ia)-yys(ia)
+        zdab(ii)=zzz(ia)-zzs(ia)
+
+      enddo
+
+c     ignore  periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+
+c     zero tether energy and virial accumulators
+      
+      engtet=0.d0
+      virtet=0.d0
+
+c     loop over all specified tethered atoms
+
+      ii=0
+      do i=itet1,itet2
+        
+        ii=ii+1
+
+c     define components of bond vector
+        
+        rab=sqrt(xdab(ii)**2+ydab(ii)**2+zdab(ii)**2)
+
+c     check for possible zero length vector
+
+        if(rab.lt.1.d-10)then
+
+          rrab =0.d0
+
+        else
+
+          rrab=1.d0/rab
+
+        endif
+
+c     index of potential function parameters
+
+        kk=listtet(ii,1)
+
+c     calculate scalar constant terms
+
+        if(keytet(kk).eq.1)then
+
+c     harmonic function
+
+          omega=0.5d0*prmtet(kk,1)*rab**2
+          gamma=prmtet(kk,1)
+
+        elseif(keytet(kk).eq.2)then
+
+c     restrained harmonic: 
+
+          omega=0.5d0*prmtet(kk,1)*(min(rab,prmtet(kk,2)))**2
+     x      +prmtet(kk,1)*prmtet(kk,2)*
+     x      (sign(max(rab-prmtet(kk,2),0.d0),rab))
+          gamma=prmtet(kk,1)*(sign(min(rab,prmtet(kk,2)),rab))*rrab
+
+        elseif(keytet(kk).eq.3)then
+
+c     quartic potential
+
+          omega=0.5d0*prmtet(kk,1)*rab**2 +
+     x      1.d0/3.d0*prmtet(kk,2)*rab**3+
+     x      0.25d0*prmtet(kk,3)*rab**4
+          gamma=(prmtet(kk,1)*rab +
+     x      prmtet(kk,2)*rab**2 +
+     x      prmtet(kk,3)*rab**3)*rrab
+
+        else
+          safe=.false.
+          omega=0.d0
+          gamma=0.d0
+        endif
+        
+        gamma=-gamma
+
+c     calculate tether energy and virial
+
+        engtet=engtet+omega
+        virtet=virtet-gamma*rab*rab
+        
+c     index of atom
+        
+        ia=listtet(ii,2)
+
+c     calculate atomic forces
+        
+        fxx(ia)=fxx(ia)+gamma*xdab(ii)
+        fyy(ia)=fyy(ia)+gamma*ydab(ii)
+        fzz(ia)=fzz(ia)+gamma*zdab(ii)
+
+c     stress tensor 
+
+        stress(1)=stress(1)+xdab(ii)*gamma*xdab(ii)
+        stress(2)=stress(2)+xdab(ii)*gamma*ydab(ii)
+        stress(3)=stress(3)+xdab(ii)*gamma*zdab(ii)
+        stress(4)=stress(4)+ydab(ii)*gamma*xdab(ii)
+        stress(5)=stress(5)+ydab(ii)*gamma*ydab(ii)
+        stress(6)=stress(6)+ydab(ii)*gamma*zdab(ii)
+        stress(7)=stress(7)+zdab(ii)*gamma*xdab(ii)
+        stress(8)=stress(8)+zdab(ii)*gamma*ydab(ii)
+        stress(9)=stress(9)+zdab(ii)*gamma*zdab(ii)
+
+      enddo
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,450)
+
+c     sum contributions to potential and virial
+
+      if(mxnode.gt.1)then
+
+        buffer(3)=engtet
+        buffer(4)=virtet
+
+        call gdsum(buffer(3),2,buffer(1))
+
+        engtet=buffer(3)
+        virtet=buffer(4)
+
+      endif
+
+      deallocate (xdab,ydab,zdab,stat=fail)
+      
+      return
+      end subroutine tethfrc
+      
+      subroutine xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+
+c***********************************************************************
+c     
+c     dl_poly routine to scale positions with change in box shape
+c     
+c     parallel replicated data version
+c     
+c     copyright daresbury laboratory 1995
+c     author t.forester      october 1995
+c     
+c***********************************************************************
+
+      implicit none
+      
+      integer idnode,mxnode,natms,keyens,imcon,iatm0,iatm1,i
+      real(8) tstep,xa,ya,za,totmas,xcmo,ycmo,zcmo
+      
+c     assign block of atoms to processor
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      if((keyens.eq.4).or.(keyens.eq.6))then
+
+c     berendsen npt/nst
+
+        do i=iatm0,iatm1
+
+          xa=eta(1)*xxs(i)+eta(2)*yys(i)+eta(3)*zzs(i)
+          ya=eta(4)*xxs(i)+eta(5)*yys(i)+eta(6)*zzs(i)
+          za=eta(7)*xxs(i)+eta(8)*yys(i)+eta(9)*zzs(i)
+
+          xxs(i)=xa
+          yys(i)=ya
+          zzs(i)=za
+
+        enddo
+
+      elseif(keyens.eq.5.or.keyens.eq.7)then
+
+c     hoover npt/nst
+        
+        totmas=0.d0
+        do i=1,natms
+          if(rmass(i).gt.0.d0)totmas=totmas+weight(i)
+        enddo
+        
+        xcmo=0.d0
+        ycmo=0.d0
+        zcmo=0.d0
+
+        do i=1,natms
+
+          if(rmass(i).gt.0.d0)then
+
+            xcmo=xcmo+weight(i)*xxs(i)
+            ycmo=ycmo+weight(i)*yys(i)
+            zcmo=zcmo+weight(i)*zzs(i)
+
+          endif
+
+        enddo
+        xcmo=xcmo/totmas
+        ycmo=ycmo/totmas
+        zcmo=zcmo/totmas
+
+        do i=iatm0,iatm1
+
+          xa=xxs(i)-xcmo
+          ya=yys(i)-ycmo
+          za=zzs(i)-zcmo
+
+          xxs(i)=xxs(i)+tstep*(eta(1)*xa+eta(2)*ya+eta(3)*za)
+          yys(i)=yys(i)+tstep*(eta(2)*xa+eta(5)*ya+eta(6)*za)
+          zzs(i)=zzs(i)+tstep*(eta(3)*xa+eta(6)*ya+eta(9)*za)
+
+        enddo
+
+        call images(imcon,idnode,mxnode,natms,cell,xxs,yys,zzs)
+
+      endif
+
+      if(mxnode.gt.1)
+     x  call merge(idnode,mxnode,natms,mxbuff,xxs,yys,zzs,buffer)
+      
+      return 
+      end subroutine xscale
+      
+      end module tether_module
+
diff -urN dl_class_1.9.orig/srcmod/three_body_module.f dl_class_1.9/srcmod/three_body_module.f
--- dl_class_1.9.orig/srcmod/three_body_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/three_body_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,882 @@
+      module three_body_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining three-body potential arrays
+c     copyright - daresbury laboratory
+c     author  - w. smith  sep 2003
+c     adapted - w. smith  aug 2008 : solvation, free energy excitation
+c     adapted - w. smith  jan 2011 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module     
+      use error_module     
+      use metafreeze_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      logical, allocatable :: filter(:)
+      real(8), allocatable :: prmtbp(:,:),rcut3b(:)
+      integer, allocatable :: lsttbp(:),ltptbp(:),lattbp(:)
+
+      save prmtbp,rcut3b,lsttbp,ltptbp,lattbp,filter
+
+      contains
+      
+      subroutine alloc_tbp_arrays(idnode)
+
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(6)
+
+      do i=1,6
+        fail(i)=0
+      enddo
+
+      allocate (prmtbp(mxtbp,mxptbp),stat=fail(1))
+      allocate (rcut3b(mxtbp),stat=fail(2))
+      allocate (lsttbp(mxtbp),stat=fail(3))
+      allocate (ltptbp(mxtbp),stat=fail(4))
+      allocate (lattbp(mxatms),stat=fail(5))
+      allocate (filter(mxsite),stat=fail(6))
+
+      do i=1,6
+        if(fail(i).gt.0)call error(idnode,1170)
+      enddo
+
+      end subroutine alloc_tbp_arrays
+
+      subroutine define_three_body
+     x  (safe,lunits,lmols,idnode,ntptbp,ntpatm,rcuttb,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining three body potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom0,atom1,atom2
+      character*1 message(80)
+      integer idnode,ntptbp,ntpatm,fail,i,itbp,itptbp,keypot
+      integer idum,katm1,katm2,katm0,j,keytbp,ktbp,jtpatm
+      real(8) rcuttb,engunit
+      real(8), allocatable :: parpot(:)
+
+      data fail/0/
+
+      allocate (parpot(mxptbp),stat=fail)
+      if(fail.ne.0)call error(idnode,1180)
+
+      ntptbp=intstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified three ',
+     x    'body potentials',i10)") ntptbp
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ','atom 3  ',
+     x    3x,' key',30x,'parameters'/,/)")
+        
+      endif      
+      if(ntptbp.gt.mxtbp) call error(idnode,83)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do i=1,mxsite
+        filter(i)=.false.
+      enddo
+      
+      do itbp=1,mxtbp
+        lsttbp(itbp)=0
+      enddo
+      
+      do itbp=1,mxtbp,mx2tbp
+        lsttbp(itbp)=-1
+      enddo
+      
+      rcuttb=0.d0
+      
+      do itptbp=1,ntptbp
+        
+        do i=1,mxptbp
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+c     Note the order!! atom0 is central 
+        
+        call copystring(record,message,80)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom0,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call lowcase(record,lenrec)
+        call getword(keyword,record,4,lenrec)
+        
+        if(keyword(1:4).eq.'harm') then
+          keypot=0
+        elseif(keyword(1:4).eq.'thrm') then
+          keypot=1
+        elseif(keyword(1:4).eq.'shrm') then
+          keypot=2
+        elseif(keyword(1:4).eq.'bvs1') then
+          keypot=3
+        elseif(keyword(1:4).eq.'bvs2') then
+          keypot=4
+        elseif(keyword(1:4).eq.'hbnd') then
+          keypot=5
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,442)
+        endif
+        
+        parpot(1)=dblstr(record,lenrec,idum)
+        parpot(2)=dblstr(record,lenrec,idum)
+        parpot(3)=dblstr(record,lenrec,idum)
+        parpot(4)=dblstr(record,lenrec,idum)
+        parpot(5)=dblstr(record,lenrec,idum)
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(16x,3a8,4x,a4,1x,1p,9e13.5)") 
+     x    atom1,atom0,atom2,keyword(1:4),(parpot(j),j=1,mxptbp)
+        
+        katm0=0
+        katm1=0
+        katm2=0
+        
+        do jtpatm=1,ntpatm
+          
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          
+        enddo
+        
+        if(katm0.eq.0.or.katm1.eq.0.or.katm2.eq.0) 
+     x    call error(idnode,84)
+        
+        filter(katm0)=.true.
+        filter(katm1)=.true.
+        filter(katm2)=.true.
+        
+        keytbp=(max(katm1,katm2)*(max(katm1,katm2)-1))/2+
+     x    min(katm1,katm2)+(katm0-1)*mx2tbp
+        
+        if(keytbp.gt.mxtbp) call error(idnode,86)
+
+c     convert parameters to internal units
+        
+        parpot(1)=parpot(1)*engunit
+        if(keypot.ne.5)parpot(2)=parpot(2)*(pi/180.d0)
+        
+        if(lsttbp(keytbp).gt.0) call error(idnode,18)
+        lsttbp(keytbp)=itptbp
+        ltptbp(itptbp)=keypot
+        ktbp=mx2tbp*((keytbp-1)/mx2tbp)+1
+        if(lsttbp(ktbp).lt.0)lsttbp(ktbp)=0
+
+c     calculate max three body cutoff
+        
+        rcuttb=max(rcuttb,parpot(5))
+        rcut3b(itptbp)=parpot(5)
+
+c     store three body potential parameters
+        
+        do i=1,4
+          prmtbp(itptbp,i)=parpot(i)
+        enddo
+        if(mxptbp.ge.6) then
+          do i=6,mxptbp
+            prmtbp(itptbp,i-1)=parpot(i-1)
+          enddo
+        endif
+      enddo
+
+      if(rcuttb.lt.1.d-6)call error(idnode,451)
+      
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_three_body
+      
+      subroutine thbfrc
+     x  (lsolva,lfree,lexcite,idnode,mxnode,natms,imcon,rcuttb,
+     x  engtbp,virtbp)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating three body forces arising 
+c     from the included angle between three atoms
+c
+c     Note: the subroutine converts coordinates to reduced units
+c     to avoid a call to images.f. The link cell algorithm used
+c     here necessitates a parallelepiped cell geometry
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w.smith mar 1994 
+c     adapted   - w.smith aug 2008 solvation, free energy etc
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lsolva,lfree,lexcite,lselect,lskip
+      logical idrive,jdrive,kdrive
+      integer idnode,mxnode,natms,imcon,nix,niy,niz
+      integer i,nbx,nby,nbz,ncells,l,ix,iy,iz,k,icell,kk,jx,jy,jz
+      integer j,jcell,ii,itbp,limit,last,ktbp,jtbp,jktbp,kktbp
+      integer ia,ib,ic,ktyp,jj,jk,kkk
+      real(8) rcuttb,engtbp,virtbp,tterm,uterm,xm,ym,zm,cprp,det
+      real(8) xdc,ydc,zdc,sxx,syy,szz,sxab,syab,szab,xab,yab,zab
+      real(8) rab,sxbc,sybc,szbc,xbc,ybc,zbc,rbc,xac,yac,zac,rac
+      real(8) rrab,rrbc,rrac,cost,sint,theta,pterm,gamma,vterm
+      real(8) gamsa,gamsb,gamsc,scrn,fxa,fya,fza,fxc,fyc,fzc,strs
+      real(8) strs_loc
+      
+      dimension nix(27),niy(27),niz(27),cprp(10),strs(6),strs_loc(9)
+      
+      data nix/ 0,-1,-1,-1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 1,
+     x  1, 1, 1, 0, 0, 1,-1, 1, 0,-1, 1, 0,-1/
+      data niy/ 0, 0,-1, 1, 1, 0, 0, 0,-1,-1,-1, 1, 1, 1,
+     x  0, 1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1/
+      data niz/ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     x  0, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1/
+      
+      lskip=(lfree.or.lexcite)
+      
+c     flag for undefined potentials
+      
+      safe=.true.
+      
+c     initialise accumulators
+      
+      engtbp=0.d0
+      virtbp=0.d0
+      tbp_fre=0.d0
+      tbp_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+      if(lsolva)then
+        
+        lcomp(8)=.true.
+        en3_sol(:)=0.d0
+        if(lexcite)en3_exc(:)=0.d0
+        
+      endif
+      
+c     create mock cell vectors for non-periodic system
+      
+      if(imcon.eq.0) then
+        
+        xm=0.d0
+        ym=0.d0
+        zm=0.d0
+        do i=1,natms
+          xm=max(xm,abs(xxx(i)))
+          ym=max(ym,abs(yyy(i)))
+          zm=max(zm,abs(zzz(i)))
+        enddo
+        
+        cell(1)=2.d0*xm+rcuttb
+        cell(2)=0.d0
+        cell(3)=0.d0
+        cell(4)=0.d0
+        cell(5)=2.d0*ym+rcuttb
+        cell(6)=0.d0
+        cell(7)=0.d0
+        cell(8)=0.d0
+        cell(9)=2.d0*zm+rcuttb
+        
+      endif
+      
+c     check for appropriate boundary conditions
+      
+      if(imcon.gt.3)call error(idnode,67)
+      call invert(cell,rcell,det)
+      call dcell(cell,cprp)
+      
+c     calculate link cell numbers
+      
+      nbx=int(cprp(7)/(rcuttb+1.d-6))
+      nby=int(cprp(8)/(rcuttb+1.d-6))
+      nbz=int(cprp(9)/(rcuttb+1.d-6))
+      ncells=nbx*nby*nbz
+      if(ncells.gt.mxcell) then
+        
+        if(idnode.eq.0) then
+          
+          write(nrite,'(a,i6)')
+     x      'number of required link cells in routine thbfrc is ',ncells
+          write(nrite,'(a,i6)')
+     x      'number of default link cells in routine thbfrc is ',mxcell
+          call error(idnode,69)
+          
+        endif
+        
+      endif
+      
+c     transform atomic coordinates and construct link cells
+      
+      do l=1,ncells
+        
+        lct(l)=0
+        lst(l)=0
+        
+      enddo
+      
+      xdc=dble(nbx)
+      ydc=dble(nby)
+      zdc=dble(nbz)
+      
+      do i=1,natms
+        
+        if(filter(ltype(i)))then
+          
+          sxx=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          syy=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          szz=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+          xxx(i)=sxx
+          yyy(i)=syy
+          zzz(i)=szz
+          
+          ix=min(int(xdc*(sxx+0.5d0)),nbx-1)
+          iy=min(int(ydc*(syy+0.5d0)),nby-1)
+          iz=min(int(zdc*(szz+0.5d0)),nbz-1)
+          k=1+ix+nbx*(iy+nby*iz)
+          lst(k)=lst(k)+1
+          link(i)=lct(k)
+          lct(k)=i
+          
+        endif
+        
+      enddo
+      
+c     loop over central atoms of angles
+      
+      ix=0
+      iy=1
+      iz=1
+      do icell=1,ncells
+        
+        ix=ix+1
+        if(ix.gt.nbx)then
+          ix=1
+          iy=iy+1
+          if(iy.gt.nby)then
+            iy=1
+            iz=iz+1
+          endif
+        endif
+        
+c     construct mini-list of neighbour cell contents
+        
+        k=0
+        do kk=1,27
+          
+          jx=ix+nix(kk)
+          jy=iy+niy(kk)
+          jz=iz+niz(kk)
+          
+          if(jx.gt.nbx)jx=1
+          if(jy.gt.nby)jy=1
+          if(jz.gt.nbz)jz=1
+          if(jx.lt.1)jx=jx+nbx
+          if(jy.lt.1)jy=jy+nby
+          if(jz.lt.1)jz=jz+nbz
+          
+          jcell=jx+nbx*(jy-1+nby*(jz-1))
+          j=lct(jcell)
+          
+          do ii=1,lst(jcell)
+            
+            k=k+1
+            lattbp(k)=j
+            j=link(j)
+            
+          enddo
+          
+        enddo
+        
+        limit=k
+        
+        do ii=1,lst(icell)
+          
+          i=lattbp(ii)
+          itbp=mx2tbp*(ltype(i)-1)
+          if(mod(i,mxnode).eq.idnode.and.lsttbp(itbp+1).ge.0)then
+          
+          last=limit
+          
+          do kk=1,limit/2
+              
+          if(kk.gt.(limit-1)/2)last=limit/2
+          
+          do jj=1,last
+          
+          j=lattbp(jj)
+          jk=jj+kk
+          if(jk.gt.limit)jk=jk-limit
+          k=lattbp(jk)
+          if(i.ne.j.and.i.ne.k)then
+                  
+          jtbp=max(ltype(j),ltype(k))
+          ktbp=min(ltype(j),ltype(k))
+          jktbp=itbp+(jtbp*(jtbp-1))/2+ktbp
+          kktbp=lsttbp(jktbp)
+          if(kktbp.gt.0)then
+          
+c     make labels etc consistent with angfrc.f
+          
+          ia=j
+          ib=i
+          ic=k
+          
+          if(lmetadyn)then
+            
+            idrive=driven(ltype(ia))
+            jdrive=driven(ltype(ib))
+            kdrive=driven(ltype(ic))
+            
+          endif
+          
+          if(lskip)then
+            
+            if((atm_fre(ia).eq.1.or.atm_fre(ib).eq.1.or.
+     x        atm_fre(ic).eq.1).and.(atm_fre(ia).eq.2.or.
+     x        atm_fre(ib).eq.2.or.atm_fre(ic).eq.2))cycle
+            
+          endif
+          
+          sxab=xxx(ia)-xxx(ib)
+          sxab=sxab-nint(sxab)
+          syab=yyy(ia)-yyy(ib)
+          syab=syab-nint(syab)
+          szab=zzz(ia)-zzz(ib)
+          szab=szab-nint(szab)
+          
+          xab=cell(1)*sxab+cell(4)*syab+cell(7)*szab
+          if(abs(xab).lt.rcuttb)then
+          
+          yab=cell(2)*sxab+cell(5)*syab+cell(8)*szab
+          if(abs(yab).lt.rcuttb)then
+          
+          zab=cell(3)*sxab+cell(6)*syab+cell(9)*szab
+          if(abs(zab).lt.rcuttb)then
+                          
+          sxbc=xxx(ic)-xxx(ib)
+          sxbc=sxbc-nint(sxbc)
+          sybc=yyy(ic)-yyy(ib)
+          sybc=sybc-nint(sybc)
+          szbc=zzz(ic)-zzz(ib)
+          szbc=szbc-nint(szbc)
+          
+          xbc=cell(1)*sxbc+cell(4)*sybc+cell(7)*szbc
+          if(abs(xbc).lt.rcuttb)then
+                            
+          ybc=cell(2)*sxbc+cell(5)*sybc+cell(8)*szbc
+          if(abs(ybc).lt.rcuttb)then
+          
+          zbc=cell(3)*sxbc+cell(6)*sybc+cell(9)*szbc
+          if(abs(zbc).lt.rcuttb)then
+          
+          ktyp=ltptbp(kktbp)
+          rab=sqrt(xab*xab+yab*yab+zab*zab)
+          rbc=sqrt(xbc*xbc+ybc*ybc+zbc*zbc)
+          
+          if(rcut3b(kktbp).ge.max(rab,rbc))then
+          
+          xac=xab-xbc
+          yac=yab-ybc
+          zac=zab-zbc
+          rac=sqrt(xac*xac+yac*yac+zac*zac)
+          
+          rrab=1.d0/rab
+          rrbc=1.d0/rbc
+          rrac=1.d0/rac
+          
+c     normalise direction vectors
+          
+          xab=xab*rrab
+          yab=yab*rrab
+          zab=zab*rrab
+          
+          xbc=xbc*rrbc
+          ybc=ybc*rrbc
+          zbc=zbc*rrbc
+          
+          xac=xac*rrac
+          yac=yac*rrac
+          zac=zac*rrac
+          
+          cost=(xab*xbc+yab*ybc+zab*zbc)
+          if(abs(cost).gt.1.d0)cost=sign(1.d0,cost)
+          if(ktyp.ne.5)then
+            
+            sint=max(1.d-8,sqrt(1.d0-cost*cost))
+            theta=acos(cost)
+            
+          endif
+          
+          if(ktyp.eq.0)then
+            
+c     harmonic angle potential
+            
+            pterm=0.5d0*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))**2
+            gamma=prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))/sint
+            
+            vterm=0.d0
+            gamsa=0.d0
+            gamsc=0.d0
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.1)then
+            
+c     truncated harmonic valence angle potential
+            
+            scrn=exp(-(rab**8+rbc**8)/prmtbp(kktbp,3)**8)
+            pterm=scrn*0.5d0*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))**2
+            vterm=-8.d0*pterm*(rab**8+rbc**8)/prmtbp(kktbp,3)**8
+            gamma=scrn*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))/sint
+            gamsa=(8.d0*pterm/prmtbp(kktbp,3)**8)*rab**7
+            gamsc=(8.d0*pterm/prmtbp(kktbp,3)**8)*rbc**7
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.2)then
+            
+c     screened harmonic valence angle potential
+            
+            scrn=exp(-(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4)))
+            pterm=scrn*0.5d0*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))**2
+            vterm=-pterm*(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4))
+            gamma=scrn*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))/sint
+            gamsa=(pterm/prmtbp(kktbp,3))
+            gamsc=(pterm/prmtbp(kktbp,4))
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.3)then
+            
+c     screened vessal potential type 1
+            
+            scrn=exp(-(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4)))
+            pterm=scrn*prmtbp(kktbp,1)/
+     x        (8.d0*(prmtbp(kktbp,2)-pi)**2)*
+     x        ((prmtbp(kktbp,2)-pi)**2-(theta-pi)**2)**2
+            vterm=-pterm*(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4))
+            gamma=scrn*prmtbp(kktbp,1)/
+     x        (2.d0*(prmtbp(kktbp,2)-pi)**2)*
+     x        ((prmtbp(kktbp,2)-pi)**2-(theta-pi)**2)*(theta-pi)/sint
+            gamsa=(pterm/prmtbp(kktbp,3))
+            gamsc=(pterm/prmtbp(kktbp,4))
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.4)then
+            
+c     truncated vessal potential type 2 - use with sw1
+            
+            scrn=exp(-(rab**8+rbc**8)/prmtbp(kktbp,4)**8)
+            pterm=scrn*prmtbp(kktbp,1)*(theta**prmtbp(kktbp,3)*
+     x        (theta-prmtbp(kktbp,2))**2*(theta+prmtbp(kktbp,2)-
+     x        2.d0*pi)**2-0.5d0*prmtbp(kktbp,3)*pi**(prmtbp(kktbp,3)
+     x        -1.d0)*(theta-prmtbp(kktbp,2))**2*(pi-
+     x        prmtbp(kktbp,2))**3)
+            vterm=-8.d0*pterm*(rab**8+rbc**8)/prmtbp(kktbp,4)**8
+            gamma=scrn*prmtbp(kktbp,1)*(theta**(prmtbp(kktbp,3)-1.d0)*
+     x        (theta-prmtbp(kktbp,2))*(theta+prmtbp(kktbp,2)-
+     x        2.d0*pi)*((prmtbp(kktbp,3)+4.d0)*theta**2-2.d0*pi*
+     x        (prmtbp(kktbp,3)+2.d0)*theta+prmtbp(kktbp,3)*
+     x        prmtbp(kktbp,2)*(2.d0*pi-prmtbp(kktbp,2)))-
+     x        prmtbp(kktbp,3)*pi**(prmtbp(kktbp,3)-1.d0)*
+     x        (theta-prmtbp(kktbp,2))*(pi-prmtbp(kktbp,2))**3)/sint
+            gamsa=(8.d0*pterm/prmtbp(kktbp,4)**8)*rab**7
+            gamsc=(8.d0*pterm/prmtbp(kktbp,4)**8)*rbc**7
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.5)then
+            
+            if(min(rab,rbc).lt.1.5d0)then
+              
+              scrn=(5.d0*(prmtbp(kktbp,2)/rac)**2-6.d0)*
+     x          (prmtbp(kktbp,2)/rac)**10
+              tterm=prmtbp(kktbp,1)*cost**4
+              pterm=scrn*tterm
+              uterm=60.d0*((prmtbp(kktbp,2)/rac)**2-1.d0)*
+     x          (prmtbp(kktbp,2)/rac)**10
+              vterm=tterm*uterm
+              gamma=scrn*4.d0*prmtbp(kktbp,1)*cost**3
+              gamsb=tterm*uterm/rac
+              gamsa=0.d0
+              gamsc=0.d0
+              
+            endif
+            
+          else
+            
+            safe=.false.
+            pterm=0.d0
+            vterm=0.d0
+            gamma=0.d0
+            gamsa=0.d0
+            gamsb=0.d0
+            gamsc=0.d0
+            
+          endif
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set triple index
+          
+          if(lsolva)kkk=loc3(atmolt(ia),atmolt(ib),atmolt(ic))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1)
+     x        .and.(atm_fre(ic).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic).eq.0)
+              
+              if(lsolva)en3_exc(kkk)=en3_exc(kkk)+pterm
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1)
+     x        .or.(atm_fre(ic).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              tbp_fre=tbp_fre-pterm
+              tbp_vir=tbp_vir-vterm
+              pterm=lambda1*pterm
+              vterm=lambda1*vterm
+              gamma=lambda1*gamma
+              gamsa=lambda1*gamsa
+              gamsb=lambda1*gamsb
+              gamsc=lambda1*gamsc
+              
+            elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2)
+     x          .or.(atm_fre(ic).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              tbp_fre=tbp_fre+pterm
+              tbp_vir=tbp_vir+vterm
+              pterm=lambda2*pterm
+              vterm=lambda2*vterm
+              gamma=lambda2*gamma
+              gamsa=lambda2*gamsa
+              gamsb=lambda2*gamsb
+              gamsc=lambda2*gamsc
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential and virial
+            
+            engtbp=engtbp+pterm
+            virtbp=virtbp+vterm
+            
+            if(lsolva)en3_sol(kkk)=en3_sol(kkk)+pterm
+            
+c     calculate atomic forces
+            
+            fxa=gamma*(xbc-xab*cost)*rrab+gamsa*xab+gamsb*xac
+            fya=gamma*(ybc-yab*cost)*rrab+gamsa*yab+gamsb*yac
+            fza=gamma*(zbc-zab*cost)*rrab+gamsa*zab+gamsb*zac
+            
+            fxc=gamma*(xab-xbc*cost)*rrbc+gamsc*xbc-gamsb*xac
+            fyc=gamma*(yab-ybc*cost)*rrbc+gamsc*ybc-gamsb*yac
+            fzc=gamma*(zab-zbc*cost)*rrbc+gamsc*zbc-gamsb*zac
+            
+            fxx(ia)=fxx(ia)+fxa
+            fyy(ia)=fyy(ia)+fya
+            fzz(ia)=fzz(ia)+fza
+            
+            fxx(ib)=fxx(ib)-fxa-fxc
+            fyy(ib)=fyy(ib)-fya-fyc
+            fzz(ib)=fzz(ib)-fza-fzc
+            
+            fxx(ic)=fxx(ic)+fxc
+            fyy(ic)=fyy(ic)+fyc
+            fzz(ic)=fzz(ic)+fzc
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+rab*xab*fxa+rbc*xbc*fxc
+            strs(2)=strs(2)+rab*xab*fya+rbc*xbc*fyc
+            strs(3)=strs(3)+rab*xab*fza+rbc*xbc*fzc
+            strs(4)=strs(4)+rab*yab*fya+rbc*ybc*fyc
+            strs(5)=strs(5)+rab*yab*fza+rbc*ybc*fzc
+            strs(6)=strs(6)+rab*zab*fza+rbc*zbc*fzc
+            
+          endif
+
+c     metadynamics local parameters
+        
+          if(lmetadyn)then
+            
+c     local energy and virial
+            
+            eng_loc=eng_loc+pterm
+            vir_loc=vir_loc+vterm
+            
+c     local forces
+            
+            fxx_loc(ia)=fxx_loc(ia)+fxa
+            fyy_loc(ia)=fyy_loc(ia)+fya
+            fzz_loc(ia)=fzz_loc(ia)+fza
+            
+            fxx_loc(ib)=fxx_loc(ib)-fxa-fxc
+            fyy_loc(ib)=fyy_loc(ib)-fya-fyc
+            fzz_loc(ib)=fzz_loc(ib)-fza-fzc
+            
+            fxx_loc(ic)=fxx_loc(ic)+fxc
+            fyy_loc(ic)=fyy_loc(ic)+fyc
+            fzz_loc(ic)=fzz_loc(ic)+fzc
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+rab*xab*fxa+rbc*xbc*fxc
+            strs_loc(2)=strs_loc(2)+rab*xab*fya+rbc*xbc*fyc
+            strs_loc(3)=strs_loc(3)+rab*xab*fza+rbc*xbc*fzc
+            strs_loc(4)=strs_loc(4)+rab*yab*fya+rbc*ybc*fyc
+            strs_loc(5)=strs_loc(5)+rab*yab*fza+rbc*ybc*fzc
+            strs_loc(6)=strs_loc(6)+rab*zab*fza+rbc*zbc*fzc
+            
+          endif
+
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          
+          endif
+          
+          endif
+          
+          enddo
+          enddo
+          
+          endif
+
+        enddo
+
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     check for undefined potentials
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,442)
+
+c     global sum of three body potential and virial
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=engtbp
+        buffer(2)=virtbp
+        buffer(3)=tbp_fre
+        buffer(4)=tbp_vir
+        call gdsum(buffer(1),4,buffer(5))
+        engtbp=buffer(1)
+        virtbp=buffer(2)
+        tbp_fre=buffer(3)
+        tbp_vir=buffer(4)
+
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(en3_sol,mxtmls_sol3,buffer(1))
+          if(lexcite)call gdsum(en3_exc,mxtmls_exc3,buffer(1))
+          
+        endif
+        
+      endif
+
+c     restore coordinate array to original representation
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=xxx(i)
+          syy=yyy(i)
+          szz=zzz(i)
+          
+          xxx(i)=cell(1)*sxx+cell(4)*syy+cell(7)*szz
+          yyy(i)=cell(2)*sxx+cell(5)*syy+cell(8)*szz
+          zzz(i)=cell(3)*sxx+cell(6)*syy+cell(9)*szz
+          
+        endif
+        
+      enddo
+
+c     restore cell vector
+
+      if(imcon.eq.0) then
+        cell(1)=0.d0
+        cell(5)=0.d0
+        cell(9)=0.d0
+      endif
+      
+      return
+
+      end subroutine thbfrc
+      
+      end module three_body_module
diff -urN dl_class_1.9.orig/srcmod/utility_module.f dl_class_1.9/srcmod/utility_module.f
--- dl_class_1.9.orig/srcmod/utility_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/utility_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1612 @@
+      module utility_module
+
+c***********************************************************************
+c     
+c     dl_poly module for utility subroutines and functions
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      contains
+      
+      subroutine global_sum_forces(natms,mxnode,gxx,gyy,gzz)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to perform global sum of atomic forces as
+c     requred by replicated data strategy
+c     
+c     copyright - daresbury laboratory 
+c     author    - w.smith december 2005
+c     
+c***********************************************************************
+      
+      use config_module
+      
+      implicit none
+      
+      integer natms,mxnode,i,j
+      real(8) gxx(*),gyy(*),gzz(*)
+
+      if(mxnode.gt.1) then
+        
+        j=0
+        do i=1,natms
+          
+          buffer(j+1)=gxx(i)
+          buffer(j+2)=gyy(i)
+          buffer(j+3)=gzz(i)
+          j=j+3
+          
+        enddo
+        call gdsum(buffer(1),3*natms,buffer(3*natms+1))
+        j=0
+        do i=1,natms
+          
+          gxx(i)=buffer(j+1)
+          gyy(i)=buffer(j+2)
+          gzz(i)=buffer(j+3)
+          j=j+3
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine global_sum_forces
+      
+      subroutine images
+     x  (imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating the minimum image
+c     of atom pairs within a specified MD cell
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     T3D optimised version. t.forester july 1994
+c     
+c     for
+c     imcon=0 no boundary conditions apply
+c     imcon=1 standard cubic boundaries apply
+c     imcon=2 orthorhombic boundaries apply
+c     imcon=3 parallelepiped boundaries apply
+c     imcon=4 truncated octahedron boundaries apply
+c     imcon=5 rhombic dodecahedron boundaries apply
+c     imcon=6 x-y parallelogram boundary conditions : no periodicity in z
+c     imcon=7 hexagonal prism boundaries apply
+c     
+c     note: in all cases the centre of the cell is at (0,0,0)
+c     warning - replicated data version: does not re-merge 
+c     coordinate arrays
+c     
+c***********************************************************************
+      
+      use error_module
+      
+      implicit none
+
+      integer imcon,idnode,mxnode,natms,iatm1,iatm2,i
+      real(8) cell,xxx,yyy,zzz,aaa,bbb,ccc,det,rt2,rt3,ssx
+      real(8) ssy,ssz,ddd,xss,yss,zss,rcell
+
+      dimension xxx(*),yyy(*),zzz(*)
+      dimension cell(9),rcell(9)
+
+      data rt2/1.41421356623d0/,rt3/1.7320508075d0/
+
+      if(imcon.gt.0) then
+
+c     block indices
+
+        iatm1 = (idnode*natms)/mxnode+1
+        iatm2 = ((idnode+1)*natms)/mxnode
+
+      endif
+      
+      if(imcon.eq.1)then
+
+c     standard cubic boundary conditions
+        
+        
+        aaa=1.d0/cell(1)
+
+        do i=iatm1,iatm2
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(1)*nint(aaa*zzz(i))
+        enddo
+        
+      else if(imcon.eq.2)then
+
+c     rectangular (slab) boundary conditions
+        
+        aaa=1.d0/cell(1)
+        bbb=1.d0/cell(5)
+        ccc=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(5)*nint(bbb*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(ccc*zzz(i))
+          
+        enddo
+        
+      else if(imcon.eq.3)then
+
+c     parallelepiped boundary conditions
+        
+        call invert(cell,rcell,det)
+        
+        do i=iatm1,iatm2
+          
+          ssx=(rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i))
+          ssy=(rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i))
+          ssz=(rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i))
+          
+          xss=ssx-nint(ssx)
+          yss=ssy-nint(ssy)
+          zss=ssz-nint(ssz)
+          
+          xxx(i)=(cell(1)*xss+cell(4)*yss+cell(7)*zss)
+          yyy(i)=(cell(2)*xss+cell(5)*yss+cell(8)*zss)
+          zzz(i)=(cell(3)*xss+cell(6)*yss+cell(9)*zss)
+          
+        enddo
+        
+      else if(imcon.eq.4)then
+
+c     truncated octahedral boundary conditions
+        
+        if(.not.(abs(cell(1)-cell(5)).lt.1.d-6.and.
+     x    abs(cell(5)-cell(9)).lt.1.d-6)) call error(idnode,130)
+        
+        aaa=1.d0/cell(1)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(1)*nint(aaa*zzz(i))
+          
+          if((abs(xxx(i))+abs(yyy(i))+abs(zzz(i))).ge.
+     x      (0.75d0*cell(1)))then
+            
+            xxx(i)=xxx(i)-0.5d0*sign(cell(1),xxx(i))
+            yyy(i)=yyy(i)-0.5d0*sign(cell(1),yyy(i))
+            zzz(i)=zzz(i)-0.5d0*sign(cell(1),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      else if(imcon.eq.5)then
+
+c     rhombic dodecahedral boundary conditions
+        
+        if(.not.(abs(cell(1)-cell(5)).lt.1.d-6.and.
+     x    abs(cell(9)-cell(1)*rt2).lt.1.d-6)) 
+     x    call error(idnode,140)
+        
+        aaa=1.d0/cell(1)
+        bbb=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(bbb*zzz(i))
+          
+          if((abs(xxx(i))+abs(yyy(i))+abs(rt2*zzz(i))).ge.
+     x      cell(1))then
+            
+            xxx(i)=xxx(i)-0.5d0*sign(cell(1),xxx(i))
+            yyy(i)=yyy(i)-0.5d0*sign(cell(1),yyy(i))
+            zzz(i)=zzz(i)-0.5d0*sign(cell(9),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      else if(imcon.eq.6) then
+
+c     x-y boundary conditions 
+
+        det = cell(1)*cell(5) - cell(2)*cell(4)
+
+        if(abs(det).lt.1.d-6)call error(idnode,120)
+        
+        det = 1.d0/det
+
+        rcell(1) =  det*cell(5)
+        rcell(2) = -det*cell(2)
+        rcell(4) = -det*cell(4)
+        rcell(5) =  det*cell(1)
+        
+        do i=iatm1,iatm2
+
+          ssx = rcell(1)*xxx(i) + rcell(4)*yyy(i)
+          ssy = rcell(2)*xxx(i) + rcell(5)*yyy(i)
+
+          xss = ssx - nint(ssx)
+          yss = ssy - nint(ssy)
+
+          xxx(i)=cell(1)*xss + cell(4)*yss
+          yyy(i)=cell(2)*xss + cell(5)*yss
+
+        enddo
+
+      else if(imcon.eq.7) then
+
+c     hexagonal prism boundary conditions
+        
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,135)
+        
+        aaa=cell(1)/(rt3*2.d0)
+        bbb=cell(1)/rt3
+        ccc=rt3/cell(1)
+        ddd=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          yyy(i)=yyy(i)-bbb*nint(ccc*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(ddd*zzz(i))
+          
+          if((abs(yyy(i))+abs(rt3*xxx(i))).ge.bbb)then
+            
+            xxx(i)=xxx(i)-rt3*sign(aaa,xxx(i))
+            yyy(i)=yyy(i)-sign(aaa,yyy(i))
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine images
+
+      subroutine config_write(fname,levcfg,imcon,natms,engcfg)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing CONFIG files
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith aug 2007
+c     
+c***********************************************************************
+      
+      use config_module
+      use setup_module
+      
+      implicit none
+      
+      character*6 fname
+      
+      integer i,natms,levcfg,imcon,nstep
+      real(8) engcfg
+
+      open(nconf,file=fname,form='formatted')
+      
+      write(nconf,'(80a1)') cfgname
+      write(nconf,'(3i10,1p,g20.12)') levcfg,imcon,natms,engcfg
+      if(imcon.gt.0) write(nconf,'(3f20.12)') cell
+      
+      do i=1,natms
+        
+        write(nconf,'(a8,i10)') atmnam(i),i
+        write(nconf,'(3g20.10)') xxx(i),yyy(i),zzz(i)
+        if(levcfg.gt.0)write(nconf,'(3g20.12)')
+     x    vxx(i),vyy(i),vzz(i)
+        if(levcfg.gt.1)write(nconf,'(3g20.12)') 
+     x    fxx(i),fyy(i),fzz(i)
+        
+      enddo
+      
+      close (nconf)
+      
+      return
+      end subroutine config_write
+      
+      subroutine bomb(idnode,nyr,nmn,ndy)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to set an expiry date in a compiled program
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    oct 2002
+c
+c***********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical safe
+      integer info(8)
+      character*12 dat,tim,zon
+      integer idnode,nyr,nmn,ndy
+
+      safe=.true.
+
+      call date_and_time(dat,tim,zon,info)
+      
+      if(info(1).gt.nyr)then
+
+        safe=.false.
+
+      else if(info(1).eq.nyr)then
+
+        if(info(2).gt.nmn)then
+
+          safe=.false.
+
+        else if(info(2).eq.nmn)then
+
+          if(info(3).ge.ndy)safe=.false.
+
+        endif
+
+      endif
+
+      if(.not.safe)then
+
+        if(idnode.eq.0)write(nrite,'(a,/,a)')
+     x    'THE EXPIRY DATE OF THIS EXECUTABLE HAS PASSED.',
+     X    'PLEASE CONTACT W.SMITH@DL.AC.UK FOR A NEW LICENCE'
+
+        call exitcomms()
+
+      endif
+
+      return
+      end subroutine bomb
+
+      subroutine cpy_rtc(nnn,aaa,bbb)
+
+c**********************************************************************
+c
+c     dl_poly subroutine for copying a real array into a complex array
+c     of the same dimension
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith oct 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      real(8) aaa(*)
+      complex(8) bbb(*)
+
+      do i=1,nnn
+
+        bbb(i)=cmplx(aaa(i),0.d0,kind=8)
+
+      enddo
+
+      return
+      end subroutine cpy_rtc
+
+      function duni()
+
+c*********************************************************************
+c     
+c     dl_poly random number generator based on the universal
+c     random number generator of marsaglia, zaman and tsang
+c     (stats and prob. lett. 8 (1990) 35-39.) it must be
+c     called once to initialise parameters u,c,cd,cm
+c     
+c     copyright daresbury laboratory 1992
+c     author -  w.smith         july 1992
+c     
+c*********************************************************************
+
+      implicit none
+
+      logical new
+      integer ir,jr,i,j,k,l,m,ii,jj
+      real(4) s,t,u,c,cd,cm,uni
+      real(8) duni
+      dimension u(97)
+      save u,c,cd,cm,uni,ir,jr,new
+      data new/.true./
+
+      if(new)then
+
+c     initial values of i,j,k must be in range 1 to 178 (not all 1)
+c     initial value of l must be in range 0 to 168.
+
+        i=12
+        j=34
+        k=56
+        l=78
+c     
+        ir=97
+        jr=33
+        new=.false.
+
+        do 200 ii=1,97
+          s=0.0
+          t=0.5
+          do 100 jj=1,24
+            m=mod(mod(i*j,179)*k,179)
+            i=j
+            j=k
+            k=m
+            l=mod(53*l+1,169)
+            if(mod(l*m,64).ge.32)s=s+t
+            t=0.5*t
+  100     continue
+          u(ii)=s
+  200   continue
+        c =  362436.0/16777216.0
+        cd= 7654321.0/16777216.0
+        cm=16777213.0/16777216.0
+      else
+
+c     calculate random number
+        uni=u(ir)-u(jr)
+        if(uni.lt.0.0)uni=uni+1.0
+        u(ir)=uni
+        ir=ir-1
+        if(ir.eq.0)ir=97
+        jr=jr-1
+        if(jr.eq.0)jr=97
+        c=c-cd
+        if(c.lt.0.0)c=c+cm
+        uni=uni-c
+        if(uni.lt.0.0)uni=uni+1.0
+        duni=dble(uni)
+      endif
+      
+      return
+      end function duni
+
+      subroutine ele_prd(nnn,aaa,bbb,ccc)
+
+c**********************************************************************
+c
+c     dl_poly subroutine for element by element product of
+c     a real array (bbb) and a complex array (ccc)
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith july 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      real(8) bbb(*)
+      complex(8) aaa(*),ccc(*)
+
+      do i=1,nnn
+
+        aaa(i)=bbb(i)*ccc(i)
+
+      enddo
+
+      return
+      end subroutine ele_prd
+
+      subroutine gauss(natms,vxx,vyy,vzz)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for constructing velocity arrays
+c     with a gaussian distribution of unit variance.
+c     
+c     based on the Box-Muller method
+c     
+c     note - this version uses a universal random number 
+c     generator, which generates pseudo-random numbers between
+c     0 and 1. it is based on the algorithm of marsaglia, zaman
+c     and tsang in: stats and prob. lett. 8 (1990) 35-39.
+c     
+c     copyright daresbury laboratory 2007
+c     author - w. smith         nov  2007
+c     
+c*********************************************************************
+      
+      use setup_module
+      
+      implicit none
+
+      integer natms,i
+      real(8) vxx,vyy,vzz,rrr,rr1,rr2
+      
+      dimension vxx(natms),vyy(natms),vzz(natms)
+      
+c     initialise random number generator
+      
+      rrr=duni()
+      
+c     calculate gaussian random numbers
+      
+      do i=1,2*(natms/2),2
+        
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vxx(i)=rr1*cos(rr2)
+        vxx(i+1)=rr1*sin(rr2)
+
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vyy(i)=rr1*cos(rr2)
+        vyy(i+1)=rr1*sin(rr2)
+
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vzz(i)=rr1*cos(rr2)
+        vzz(i+1)=rr1*sin(rr2)
+        
+      enddo
+      if(mod(natms,2).ne.0)then
+        
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vxx(natms)=rr1*cos(rr2)
+        vyy(natms)=rr1*sin(rr2)
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vzz(natms)=rr1*cos(rr2)
+        
+      endif
+      
+      return
+      end subroutine gauss
+
+      subroutine invert(a,b,d)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to invert a 3 * 3 matrix using cofactors
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       april 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      real(8) a,b,d,r
+
+      dimension a(9),b(9)
+
+c     calculate adjoint matrix
+      b(1)=a(5)*a(9)-a(6)*a(8)
+      b(2)=a(3)*a(8)-a(2)*a(9)
+      b(3)=a(2)*a(6)-a(3)*a(5)
+      b(4)=a(6)*a(7)-a(4)*a(9)
+      b(5)=a(1)*a(9)-a(3)*a(7)
+      b(6)=a(3)*a(4)-a(1)*a(6)
+      b(7)=a(4)*a(8)-a(5)*a(7)
+      b(8)=a(2)*a(7)-a(1)*a(8)
+      b(9)=a(1)*a(5)-a(2)*a(4)
+
+c     calculate determinant
+      d=a(1)*b(1)+a(4)*b(2)+a(7)*b(3)
+      r=0.d0
+      if(abs(d).gt.0.d0)r=1.d0/d
+
+c     complete inverse matrix
+      b(1)=r*b(1)
+      b(2)=r*b(2)
+      b(3)=r*b(3)
+      b(4)=r*b(4)
+      b(5)=r*b(5)
+      b(6)=r*b(6)
+      b(7)=r*b(7)
+      b(8)=r*b(8)
+      b(9)=r*b(9)
+
+      return
+      end subroutine invert
+
+      subroutine jacobi(a,v,n)
+
+c***********************************************************************
+c     
+c     diagonalisation of real symmetric matices by jacobi method
+c     
+c     input parameters:
+c     
+c     a(n,n) is the matrix to be diagonalised
+c     v(n,n) is the eigenvector matrix
+c     n   is the dimension of the matrices
+c     
+c     jacobi processes lower triangle only (upper triangle unchanged)
+c     
+c     variable rho sets absolute tolerance on convergence
+c     variable tes is a moving tolerance that diminishes
+c     on each pass until at true convergence tes<rho
+c     
+c     author w.smith 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical pass
+      integer n,i,j,k
+      real(8) a,v,rho,tes,scl,v1,v2,v3,u,omg,s,c,tem
+
+      dimension a(n,n),v(n,n)
+
+      rho=1.0d-16
+      tes=0.0d0
+      scl=0.0d0
+
+c     initialize eigenvectors
+
+      do i=1,n
+        do j=1,n
+          v(i,j)=0.0d0
+        enddo
+        v(i,i)=1.0d0
+      enddo
+
+c     rescale matrix for optimal accuracy
+
+      do i=1,n
+        if(abs(a(i,i)).gt.scl)scl=abs(a(i,i))
+      enddo
+      do i=1,n
+        do j=1,i
+          a(i,j)=a(i,j)/scl
+        enddo
+      enddo
+
+c     set initial value of moving tolerance
+
+      do i=2,n
+        do j=1,i-1
+          tes=tes+2.0d0*a(i,j)*a(i,j)
+        enddo
+      enddo
+      tes=sqrt(tes)
+
+c     recycle until absolute tolerance satisfied
+
+      do while(tes.gt.rho)
+
+        tes=tes/dble(n)
+        if(tes.lt.rho)tes=rho
+        
+c     jacobi diagonalisation
+        
+        pass=.true.
+        
+c     recycle until moving tolerance satisfied
+        
+        do while(pass)
+          
+          pass=.false.
+          
+          do i=2,n
+            
+            do j=1,i-1
+              
+              if(abs(a(i,j)).ge.tes)then
+                pass=.true.
+                v1=a(j,j)
+                v2=a(i,j)
+                v3=a(i,i)
+                u=0.5d0*(v1-v3)
+                if(abs(u).lt.rho)then
+                  omg=-1.0d0
+                else
+                  omg=-v2/sqrt(v2*v2+u*u)
+                  if(u.lt.0.0d0)omg=-omg
+                endif
+                s=omg/sqrt(2.0d0*(1.0d0+sqrt(1.0d0-omg*omg)))
+                c=sqrt(1.0d0-s*s)
+                do k=1,n
+                  if(k.ge.i)then
+                    tem=a(k,j)*c-a(k,i)*s
+                    a(k,i)=a(k,j)*s+a(k,i)*c
+                    a(k,j)=tem
+                  else if(k.lt.j)then
+                    tem=a(j,k)*c-a(i,k)*s
+                    a(i,k)=a(j,k)*s+a(i,k)*c
+                    a(j,k)=tem
+                  else
+                    tem=a(k,j)*c-a(i,k)*s
+                    a(i,k)=a(k,j)*s+a(i,k)*c
+                    a(k,j)=tem
+                  endif
+                  tem=v(k,j)*c-v(k,i)*s
+                  v(k,i)=v(k,j)*s+v(k,i)*c
+                  v(k,j)=tem
+                enddo
+                a(j,j)=v1*c*c+v3*s*s-2.0d0*v2*s*c
+                a(i,i)=v1*s*s+v3*c*c+2.0d0*v2*s*c
+                a(i,j)=(v1-v3)*s*c+v2*(c*c-s*s)
+              endif
+              
+            enddo
+            
+          enddo
+          
+        enddo
+
+      enddo
+
+c     rescale matrix
+
+      do i=1,n
+        do j=1,i
+          a(i,j)=scl*a(i,j)
+        enddo
+      enddo
+
+      return
+      end subroutine jacobi
+
+      subroutine scl_csum(nnn,tot,aaa)
+
+c**********************************************************************
+c
+c     dl_poly subroutine to calculate the scalar sum of the elements
+c     of a complex array
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith july 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      complex(8) aaa(*),tot
+
+      tot=(0.d0,0.d0)
+
+      do i=1,nnn
+
+        tot=tot+aaa(i)
+
+      enddo
+
+      return
+      end subroutine scl_csum
+
+      subroutine set_block(nnn,ccc,aaa)
+
+c**********************************************************************
+c
+c     dl_poly subroutine to initialise an array to a single value
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith july 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      real(8) ccc,aaa(nnn)
+
+      do i=1,nnn,2
+
+        aaa(i)=ccc
+        aaa(i+1)=ccc
+
+      enddo
+      
+      return
+      end subroutine set_block
+
+      subroutine shellsort(n,list)
+
+c***********************************************************************
+c     
+c     dlpoly shell sort routine. 
+c     Sorts an array of integers into ascending order
+c     
+c     copyright daresbury laboratory 1993
+c     author - t.forester   november 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer n,list,nn,nl,i,j,ix,imax
+
+      dimension list(*)
+
+c     set up sort
+
+      if(n.gt.1) then
+
+c     number of lists
+
+        nl = n/2
+
+c     iterate shell sort
+
+        do while(nl.gt.0)
+
+          do nn = 1,nl
+            
+c     begin insertion sort on nnth list
+            
+            do i = nn+nl,n,nl
+              
+              imax = list(i)
+              ix = i
+              
+c     find location for insertion
+              
+              j = i
+              do while(j.ge.nl+1)
+                
+                j = j-nl
+                if (list(j).gt.imax) then
+                  ix = j
+                else
+                  j =1
+                endif
+                
+              enddo
+              
+c     insert in index array
+              
+              do j = i,ix+nl,-nl
+                list(j) = list(j-nl)
+              enddo
+              
+              list(ix) = imax
+              
+            enddo
+            
+          enddo
+        
+          nl = nl/2
+
+        enddo
+        
+      endif
+
+      return
+      end subroutine shellsort
+
+      subroutine fcap(lfcap,natms,fmax,temp)
+      
+c*********************************************************************
+c     
+c     DLPOLY routinue for limiting the absolute magnitude of
+c     forces. Used in equilibration period only
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author -     t. forester march 1993
+c     amended-     t. forester  sept 1994
+c     
+c*********************************************************************
+
+      use config_module
+      
+      implicit none
+
+      logical lfcap
+      integer natms,i
+      real(8) fmax,temp,fmax1,fmax2,fxc,fyc,fzc,fmod,fscale
+      
+      if(lfcap) then
+
+c     maximum force permitted
+        
+        fmax1 = boltz*fmax*temp
+        fmax2 = fmax1*fmax1
+
+c     cap forces and conserve linear momentum
+        
+        fxc = 0.d0
+        fyc = 0.d0
+        fzc = 0.d0
+        
+        do i = 1,natms
+          
+          fmod = fxx(i)**2 + fyy(i)**2 + fzz(i)**2
+          
+          if(fmod.gt.fmax2) then
+            
+            fscale = sqrt(fmax2/fmod)
+            
+            fxx(i) = fxx(i)*fscale
+            fyy(i) = fyy(i)*fscale
+            fzz(i) = fzz(i)*fscale
+            
+          endif
+
+c     accummulate forces - to check on momentum conservation
+          
+          fxc = fxc + fxx(i)
+          fyc = fyc + fyy(i)
+          fzc = fzc + fzz(i)
+          
+        enddo
+
+c     ensure net forces sum to zero
+        
+        fxc = -fxc/dble(natms)
+        fyc = -fyc/dble(natms)
+        fzc = -fzc/dble(natms)
+
+c     conserve momentum
+        
+        do i = 1,natms
+          
+          fxx(i) = fxx(i) + fxc
+          fyy(i) = fyy(i) + fyc
+          fzz(i) = fzz(i) + fzc
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine fcap
+
+      subroutine freeze(natms)
+
+c***********************************************************************
+c     
+c     dlpoly routine to quench forces and velocities on 'frozen' atoms
+c     replicated data version - blocked data
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester nov 1994
+c     
+c***********************************************************************
+
+      use config_module
+
+      implicit none
+
+      integer natms,i
+
+      do i = 1,natms
+        
+        if(lstfrz(i).ne.0) then
+          
+          vxx(i) = 0.d0
+          vyy(i) = 0.d0
+          vzz(i) = 0.d0
+          fxx(i) = 0.d0
+          fyy(i) = 0.d0
+          fzz(i) = 0.d0
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine freeze
+
+      subroutine mat_mul(aaa,bbb,ccc)
+
+c***********************************************************************
+c     
+c     dlpoly utility to multiply 3x3 matrices
+c
+c     copyright daresbury laboratory
+c     author      w.smith  oct  2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer i
+      real(8) aaa(9),bbb(9),ccc(9),tmp(9)
+
+      tmp(1)=aaa(1)*bbb(1)+aaa(4)*bbb(2)+aaa(7)*bbb(3)
+      tmp(2)=aaa(2)*bbb(1)+aaa(5)*bbb(2)+aaa(8)*bbb(3)
+      tmp(3)=aaa(3)*bbb(1)+aaa(6)*bbb(2)+aaa(9)*bbb(3)
+
+      tmp(4)=aaa(1)*bbb(4)+aaa(4)*bbb(5)+aaa(7)*bbb(6)
+      tmp(5)=aaa(2)*bbb(4)+aaa(5)*bbb(5)+aaa(8)*bbb(6)
+      tmp(6)=aaa(3)*bbb(4)+aaa(6)*bbb(5)+aaa(9)*bbb(6)
+
+      tmp(7)=aaa(1)*bbb(7)+aaa(4)*bbb(8)+aaa(7)*bbb(9)
+      tmp(8)=aaa(2)*bbb(7)+aaa(5)*bbb(8)+aaa(8)*bbb(9)
+      tmp(9)=aaa(3)*bbb(7)+aaa(6)*bbb(8)+aaa(9)*bbb(9)
+      
+      do i=1,9
+        ccc(i)=tmp(i)
+      enddo
+      
+      return
+      end subroutine mat_mul
+
+      subroutine getrotmat(q0,q1,q2,q3,rot)
+      
+c***********************************************************************
+c     
+c     dlpoly utility to  construct rotation matrix
+c     from quaternions using x convention for euler angles
+c
+c     copyright daresbury laboratory
+c     author      w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+      
+      real(8) q0,q1,q2,q3,rot(9)
+      
+      rot(1)=q0**2+q1**2-q2**2-q3**2
+      rot(2)=2.d0*(q1*q2-q0*q3)
+      rot(3)=2.d0*(q1*q3+q0*q2)
+      rot(4)=2.d0*(q1*q2+q0*q3)
+      rot(5)=q0**2-q1**2+q2**2-q3**2
+      rot(6)=2.d0*(q2*q3-q0*q1)
+      rot(7)=2.d0*(q1*q3-q0*q2)
+      rot(8)=2.d0*(q2*q3+q0*q1)
+      rot(9)=q0**2-q1**2-q2**2+q3**2
+      
+      return
+      end subroutine getrotmat
+
+      function sdot0(n,aaa,bbb)
+
+c***********************************************************************
+c     
+c     dlpoly utility to calculate scalar product of two arrays
+c
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer n,i
+      real(8) sdot0,aaa,bbb
+
+      dimension aaa(*),bbb(*)
+
+      sdot0=0.d0
+
+      do i=1,n
+        sdot0=sdot0+aaa(i)*bbb(i)
+      enddo
+
+      return
+      end function sdot0
+
+      function sdot1(natms,idnode,mxnode,aaa,bbb)
+
+c***********************************************************************
+c     
+c     dlpoly utility to calculate scalar product of two arrays
+c     distributed version
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+      
+      use config_module
+      
+      implicit none
+      
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) sdot1,aaa,bbb
+      
+      dimension aaa(*),bbb(*)
+      
+c     assign block of atoms to processor
+
+      iatm0=(idnode*natms)/mxnode + 1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+      sdot1=0.d0
+      
+      do i=iatm0,iatm1
+        sdot1=sdot1+aaa(i)*bbb(i)
+      enddo
+      
+      if(mxnode.gt.1)then
+        buffer(1)=sdot1
+        call gdsum(buffer(1),1,buffer(2))
+        sdot1=buffer(1)
+      endif
+      
+      return
+      end function sdot1
+
+      integer function loc2(i,j)
+
+c*********************************************************************
+c
+c     calculates double index array minimum reference
+c
+c     copyright daresbury laboratory
+c     author w.smith november 2005
+c
+c*********************************************************************
+      
+      integer i,j
+      
+      loc2=(max(i,j)*(max(i,j)-1))/2+min(i,j)
+      
+      return
+      end function loc2
+
+      integer function loc3(i,j,k)
+
+c*********************************************************************
+c
+c     calculates triple index array minimum reference
+c
+c     copyright daresbury laboratory
+c     author w.smith september 2008
+c
+c*********************************************************************
+      
+      integer i,j,k,a,b,c,u,v,w
+      
+      a=max(i,j)
+      b=min(a,k)
+      c=min(i,j)
+      u=max(a,k)
+      v=max(b,c)
+      w=min(b,c)
+      loc3=(u*(u*u-1))/6+(v*(v-1))/2+w
+      
+      return
+      end function loc3
+
+      integer function loc4(i,j,k,l)
+
+c*********************************************************************
+c
+c     calculates quaduple index array minimum reference
+c
+c     copyright daresbury laboratory
+c     author w.smith september 2008
+c
+c*********************************************************************
+      
+      integer i,j,k,l,a,b,c,d,e,f,t,u,v,w
+      
+      a=max(i,j)
+      b=max(k,l)
+      c=min(i,j)
+      d=min(k,l)
+      e=max(c,d)
+      f=min(a,b)
+      t=max(a,b)
+      u=max(e,f)
+      v=min(e,f)
+      w=min(c,d)
+      loc4=((((t+2)*t-1)*t-2)*t)/24+(u*(u*u-1))/6+(v*(v-1))/2+w
+      
+      return
+      end function loc4
+
+      character*3 function intstr3(nnn)
+
+c*********************************************************************
+c
+c     converts a 3 digit integer to a string "001" etc.
+c
+c     copyright daresbury laboratory
+c     author w.smith november 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer nnn
+
+      write(intstr3,'(i3.3)')nnn
+
+      return
+      end function intstr3
+      
+      subroutine traject
+     x  (ltraj,idnode,imcon,istraj,keytrj,natms,nstraj,nstep,tstep)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing history file at selected
+c     intervals in simulation
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c
+c***********************************************************************
+
+      use setup_module
+      use config_module
+
+      implicit none
+      
+      logical newjob,ltraj
+      integer idnode,imcon,istraj,keytrj,natms,nstraj,nstep,i
+      real(8) tstep
+
+      save newjob
+      data newjob/.true./
+      
+      if(ltraj.and.idnode.eq.0)then
+        
+c     open the history file if new job or file closed
+        
+        if(newjob)then
+          
+          newjob = .false.
+
+          open(nhist,file='HISTORY',position='append')
+
+        endif
+        
+        if(nstep.eq.nstraj.or.nstep.eq.istraj)then
+          
+          write(nhist,'(80a1)') cfgname
+          write(nhist,'(3i10)') keytrj,imcon,natms
+          
+        endif
+        
+        if(mod(nstep-nstraj,istraj).eq.0)then
+          
+          write(nhist,'(a8,4i10,f12.6)') 'timestep',
+     x         nstep,natms,keytrj,imcon,tstep
+
+          if(imcon.gt.0) write(nhist,'(3g12.4)') cell
+
+          do i = 1,natms
+
+            write(nhist,'(a8,i10,2f12.6)')
+     x        atmnam(i),i,weight(i),chge(i)
+            write(nhist,'(1p,3e12.4)') xxx(i),yyy(i),zzz(i)
+            if(keytrj.ge.1)then
+              write(nhist,'(1p,3e12.4)') vxx(i),vyy(i),vzz(i)
+            endif
+            if(keytrj.ge.2)then
+              write(nhist,'(1p,3e12.4)') fxx(i),fyy(i),fzz(i)
+            endif
+
+          enddo
+
+        endif
+
+c     close history file at regular intervals
+        
+        if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+          
+          close (nhist)
+          newjob = .true.
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine traject
+      
+      subroutine traject_u
+     x     (ltraj,idnode,imcon,istraj,keytrj,natms,nstraj,nstep,tstep)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing history file at selected
+c     intervals in simulation
+c     
+c     Unformatted, double precision version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     
+c***********************************************************************
+      
+      use setup_module
+      use config_module
+      
+      implicit none
+      
+      logical newjob,ltraj
+      integer idnode,imcon,istraj,keytrj,natms,nstraj,nstep,i
+      real(8) tstep
+      
+      save newjob
+      data newjob/.true./
+      
+      if(ltraj.and.idnode.eq.0)then
+        
+c     open the history file if new job or file closed
+        
+        if(newjob)  then
+          
+          newjob = .false.
+          open(nhist,file='HISTORY',form='unformatted',
+     x      position='append')
+          
+        endif
+        if(nstep.eq.nstraj.or.nstep.eq.istraj)then
+          
+          write(nhist) cfgname
+          write(nhist) dble(natms)
+          write(nhist) (atmnam(i),i=1,natms)
+          write(nhist) (weight(i),i=1,natms)
+          write(nhist) (chge(i),i=1,natms)
+          
+        endif
+        
+        if(mod(nstep-nstraj,istraj).eq.0)then
+          
+          write(nhist)dble(nstep),dble(natms),dble(keytrj),
+     x      dble(imcon),tstep
+          
+          if(imcon.gt.0) write(nhist) cell
+          
+          write(nhist) (xxx(i),i = 1,natms)
+          write(nhist) (yyy(i),i = 1,natms)
+          write(nhist) (zzz(i),i = 1,natms)
+          
+          if(keytrj.ge.1)then
+            write(nhist) (vxx(i),i = 1,natms)
+            write(nhist) (vyy(i),i = 1,natms)
+            write(nhist) (vzz(i),i = 1,natms)
+          endif
+          if(keytrj.ge.2)then
+            write(nhist) (fxx(i),i = 1,natms)
+            write(nhist) (fyy(i),i = 1,natms)
+            write(nhist) (fzz(i),i = 1,natms)
+          endif
+          
+        endif
+        
+c     close history file at regular intervals
+        
+        if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+          
+          close (nhist)
+          newjob=.true.
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine traject_u
+      
+      subroutine getcom_mol(ibeg,iend,imcon,idnode,mxnode,molmas,com)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to calculate centre of mass of a molecule
+c     specified between two atomic indices of the configuration
+c     
+c     copyright daresbury laboratory
+c     author - w.smith june 2009
+c     
+c*********************************************************************
+      
+      use config_module
+      
+      implicit none
+      
+      integer ibeg,iend,imcon,i,idnode,mxnode,iatm0,iatm1,nmol
+      integer j,fail
+      real(8) molmas
+      real(8) com(3)
+      real(8), allocatable :: disx(:),disy(:),disz(:)
+      data fail/0/
+      
+      nmol=iend-ibeg+1
+      if(mxnode.eq.1.or.nmol.lt.mxnode)then
+        
+        iatm0=ibeg
+        iatm1=iend
+        
+      else
+        
+        iatm0=(idnode*nmol)/mxnode+ibeg
+        iatm1=((idnode+1)*nmol)/mxnode+ibeg-1
+        nmol=(iend-ibeg+1)/mxnode+1
+        
+      endif
+      
+      allocate (disx(nmol),disy(nmol),disz(nmol),stat=fail)
+      
+      com(1)=0.d0
+      com(2)=0.d0
+      com(3)=0.d0
+      molmas=0.d0
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        disx(j)=xxx(i)-xxx(ibeg)
+        disy(j)=yyy(i)-yyy(ibeg)
+        disz(j)=zzz(i)-zzz(ibeg)
+        
+      enddo
+      nmol=j
+      
+      call images(imcon,0,1,nmol,cell,disx,disy,disz)
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        molmas=molmas+weight(i)
+        com(1)=com(1)+weight(i)*(disx(j)+xxx(ibeg))
+        com(2)=com(2)+weight(i)*(disy(j)+yyy(ibeg))
+        com(3)=com(3)+weight(i)*(disz(j)+zzz(ibeg))
+
+      enddo
+
+      nmol=iend-ibeg+1
+      if(mxnode.gt.1.and.nmol.ge.mxnode)then
+        
+        buffer(1)=com(1)
+        buffer(2)=com(2)
+        buffer(3)=com(3)
+        buffer(4)=molmas
+        call gdsum(buffer(1),4,buffer(5))
+        com(1)=buffer(1)
+        com(2)=buffer(2)
+        com(3)=buffer(3)
+        molmas=buffer(4)
+        
+      endif
+      
+      com(1)=com(1)/molmas
+      com(2)=com(2)/molmas
+      com(3)=com(3)/molmas
+
+      call images(imcon,0,1,1,cell,com(1),com(2),com(3))
+
+      deallocate(disx,disy,disz)
+      
+      return
+      end subroutine getcom_mol
+
+      subroutine timchk(ktim,time)
+      
+c***********************************************************************
+c     
+c     dlpoly timing routine for time elapsed in seconds
+c     
+c     copyright daresbury laboratory
+c     author w.smith nov 2003
+c
+c***********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical init
+      character*12 dat,tim,zon
+      integer idnode,mynode,ktim,day
+      real(8) time,told,tsum,tnow
+      integer info(8)
+
+      save init,idnode,told,tsum,day
+
+      data init/.true./
+
+   10 format(/,' time elapsed since job start = ',f15.3,' seconds',/)
+
+      call date_and_time(dat,tim,zon,info)
+      
+      if(init)then
+
+         tsum=0.d0
+         time=0.d0
+         day=info(3)
+         idnode=mynode()
+         told=3600.d0*dble(info(5))+60.d0*dble(info(6))+
+     x         dble(info(7))+0.001d0*dble(info(8))
+         init=.false.
+
+      else
+
+         tnow=3600.d0*dble(info(5))+60.d0*dble(info(6))+
+     x         dble(info(7))+0.001d0*dble(info(8))
+         if(day.ne.info(3))then
+           told=told-86400.d0
+           day=info(3)
+         endif
+         tsum=tsum+tnow-told
+         told=tnow
+         time=tsum
+
+      endif
+
+      if(ktim.gt.0.and.idnode.eq.0) write(nrite,10)time
+
+      return
+      end subroutine timchk
+      
+      subroutine get_prntime(hms,timelp,prntim)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for casting cpu elapsed time into days, hours, 
+c     minutes and seconds for printing (input timelp in seconds)
+c     copyright daresbury laboratory
+c     author w.smith may 2009
+c
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 hms
+      real(8) timelp,prntim
+      
+      if(timelp.ge.8.64d4)then
+        hms='d'
+        prntim=timelp/8.64d4
+      elseif(timelp.ge.3.6d3)then
+        hms='h'
+        prntim=timelp/3.6d3
+      elseif(timelp.ge.6.0d1)then
+        hms='m'
+        prntim=timelp/6.0d1
+      else
+        hms='s'
+        prntim=timelp
+      endif
+
+      return
+      end subroutine get_prntime
+      
+      subroutine get_simtime(dec,nstep,tstep,simtim)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for casting simulation time into microseconds,
+c     nanoseconds, picoseconds and femtoseconds for printing (input
+c     tstep in picoseconds)
+c     copyright daresbury laboratory
+c     author w.smith may 2009
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 dec
+      integer nstep
+      real(8) tmptim,simtim,tstep
+      
+      tmptim=tstep*dble(nstep)
+
+      if(tmptim.ge.1.0d6)then
+        dec='m'
+        simtim=tmptim*1.0d-6
+      elseif(tmptim.ge.1.0d3)then
+        dec='n'
+        simtim=tmptim*1.0d-3
+      elseif(tmptim.ge.1.0d0)then
+        dec='p'
+        simtim=tmptim
+      else
+        dec='f'
+        simtim=tmptim*1.0d3
+      endif
+
+      return
+      end subroutine get_simtime
+
+      end module utility_module
diff -urN dl_class_1.9.orig/srcmod/vdw_module.f dl_class_1.9/srcmod/vdw_module.f
--- dl_class_1.9.orig/srcmod/vdw_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vdw_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1743 @@
+      module vdw_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining van der waals potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     adapted   - d. quigley : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use pair_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      integer, allocatable :: ltpvdw(:),lstvdw(:)
+      real(8), allocatable :: vvv(:,:),ggg(:,:),prmvdw(:,:)
+
+      save ltpvdw,lstvdw,prmvdw,vvv,ggg
+
+      contains
+      
+      subroutine alloc_vdw_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=5
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (ltpvdw(mxvdw),stat=fail(1))
+      allocate (lstvdw(mxvdw),stat=fail(2))
+      allocate (prmvdw(mxvdw,mxpvdw),stat=fail(3))
+      allocate (vvv(mxgrid,mxvdw),stat=fail(4))
+      allocate (ggg(mxgrid,mxvdw),stat=fail(5))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1014)
+      enddo
+
+      end subroutine alloc_vdw_arrays
+
+      subroutine define_van_der_waals
+     x  (safe,ltable,lunits,lmols,idnode,ntpvdw,
+     x  ntpatm,keyfce,dlrpot,rvdw,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining van der Waals potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,ltable,lunits,lmols
+      character*1 message(80)
+      character*8 atom1,atom2,keyword
+
+      integer ntpvdw,ntpatm,keyfce,fail,idum,ivdw
+      integer itpvdw,keypot,numpar,katom1,katom2,jtpatm,keyvdw,i
+      integer ntab,idnode,j
+      real(8) dlrpot,rvdw,engunit
+      real(8), allocatable :: parpot(:)
+
+      allocate (parpot(mxpvdw),stat=fail)
+
+      ntpvdw=intstr(record,lenrec,idum)
+
+      ltable=findstring('table',record,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified pair ',
+     x    'potentials',i10)") ntpvdw
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ',3x,
+     x    ' key',30x,'parameters'/,/)")
+        
+      endif      
+
+      if(ntpvdw.gt.mxvdw) call error(idnode,80)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do ivdw=1,mxvdw
+        
+        lstvdw(ivdw)=0
+        ltpvdw(ivdw)=-1
+        
+      enddo
+      
+      do itpvdw=1,ntpvdw
+        
+        do i=1,mxpvdw
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call lowcase(record,lenrec-16)
+        call getword(keyword,record,4,lenrec)
+
+        if(keyword(1:4).eq.'12-6') then
+          keypot=1
+          numpar=2
+        elseif(keyword(1:4).eq.'lj  ') then
+          keypot=2
+          numpar=2
+        elseif(keyword(1:4).eq.'nm  ') then
+          keypot=3
+          numpar=4
+        elseif(keyword(1:4).eq.'buck') then
+          keypot=4
+          numpar=3
+        elseif(keyword(1:4).eq.'bhm ') then
+          keypot=5
+          numpar=5
+        elseif(keyword(1:4).eq.'hbnd') then
+          keypot=6
+          numpar=2
+        elseif(keyword(1:4).eq.'snm ') then
+          keypot=7
+          numpar=5
+        elseif(keyword(1:4).eq.'mors') then
+          keypot=8
+          numpar=3
+        elseif(keyword(1:4).eq.'wca ') then
+          keypot=9
+          numpar=3
+        elseif(keyword(1:4).eq.'gaus') then
+          keypot=10
+          numpar=6
+        elseif(keyword(1:4).eq.'tab ') then
+          keypot=0
+          numpar=0
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,452)
+        endif
+
+        parpot(1)=dblstr(record,lenrec,idum)
+        parpot(2)=dblstr(record,lenrec,idum)
+        parpot(3)=dblstr(record,lenrec,idum)
+        parpot(4)=dblstr(record,lenrec,idum)
+        parpot(5)=dblstr(record,lenrec,idum)
+        parpot(6)=dblstr(record,lenrec,idum)
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(16x,2a8,2x,a4,3x,1p,9e13.5)") 
+     x    atom1,atom2,keyword(1:4),(parpot(j),j=1,numpar)
+        
+        katom1=0
+        katom2=0
+        
+        do jtpatm=1,ntpatm
+
+          if(atom1.eq.unqatm(jtpatm))katom1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katom2=jtpatm
+          
+        enddo
+        
+        if(katom1.eq.0.or.katom2.eq.0) then
+          call  error(idnode,81)
+        endif
+        
+        keyvdw=loc2(katom1,katom2)
+
+c     convert energies to internal unit
+
+        if(keyvdw.gt.mxvdw) call error(idnode,82)
+        
+        parpot(1)=parpot(1)*engunit
+        
+        if(keypot.eq.1) then
+          
+          parpot(2)=parpot(2)*engunit
+          
+        else if(keypot.eq.4) then
+          
+          parpot(3)=parpot(3)*engunit
+          
+        else if(keypot.eq.5) then
+          
+          parpot(4)=parpot(4)*engunit
+          parpot(5)=parpot(5)*engunit
+          
+        else if(keypot.eq.6) then
+          
+          parpot(2)=parpot(2)*engunit
+          
+        else if(keypot.eq.10) then
+          
+          parpot(3)=parpot(3)*engunit
+          parpot(5)=parpot(5)*engunit
+          
+        endif
+
+        ltable=(ltable.or.(keypot.eq.0))
+
+        if(lstvdw(keyvdw).ne.0) call error(idnode,15)
+        lstvdw(keyvdw)=itpvdw
+        ltpvdw(itpvdw)=keypot
+        
+        do i=1,mxpvdw
+          
+          prmvdw(itpvdw,i)=parpot(i)
+          
+        enddo
+        
+      enddo
+
+c     generate nonbonded force arrays
+
+      if((ntpvdw.gt.0.and.mod(keyfce,2).eq.1).or.(keyfce.eq.2))
+     x  then
+        
+        call forgen(ltable,idnode,ntpvdw,dlrpot,rvdw)
+        
+        if(ltable)then
+          
+          call fortab
+     x      (idnode,ntpvdw,ntpatm,dlrpot,rvdw,engunit)
+          
+        endif
+        
+      endif
+
+c     check for unspecified atom-atom potentials
+      
+      ntab=(ntpatm*(ntpatm+1))/2
+      
+      if(ntpvdw.lt.ntab) then
+        
+        call warning(idnode,110,0.d0,0.d0,0.d0)
+
+        if(mxvdw.le.ntpvdw) call error(idnode,82)
+
+        do i=1,ntab
+          
+          if(lstvdw(i).eq.0)then
+            
+            lstvdw(i)=ntpvdw+1
+            
+          endif
+          
+        enddo
+
+c     define zero potential for undefined interactions
+        
+        do i=1,mxgrid
+          
+          ggg(i,ntpvdw+1)=0.d0
+          vvv(i,ntpvdw+1)=0.d0
+          
+        enddo
+        
+      endif
+
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_van_der_waals
+
+      subroutine forgen(ltable,idnode,ntpvdw,dlrpot,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating potential energy and 
+c     force arrays for van der waals forces only
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith may 1992.
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical ltable
+      integer i,ivdw,ntpvdw,idnode
+      real(8) dlrpot,rcut,rrr,ann,amm,gam,bet,eps,rr0,aaa,bbb
+      real(8) ccc,ddd,eee,sig,rho,rrc,aa1,aa2,aa3,ee1,ee2,ee3
+      real(8) rsq,ex1,ex2,ex3
+
+c     define grid resolution for potential arrays
+      
+      dlrpot=rcut/dble(mxgrid-4)
+
+c     construct arrays for all types of short ranged  potential
+      
+      do ivdw=1,ntpvdw
+        
+        if(ltpvdw(ivdw).eq.1)then
+          
+c       12 - 6 potential
+      
+          aaa=prmvdw(ivdw,1)
+          bbb=prmvdw(ivdw,2)
+          
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=(aaa/rrr**6-bbb)/rrr**6
+            ggg(i,ivdw)=6.d0*(2.d0*aaa/rrr**6-bbb)/rrr**6
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.2)then
+          
+c       lennard-jones potential
+      
+          eps=prmvdw(ivdw,1)
+          sig=prmvdw(ivdw,2)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=4.d0*eps*(sig/rrr)**6*((sig/rrr)**6-1.d0)
+            ggg(i,ivdw)=24.d0*eps*(sig/rrr)**6*(2.d0*(sig/rrr)**6-1.d0)
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.3)then
+
+c       n - m potential
+      
+          eps=prmvdw(ivdw,1)
+          ann=max(prmvdw(ivdw,2),prmvdw(ivdw,3))
+          amm=min(prmvdw(ivdw,2),prmvdw(ivdw,3))
+          rr0=prmvdw(ivdw,4)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=eps/(ann-amm)*(amm*(rr0/rrr)**ann-
+     x        ann*(rr0/rrr)**amm)
+            ggg(i,ivdw)=eps*amm*ann/(ann-amm)*((rr0/rrr)**ann-
+     x        (rr0/rrr)**amm)
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.4)then
+          
+c       buckingham exp - 6 potential
+      
+          aaa=prmvdw(ivdw,1)
+          rho=prmvdw(ivdw,2)
+          ccc=prmvdw(ivdw,3)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=aaa*exp(-rrr/rho)-ccc/rrr**6
+            ggg(i,ivdw)=rrr*aaa*exp(-rrr/rho)/rho-6.d0*ccc/rrr**6
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.5)then
+          
+c       born-huggins-meyer exp - 6 - 8 potential
+      
+          aaa=prmvdw(ivdw,1)
+          bbb=prmvdw(ivdw,2)
+          ccc=prmvdw(ivdw,3)
+          ddd=prmvdw(ivdw,4)
+          eee=prmvdw(ivdw,5)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=aaa*exp(bbb*(ccc-rrr))-ddd/rrr**6-eee/rrr**8
+            ggg(i,ivdw)=rrr*aaa*bbb*exp(bbb*(ccc-rrr))-6.d0*ddd/rrr**6
+     x        -8.d0*eee/rrr**8
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.6) then
+          
+c       Hydrogen-bond 12 - 10 potential
+      
+          aaa=prmvdw(ivdw,1)
+          bbb=prmvdw(ivdw,2)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=aaa/rrr**12-bbb/rrr**10
+            ggg(i,ivdw)=12.0d0*aaa/rrr**12-10.d0*bbb/rrr**10
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.7) then
+          
+c       shifted and force corrected n - m potential (w. smith)
+      
+          eps=prmvdw(ivdw,1)
+          ann=prmvdw(ivdw,2)
+          amm=prmvdw(ivdw,3)
+          rr0=prmvdw(ivdw,4)
+          rrc=prmvdw(ivdw,5)
+          if(rrc.lt.1.d-6)rrc=rcut
+ 
+          if(ann.le.amm) call error(idnode,470)
+
+          gam=rrc/rr0
+          if(gam.lt.1.d0) call error(idnode,468)
+          bet=gam*((gam**(amm+1.d0)-1.d0)/(gam**(ann+1.d0)-1.d0))
+     x      **(1.d0/(ann-amm))
+          eps=-eps*(ann-amm)/(amm*(bet**ann)*(1.d0+(ann/gam-ann-1.d0)
+     x      /gam**ann)-ann*(bet**amm)*(1.d0+(amm/gam-amm-1.d0)
+     x      /gam**amm))
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            if(rrr.gt.rrc)then
+
+              vvv(i,ivdw)=0.d0
+              ggg(i,ivdw)=0.d0
+
+            else
+
+              vvv(i,ivdw)=eps/(ann-amm)*(amm*(bet**ann)*((rr0/rrr)**ann-
+     x          (1.d0/gam)**ann)-ann*(bet**amm)*((rr0/rrr)**amm-
+     x          (1.d0/gam)**amm)+ann*amm*((rrr/(gam*rr0)-1.d0)*
+     x          ((bet/gam)**ann-(bet/gam)**amm)))
+              ggg(i,ivdw)=eps*amm*ann/(ann-amm)*((bet**ann)*
+     x          (rr0/rrr)**ann-(bet**amm)*(rr0/rrr)**amm-rrr/
+     x          (gam*rr0)*((bet/gam)**ann-(bet/gam)**amm))
+
+            endif
+
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.8) then
+          
+c       morse potential
+          
+          eps=prmvdw(ivdw,1)
+          rr0=prmvdw(ivdw,2)
+          sig=prmvdw(ivdw,3)
+          
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=eps*((1.d0-exp(-sig*(rrr-rr0)))**2-1.d0)
+            ggg(i,ivdw)=-2.d0*rrr*eps*sig*(1.d0-exp(-sig*(rrr-rr0)))*
+     x        exp(-sig*(rrr-rr0))
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.9) then
+          
+c       weeks-chandler-anderson potential
+          
+          eps=prmvdw(ivdw,1)
+          sig=prmvdw(ivdw,2)
+          rr0=prmvdw(ivdw,3)
+          ddd=sig*2.d0**(1.d0/6.d0)
+          
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot-rr0
+            if(rrr.gt.ddd)then
+              
+              vvv(i,ivdw)=0.d0
+              ggg(i,ivdw)=0.d0
+
+            else if(rrr.gt.0.d0)then
+              
+              vvv(i,ivdw)=4.d0*eps*(sig/rrr)**6*
+     x          ((sig/rrr)**6-1.d0)+eps
+              ggg(i,ivdw)=24.d0*eps*(1.d0+rr0/rrr)*(sig/rrr)**6*
+     x          (2.d0*(sig/rrr)**6-1.d0)
+            
+            endif
+              
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.10)then
+          
+c       gaussian potential
+      
+          aa1=prmvdw(ivdw,1)
+          ee1=prmvdw(ivdw,2)
+          aa2=prmvdw(ivdw,3)
+          ee2=prmvdw(ivdw,4)
+          aa3=prmvdw(ivdw,5)
+          ee3=prmvdw(ivdw,6)
+
+          do i=1,mxgrid
+            
+            rsq=(dble(i)*dlrpot)**2
+            ex1=aa1*exp(-rsq*ee1)
+            ex2=aa2*exp(-rsq*ee2)
+            ex3=aa3*exp(-rsq*ee3)
+            vvv(i,ivdw)=ex1+ex2+ex3
+            ggg(i,ivdw)=2.d0*rsq*(ee1*ex1+ee2*ex2+ee3*ex3)
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).lt.100) then
+          
+          if(.not.ltable)call error(idnode,150)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine forgen
+
+      subroutine fortab
+     x  (idnode,ntpvdw,ntpatm,dlrpot,rcut,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading potential energy and 
+c     force arrays for van der waals forces only
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith march 1994
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical safe
+      character*8 atom1,atom2
+      integer idnode,ntpvdw,ntpatm,idum,ngrid
+      integer ivdw,katom1,katom2,jtpatm,l,i,j,k,keyvdw
+      real(8) dlrpot,rcut,engunit,delpot,cutpot,rdr,rrr,ppp
+      real(8) vk0,vk1,vk2,t1,t2
+
+      if(idnode.eq.0)open (ntable,file='TABLE')
+
+c     skip header record
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_table_read(idnode,ntable)
+
+c     read mesh resolution
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_table_read(idnode,ntable)
+      delpot=dblstr(record,lenrec,idum)
+      cutpot=dblstr(record,lenrec,idum)
+      ngrid=intstr(record,lenrec,idum)
+
+      dlrpot=rcut/dble(mxgrid-4)
+
+      if (abs(delpot-dlrpot) <= 1.0d-8) delpot=dlrpot
+      if ((delpot>dlrpot) .or. (ngrid-4 /= nint(cutpot/delpot))) then
+        
+         if (idnode == 0) write(nrite,"(                 
+     x    'expected radial increment : ',1p,e15.7,/,     
+     x    'TABLE    radial increment : ',1p,e15.7,/,/,   
+     x    'expected number of grid points : ',0p,i10,/,  
+     x    'grid points in TABLE           : ',i10)")     
+     x    dlrpot, delpot, mxgrid, ngrid
+         
+         call error(idnode,22)
+         
+      endif
+
+      if(cutpot.lt.rcut) call error(idnode,504)
+      if(abs(1.d0-(delpot/dlrpot)).gt.1.0d-8) then
+        if(idnode.eq.0) write(nrite,
+     x    "(/,' TABLE arrays resized for mxgrid=',i10)") mxgrid
+      endif
+
+c     read potential arrays for all pairs
+      
+      do ivdw=1,ntpvdw
+
+c     read potential arrays if potential not already defined
+        
+        if(ltpvdw(ivdw).eq.0)then
+          
+c     read pair potential labels and long range corrections
+          
+          call getrec(safe,idnode,ntable)
+          if(.not.safe)call abort_table_read(idnode,ntable)
+
+          call getword(atom1,record,8,lenrec)
+          call getword(atom2,record,8,lenrec)
+          prmvdw(ivdw,1)=dblstr(record,lenrec,idum)
+          prmvdw(ivdw,2)=dblstr(record,lenrec,idum)
+          
+          katom1=0
+          katom2=0
+          
+          do jtpatm=1,ntpatm
+            
+            if(atom1.eq.unqatm(jtpatm))katom1=jtpatm
+            if(atom2.eq.unqatm(jtpatm))katom2=jtpatm
+            
+          enddo
+          
+          if(katom1.eq.0.or.katom2.eq.0)then
+            if(idnode.eq.0) 
+     x        write(nrite,'(a)') '****',atom1,'***',atom2,'****'
+            call  error(idnode,81)
+          endif
+          
+          keyvdw=loc2(katom1,katom2)
+          
+          if(lstvdw(keyvdw).ne.ivdw) call error(idnode,23)
+          
+c     read potential arrays
+          
+          if(mxbuff.lt.ngrid)  then
+              
+            if(idnode.eq.0)
+     x         write(nrite,*) 'mxbuff must be >=',ngrid,' in fortab'
+            call error(idnode,48)
+              
+          endif
+
+c     read in potential arrays
+
+          do i=1,(ngrid+3)/4
+            
+             l=min(4,ngrid-(i-1)*4)
+             if (idnode == 0) then
+                read(unit=ntable, fmt=*, end=100)
+     x              (buffer((i-1)*4+j),j=1,l)
+             else
+                buffer((i-1)*4+1:(i-1)*4+l)=0.0d0
+             endif
+             
+          enddo
+          call gdsum(buffer(1:ngrid),ngrid,buffer(ngrid+1:2*ngrid))
+
+c     reconstruct arrays using 3pt interpolation
+
+          rdr=1.d0/delpot
+          vvv(1,ivdw)=1.d0
+          ggg(1,ivdw)=0.d0
+          do i=2,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            l=int(rrr*rdr)
+            ppp=rrr*rdr-dble(l)
+            vk0=buffer(l)
+            vk1=buffer(l+1)
+            vk2=buffer(l+2)
+            
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            vvv(i,ivdw)=t1+(t2-t1)*ppp*0.5d0
+
+          enddo
+
+c     read in force arrays
+
+          do i=1,(ngrid+3)/4
+            
+             l=min(4,ngrid-(i-1)*4)
+             if (idnode == 0) then
+                read(unit=ntable, fmt=*, end=100)
+     x              (buffer((i-1)*4+j),j=1,l)
+             else
+                buffer((i-1)*4+1:(i-1)*4+l)=0.0d0
+             endif
+             
+          enddo
+          call gdsum(buffer(1:ngrid),ngrid,buffer(ngrid+1:2*ngrid))
+
+c     reconstruct ggg arrays using 3pt interpolation
+
+          do i=2,mxgrid
+
+            rrr=dble(i)*dlrpot
+            l=int(rrr*rdr)
+            ppp=rrr*rdr-dble(l)
+            vk0=buffer(l)
+            vk1=buffer(l+1)
+            vk2=buffer(l+2)
+            
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            
+            ggg(i,ivdw)=t1+(t2-t1)*ppp*0.5d0
+
+          enddo
+
+        endif
+        
+      enddo
+
+c     convert to internal units
+      
+      do k=1,ntpvdw
+        
+        if(ltpvdw(k).eq.0)then
+
+          do i=1,mxgrid
+            
+            vvv(i,k)=vvv(i,k)*engunit
+            ggg(i,k)=ggg(i,k)*engunit
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)close (ntable)
+      
+      if(idnode.eq.0)write(nrite,'(/,/,1x,a)')
+     x  'potential tables read from TABLE file'
+      
+      return
+      
+c     end of file error exit
+      
+  100 call abort_table_read(idnode,ntable)
+
+      end subroutine fortab
+
+      subroutine abort_table_read(idnode,ntable)
+
+c***********************************************************************
+c     
+c     dl_poly error exit subroutine for reading TABLE file
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith   sept 2005
+c     
+c***********************************************************************
+
+      implicit none
+      integer idnode,ntable
+
+      if(idnode.eq.0)close (ntable)
+      
+      call error(idnode,24)
+      
+      end subroutine abort_table_read
+
+      subroutine srfrce
+     x  (lsolva,lfree,lghost,iatm,ik,engsrp,virsrp,rcut,dlrpot)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating short range force and
+c     potential energy terms using verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     
+c     version 3
+c     author    - t. forester    june  1993
+c     stress tensor added t.forester may 1994
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,k,l,kkk
+      real(8) engsrp,virsrp,rcut,dlrpot
+      real(8) ab,rrr,rsq,ppp,t1,t2,vk0,vk1,vk2,gk0,gk1,gk2,gamma
+      real(8) fi,rcsq,rdr,ai,aj,fx,fy,fz,omega
+      real(8) strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     set cutoff condition for pair forces
+
+      rcsq=rcut**2
+
+c     interpolation spacing
+      
+      rdr=1.d0/dlrpot
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engsrp=0.d0
+      virsrp=0.d0
+
+c     store forces for iatm 
+      
+      ai=dble(ltype(iatm))
+      fi(1)=fxx(iatm)
+      fi(2)=fyy(iatm)
+      fi(3)=fzz(iatm)
+
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+        if(lmetadyn)jdrive=driven(ltype(jatm))
+        
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        aj=dble(ltype(jatm))
+        
+        if(ai.gt.aj) then
+          ab=ai*(ai-1.d0)*0.5d0+aj+0.5d0
+        else
+          ab=aj*(aj-1.d0)*0.5d0+ai+0.5d0
+        endif
+        
+        k=lstvdw(int(ab))
+        
+        if((ltpvdw(k).lt.100).and.(abs(vvv(1,k)).gt.1.d-10))then
+          
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+          
+          if(rcsq.gt.rsq)then
+            
+            rrr=sqrt(rsq)               
+            l=int(rrr*rdr)
+            ppp=rrr*rdr-dble(l)
+            
+            if(l.eq.0)then
+              
+              omega=vvv(1,k)
+              gamma=ggg(1,k)
+              
+            else
+              
+c     calculate interaction energy using 3-point interpolation
+              
+              vk0=vvv(l,k)
+              vk1=vvv(l+1,k)
+              vk2=vvv(l+2,k)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              omega=t1+(t2-t1)*ppp*0.5d0
+              
+c     calculate forces using 3-point interpolation
+              
+              gk0=ggg(l,k)
+              gk1=ggg(l+1,k)
+              gk2=ggg(l+2,k)
+              t1=gk0+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+              gamma=(t1+(t2-t1)*ppp*0.5d0)/rsq
+              
+            endif
+            
+c     set selection control
+            
+            lselect=.true.
+            
+c     set double index
+            
+            if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+            
+            if(lghost)then
+              
+c     selected excitation option
+              
+              if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                
+c     reset selection control
+                
+                lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                
+                if(lsolva)vdw_exc(kkk)=vdw_exc(kkk)+omega
+                
+              endif
+              
+            elseif(lfree)then
+              
+c     selected free energy option
+              
+              if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                
+c     set hamiltonian mixing parameter
+                
+                vdw_fre=vdw_fre-omega
+                vdw_vir=vdw_vir+gamma*rsq
+                omega=lambda1*omega
+                gamma=lambda1*gamma
+                
+              elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                
+c     set hamiltonian mixing parameter
+                
+                vdw_fre=vdw_fre+omega
+                vdw_vir=vdw_vir-gamma*rsq
+                omega=lambda2*omega
+                gamma=lambda2*gamma
+                
+              endif
+              
+            endif
+            
+            if(lselect)then
+              
+c     calculate potential and virial
+              
+              engsrp=engsrp+omega
+              virsrp=virsrp-gamma*rsq
+              
+              if(lsolva)vdw_sol(kkk)=vdw_sol(kkk)+omega
+              
+c     calculate forces
+              
+              fx=gamma*xdf(m)
+              fy=gamma*ydf(m)
+              fz=gamma*zdf(m)
+              
+              fi(1)=fi(1)+fx
+              fi(2)=fi(2)+fy
+              fi(3)=fi(3)+fz
+              
+              fxx(jatm)=fxx(jatm)-fx
+              fyy(jatm)=fyy(jatm)-fy
+              fzz(jatm)=fzz(jatm)-fz
+              
+c     calculate stress tensor
+              
+              strs(1)=strs(1)+xdf(m)*fx
+              strs(2)=strs(2)+xdf(m)*fy
+              strs(3)=strs(3)+xdf(m)*fz
+              strs(4)=strs(4)+ydf(m)*fy
+              strs(5)=strs(5)+ydf(m)*fz
+              strs(6)=strs(6)+zdf(m)*fz
+              
+            endif
+            
+            if(lmetadyn.and.(idrive.or.jdrive))then
+              
+              eng_loc=eng_loc+omega
+              vir_loc=vir_loc-gamma*rsq
+              
+              fxx_loc(iatm)=fxx_loc(iatm)+fx
+              fyy_loc(iatm)=fyy_loc(iatm)+fy
+              fzz_loc(iatm)=fzz_loc(iatm)+fz
+              
+              fxx_loc(jatm)=fxx_loc(jatm)-fx
+              fyy_loc(jatm)=fyy_loc(jatm)-fy
+              fzz_loc(jatm)=fzz_loc(jatm)-fz
+              
+              strs_loc(1)=strs_loc(1)+xdf(m)*fx
+              strs_loc(2)=strs_loc(2)+xdf(m)*fy
+              strs_loc(3)=strs_loc(3)+xdf(m)*fz
+              strs_loc(4)=strs_loc(4)+ydf(m)*fy
+              strs_loc(5)=strs_loc(5)+ydf(m)*fz
+              strs_loc(6)=strs_loc(6)+zdf(m)*fz
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     load temps back to fxx(iatm) etc
+      
+      fxx(iatm)=fi(1)
+      fyy(iatm)=fi(2)
+      fzz(iatm)=fi(3)
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+
+      return
+      end subroutine srfrce
+      
+      subroutine lrcorrect
+     x  (lsolva,lfree,lghost,idnode,imcon,keyfce,natms,
+     x  ntpatm,ntpvdw,elrc,engunit,virlrc,rcut,volm)
+      
+c*************************************************************************
+c     
+c     DL_POLY subroutine to evaluate long-range corrections to
+c     pressure and energy in a periodic system.
+c     
+c     copyright daresbury laboratory 1993
+c     author    - t. forester may 1993
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***************************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=10
+      logical lsolva,lfree,lghost
+      integer idnode,imcon,keyfce,natms,ntpatm,i,ka,ntpvdw
+      integer ivdw,j,k,it,jt,kt,fail
+      real(8) natyp,nbtyp,nctyp,ndtyp,nafrz,nbfrz,ncfrz,ndfrz
+      real(8) elrc,engunit,virlrc,rcut,volm,twopi,eadd,padd
+      real(8) denprd,aaa,bbb,ccc,ddd,eee,eps,sig,rr0,ann,amm
+      real(8) denprd1,denprd2,denprd3,denprdf
+      integer, allocatable :: numtyp_sol0(:,:),numfrz_sol0(:,:)
+      integer, allocatable :: numtyp_sol1(:,:),numfrz_sol1(:,:)
+      integer, allocatable :: numtyp_sol2(:,:),numfrz_sol2(:,:)
+      integer, allocatable :: numtyp_fre(:,:),numfrz_fre(:,:)
+      real(8), allocatable :: elrc_sol0(:),elrc_exc0(:)
+      
+      dimension fail(nnn)
+      
+      twopi=2.0d0*pi
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      if(lfree.or.lghost)then
+        
+        allocate (numtyp_fre(mxatyp,0:2),stat=fail(1))
+        allocate (numfrz_fre(mxatyp,0:2),stat=fail(2))
+        allocate (elrc_exc0(mxtmls_exc2),stat=fail(3))
+        
+      endif
+      
+      if(lsolva)then
+        
+        allocate (elrc_sol0(mxtmls_sol2),stat=fail(4))
+        allocate (numtyp_sol0(mxatyp,mxtmls),stat=fail(5))
+        allocate (numfrz_sol0(mxatyp,mxtmls),stat=fail(6))
+        
+        if(lghost)then
+          
+          allocate (numtyp_sol1(mxatyp,mxtmls),stat=fail(7))
+          allocate (numfrz_sol1(mxatyp,mxtmls),stat=fail(8))
+          allocate (numtyp_sol2(mxatyp,mxtmls),stat=fail(9))
+          allocate (numfrz_sol2(mxatyp,mxtmls),stat=fail(10))
+          
+        endif
+        
+      endif
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1015)
+      enddo
+      
+c     initalise counter arrays
+      
+      do i=1,ntpatm
+        
+        numtyp(i)=0
+        numfrz(i)=0
+        
+      enddo
+      
+      if(lfree.or.lghost)then
+        
+        numtyp_fre(:,:)=0
+        numfrz_fre(:,:)=0
+        
+      endif
+      
+      if(lsolva)then
+        
+        numtyp_sol0(:,:)=0
+        numfrz_sol0(:,:)=0
+        
+        if(lghost)then
+          
+          numtyp_sol1(:,:)=0
+          numfrz_sol1(:,:)=0
+          numtyp_sol2(:,:)=0
+          numfrz_sol2(:,:)=0
+          
+        endif
+        
+      endif
+      
+c     evaluate number density in system
+      
+      do i=1,natms
+        
+        ka=ltype(i)
+        numtyp(ka)=numtyp(ka)+1
+        if(lstfrz(i).ne.0)numfrz(ka)=numfrz(ka)+1
+        
+      enddo
+      
+      if(lfree.or.lghost)then
+         
+        do i=1,natms
+          
+          ka=ltype(i)
+          numtyp_fre(ka,atm_fre(i))=numtyp_fre(ka,atm_fre(i))+1
+          if(lstfrz(i).ne.0)
+     x      numfrz_fre(ka,atm_fre(i))=numfrz_fre(ka,atm_fre(i))+1          
+          
+        enddo
+        
+      endif
+      
+      if(lsolva)then
+        
+        if(lghost)then
+          
+          do i=1,natms
+            
+            ka=ltype(i)
+            
+            if(atm_fre(i).eq.0)then
+              
+              numtyp_sol0(ka,atmolt(i))=numtyp_sol0(ka,atmolt(i))+1
+              if(lstfrz(i).ne.0)
+     x          numfrz_sol0(ka,atmolt(i))=numfrz_sol0(ka,atmolt(i))+1
+              
+            elseif(atm_fre(i).eq.1)then
+              
+              numtyp_sol1(ka,atmolt(i))=numtyp_sol1(ka,atmolt(i))+1
+              if(lstfrz(i).ne.0)
+     x          numfrz_sol1(ka,atmolt(i))=numfrz_sol1(ka,atmolt(i))+1
+              
+            elseif(atm_fre(i).eq.2)then
+              
+              numtyp_sol2(ka,atmolt(i))=numtyp_sol2(ka,atmolt(i))+1
+              if(lstfrz(i).ne.0)
+     x          numfrz_sol2(ka,atmolt(i))=numfrz_sol2(ka,atmolt(i))+1
+              
+            endif
+            
+          enddo
+          
+        else
+          
+          do i=1,natms
+            
+            ka=ltype(i)
+            numtyp_sol0(ka,atmolt(i))=numtyp_sol0(ka,atmolt(i))+1
+            if(lstfrz(i).ne.0)
+     x        numfrz_sol0(ka,atmolt(i))=numfrz_sol0(ka,atmolt(i))+1
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     number densities
+      
+      do i=1,ntpatm
+        dens(i)=dble(numtyp(i))/volm
+      enddo
+      
+c     long range corrections to energy and pressure
+      
+      elrc=0.d0
+      elrc2=0.d0
+      virlrc=0.d0
+      virlrc2=0.d0
+      denprdf=0.d0
+      volm_sav=0.d0
+      elrc_fre=0.d0
+      vlrc_fre=0.d0
+      
+      if(imcon.ne.0.and.imcon.ne.6.and.ntpvdw.gt.0) then 
+         
+        if(mod(keyfce,2).eq.1) then
+          
+          ivdw=0
+          
+          do i=1,ntpatm
+            
+            do j=1,i
+               
+              eadd=0.d0
+              padd=0.d0
+              
+              ivdw=ivdw+1
+              k=lstvdw(ivdw)
+              
+              if(ltpvdw(k).eq.0) then
+                
+c     tabulated potential
+                
+                eadd=prmvdw(k,1)
+                padd=-prmvdw(k,2)
+                
+              else if(ltpvdw(k).eq.1) then
+                
+c     12-6 potential
+                
+                aaa=prmvdw(k,1)
+                bbb=prmvdw(k,2)
+                
+                eadd=aaa/(9.d0*rcut**9)-bbb/(3.d0*rcut**3)
+                padd=12.d0*aaa/(9.d0*rcut**9)-6.d0*bbb/(3.d0*rcut**3)
+                
+              else if(ltpvdw(k).eq.2) then
+                
+c     Lennard Jones potential
+      
+                eps=prmvdw(k,1)
+                sig=prmvdw(k,2)
+                
+                eadd=4.d0*eps*(sig**12/(9.d0*rcut**9)-
+     x            sig**6/(3.d0*rcut**3))
+                padd=4.d0*eps*(12.d0*sig**12/(9.d0*rcut**9)-
+     x            2.d0*sig**6/(rcut**3))
+                
+              else if(ltpvdw(k).eq.3) then
+                
+c     n - m potential
+                
+                eps=prmvdw(k,1)
+                ann=prmvdw(k,2)
+                amm=prmvdw(k,3)
+                rr0=prmvdw(k,4)
+                
+                eadd=eps/(ann-amm)*(amm*rr0**ann/((ann-3.d0)*
+     x            rcut**(ann-3.d0))-ann*rr0**amm/((amm-3.0d0)*
+     x            rcut**(amm-3.d0)))
+                padd=eps/(ann-amm)*ann*amm*(rr0**ann/((ann-3.d0)*
+     x            rcut**(ann-3.d0))-rr0**amm/((amm-3.0d0)*
+     x            rcut**(amm-3.d0)))
+                
+              else if(ltpvdw(k).eq.4) then
+                
+c     buckingham exp - 6 potential
+                
+                ccc=prmvdw(k,3)
+                
+                eadd=-ccc/(3.d0*rcut**3)
+                padd=-2.d0*ccc/(rcut**3)
+                
+              else if(ltpvdw(k).eq.5) then
+                
+c     born huggins meyer exp -6 - 8  potential
+                
+                ddd=prmvdw(k,4)
+                eee=prmvdw(k,5)
+                
+                eadd=-ddd/(3.d0*rcut**3)-eee/(5.d0*rcut**5)
+                padd=-2.d0*ddd/(rcut**3)-8.d0*eee/(5.d0*rcut**5)
+                
+              else if(ltpvdw(k).eq.6) then
+                
+c     hydrogen bond  12 - 10 potential
+                
+                aaa=prmvdw(k,1)
+                bbb=prmvdw(k,2)
+                
+                eadd=aaa/(9.d0*rcut**9)-bbb/(7.d0*rcut**7)
+                padd=12.d0*aaa/(9.d0*rcut**9)-1.d1*bbb/(7.d0*rcut**7)
+                
+              endif
+              
+              if(i.ne.j) then
+                
+                eadd=eadd*2.d0
+                padd=padd*2.d0
+                
+              endif
+              
+              if(.not.(lfree.or.lghost))then
+                
+                denprd=twopi*(dble(numtyp(i))*dble(numtyp(j))-
+     x            dble(numfrz(i))*dble(numfrz(j)))/volm**2
+                
+              else
+                 
+                nafrz=dble(numfrz_fre(i,0)+numfrz_fre(i,1))
+                natyp=dble(numtyp_fre(i,0)+numtyp_fre(i,1))
+                nbfrz=dble(numfrz_fre(j,0)+numfrz_fre(j,1))
+                nbtyp=dble(numtyp_fre(j,0)+numtyp_fre(j,1))
+                ncfrz=dble(numfrz_fre(i,0)+numfrz_fre(i,2))
+                nctyp=dble(numtyp_fre(i,0)+numtyp_fre(i,2))
+                ndfrz=dble(numfrz_fre(j,0)+numfrz_fre(j,2))
+                ndtyp=dble(numtyp_fre(j,0)+numtyp_fre(j,2))
+                
+                if(lghost)then
+                  
+                  denprd=twopi*(natyp*nbtyp-nafrz*nbfrz)/volm**2
+                  denprd3=twopi*(nctyp*ndtyp-ncfrz*ndfrz)/volm**2
+                  
+                elseif(lfree)then
+                  
+                  denprd1=twopi*(natyp*nbtyp-nafrz*nbfrz)/volm**2
+                  denprd2=twopi*(nctyp*ndtyp-ncfrz*ndfrz)/volm**2
+                  denprd=lambda1*denprd1+lambda2*denprd2
+                  denprd3=lambda2*denprd1+lambda1*denprd2
+                  denprdf=denprd2-denprd1
+                  
+                endif
+                
+              endif
+              
+              elrc=elrc+volm*denprd*eadd
+              virlrc=virlrc-denprd*padd*volm
+              
+              if(lfree.or.lghost)then
+                
+                elrc2=elrc2+volm*denprd3*eadd
+                virlrc2=virlrc2-denprd3*padd*volm
+                if(lfree)then
+                  elrc_fre=elrc_fre+volm*denprdf*eadd
+                  vlrc_fre=vlrc_fre-denprdf*padd*volm
+                endif
+                
+              endif
+              
+              if(lsolva)then
+                
+                elrc_sol0(:)=0.d0
+                if(lghost)elrc_exc0(:)=0.d0
+                
+                do it=1,mxtmls
+                  
+                  do jt=1,mxtmls
+                    
+                    kt=loc2(it,jt)
+                    
+                    if(lghost)then
+                       
+                      natyp=dble(numtyp_sol0(i,it)+numtyp_sol1(i,it))
+                      nbtyp=dble(numtyp_sol0(j,jt)+numtyp_sol1(j,jt))
+                      nafrz=dble(numfrz_sol0(i,it)+numfrz_sol1(i,it))
+                      nbfrz=dble(numfrz_sol0(j,jt)+numfrz_sol1(j,jt))
+                      
+                      elrc_sol0(kt)=elrc_sol0(kt)+twopi*(natyp*
+     x                nbtyp-nafrz*nbfrz)/volm**2
+                      
+                      nctyp=dble(numtyp_sol0(i,it)+numtyp_sol2(i,it))
+                      ndtyp=dble(numtyp_sol0(j,jt)+numtyp_sol2(j,jt))
+                      ncfrz=dble(numfrz_sol0(i,it)+numfrz_sol2(i,it))
+                      ndfrz=dble(numfrz_sol0(j,jt)+numfrz_sol2(j,jt))
+                      
+                      elrc_exc0(kt)=elrc_exc0(kt)+twopi*(nctyp*
+     x                ndtyp-ncfrz*ndfrz)/volm**2
+                      
+                    else
+                      
+                      natyp=dble(numtyp_sol0(i,it))
+                      nbtyp=dble(numtyp_sol0(j,jt))
+                      nafrz=dble(numfrz_sol0(i,it))
+                      nbfrz=dble(numfrz_sol0(j,jt))
+                      
+                      elrc_sol0(kt)=elrc_sol0(kt)+twopi*(natyp*
+     x                nbtyp-nafrz*nbfrz)/volm**2             
+                      
+                    endif
+                    
+                  enddo
+                  
+                enddo
+                
+                if(lghost)then
+                   
+                  elrc_sol(:)=elrc_sol(:)+volm*eadd*elrc_sol0(:)
+                  elrc_exc(:)=elrc_exc(:)+volm*eadd*elrc_exc0(:)
+                  
+                else
+                  
+                  elrc_sol(:)=elrc_sol(:)+volm*eadd*elrc_sol0(:)
+                  
+                endif
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+          if(lfree.or.lghost)then
+             
+            elrc_sav=elrc
+            elrc2_sav=elrc2
+            virlrc_sav=virlrc
+            virlrc2_sav=virlrc2
+            elrc_fre_sav=elrc_fre
+            vlrc_fre_sav=vlrc_fre
+            
+          endif
+          
+          volm_sav=volm
+          
+          if(lghost)then
+             
+            elrc_sol_sav(:)=elrc_sol(:)
+            elrc_exc_sav(:)=elrc_exc(:)
+            
+          elseif(lsolva)then
+            
+            elrc_sol_sav(:)=elrc_sol(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,/,'long range correction for: vdw energy  ',e15.6,/,
+     x    25x,': vdw pressure',e15.6)")elrc/engunit,
+     x    prsunt*virlrc/(-3.d0*volm)
+      
+        if(lghost)
+     x    write(nrite,
+     x    "(/,/,'long range correction for: vdw energy  ',e15.6,/,
+     x    25x,': vdw pressure',e15.6)")elrc2/engunit,
+     x    prsunt*virlrc2/(-3.d0*volm)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      if(lfree.or.lghost)
+     x  deallocate (elrc_exc0,numtyp_fre,numfrz_fre,stat=fail(1))
+      
+      if(lsolva)then
+        
+        deallocate (elrc_sol0,numtyp_sol0,numfrz_sol0,stat=fail(2))
+        
+        if(lghost)then
+          
+          deallocate (numtyp_sol1,numfrz_sol1,stat=fail(3))
+          deallocate (numtyp_sol2,numfrz_sol2,stat=fail(4))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine lrcorrect
+
+
+      subroutine srfrceneu
+     x  (lsolva,lfree,lghost,ik,engsrp,virsrp,dlrpot,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating short range force and
+c     potential energy terms using verlet neighbour list
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     
+c     neutral groups
+c     author    - t. forester    march  1994
+c     
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer ik,m,iatm,jatm,l,k,kkk
+      real(8) engsrp,virsrp,dlrpot,rcut,rcsq,fx,fy,fz,omega,omega_exc
+      real(8) rrr,ppp,vk0,vk1,vk2,t1,t2,gk0,gk1,gk2,rdlpot,gamma
+      real(8) ai,aj,ak,rsq,strs(6),strs_loc(6)
+      
+      lskip=(lfree.or.lghost)
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     reciprocal of interpolation spacing
+
+      rdlpot=1.d0/dlrpot
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engsrp=0.d0
+      virsrp=0.d0
+
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+
+c     atomic and potential function indices
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+          
+        endif
+        
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        aj=ltype(jatm)
+        ai=ltype(iatm)
+
+        if(ai.gt.aj) then
+          ak=(ai*(ai-1.d0)*0.5d0+aj+0.5d0)
+        else
+          ak=(aj*(aj-1.d0)*0.5d0+ai+0.5d0)
+        endif
+        k=lstvdw(int(ak))
+
+        if(abs(vvv(1,k)).gt.1.d-10)then
+
+          rsq=rsqdf(m)
+
+          if(rsq.lt.rcsq) then
+              
+            rrr=sqrt(rsq)
+
+c     determine interpolation panel for force arrays
+            
+            l=int(rrr*rdlpot)
+            ppp=rrr*rdlpot-dble(l)
+
+c     calculate interaction energy using 3-point interpolation
+            
+            vk0=vvv(l,k)
+            vk1=vvv(l+1,k)
+            vk2=vvv(l+2,k)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            omega=t1+(t2-t1)*ppp*0.5d0
+
+c     calculate forces using 3-point interpolation
+            
+            gk0=ggg(l,k)
+            gk1=ggg(l+1,k)
+            gk2=ggg(l+2,k)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            gamma=(t1+(t2-t1)*ppp*0.5d0)/rsq
+
+c     set selection control
+              
+            lselect=.true.
+            
+c     set double index
+            
+            if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+            
+            if(lghost)then
+              
+c     selected excitation option
+              
+              if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                
+c     reset selection control
+                
+                lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                
+                if(lsolva)vdw_exc(kkk)=vdw_exc(kkk)+omega
+                
+              endif
+              
+            elseif(lfree)then
+              
+c     selected free energy option
+              
+              if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                
+c     set hamiltonian mixing parameter
+                
+                omega=lambda1*omega
+                gamma=lambda1*gamma
+                
+              elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                
+c     set hamiltonian mixing parameter
+                
+                omega=lambda2*omega
+                gamma=lambda2*gamma
+                
+              endif
+              
+            endif
+            
+            if(lselect)then
+              
+c     calculate potential energy and virial
+            
+              engsrp=omega+engsrp
+              virsrp=virsrp-gamma*rsq
+              
+              if(lsolva)vdw_sol(kkk)=vdw_sol(kkk)+omega
+              
+              fx=gamma*xdf(m)
+              fy=gamma*ydf(m)
+              fz=gamma*zdf(m)
+              
+              fxx(iatm)=fxx(iatm)+fx
+              fyy(iatm)=fyy(iatm)+fy
+              fzz(iatm)=fzz(iatm)+fz
+              
+              fxx(jatm)=fxx(jatm)-fx
+              fyy(jatm)=fyy(jatm)-fy
+              fzz(jatm)=fzz(jatm)-fz
+              
+c     calculate stress tensor
+            
+              strs(1)=strs(1)+xdf(m)*fx
+              strs(2)=strs(2)+xdf(m)*fy
+              strs(3)=strs(3)+xdf(m)*fz
+              strs(4)=strs(4)+ydf(m)*fy
+              strs(5)=strs(5)+ydf(m)*fz
+              strs(6)=strs(6)+zdf(m)*fz
+              
+            endif
+
+c     metadynamics local parameters
+        
+            if(lmetadyn.and.(idrive.or.jdrive))then
+              
+c     local energy and virial
+          
+              eng_loc=eng_loc+omega
+              vir_loc=vir_loc-gamma*rsq
+              
+c     local forces
+          
+              fxx_loc(iatm)=fxx_loc(iatm)+fx
+              fyy_loc(iatm)=fyy_loc(iatm)+fy
+              fzz_loc(iatm)=fzz_loc(iatm)+fz
+              
+              fxx_loc(jatm)=fxx_loc(jatm)-fx
+              fyy_loc(jatm)=fyy_loc(jatm)-fy
+              fzz_loc(jatm)=fzz_loc(jatm)-fz
+              
+c     local stress tensor
+          
+              strs_loc(1)=strs_loc(1)+xdf(m)*fx
+              strs_loc(2)=strs_loc(2)+xdf(m)*fy
+              strs_loc(3)=strs_loc(3)+xdf(m)*fz
+              strs_loc(4)=strs_loc(4)+ydf(m)*fy
+              strs_loc(5)=strs_loc(5)+ydf(m)*fz
+              strs_loc(6)=strs_loc(6)+zdf(m)*fz
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine srfrceneu
+
+      end module vdw_module
diff -urN dl_class_1.9.orig/srcmod/vv_motion_module.f dl_class_1.9/srcmod/vv_motion_module.f
--- dl_class_1.9.orig/srcmod/vv_motion_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vv_motion_module.f	2011-02-22 12:46:30.000000000 +0100
@@ -0,0 +1,3031 @@
+      module vv_motion_module
+
+c***********************************************************************
+c     
+c     dl_poly module for velocity verlet integration schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use metafreeze_module,only : lmetadyn
+      use property_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+      
+      subroutine rdrattle_r
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x  tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x  txx,tyy,tzz,xxt,yyt,zzt,stresh)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration. rattle algorithm
+c     must be used in conjunction with integration algorithms
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical check,safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,icyc,i,j,k
+      real(8) tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,esig
+      real(8) txx,tyy,tzz,xxt,yyt,zzt,stresh,dx,dy,dz,dis,omega2
+      real(8) strs1,strs2,strs3,strs5,strs6,strs9,amti,amtj,gamma
+      real(8) gammi,gammj,dli,dlj
+      
+      dimension stresh(9)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      
+c     constraint virial
+
+      vircon=0.d0
+
+c     accumulators for stress tensor
+
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+
+c     test size of work arrays
+
+      check=.true.
+      if(mxxdf.lt.nscons)check=.false.
+      if(mxnode.gt.1)call gstate(check)
+      if(.not.check)call error(idnode,412)
+
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      safe=.false.
+
+      do while(.not.safe.and.icyc.lt.mxshak)
+
+        icyc=icyc+1
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+
+c     calculate temporary bond vector
+          
+          dxt(k)=xxx(i)-xxx(j)
+          dyt(k)=yyy(i)-yyy(j)
+          dzt(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+c     periodic boundary condition
+        
+        call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+
+c     calculate maximum error in bondlength
+        
+        esig=0.d0
+        
+        do k=1,nscons
+
+c     set bond parameter
+          
+          dx=dxt(k)
+          dy=dyt(k)
+          dz=dzt(k)
+          dis=prmcon(listcon(k,1))
+          esig=max(esig,abs(dx*dx+dy*dy+dz*dz-dis*dis)/dis)
+          
+        enddo
+        
+        esig=esig*0.5d0
+
+c     global verification of convergence
+        
+        safe=(esig.lt.tolnce)
+        
+        if(mxnode.gt.1)call gstate(safe)
+
+c     bypass calculations if all tolerances satisfied 
+        
+        if(.not.safe)then
+          
+c     initialise increment arrays
+          
+          do i=1,natms
+            
+            xxt(i)=0.d0
+            yyt(i)=0.d0
+            zzt(i)=0.d0
+            
+          enddo
+          
+c     calculate constraint forces
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+c     set constraint parameters
+            
+            dis=prmcon(listcon(k,1))
+            omega2= dis*dis
+            amti= tstep*rmass(i)
+            amtj=-tstep*rmass(j)
+            
+c     constraint force parameter
+            
+            dx=dxt(k)
+            dy=dyt(k)
+            dz=dzt(k)
+            
+            gamma=(omega2-(dx*dx+dy*dy+dz*dz))/
+     x        (-tstep*(amti-amtj)*(dxx(k)*dx+dyy(k)*dy+dzz(k)*dz))
+            
+c     accumulate bond virial
+            
+            vircon=vircon+gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+            
+            strs1=strs1-gamma*dxx(k)*dxx(k)
+            strs2=strs2-gamma*dxx(k)*dyy(k)
+            strs3=strs3-gamma*dxx(k)*dzz(k)
+            strs5=strs5-gamma*dyy(k)*dyy(k)
+            strs6=strs6-gamma*dyy(k)*dzz(k)
+            strs9=strs9-gamma*dzz(k)*dzz(k)
+            
+c     improve approximate constraint force
+            
+            gammi=-0.5d0*gamma*amti
+            xxt(i)=xxt(i)+dxx(k)*gammi
+            yyt(i)=yyt(i)+dyy(k)*gammi
+            zzt(i)=zzt(i)+dzz(k)*gammi
+            
+            gammj=-0.5d0*gamma*amtj
+            xxt(j)=xxt(j)+dxx(k)*gammj
+            yyt(j)=yyt(j)+dyy(k)*gammj
+            zzt(j)=zzt(j)+dzz(k)*gammj
+            
+          enddo
+          
+c     sum up constraint forces across nodes
+          
+          if(mxnode.gt.1)then
+            
+            if(lshmov)call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x        txx,tyy,tzz,buffer)
+            
+          endif
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+            dli=1.0d0/dble(listme(i))
+            dlj=1.0d0/dble(listme(j))
+            
+            xxx(i)=xxx(i)+tstep*dli*xxt(i)
+            yyy(i)=yyy(i)+tstep*dli*yyt(i)
+            zzz(i)=zzz(i)+tstep*dli*zzt(i)
+            xxx(j)=xxx(j)+tstep*dlj*xxt(j)
+            yyy(j)=yyy(j)+tstep*dlj*yyt(j)
+            zzz(j)=zzz(j)+tstep*dlj*zzt(j)
+            
+            vxx(i)=vxx(i)+dli*xxt(i)
+            vzz(i)=vzz(i)+dli*zzt(i)
+            vyy(i)=vyy(i)+dli*yyt(i)
+            vxx(j)=vxx(j)+dlj*xxt(j)
+            vyy(j)=vyy(j)+dlj*yyt(j)
+            vzz(j)=vzz(j)+dlj*zzt(j)
+            
+          enddo
+          
+        endif
+        
+      enddo
+
+c     error exit for non-convergence
+
+      if(.not.safe)return
+      
+c     complete stress tensor
+      
+      stresh(1)=strs1
+      stresh(2)=strs2
+      stresh(3)=strs3
+      stresh(4)=strs2
+      stresh(5)=strs5
+      stresh(6)=strs6
+      stresh(7)=strs3
+      stresh(8)=strs6
+      stresh(9)=strs9
+      
+c     splice coordinate arrays across nodes
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(stresh,9,buffer)
+        call splice 
+     x    (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+        call splice 
+     x    (idnode,natms,listme,listot,vxx,vyy,vzz,buffer)
+
+      endif
+      
+      return
+      end subroutine rdrattle_r
+
+      subroutine rdrattle_v
+     x  (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x  dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for applying a bond constraints to 
+c     the velocities of the constrained atoms using the rattle
+c     procedure (replicated data version)
+c     
+c     copyright - daresbury laboratory
+c     author w.smith october 2002
+c     
+c*********************************************************************
+
+      implicit none
+
+      logical safe
+      integer idnode,mxnode,natms,nscons,icyc
+      integer i,j,k
+      real(8) tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt
+      real(8) esig,amti,amtj,gamma,gammi,gammj,dli,dlj,tolvel
+
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      
+c     constraint convergence tolerance
+
+      tolvel=tolnce/tstep
+
+c     start of rattle cycle
+      
+      icyc=0
+      safe=.false.
+
+      do while(.not.safe.and.icyc.lt.mxshak)
+
+        icyc=icyc+1
+
+c     initialise velocity correction arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+
+        enddo
+
+c     calculate velocity constraint corrections
+        
+        esig=0.d0
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          amti= 0.5d0*tstep*rmass(i)
+          amtj=-0.5d0*tstep*rmass(j)
+
+c     calculate constraint force parameter
+
+          gamma=(dxx(k)*(vxx(i)-vxx(j))+dyy(k)*(vyy(i)-vyy(j))+
+     x      dzz(k)*(vzz(i)-vzz(j)))/((amti-amtj)*
+     x      (dxx(k)**2+dyy(k)**2+dzz(k)**2))
+          esig=max(esig,abs(gamma))
+
+c     improve approximate constraint force
+
+          gammi=-gamma*amti
+          xxt(i)=xxt(i)+gammi*dxx(k)
+          yyt(i)=yyt(i)+gammi*dyy(k)
+          zzt(i)=zzt(i)+gammi*dzz(k)
+          gammj=-gamma*amtj
+          xxt(j)=xxt(j)+gammj*dxx(k)
+          yyt(j)=yyt(j)+gammj*dyy(k)
+          zzt(j)=zzt(j)+gammj*dzz(k)
+          
+        enddo
+
+c     global verification of convergence
+        
+        safe=(esig.lt.tolvel)
+        if(mxnode.gt.1)then
+          
+          call gstate(safe)
+          
+        endif
+
+c     terminate iteration if constraints satisfied
+        
+        if(.not.safe)then
+          
+c     transport velocity adjustments to other nodes
+          
+          if(mxnode.gt.1)then
+            
+            call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x        txx,tyy,tzz,buffer)
+            
+          endif
+          
+c     update velocities
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+            dli=1.d0/dble(listme(i))
+            vxx(i)=vxx(i)+dli*xxt(i)
+            vyy(i)=vyy(i)+dli*yyt(i)
+            vzz(i)=vzz(i)+dli*zzt(i)
+            dlj=1.d0/dble(listme(j))
+            vxx(j)=vxx(j)+dlj*xxt(j)
+            vyy(j)=vyy(j)+dlj*yyt(j)
+            vzz(j)=vzz(j)+dlj*zzt(j)
+            
+          enddo
+        
+        endif
+        
+      enddo
+
+c     error exit if rattle fails
+
+      if(.not.safe)return
+      
+c     splice velocity arrays across nodes
+      
+      if(mxnode.gt.1)then
+
+        call splice
+     x    (idnode,natms,listme,listot,vxx,vyy,vzz,buffer)
+
+      endif
+      
+      return
+      end subroutine rdrattle_v
+
+      subroutine nvevv_1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  tstep,engke,tolnce,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nve ensemble
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+      
+      integer, parameter :: nnn=4
+
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,i,j,k
+      integer iatm0,iatm1
+      real(8) tstep,engke,tolnce,vircon
+      integer fail(nnn)
+      real(8) strkin(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,1980)
+        enddo
+
+      endif
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     update velocities for first and second stages
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second stage of velocity verlet algorithm
+
+      else
+
+c     merge velocity data
+
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strcns(i)+strkin(i)
+        enddo
+
+      endif
+      
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvevv_1
+
+      subroutine nvtvv_b1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  tstep,taut,sigma,engke,tolnce,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nvt ensemble - Berendsen thermostat (n.b. not symplectic)
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+      
+      integer, parameter :: nnn=4
+
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons
+      integer i,j,k,iatm0,iatm1
+      real(8) tstep,taut,sigma,engke,tolnce,vircon,chit
+      integer fail(nnn)
+      real(8) strkin(9)
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,1990)
+        enddo
+
+      endif
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     update velocities
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     first pass of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+        
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second pass of velocity verlet algorithm
+        
+      else
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=chit*vxx(i)
+          vyy(i)=chit*vyy(i)
+          vzz(i)=chit*vzz(i)
+          
+        enddo
+        
+        engke=engke*chit**2
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,
+     x    buffer)
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvtvv_b1
+
+      subroutine nvtvv_e1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  tstep,engke,tolnce,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nvt ensemble - evans thermostat
+c     Comp. Phys. reports 1, 299, (1984)
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=4
+
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons
+      integer i,j,k,iatm0,iatm1
+      real(8) tstep,engke,tolnce,vircon,vdotf,scale,chit
+      integer fail(nnn)
+      real(8) strkin(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2000)
+        enddo
+
+      endif
+
+      if(ntcons.eq.0)safe=.true.
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+
+c     calculate kinetic energy and evans thermostat parameter
+        
+        engke=0.d0
+        vdotf=0.d0
+        do i=iatm0,iatm1
+          
+          engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+          vdotf=vdotf+vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=engke
+          buffer(2)=vdotf
+          call gdsum(buffer(1),2,buffer(3))
+          engke=buffer(1)
+          vdotf=buffer(2)
+          
+        endif
+        engke=0.5d0*engke
+        chit=0.5d0*vdotf/engke
+
+c     thermostat the velocities
+        
+        scale=(1.d0-0.5d0*tstep*chit)
+        do i=iatm0,iatm1
+          
+          vxx(i)=scale*vxx(i)
+          vyy(i)=scale*vyy(i)
+          vzz(i)=scale*vzz(i)
+          
+        enddo
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+        
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     calculate kinetic energy and evans thermostat parameter
+        
+        engke=0.d0
+        vdotf=0.d0
+        do i=iatm0,iatm1
+          
+          engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+          vdotf=vdotf+vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=engke
+          buffer(2)=vdotf
+          call gdsum(buffer(1),2,buffer(3))
+          engke=buffer(1)
+          vdotf=buffer(2)
+          
+        endif
+        engke=0.5d0*engke
+        chit=0.5d0*vdotf/engke
+        scale=(1.d0-0.5d0*tstep*chit)
+
+c     scale velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=scale*vxx(i)
+          vyy(i)=scale*vyy(i)
+          vzz(i)=scale*vzz(i)
+          
+        enddo
+        
+        engke=engke*scale**2
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvtvv_e1
+
+      subroutine nvtvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  ntshl,keyshl,tstep,taut,sigma,chit,consv,conint,engke,
+     x  tolnce,vircon,chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nvt ensemble - nose-hoover thermostat
+c     Molecular Physics 87 (1996) 1117
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=4
+      
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons
+      integer i,j,k,iatm0,iatm1
+      real(8) tstep,taut,sigma,chit,consv,conint,engke,tolnce,vircon
+      real(8) hstep,qmass
+      integer fail(nnn)
+      real(8) strkin(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2010)
+        enddo
+
+      endif
+
+c     inertia parameter for Nose-Hoover thermostat
+      
+      hstep=0.5d0*tstep
+      qmass=2.d0*sigma*taut**2
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+
+c     integrate and apply nvt thermostat
+
+        call nvtscale
+     x    (idnode,mxnode,natms,engke,sigma,hstep,qmass,taut,
+     x    chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+
+        enddo
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+        
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+        if(ntcons.gt.0)then
+
+c     merge velocity data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     integrate and apply nvt thermostat
+        
+        call nvtscale
+     x    (idnode,mxnode,natms,engke,sigma,hstep,qmass,taut,
+     x    chit,conint)
+        
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+           consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvtvv_h1
+
+      subroutine nptvv_b1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x  ntcons,ntpatm,tstep,taut,taup,sigma,engke,press,elrc,
+     x  virlrc,tolnce,virtot,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith december 2002
+c     amended   - w. smith  january 2005 : f90 conversion
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=7
+
+      logical newjob,safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk
+      real(8) tstep,taut,taup,sigma,engke,press,elrc,virlrc,tolnce
+      real(8) virtot,vircon,volm,volm0,elrc0,virlrc0,psyst
+      real(8) chit,chip,scale,beta
+
+      integer fail(nnn)
+      real(8) strkin(9),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2020)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(4))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(5))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(6))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(7))
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2030)
+        enddo
+
+      endif
+
+c     construct current bond vectors
+
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then          
+
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+          
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+        
+        endif
+
+c     iteration required if ntcons > 0 and isw = 1
+
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+          
+          scale=1.d0
+          
+          if(iter.eq.mxiter)then
+
+c     calculate system pressure
+            
+            psyst=(2.d0*engke-virtot-vircon)/(3.d0*volm)
+
+c     apply Berendsen barostat taup is relaxation time
+            
+            chip=1.d0+beta*tstep*(psyst-press)/taup
+            scale=chip**(1.d0/3.d0)
+            volm=chip*volm
+            
+c     reset cell parameters for new volume
+          
+            do i=1,9
+              cell(i)=scale*cell(i)
+            enddo
+          
+          endif
+
+c     update positions
+          
+          do i=iatm0,iatm1
+            
+            xxx(i)=scale*xxx(i)+tstep*vxx(i)
+            yyy(i)=scale*yyy(i)+tstep*vyy(i)
+            zzz(i)=scale*zzz(i)+tstep*vzz(i)
+            
+          enddo
+          
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+          endif
+          
+          if(iter.lt.mxiter)then
+            
+            do i=iatm0,iatm1
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     construct scaling tensor for tethered bonds
+
+        do i=1,9
+          eta(i)=scale*uni(i)
+        enddo
+
+c     second pass of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     apply Berendsen thermostat taut is relaxation time
+        
+        engke=getkin(natms,idnode,mxnode)
+        chit=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=chit*vxx(i)
+          vyy(i)=chit*vyy(i)
+          vzz(i)=chit*vzz(i)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        engke=0.5d0*(strkin(1)+strkin(5)+strkin(9))
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,vxo,vyo,vzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nptvv_b1
+
+      subroutine nptvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  ntpatm,ntshl,keyshl,tstep,taut,taup,sigma,temp,chip,chit,
+     x  consv,conint,engke,elrc,tolnce,vircon,virtot,virlrc,volm,
+     x  press,chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     npt ensemble - Melchionna, Ciccotti and Holian
+c     Molecular Physics 78 (1993) 533
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith november 2002
+c     amended   - w. smith january 2005: f90 conversion
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=7
+      integer, parameter :: ncyc=5
+      
+      logical safe,lshmov,newjob
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk,icyc
+      real(8) tstep,taup,taut,sigma,temp,chip,chit,consv,conint
+      real(8) engke,elrc,tolnce,vircon,virtot,virlrc,volm,press
+      real(8) volm0,elrc0,virlrc0,hstep,qstep,totmas,qmass,pmass
+      real(8) vzero,chit0,chip0,cons0,scale,fstep
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      integer fail(nnn)
+      real(8) cell0(9),com(3),vom(3),strkin(9),uni(9)
+
+      save newjob,totmas,volm0,elrc0,virlrc0,dens0
+      save cell0,iatm0,iatm1,hstep,qstep,fstep,pmass,qmass
+
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl 
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2040)
+
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     inertia parameter for Nose-Hoover thermostat and barostat
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2050)
+        enddo
+        
+      endif
+      
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metdynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+        
+c     store current integration variables if ntcons > 0
+        
+        if(ntcons.gt.0)then
+          
+          vzero=volm
+          chit0=chit
+          chip0=chip
+          cons0=conint
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          
+        endif
+        
+c     iteration necessary if ntcons > 0 and isw = 1
+        
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+          
+c     volume integration parameter
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptscale_t
+     x        (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x        taut,chip,chit,conint)
+            
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+c     integrate and apply npt barostat
+            
+            call nptscale_p
+     x        (idnode,mxnode,natms,engke,fstep,pmass,chip,chit,
+     x        volm,press,vircon,virtot)
+            
+c     integrate and apply npt thermostat
+            
+            call nptscale_t
+     x        (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x        taut,chip,chit,conint)
+            
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif   
+            
+          enddo
+          
+c     scale cell vectors - isotropic
+          
+          scale=(volm/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     update velocities
+          
+          do i=iatm0,iatm1
+            
+            vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+
+c     update positions
+          
+          scale=exp(tstep*chip)
+          do i=iatm0,iatm1
+            
+            xxx(i)=scale*(xxx(i)-com(1))+tstep*vxx(i)+com(1)
+            yyy(i)=scale*(yyy(i)-com(2))+tstep*vyy(i)+com(2)
+            zzz(i)=scale*(zzz(i)-com(3))+tstep*vzz(i)+com(3)
+            
+          enddo
+
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+          endif
+
+c     restore original integration parameters if iter < mxiter
+          
+          if(iter.lt.mxiter)then
+            
+            volm=vzero
+            chit=chit0
+            chip=chip0
+            conint=cons0
+
+            do i=iatm0,iatm1
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+            
+          endif
+          
+        enddo
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+        if(ntcons.gt.0)then
+
+c     merge velocity data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+        do icyc=1,ncyc
+          
+c     integrate and apply npt thermostat
+          
+          call nptscale_t
+     x      (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x      taut,chip,chit,conint)
+          
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+c     integrate and apply npt barostat
+          
+          call nptscale_p
+     x      (idnode,mxnode,natms,engke,fstep,pmass,chip,chit,
+     x      volm,press,vircon,virtot)
+          
+c     integrate and apply npt thermostat
+          
+          call nptscale_t
+     x      (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x      taut,chip,chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+        enddo
+
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     scale cell vectors - isotropic
+        
+        scale=(volm/volm0)**(1.d0/3.d0)
+        do i=1,9
+          cell(i)=cell0(i)*scale
+        enddo
+
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2+
+     x    0.5d0*pmass*chip**2+press*volm
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        engke=0.5d0*(strkin(1)+strkin(5)+strkin(9))
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do kk=1,ntpatm
+        dens(kk)=dens0(kk)*(volm0/volm)
+      enddo
+
+c     construct scaling tensor (for tethered atoms)
+      
+      do i=1,9
+        eta(i)=chip*uni(i)
+      enddo
+
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,vxo,vyo,vzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nptvv_h1
+
+      subroutine nstvv_b1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x  ntcons,ntpatm,mode,tstep,taut,taup,sigma,engke,press,elrc,
+     x  virlrc,tolnce,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     anisotropic npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith december 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=7
+
+      logical newjob,safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk,mode
+      real(8) tstep,taut,taup,sigma,engke,press,elrc,virlrc,tolnce,beta
+      real(8) vircon,volm,volm0,elrc0,virlrc0,chit
+      real(8) xtmp,ytmp,ztmp
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      integer fail(nnn)
+      real(8) uni(9),strkin(9),celp(10)
+
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2060)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(4))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(5))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(6))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(7))
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2070)
+        enddo
+        
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then          
+
+c     extract previous constraint terms from stress tensor
+
+        do i=1,9
+          stress(i)=stress(i)-strcns(i)
+        enddo
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+          
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          
+        endif
+        
+c     iteration required if ntcons > 0 and isw = 1
+
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+c     zero scaling matrix
+
+          do i=1,9
+            eta(i)=uni(i)
+          enddo
+
+          if(iter.eq.mxiter)then
+
+c     calculate Berendsen barostat - taup is relaxation time
+            
+            do i=1,9
+              eta(i)=tstep*beta*(stress(i)+strcns(i)-
+     x          press*volm*uni(i))/(taup*volm)+uni(i)
+            enddo
+            if(mode.gt.0)then
+              eta(3)=0.d0
+              eta(6)=0.d0
+              eta(7)=0.d0
+              eta(8)=0.d0
+              if(mode.lt.3)then
+                eta(2)=0.d0
+                eta(4)=0.d0
+                if(mode.eq.2)then
+                  eta(1)=0.5d0*(eta(1)+eta(5))
+                  eta(5)=eta(1)
+                endif
+              endif
+            endif
+
+c     reset cell parameters for new volume
+          
+            call mat_mul(eta,cell,cell)
+            
+c     calculate new volume
+            
+            call dcell(cell,celp)
+            volm=celp(10)
+            
+          endif
+
+c     update positions
+          
+          do i=iatm0,iatm1
+            
+            xtmp=eta(1)*xxx(i)+eta(4)*yyy(i)+eta(7)*zzz(i)
+            ytmp=eta(2)*xxx(i)+eta(5)*yyy(i)+eta(8)*zzz(i)
+            ztmp=eta(3)*xxx(i)+eta(6)*yyy(i)+eta(9)*zzz(i)
+            xxx(i)=tstep*vxx(i)+xtmp
+            yyy(i)=tstep*vyy(i)+ytmp
+            zzz(i)=tstep*vzz(i)+ztmp
+            
+          enddo
+
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+          endif
+          
+          if(iter.lt.mxiter)then
+
+            do i=iatm0,iatm1
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+            
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+        
+c     second pass of velocity verlet algorithm
+        
+      else
+        
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+c     apply Berendsen thermostat taut is relaxation time
+        
+        engke=getkin(natms,idnode,mxnode)
+        chit=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=chit*vxx(i)
+          vyy(i)=chit*vyy(i)
+          vzz(i)=chit*vzz(i)
+          
+        enddo
+        
+c     merge velocity data
+          
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        engke=0.5d0*(strkin(1)+strkin(5)+strkin(9))
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+        
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nstvv_b1
+
+      subroutine nstvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  ntpatm,mode,ntshl,keyshl,tstep,taut,taup,sigma,temp,chit,
+     x  consv,conint,engke,elrc,tolnce,vircon,virlrc,volm,press,
+     x  chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     anisotropic npt ensemble - Melchionna, Ciccotti and Holian
+c     Molecular Physics 78 (1993) 533
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith november 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=7
+      integer, parameter :: ncyc=5
+      
+      logical safe,lshmov,newjob
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk,icyc,mode
+      real(8) tstep,taup,taut,sigma,temp,chit,consv,conint,chit0
+      real(8) engke,elrc,tolnce,vircon,virlrc,volm,press,volm0
+      real(8) elrc0,virlrc0,hstep,qstep,totmas,qmass,pmass
+      real(8) cons0,cxx,cyy,czz,chip2,fstep
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      integer fail(nnn)
+      real(8) com(3),vom(3),czero(9),strkin(9),eta0(9),celp(10)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metdynamics shell thermostat variables
+      
+      data newjob/.true./
+
+      save newjob,totmas,volm0,elrc0,virlrc0,dens0
+      save iatm0,iatm1,hstep,qstep,pmass,qmass,fstep
+      
+      safe=.true.
+
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2080)
+
+c     store intitial parameters
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+
+c     system total mass
+
+        totmas=getmass(natms,idnode,mxnode)
+
+c     inertia parameter for Nose-Hoover thermostat and barostat
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2090)
+        enddo
+
+      endif
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metdynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+c     construct current bond vectors
+
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+          
+          chit0=chit
+          cons0=conint
+          do i=1,9
+
+            czero(i)=cell(i)
+            eta0(i)=eta(i)
+
+          enddo
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          
+        endif
+
+c     subtract kinetic terms from stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        do i=1,9
+          stress(i)=stress(i)-strkin(i)
+        enddo
+
+c     iteration necessary if ntcons > 0 and isw = 1
+
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+c     calculate current volume
+
+          call dcell(cell,celp)
+          volm=celp(10)
+
+          do icyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstscale_t
+     x        (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x        pmass,qmass,taut,chit,conint)
+            
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstscale_p
+     x        (idnode,mxnode,natms,mode,fstep,pmass,chit,press,volm)
+            
+c     integrate and apply nst thermostat
+            
+            call nstscale_t
+     x        (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x        pmass,qmass,taut,chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+
+c     update velocities
+          
+          do i=iatm0,iatm1
+   
+            vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+
+c     update positions
+          
+          do i=iatm0,iatm1
+            
+            cxx=xxx(i)-com(1)
+            cyy=yyy(i)-com(2)
+            czz=zzz(i)-com(3)
+            
+            xxx(i)=xxx(i)+
+     x        tstep*(vxx(i)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+            yyy(i)=yyy(i)+
+     x        tstep*(vyy(i)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+            zzz(i)=zzz(i)+
+     x        tstep*(vzz(i)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+            
+          enddo
+
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            
+c     subtract old constraint terms from stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)-strcns(i)
+            enddo
+
+c     correct constraint bonds using rattle
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+c     add new constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+          endif
+
+c     restore original integration parameters if iter < mxiter
+
+          if(iter.lt.mxiter)then
+
+            chit=chit0
+            conint=cons0
+            do i=1,9
+
+              cell(i)=czero(i)
+              eta(i)=eta0(i)
+
+            enddo
+            do i=iatm0,iatm1
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+
+          endif
+
+        enddo
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+        if(ntcons.gt.0)then
+
+c     merge velocity data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     add constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+c     correct constraint bond velocities using rattle
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+        do icyc=1,ncyc
+          
+c     integrate and apply nst thermostat
+          
+          call nstscale_t
+     x      (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x      pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+c     integrate and apply nst barostat
+          
+          call nstscale_p
+     x      (idnode,mxnode,natms,mode,fstep,pmass,chit,press,volm)
+          
+c     integrate and apply nst thermostat
+          
+          call nstscale_t
+     x      (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x      pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+        enddo
+        
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     conserved quantity less kinetic and potential energy terms
+        
+        chip2=sdot0(9,eta,eta)
+        if(mode.eq.2)chip2=chip2-eta(1)**2
+        consv=conint+0.5d0*qmass*chit**2+0.5d0*pmass*chip2+press*volm
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,vxo,vyo,vzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nstvv_h1
+      
+      end module vv_motion_module
+
diff -urN dl_class_1.9.orig/srcmod/vv_rotation1_module.f dl_class_1.9/srcmod/vv_rotation1_module.f
--- dl_class_1.9.orig/srcmod/vv_rotation1_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vv_rotation1_module.f	2011-02-22 12:46:30.000000000 +0100
@@ -0,0 +1,4701 @@
+      module vv_rotation1_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 1 for velocity verlet rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use metafreeze_module, only : lmetadyn
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use vv_motion_module
+      use utility_module
+      
+      contains
+      
+      subroutine rotate_omega
+     x  (idnode,mxnode,ngrp,tstep,p0,p1,p2,p3,dtx,dty,dtz)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for updating the angular velocity and momentum
+c     for rigid bodies
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith  sept 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ngrp,i,j,jr,jrs,ig,igrp1,igrp2,id
+      real(8) ftx,fty,ftz,fmx,fmy,fmz,tstep,tqx,tqy,tqz,tq0,tq1,tq2,tq3
+
+      real(8) p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp)
+      real(8) dtx(mxatms),dty(mxatms),dtz(mxatms),rot(9)
+
+c     group block indices
+        
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     fmx,fmy,fmz represent force on c.o.m.
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+          
+        enddo
+        
+c     current rotational matrix
+          
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+          
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        tq0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        tq1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        tq2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        tq3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+        
+c     update quaternion momentum by half timestep
+
+        p0(ig)=p0(ig)+tq0*tstep
+        p1(ig)=p1(ig)+tq1*tstep
+        p2(ig)=p2(ig)+tq2*tstep
+        p3(ig)=p3(ig)+tq3*tstep
+
+c     update centre of mass velocity by half timestep
+
+        gvxx(ig)=gvxx(ig)+fmx*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*tstep/gmass(id)
+        
+      enddo
+
+      return
+      end subroutine rotate_omega
+
+      subroutine nosquish(ig,tstep,qq0,qq1,qq2,qq3,pp0,pp1,pp2,pp3)
+
+c***********************************************************************
+c     
+c     dlpoly routine to implement the symplectic no_squish quaternion 
+c     algorithm of miller et al j.chem.phys 116 (2002) 8649
+c     
+c     copyright daresbury laboratory
+c     author      m. leslie jan 2004
+c     amended     w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer m,ig,id
+      real(8) zetax,zetay,zetaz,tstep,cs,sn,trstep
+
+      integer, parameter :: mrot=10
+      real(8), parameter :: ov4=0.25d0
+      real(8), parameter :: ov8=0.125d0
+
+      real(8) qq0(*),qq1(*),qq2(*),qq3(*)
+      real(8) pp0(*),pp1(*),pp2(*),pp3(*)
+
+      real(8) qn1(0:3),pq2(0:3),qn2(0:3),pq3(0:3)
+      real(8) qn3(0:3),pq4(0:3)
+
+c     rotational time step
+
+      trstep=tstep/dble(mrot)
+
+c     rotation: iterate over mrot rotational time steps
+
+      id=lstgtp(ig)
+
+      do m=1,mrot
+        
+        zetaz=ov8*rotinz(id,2)*trstep*
+     x    (-pp0(ig)*qq3(ig)+pp1(ig)*qq2(ig)-
+     x    pp2(ig)*qq1(ig)+pp3(ig)*qq0(ig))
+        cs=cos(zetaz)
+        sn=sin(zetaz)
+        qn1(0)=cs*qq0(ig)-sn*qq3(ig)
+        qn1(1)=cs*qq1(ig)+sn*qq2(ig)
+        qn1(2)=cs*qq2(ig)-sn*qq1(ig)
+        qn1(3)=cs*qq3(ig)+sn*qq0(ig)
+        pq2(0)=cs*pp0(ig)-sn*pp3(ig)
+        pq2(1)=cs*pp1(ig)+sn*pp2(ig)
+        pq2(2)=cs*pp2(ig)-sn*pp1(ig)
+        pq2(3)=cs*pp3(ig)+sn*pp0(ig)
+        
+        zetay=ov8*rotiny(id,2)*trstep*
+     x    (-pq2(0)*qn1(2)-pq2(1)*qn1(3)+
+     x    pq2(2)*qn1(0)+pq2(3)*qn1(1))
+        cs=cos(zetay)
+        sn=sin(zetay)
+        qn2(0)=cs*qn1(0)-sn*qn1(2)
+        qn2(1)=cs*qn1(1)-sn*qn1(3)
+        qn2(2)=cs*qn1(2)+sn*qn1(0)
+        qn2(3)=cs*qn1(3)+sn*qn1(1)
+        pq3(0)=cs*pq2(0)-sn*pq2(2)
+        pq3(1)=cs*pq2(1)-sn*pq2(3)
+        pq3(2)=cs*pq2(2)+sn*pq2(0)
+        pq3(3)=cs*pq2(3)+sn*pq2(1)
+        
+        zetax=ov4*rotinx(id,2)*trstep*
+     x    (-pq3(0)*qn2(1)+pq3(1)*qn2(0)+
+     x    pq3(2)*qn2(3)-pq3(3)*qn2(2))
+        cs=cos(zetax)
+        sn=sin(zetax)
+        qn3(0)=cs*qn2(0)-sn*qn2(1)
+        qn3(1)=cs*qn2(1)+sn*qn2(0)
+        qn3(2)=cs*qn2(2)+sn*qn2(3)
+        qn3(3)=cs*qn2(3)-sn*qn2(2)
+        pq4(0)=cs*pq3(0)-sn*pq3(1)
+        pq4(1)=cs*pq3(1)+sn*pq3(0)
+        pq4(2)=cs*pq3(2)+sn*pq3(3)
+        pq4(3)=cs*pq3(3)-sn*pq3(2)
+        
+        zetay=ov8*rotiny(id,2)*trstep*
+     x    (-pq4(0)*qn3(2)-pq4(1)*qn3(3)+
+     x    pq4(2)*qn3(0)+pq4(3)*qn3(1))
+        cs=cos(zetay)
+        sn=sin(zetay)
+        qn2(0)=cs*qn3(0)-sn*qn3(2)
+        qn2(1)=cs*qn3(1)-sn*qn3(3)
+        qn2(2)=cs*qn3(2)+sn*qn3(0)
+        qn2(3)=cs*qn3(3)+sn*qn3(1)
+        pq3(0)=cs*pq4(0)-sn*pq4(2)
+        pq3(1)=cs*pq4(1)-sn*pq4(3)
+        pq3(2)=cs*pq4(2)+sn*pq4(0)
+        pq3(3)=cs*pq4(3)+sn*pq4(1)
+        
+        zetaz=ov8*rotinz(id,2)*trstep*
+     x    (-pq3(0)*qn2(3)+pq3(1)*qn2(2)-
+     x    pq3(2)*qn2(1)+pq3(3)*qn2(0))
+        cs=cos(zetaz)
+        sn=sin(zetaz)
+        qq0(ig)=cs*qn2(0)-sn*qn2(3)
+        qq1(ig)=cs*qn2(1)+sn*qn2(2)
+        qq2(ig)=cs*qn2(2)-sn*qn2(1)
+        qq3(ig)=cs*qn2(3)+sn*qn2(0)
+        pp0(ig)=cs*pq3(0)-sn*pq3(3)
+        pp1(ig)=cs*pq3(1)+sn*pq3(2)
+        pp2(ig)=cs*pq3(2)-sn*pq3(1)
+        pp3(ig)=cs*pq3(3)+sn*pq3(0)
+        
+      enddo
+
+      return
+      end subroutine nosquish
+
+      subroutine nveqvv_1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      m. leslie jan 2004
+c     amended     w.smith   jan 2005: f90 conversion
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,jrs,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,engfke
+
+      integer, parameter :: nnn=6
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      
+      save newjob,p0,p1,p2,p3
+      
+      data newjob/.true./
+      
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+      safe=(igrp2-igrp1+1.le.msgrp) 
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe)then 
+        igrp=igrp2-igrp1+1
+        call gimax(igrp,1,idum)
+        if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+        call  error(idnode,506)
+      endif
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(6))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2100)
+      enddo
+
+      newjob=.false.
+      
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     *************  Rigid body motion ****************************
+c     operations common to first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+        
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     merge centre of mass velocities from all nodes
+
+      if(mxnode.gt.1)call merge
+     x  (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     move centre of mass by full time step
+
+        do ig=igrp1,igrp2
+
+          gcmx(ig)=gcmx(ig)+tstep*gvxx(ig)
+          gcmy(ig)=gcmy(ig)+tstep*gvyy(ig)
+          gcmz(ig)=gcmz(ig)+tstep*gvzz(ig)
+
+        enddo
+
+c     merge centre of mass position from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+          
+          call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          
+        enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+        
+        k=0
+        do ig=igrp1,igrp2
+
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          id=lstgtp(ig)
+
+          do j=1,numgsit(id)
+            
+            k=k+1
+            i=lstme(k)
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+
+          enddo
+          
+        enddo
+
+c     update positions of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge atom positions
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nveqvv_1
+
+      subroutine nvtqvv_b1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x  vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nvt ensemble - Berendsen thermostat (n.b. not symplectic)
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,jrs,idum,ig,iatm0,iatm1
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,taut,sigma,engtke
+      real(8) chit,engfke
+
+      integer, parameter :: nnn=6
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      
+      save newjob,p0,p1,p2,p3
+
+      data newjob/.true./
+      
+c     atom block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+      safe=(igrp2-igrp1+1.le.msgrp) 
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe)then 
+        igrp=igrp2-igrp1+1
+        call gimax(igrp,1,idum)
+        if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+        call  error(idnode,506)
+      endif
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(6))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2120)
+      enddo
+
+      newjob=.false.
+
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     *************  Rigid body motion ****************************
+c     operations common to first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     move centre of mass by full time step
+
+        do ig=igrp1,igrp2
+
+          gcmx(ig)=gcmx(ig)+tstep*gvxx(ig)
+          gcmy(ig)=gcmy(ig)+tstep*gvyy(ig)
+          gcmz(ig)=gcmz(ig)+tstep*gvzz(ig)
+
+        enddo
+
+c     merge group coms from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algoritm
+
+        jr=0
+        do ig=igrp1,igrp2
+          call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+        enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+        
+        k=0
+        do ig=igrp1,igrp2
+
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          id=lstgtp(ig)
+
+          do j=1,numgsit(id)
+            
+            k=k+1
+            i=lstme(k)
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+
+          enddo
+          
+        enddo
+
+c     update positions of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge atom positions
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engfke+engtrn+engrot
+        engke=engfke+engtrn
+
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+        
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+        
+c     thermostat velocities 
+        
+        do i=iatm0,iatm1
+          
+          if(lstfrz(i).eq.0)then
+
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     thermostat rigid body velocities
+
+        do ig=igrp1,igrp2
+          
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+
+        enddo
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     exchange position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     merge group velocities from all processors
+
+      if(mxnode.gt.1)call merge
+     x  (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nvtqvv_b1
+
+      subroutine nvtqvv_h1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,engrot,
+     x  taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nvt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=6
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ifre1,ifre2,igrp1,igrp2,igrp,i,j,k,jr
+      integer id,ig,ifre,jrs,idum
+      real(8) chit,consv,conint,engke,engrot,taut,sigma,tolnce,tstep
+      real(8) vircom,vircon,hstep,qmass,opx,opy,opz,fmx,fmy,fmz,engtrn
+      real(8) ftx,fty,ftz,tqx,tqy,tqz,qt0,qt1,qt2,qt3,vaa,vbb,vcc
+      real(8) engfke
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+
+      save newjob,p0,p1,p2,p3
+
+      data newjob/.true./
+      
+c     timestep parameters
+
+      hstep=pt5*tstep
+
+c     nose-hoover inertia parameter
+
+      qmass=2.d0*sigma*taut**2
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+      safe=(igrp2-igrp1+1.le.msgrp) 
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe)then 
+        igrp=igrp2-igrp1+1
+        call gimax(igrp,1,idum)
+        if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+        call  error(idnode,506)
+      endif
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(6))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2140)
+      enddo
+
+      newjob=.false.
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     apply thermostat for first stage
+
+      if(isw.eq.1)then
+        
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+        
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+      endif
+      
+c     calculate quaternion momenta at start of time step
+      
+      if(isw.eq.1)then
+        
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     *************  Rigid body motion ****************************
+c     operations common to first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*hstep
+        p1(ig)=p1(ig)+qt1*hstep
+        p2(ig)=p2(ig)+qt2*hstep
+        p3(ig)=p3(ig)+qt3*hstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*hstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*hstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*hstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     move centre of mass by full time step
+
+        do ig=igrp1,igrp2
+
+          gcmx(ig)=gcmx(ig)+tstep*gvxx(ig)
+          gcmy(ig)=gcmy(ig)+tstep*gvyy(ig)
+          gcmz(ig)=gcmz(ig)+tstep*gvzz(ig)
+
+        enddo
+
+c     merge group coms from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algoritm
+
+        jr=0
+        do ig=igrp1,igrp2
+          call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+        enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+        
+        k=0
+        do ig=igrp1,igrp2
+
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          id=lstgtp(ig)
+
+          do j=1,numgsit(id)
+            
+            k=k+1
+            i=lstme(k)
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+
+          enddo
+          
+        enddo
+
+c     update positions of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge atom positions
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+      
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     apply thermostat for second stage and calculate kinetic energy
+      
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+
+        engke=engfke+engtrn
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     merge group velocities from all processors
+
+      if(mxnode.gt.1)call merge
+     x  (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nvtqvv_h1
+
+      subroutine nptqvv_b1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr,kk
+      integer id,ifre,jrs,idum,ig,iatm0,iatm1,ntpatm,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,taut,sigma,engtke
+      real(8) chit,chip,beta,volm,volm0,elrc,elrc0,virlrc,virlrc0
+      real(8) virtot,psyst,press,taup,scale,engfke
+
+      integer, parameter :: nnn=11
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+      safe=.true.
+
+      if(newjob)then
+        
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2160)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     atom block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+      endif
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+        if(isw.eq.1)then
+
+          allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(6))
+          allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(7))
+          allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),stat=fail(8))
+          allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+          allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(10))
+
+        endif
+
+      endif
+      if(newjob)then         
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(11))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2170)
+      enddo
+
+      newjob=.false.
+      if(ntcons.gt.0)safe=.false.
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+      if(isw.eq.1)then
+
+c     calculate kinetic energy
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+
+c     calculate quaternion momenta at start of time step
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     rigid body motion for first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            c0(ig)=p0(ig)
+            c1(ig)=p1(ig)
+            c2(ig)=p2(ig)
+            c3(ig)=p3(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            
+          enddo
+
+        endif
+
+c     iteration required if ntcons > 0
+
+        mxiter=1
+        if(ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+          scale=1.d0
+
+          if(iter.eq.mxiter)then
+            
+c     calculate system pressure
+            
+            psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+            
+c     apply Berendsen barostat
+            
+            chip=1.d0+beta*tstep*(psyst-press)/taup
+            scale=chip**(1.d0/3.d0)
+            volm=chip*volm
+
+c     reset cell parameters for new volume
+            
+            do i=1,9
+              cell(i)=scale*cell(i)
+            enddo
+
+          endif
+
+c     update centre of mass position
+
+          do ig=igrp1,igrp2
+
+            gcmx(ig)=scale*gcmx(ig)+tstep*gvxx(ig)
+            gcmy(ig)=scale*gcmy(ig)+tstep*gvyy(ig)
+            gcmz(ig)=scale*gcmz(ig)+tstep*gvzz(ig)
+
+          enddo
+
+c     merge group coms from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+          jr=0
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=gcmx(ig)+
+     x          rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+              yyy(i)=gcmy(ig)+
+     x          rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+              zzz(i)=gcmz(ig)+
+     x          rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=scale*xxx(i)+tstep*vxx(i)
+            yyy(i)=scale*yyy(i)+tstep*vyy(i)
+            zzz(i)=scale*zzz(i)+tstep*vzz(i)
+            
+          enddo
+          
+c     merge position data
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+          endif
+
+          if(iter.lt.mxiter)then
+
+            do i=1,natms
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+            do ig=1,ngrp
+
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              p0(ig)=c0(ig)
+              p1(ig)=c1(ig)
+              p2(ig)=c2(ig)
+              p3(ig)=c3(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+
+            enddo
+
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     construct scaling tensor for tethered bonds
+
+        do i=1,9
+          eta(i)=scale*uni(i)
+        enddo
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities and forces from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate kinetic energy
+        
+        if(isw.eq.2)then
+
+          engfke=getkinf(ntfree,idnode,mxnode)
+          call getking(ngrp,idnode,mxnode,engtrn,engrot)
+          engtke=engfke+engtrn+engrot
+          engke=engfke+engtrn
+
+c     apply Berendsen thermostat - taut is the relaxation time
+          
+          chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+          
+          engke=engke*chit**2
+          engtrn=engtrn*chit**2
+          engrot=engrot*chit**2
+          
+c     thermostat velocities 
+          
+          do i=iatm0,iatm1
+            
+            if(lstfrz(i).eq.0)then
+
+              vxx(i)=chit*vxx(i)
+              vyy(i)=chit*vyy(i)
+              vzz(i)=chit*vzz(i)
+              
+            endif
+            
+          enddo
+
+c     merge velocities from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     thermostat rigid body velocities
+
+          do ig=igrp1,igrp2
+            
+            omx(ig)=chit*omx(ig)
+            omy(ig)=chit*omy(ig)
+            omz(ig)=chit*omz(ig)
+            gvxx(ig)=chit*gvxx(ig)
+            gvyy(ig)=chit*gvyy(ig)
+            gvzz(ig)=chit*gvzz(ig)
+
+          enddo
+
+c     merge group velocities from all processors
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+          enddo
+          
+        endif
+        
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+        
+        if(isw.eq.1)then
+          
+          deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(4))
+          deallocate(xxo,yyo,zzo,c0,c1,c2,c3,stat=fail(5))
+          deallocate(gxo,gyo,gzo,stat=fail(6))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine nptqvv_b1
+
+      subroutine nptqvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x  temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircon,virtot,virlrc,vircom,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     npt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith may 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=12
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ifre1,ifre2,igrp1,igrp2,igrp,i,j,k,jr
+      integer id,ig,ifre,jrs,idum,mxiter,iter,ntpatm,kk,icyc
+      real(8) chit,consv,conint,engke,engrot,taut,sigma,tolnce,tstep
+      real(8) vircom,vircon,hstep,qmass,opx,opy,opz,fmx,fmy,fmz,engtrn
+      real(8) ftx,fty,ftz,tqx,tqy,tqz,qt0,qt1,qt2,qt3,vaa,vbb,vcc
+      real(8) taup,temp,press,virtot,vzero,chit0,chip0,cons0
+      real(8) chip,volm,elrc,elrc0,virlrc,virlrc0,qstep,pmass,totmas
+      real(8) volm0,scale,cxx,cyy,czz,engfke,fstep
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),cell0(9),com(3),vom(3),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+
+      save newjob,hstep,qstep,fstep,pmass,qmass
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2,volm0,elrc0,virlrc0
+      save totmas,dens0,cell0
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2200)
+
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call error(idnode,506)
+        endif
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      
+      if(ntcons.gt.0)then
+        
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(2))
+        allocate(oxo(mxgrp),oyo(mxgrp),ozo(mxgrp),stat=fail(3))
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(4))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(8))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(9))
+        allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(10))
+        allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(11))
+        
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(12))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2210)
+      enddo
+
+      newjob=.false.
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store current integration variables if ntcons > 0
+        
+        if(ntcons.gt.0)then
+          
+          vzero=volm
+          chit0=chit
+          chip0=chip
+          cons0=conint
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            oxo(ig)=omx(ig)
+            oyo(ig)=omy(ig)
+            ozo(ig)=omz(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            gvxo(ig)=gvxx(ig)
+            gvyo(ig)=gvyy(ig)
+            gvzo(ig)=gvzz(ig)
+            
+          enddo
+          
+        endif
+        
+      endif
+
+c     iteration necessary if ntcons > 0 and isw=1
+
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+        
+        if(isw.eq.1)then
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+          enddo
+          
+          engke=engfke+engtrn
+          
+c     scale cell vectors - isotropic
+          
+          scale=(volm/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+            p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+            p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+            p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+            
+          enddo
+          
+        endif
+
+c     update free atom velocities 
+
+        do ifre=ifre1,ifre2
+
+          i=lstfre(ifre)
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     *************  Rigid body motion ****************************
+
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     calculate com force arrays 
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+          
+c     current rotation matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     calculate torque in principal frame
+          
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+          
+c     calculate quaternion torques
+          
+          qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+          qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+          qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+          qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+          
+c     update quaternion momenta by 1/2 time step
+          
+          p0(ig)=p0(ig)+qt0*hstep
+          p1(ig)=p1(ig)+qt1*hstep
+          p2(ig)=p2(ig)+qt2*hstep
+          p3(ig)=p3(ig)+qt3*hstep
+          
+c     update centre of mass velocity by 1/2 time step
+          
+          gvxx(ig)=gvxx(ig)+fmx*hstep/gmass(id)
+          gvyy(ig)=gvyy(ig)+fmy*hstep/gmass(id)
+          gvzz(ig)=gvzz(ig)+fmz*hstep/gmass(id)
+          
+        enddo
+        
+        if(isw.eq.1)then
+          
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+          
+c     move centre of mass by full time step
+          
+          do ig=igrp1,igrp2
+            
+            cxx=gcmx(ig)-com(1)
+            cyy=gcmy(ig)-com(2)
+            czz=gcmz(ig)-com(3)
+            gcmx(ig)=gcmx(ig)+tstep*(gvxx(ig)+chip*cxx)
+            gcmy(ig)=gcmy(ig)+tstep*(gvyy(ig)+chip*cyy)
+            gcmz(ig)=gcmz(ig)+tstep*(gvzz(ig)+chip*czz)
+            
+          enddo
+          
+c     merge group coms from all nodes
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+c     rotate rigid groups: nosquish algorithm
+          
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+          
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x          +gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x          +gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x          +gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            cxx=xxx(i)-com(1)
+            cyy=yyy(i)-com(2)
+            czz=zzz(i)-com(3)
+            xxx(i)=xxx(i)+tstep*(vxx(i)+chip*cxx)
+            yyy(i)=yyy(i)+tstep*(vyy(i)+chip*cyy)
+            zzz(i)=zzz(i)+tstep*(vzz(i)+chip*czz)
+            
+          enddo
+          
+c     merge position data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+          endif
+          
+c     restore original integration parameters if iter < mxiter
+          
+          if(iter.lt.mxiter)then
+            
+            volm=vzero
+            chit=chit0
+            chip=chip0
+            conint=cons0
+            do i=1,natms
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+            do ig=1,ngrp
+              
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              omx(ig)=oxo(ig)
+              omy(ig)=oyo(ig)
+              omz(ig)=ozo(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+              gvxx(ig)=gvxo(ig)
+              gvyy(ig)=gvyo(ig)
+              gvzz(ig)=gvzo(ig)
+              
+            enddo
+            
+          endif
+          
+        endif
+
+c     operations for second stage only
+
+        if(isw.eq.2)then
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+            
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+            
+            id=lstgtp(ig)
+            
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+            
+c     new rotation matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+              
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities from all nodes
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_v
+     x        (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x        dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+            if(.not.safe)return
+            
+          endif
+          
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     calculate rigid body contribution to stress tensor
+
+          call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+          enddo
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+          enddo
+
+          engke=engfke+engtrn
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     scale cell vectors - isotropic
+          
+          scale=(volm/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     calculate conserved variable
+
+          consv=conint+0.5d0*qmass*chit**2+press*volm
+     x      +0.5d0*pmass*chip**2
+          
+c     metadynamics shell thermostat
+          
+          if(lmetadyn.and.keyshl.eq.1)then
+            consv=consv+0.5d0*qmass_shl*chit_shl**2
+          endif
+          
+c     end of second stage of velocity verlet algorithm
+          
+        endif
+        
+c     end of iteration cycle
+
+      enddo
+          
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do kk=1,ntpatm
+        dens(kk)=dens0(kk)*(volm0/volm)
+      enddo
+      
+c     construct scaling tensor (for tethered atoms)
+      
+      do i=1,9
+        eta(i)=chip*uni(i)
+      enddo
+      
+c     deallocate working arrays
+      
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(3))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(4))
+        deallocate(xxo,yyo,zzo,oxo,oyo,ozo,stat=fail(5))
+        deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(6))
+        deallocate(gxo,gyo,gzo,gvxo,gvyo,gvzo,stat=fail(7))
+
+      endif
+      
+      return
+      end subroutine nptqvv_h1
+
+      subroutine nstqvv_b1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nst ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith may 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr,kk,mode
+      integer id,ifre,jrs,idum,ig,iatm0,iatm1,ntpatm,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engfke
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,taut,sigma,engtke
+      real(8) chit,beta,volm,volm0,elrc,elrc0,virlrc,virlrc0
+      real(8) press,taup,xtmp,ytmp,ztmp
+
+      integer, parameter :: nnn=11
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+      real(8) celp(10),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data newjob/.true./,beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      safe=.true.
+
+      if(newjob)then
+        
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2240)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     atom block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+      endif
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+        if(isw.eq.1)then
+
+          allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(6))
+          allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(7))
+          allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),stat=fail(8))
+          allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+          allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(10))
+
+        endif
+
+      endif
+      if(newjob)then         
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(11))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2250)
+      enddo
+
+      newjob=.false.
+      if(ntcons.gt.0)safe=.false.
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+      if(isw.eq.1)then
+
+c     calculate kinetic energy
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+
+c     calculate quaternion momenta at start of time step
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     rigid body motion for first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            c0(ig)=p0(ig)
+            c1(ig)=p1(ig)
+            c2(ig)=p2(ig)
+            c3(ig)=p3(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            
+          enddo
+
+        endif
+
+c     extract previous constraint terms from stress tensor
+
+      if(isw.eq.1)then          
+
+        do i=1,9
+          stress(i)=stress(i)-strcns(i)
+        enddo
+
+      endif
+
+c     iteration required if ntcons > 0
+
+        mxiter=1
+        if(ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+c     zero scaling matrix
+
+          do i=1,9
+            eta(i)=uni(i)
+          enddo
+
+          if(iter.eq.mxiter)then
+            
+c     calculate Berendsen barostat
+            
+            do i=1,9
+              eta(i)=tstep*beta*(stress(i)+strcns(i)-
+     x          press*volm*uni(i))/(taup*volm)+uni(i)
+            enddo
+            if(mode.gt.0)then
+              eta(3)=0.d0
+              eta(6)=0.d0
+              eta(7)=0.d0
+              eta(8)=0.d0
+              if(mode.lt.3)then
+                eta(2)=0.d0
+                eta(4)=0.d0
+                if(mode.eq.2)then
+                  eta(1)=0.5d0*(eta(1)+eta(5))
+                  eta(5)=eta(1)
+                endif
+              endif
+            endif
+
+c     reset cell parameters for new volume
+          
+            call mat_mul(eta,cell,cell)
+            
+c     calculate new volume
+            
+            call dcell(cell,celp)
+            volm=celp(10)
+
+          endif
+
+c     update centre of mass position
+
+          do ig=igrp1,igrp2
+
+            xtmp=eta(1)*gcmx(ig)+eta(4)*gcmy(ig)+eta(7)*gcmz(ig)
+            ytmp=eta(2)*gcmx(ig)+eta(5)*gcmy(ig)+eta(8)*gcmz(ig)
+            ztmp=eta(3)*gcmx(ig)+eta(6)*gcmy(ig)+eta(9)*gcmz(ig)
+            gcmx(ig)=tstep*gvxx(ig)+xtmp
+            gcmy(ig)=tstep*gvyy(ig)+ytmp
+            gcmz(ig)=tstep*gvzz(ig)+ztmp
+
+          enddo
+
+c     merge group coms from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+          jr=0
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=gcmx(ig)+
+     x          rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+              yyy(i)=gcmy(ig)+
+     x          rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+              zzz(i)=gcmz(ig)+
+     x          rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=tstep*vxx(i)+
+     x        eta(1)*xxx(i)+eta(4)*yyy(i)+eta(7)*zzz(i)
+            yyy(i)=tstep*vyy(i)+
+     x        eta(2)*xxx(i)+eta(5)*yyy(i)+eta(8)*zzz(i)
+            zzz(i)=tstep*vzz(i)+
+     x        eta(3)*xxx(i)+eta(6)*yyy(i)+eta(9)*zzz(i)
+            
+          enddo
+          
+c     merge position data
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+          endif
+
+          if(iter.lt.mxiter)then
+
+            do i=1,natms
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+            do ig=1,ngrp
+
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              p0(ig)=c0(ig)
+              p1(ig)=c1(ig)
+              p2(ig)=c2(ig)
+              p3(ig)=c3(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+
+            enddo
+
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities and forces from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate kinetic energy
+        
+        if(isw.eq.2)then
+
+          engfke=getkinf(ntfree,idnode,mxnode)
+          call getking(ngrp,idnode,mxnode,engtrn,engrot)
+          engtke=engfke+engtrn+engrot
+          engke=engfke+engtrn
+
+c     apply Berendsen thermostat - taut is the relaxation time
+          
+          chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+          
+          engke=engke*chit**2
+          engtrn=engtrn*chit**2
+          engrot=engrot*chit**2
+          
+c     thermostat velocities 
+          
+          do i=iatm0,iatm1
+            
+            if(lstfrz(i).eq.0)then
+
+              vxx(i)=chit*vxx(i)
+              vyy(i)=chit*vyy(i)
+              vzz(i)=chit*vzz(i)
+              
+            endif
+            
+          enddo
+
+c     merge velocities from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     thermostat rigid body velocities
+
+          do ig=igrp1,igrp2
+            
+            omx(ig)=chit*omx(ig)
+            omy(ig)=chit*omy(ig)
+            omz(ig)=chit*omz(ig)
+            gvxx(ig)=chit*gvxx(ig)
+            gvyy(ig)=chit*gvyy(ig)
+            gvzz(ig)=chit*gvzz(ig)
+
+          enddo
+
+c     merge group velocities from all processors
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+          enddo
+          
+        endif
+
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+      
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+        
+        if(isw.eq.1)then
+          
+          deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(4))
+          deallocate(xxo,yyo,zzo,c0,c1,c2,c3,stat=fail(5))
+          deallocate(gxo,gyo,gzo,stat=fail(6))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine nstqvv_b1
+
+      subroutine nstqvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x  sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircon,virlrc,vircom,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nst ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith may 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=12
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ifre1,ifre2,igrp1,igrp2,igrp,i,j,k,jr,mode
+      integer id,ig,ifre,jrs,idum,mxiter,iter,ntpatm,kk,icyc
+      real(8) chit,consv,conint,engke,engrot,taut,sigma,tolnce,tstep
+      real(8) vircom,vircon,hstep,qmass,opx,opy,opz,fmx,fmy,fmz,engtrn
+      real(8) ftx,fty,ftz,tqx,tqy,tqz,qt0,qt1,qt2,qt3,vaa,vbb,vcc
+      real(8) taup,temp,press,vzero,chit0,cons0
+      real(8) chip2,volm,elrc,elrc0,virlrc,virlrc0,qstep,pmass,totmas
+      real(8) volm0,cxx,cyy,czz,engfke,fstep
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),com(3),vom(3)
+      real(8) czero(9),eta0(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      save newjob,hstep,qstep,fstep,pmass,qmass
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2,volm0,elrc0,virlrc0
+      save totmas,dens0
+
+      data newjob/.true./
+      
+      safe=.true.
+      if(newjob)then
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2280)
+
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call error(idnode,506)
+        endif
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(2))
+        allocate(oxo(mxgrp),oyo(mxgrp),ozo(mxgrp),stat=fail(3))
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(4))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(8))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(9))
+        allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(10))
+        allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(11))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(12))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2290)
+      enddo
+
+      newjob=.false.
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store current integration variables if ntcons > 0
+        
+        if(ntcons.gt.0)then
+          
+          vzero=volm
+          chit0=chit
+          cons0=conint
+          do i=1,9
+
+            eta0(i)=eta(i)
+            czero(i)=cell(i)
+
+          enddo
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            oxo(ig)=omx(ig)
+            oyo(ig)=omy(ig)
+            ozo(ig)=omz(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            gvxo(ig)=gvxx(ig)
+            gvyo(ig)=gvyy(ig)
+            gvzo(ig)=gvzz(ig)
+            
+          enddo
+          
+        endif
+        
+      endif
+
+c     iteration necessary if ntcons > 0 and isw=1
+
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+
+        if(isw.eq.1)then
+
+          do icyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,
+     x        press,volm)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+          engke=engfke+engtrn
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+            p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+            p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+            p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+            
+          enddo
+          
+        endif
+
+c     update free atom velocities 
+
+        do ifre=ifre1,ifre2
+
+          i=lstfre(ifre)
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     *************  Rigid body motion ****************************
+
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     calculate com force arrays 
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+
+          enddo
+
+c     current rotation matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+          qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+          qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+          qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+          p0(ig)=p0(ig)+qt0*hstep
+          p1(ig)=p1(ig)+qt1*hstep
+          p2(ig)=p2(ig)+qt2*hstep
+          p3(ig)=p3(ig)+qt3*hstep
+
+c     update centre of mass velocity by 1/2 time step
+
+          gvxx(ig)=gvxx(ig)+fmx*hstep/gmass(id)
+          gvyy(ig)=gvyy(ig)+fmy*hstep/gmass(id)
+          gvzz(ig)=gvzz(ig)+fmz*hstep/gmass(id)
+
+        enddo
+
+        if(isw.eq.1)then
+
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+
+c     move centre of mass by full time step
+
+          do ig=igrp1,igrp2
+
+            cxx=gcmx(ig)-com(1)
+            cyy=gcmy(ig)-com(2)
+            czz=gcmz(ig)-com(3)
+            gcmx(ig)=gcmx(ig)+
+     x        tstep*(gvxx(ig)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+            gcmy(ig)=gcmy(ig)+
+     x        tstep*(gvyy(ig)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+            gcmz(ig)=gcmz(ig)+
+     x        tstep*(gvzz(ig)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+
+          enddo
+
+c     merge group coms from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x          +gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x          +gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x          +gcmz(ig)
+
+            enddo
+            
+          enddo
+
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            k=k+1
+            i=lstfre(ifre)
+            cxx=xxx(i)-com(1)
+            cyy=yyy(i)-com(2)
+            czz=zzz(i)-com(3)
+            xxx(i)=xxx(i)+
+     x        tstep*(vxx(i)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+            yyy(i)=yyy(i)+
+     x        tstep*(vyy(i)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+            zzz(i)=zzz(i)+
+     x        tstep*(vzz(i)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+            
+          enddo
+          
+c     merge position data
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     subtract old constraint terms from stress tensor
+            
+            do i=1,9
+              stress(i)=stress(i)-strcns(i)
+            enddo
+            
+c     correct constraint bonds using rattle
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+c     add new constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+          endif
+
+c     restore original integration parameters if iter < mxiter
+
+          if(iter.lt.mxiter)then
+            
+            volm=vzero
+            chit=chit0
+            conint=cons0
+            do i=1,9
+              
+              eta(i)=eta0(i)
+              cell(i)=czero(i)
+              
+            enddo
+            do i=1,natms
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+            do ig=1,ngrp
+              
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              omx(ig)=oxo(ig)
+              omy(ig)=oyo(ig)
+              omz(ig)=ozo(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+              gvxx(ig)=gvxo(ig)
+              gvyy(ig)=gvyo(ig)
+              gvzz(ig)=gvzo(ig)
+              
+            enddo
+
+          endif
+
+        endif
+
+c     operations for second stage only
+
+        if(isw.eq.2)then
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+            
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+            
+            id=lstgtp(ig)
+            
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+            
+c     new rotation matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+              
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities from all nodes
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_v
+     x        (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x        dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+            if(.not.safe)return
+            
+c     add constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+          endif
+          
+c     kinetic terms for stress tensor
+        
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     calculate rigid body contribution to stress tensor
+
+          call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strkin(i)+strgrp(i)+strbod(i)
+          enddo
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,
+     x        press,volm)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+          engke=engfke+engtrn
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     conserved quantity less kinetic and potential energy terms
+
+          chip2=sdot0(9,eta,eta)
+          if(mode.eq.2)chip2=chip2-eta(1)**2
+          consv=conint+0.5d0*qmass*chit**2+0.5d0*pmass*chip2+press*volm
+          
+c     metadynamics shell thermostat
+
+          if(lmetadyn.and.keyshl.eq.1)then
+            consv=consv+0.5d0*qmass_shl*chit_shl**2
+          endif
+          
+c     end of second stage of velocity verlet algorithm
+          
+        endif
+        
+c     end of iteration cycle
+
+      enddo
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do kk=1,ntpatm
+        dens(kk)=dens0(kk)*(volm0/volm)
+      enddo
+      
+c     deallocate working arrays
+      
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(3))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(4))
+        deallocate(xxo,yyo,zzo,oxo,oyo,ozo,stat=fail(5))
+        deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(6))
+        deallocate(gxo,gyo,gzo,gvxo,gvyo,gvzo,stat=fail(7))
+
+      endif
+      
+      return
+      end subroutine nstqvv_h1
+      
+      end module vv_rotation1_module
+
diff -urN dl_class_1.9.orig/srcmod/vv_rotation2_module.f dl_class_1.9/srcmod/vv_rotation2_module.f
--- dl_class_1.9.orig/srcmod/vv_rotation2_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vv_rotation2_module.f	2011-02-22 12:46:30.000000000 +0100
@@ -0,0 +1,5924 @@
+      module vv_rotation2_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 2 for velocity verlet rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use metafreeze_module, only : lmetadyn
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use vv_rotation1_module
+      use utility_module
+      
+      contains
+      
+      subroutine qrattle_r
+     x  (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x  nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x  dzt,txx,tyy,tzz,xxt,yyt,zzt,stresh)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration in the velocity verlet scheme. assumes rigid
+c     bodies connected by constraints.  must be used in conjunction with
+c     velocity verlet integration algorithm. note the iteration is
+c     handled by the calling routine.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newstep,newjob
+      integer fail,idnode,imcon,mxnode,natms,nscons,i,j,k,ik
+      real(8) tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,txx,tyy
+      real(8) tzz,xxt,yyt,zzt,stresh,strs1,strs2,strs3,strs5,strs6
+      real(8) strs9,tstep2,esig,dis2,tqa,tqb,gamma,dli,dlj
+
+      real(8), allocatable :: esig1(:),ggx(:),ggy(:),ggz(:)
+
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension stresh(9),tqa(3),tqb(3)
+
+      save newjob,esig1,ggx,ggy,ggz
+
+      data newjob/.true./,fail/0/
+      
+      if(newjob)then
+        
+        allocate (esig1(mxcons),ggx(mxcons),ggy(mxcons),ggz(mxcons),
+     x    stat=fail)
+        if(fail.ne.0)call error(idnode,1615)
+        newjob=.false.
+
+      endif
+
+c     accumulators for stress tensor
+
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+
+c     timestep squared
+      
+      tstep2=tstep*tstep
+
+c     constraint bond vectors are dxx,dyy,dzz (input)
+      
+
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate temporary bond vector
+        
+        dxt(k)=xxx(i)-xxx(j)
+        dyt(k)=yyy(i)-yyy(j)
+        dzt(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+
+c     calculate maximum error in bondlength
+      
+      esig=0.d0
+      do k=1,nscons
+
+        dis2=prmcon(listcon(k,1))**2
+        esig1(k)=(dis2-(dxt(k)**2+dyt(k)**2+dzt(k)**2))/dis2
+        esig=max(esig,abs(esig1(k)))
+
+      enddo
+      
+c     global verification of convergence
+
+      safe=(esig.lt.tolnce)
+      
+      if(mxnode.gt.1)call gstate(safe)
+
+c     continue if any tolerances unsatisfied 
+      
+      if(.not.safe)then
+
+c     initialise force increment arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+          
+        enddo
+
+c     calculate constraint forces
+        
+        ik=0
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dis2=prmcon(listcon(k,1))**2
+
+          if(newstep)then
+
+            call pivot(1,i,k,ik,tqa,dxx,dyy,dzz)
+            call pivot(1,j,k,ik,tqb,dxx,dyy,dzz)
+
+            ggx(k)=tstep2*(tqa(1)+tqb(1))/dis2
+            ggy(k)=tstep2*(tqa(2)+tqb(2))/dis2
+            ggz(k)=tstep2*(tqa(3)+tqb(3))/dis2
+
+          endif
+
+c     constraint force parameter 
+          
+          gamma=esig1(k)/(dxt(k)*ggx(k)+dyt(k)*ggy(k)+dzt(k)*ggz(k))
+          
+c     accumulate bond virial
+          
+          vircon=vircon-gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+
+          strs1=strs1+gamma*dxx(k)*dxx(k)
+          strs2=strs2+gamma*dxx(k)*dyy(k)
+          strs3=strs3+gamma*dxx(k)*dzz(k)
+          strs5=strs5+gamma*dyy(k)*dyy(k)
+          strs6=strs6+gamma*dyy(k)*dzz(k)
+          strs9=strs9+gamma*dzz(k)*dzz(k)
+
+c     improved atomic force
+          
+          xxt(i)=xxt(i)+dxx(k)*gamma
+          yyt(i)=yyt(i)+dyy(k)*gamma
+          zzt(i)=zzt(i)+dzz(k)*gamma
+          xxt(j)=xxt(j)-dxx(k)*gamma
+          yyt(j)=yyt(j)-dyy(k)*gamma
+          zzt(j)=zzt(j)-dzz(k)*gamma
+          
+        enddo
+        
+c     transport temporary positions to other nodes
+        
+        if(mxnode.gt.1)then
+          
+          if(lshmov) call shmove
+     x      (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+          
+        endif
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dli=1.d0/dble(listme(i))
+          dlj=1.d0/dble(listme(j))
+
+          fxx(i)=fxx(i)+xxt(i)*dli
+          fyy(i)=fyy(i)+yyt(i)*dli
+          fzz(i)=fzz(i)+zzt(i)*dli
+          fxx(j)=fxx(j)+xxt(j)*dlj
+          fyy(j)=fyy(j)+yyt(j)*dlj
+          fzz(j)=fzz(j)+zzt(j)*dlj
+          
+        enddo
+
+c     complete stress tensor
+        
+        stresh(1)=stresh(1)+strs1
+        stresh(2)=stresh(2)+strs2
+        stresh(3)=stresh(3)+strs3
+        stresh(4)=stresh(4)+strs2
+        stresh(5)=stresh(5)+strs5
+        stresh(6)=stresh(6)+strs6
+        stresh(7)=stresh(7)+strs3
+        stresh(8)=stresh(8)+strs6
+        stresh(9)=stresh(9)+strs9
+        
+c     splice force arrays across nodes
+
+        if(mxnode.gt.1)then
+
+          call splice 
+     x      (idnode,natms,listme,listot,fxx,fyy,fzz,buffer)
+          
+        endif
+        
+
+      endif
+      
+      return
+      end subroutine qrattle_r
+
+      subroutine qrattle_v
+     x  (newstep,safe,lshmov,idnode,mxnode,natms,
+     x  nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x  xxt,yyt,zzt)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration in the velocity verlet scheme. assumes rigid
+c     bodies connected by constraints.  must be used in conjunction with
+c     velocity verlet integration algorithm. note the iteration is
+c     handled by the calling routine.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newstep,newjob
+      integer fail,idnode,mxnode,natms,nscons,i,j,k,ik
+      real(8) tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,tqa,tqb
+      real(8) xxt,yyt,zzt,tstep2,esig,gamma,dli,dlj
+      real(8) tolvel
+
+      real(8), allocatable :: esig2(:),hhx(:),hhy(:),hhz(:)
+
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension tqa(3),tqb(3)
+
+      save newjob,esig2,hhx,hhy,hhz
+
+      data newjob/.true./,fail/0/
+      
+      if(newjob)then
+        
+        allocate (esig2(mxcons),hhx(mxcons),hhy(mxcons),hhz(mxcons),
+     x    stat=fail)
+        if(fail.ne.0)call error(idnode,1625)
+        newjob=.false.
+
+      endif
+
+c     constraint bond vectors are dxx,dyy,dzz (input)
+      
+c     half timestep
+      
+      tstep2=tstep/2.d0
+
+c     tolerance for velocity convergence
+
+      tolvel=tolnce/tstep
+
+c     calculate maximum error in constraint
+      
+      esig=0.d0
+      do k=1,nscons
+
+        i=listcon(k,2)
+        j=listcon(k,3)
+        esig2(k)=(dxx(k)*(vxx(i)-vxx(j))+dyy(k)*(vyy(i)-vyy(j))+
+     x    dzz(k)*(vzz(i)-vzz(j)))
+        esig=max(esig,abs(esig2(k)))
+
+      enddo
+      
+c     global verification of convergence
+
+      safe=(esig.lt.tolvel)
+      
+      if(mxnode.gt.1)then
+        call gstate(safe)
+      endif
+
+c     continue if all tolerances satisfied else return to calling routine 
+      
+      if(.not.safe)then
+
+c     initialise velocity correction arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+          
+        enddo
+
+c     calculate constraint correction
+        
+        ik=0
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+
+          if(newstep)then
+
+            call pivot(2,i,k,ik,tqa,dxx,dyy,dzz)
+            call pivot(2,j,k,ik,tqb,dxx,dyy,dzz)
+
+            hhx(k)=tstep2*(tqa(1)+tqb(1))
+            hhy(k)=tstep2*(tqa(2)+tqb(2))
+            hhz(k)=tstep2*(tqa(3)+tqb(3))
+
+          endif
+
+c     constraint force parameter 
+          
+          gamma=esig2(k)/(dxx(k)*hhx(k)+dyy(k)*hhy(k)+dzz(k)*hhz(k))
+
+c     improved atomic force
+          
+          xxt(i)=xxt(i)-dxx(k)*gamma
+          yyt(i)=yyt(i)-dyy(k)*gamma
+          zzt(i)=zzt(i)-dzz(k)*gamma
+          xxt(j)=xxt(j)+dxx(k)*gamma
+          yyt(j)=yyt(j)+dyy(k)*gamma
+          zzt(j)=zzt(j)+dzz(k)*gamma
+          
+        enddo
+        
+c     transport temporary positions to other nodes
+        
+        if(mxnode.gt.1)then
+          
+          if(lshmov) call shmove
+     x      (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+          
+        endif
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dli=1.d0/dble(listme(i))
+          dlj=1.d0/dble(listme(j))
+
+          fxx(i)=fxx(i)+dli*xxt(i)
+          fyy(i)=fyy(i)+dli*yyt(i)
+          fzz(i)=fzz(i)+dli*zzt(i)
+          fxx(j)=fxx(j)+dlj*xxt(j)
+          fyy(j)=fyy(j)+dlj*yyt(j)
+          fzz(j)=fzz(j)+dlj*zzt(j)
+          
+        enddo
+
+c     splice force arrays across nodes
+        
+        if(mxnode.gt.1)then
+
+          call splice 
+     x      (idnode,natms,listme,listot,fxx,fyy,fzz,buffer)
+          
+        endif
+
+      endif
+      
+      return
+      end subroutine qrattle_v
+
+      subroutine pivot(k,i,kk,ik,tqq,dxx,dyy,dzz)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for computing pivot vector for velocity
+c     corrections to bonds between rigid bodies
+c     must be used in conjunction with qrattle routines:
+c     if k=1 - use with qrattle_r
+c     if k=2 - use with qrattle_v
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer k,i,kk,ik,ig,id,jj
+      real(8) xxa,yya,zza,tax,tay,taz,trx,try,trz,vix,viy,viz
+      real(8) rot(9),tqq(3),dxx(mxcons),dyy(mxcons),dzz(mxcons)
+
+      ig=lstbod(i)
+
+      if(ig.eq.0)then
+
+c     atoms in constraint bonds
+        
+        tqq(1)=dxx(kk)*rmass(i)
+        tqq(2)=dyy(kk)*rmass(i)
+        tqq(3)=dzz(kk)*rmass(i)
+        
+      else
+
+c     terms for rigid body atoms
+
+        ik=ik+1
+        id=lstgtp(ig)
+
+        tqq(1)=dxx(kk)/gmass(id)
+        tqq(2)=dyy(kk)/gmass(id)
+        tqq(3)=dzz(kk)/gmass(id)
+
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        jj=lstcsit(ik)
+
+c     com-site vector in lab frame
+
+        xxa=(gxx(id,jj)*rot(1)+gyy(id,jj)*rot(2)+gzz(id,jj)*rot(3))
+        yya=(gxx(id,jj)*rot(4)+gyy(id,jj)*rot(5)+gzz(id,jj)*rot(6))
+        zza=(gxx(id,jj)*rot(7)+gyy(id,jj)*rot(8)+gzz(id,jj)*rot(9))
+
+c     cross product of com-site vector and interatomic vector
+        
+        tax=yya*dzz(kk)-zza*dyy(kk)
+        tay=zza*dxx(kk)-xxa*dzz(kk)
+        taz=xxa*dyy(kk)-yya*dxx(kk)
+
+c     transform to body fixed frame
+        
+        trx=(tax*rot(1)+tay*rot(4)+taz*rot(7))*rotinx(id,2)
+        try=(tax*rot(2)+tay*rot(5)+taz*rot(8))*rotiny(id,2)
+        trz=(tax*rot(3)+tay*rot(6)+taz*rot(9))*rotinz(id,2)
+
+        if(k.eq.1)then
+
+c     direction of induced velocites in body frame
+          
+          vix=try*gzz(id,jj)-trz*gyy(id,jj)
+          viy=trz*gxx(id,jj)-trx*gzz(id,jj)
+          viz=trx*gyy(id,jj)-try*gxx(id,jj)
+          
+c     transform to lab frame
+          
+          tqq(1)=tqq(1)+vix*rot(1)+viy*rot(2)+viz*rot(3)
+          tqq(2)=tqq(2)+vix*rot(4)+viy*rot(5)+viz*rot(6)
+          tqq(3)=tqq(3)+vix*rot(7)+viy*rot(8)+viz*rot(9)
+
+        elseif(k.eq.2)then
+
+c     transform to lab frame
+
+          tqq(1)=tqq(1)+trx*rot(1)+try*rot(2)+trz*rot(3)
+          tqq(2)=tqq(2)+trx*rot(4)+try*rot(5)+trz*rot(6)
+          tqq(3)=tqq(3)+trx*rot(7)+try*rot(8)+trz*rot(9)
+          
+        endif
+
+      endif
+
+      return
+      end subroutine pivot
+
+      subroutine nveqvv_2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   jan 2005
+c     amended     w.smith   feb 2005: qrattle added
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+
+      save newstep,newjob,p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+c     allocate working arrays
+
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(2))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(3))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(4))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(5))
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(6))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(7))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(8))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(9))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(10))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(11))
+
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(12))
+      if(isw.eq.2)then
+        allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(13))
+      endif
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2110)
+      enddo
+
+c     initialise constraint virial
+
+      if(isw.eq.1)then
+
+        vircon=0.d0
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     store key config data at start of time step
+
+      if(isw.eq.1)then
+
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom velocities
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces if isw = 2
+      
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxo(i)=fxx(i)
+          fyo(i)=fyy(i)
+          fzo(i)=fzz(i)
+
+        enddo
+      
+      endif
+
+c     -------------- start of shake iteration cycle -------------------
+      
+      icyc=0
+      mxshk=1
+      safe=.false.
+      newstep=.true.
+      if(ntcons.gt.0)mxshk=mxshak
+      do while(.not.safe.and.icyc.lt.mxshk)
+        
+        icyc=icyc+1
+
+c     update velocities of free atoms 1/2 timestep
+
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+          vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+          vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+          
+        enddo
+        
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     fmx,fmy,fmz represent force on c.o.m.
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+
+c     current rotational matrix
+          
+          jg=jg+1
+          call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+          tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+          tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+          tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+          p0(ig)=c0(jg)+tq0*pt5*tstep
+          p1(ig)=c1(jg)+tq1*pt5*tstep
+          p2(ig)=c2(jg)+tq2*pt5*tstep
+          p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+          gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+          gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+          gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+          
+        enddo
+
+c     first stage of velocity verlet algorithm
+
+        if(isw.eq.1)then
+
+          jg=0
+          do ig=igrp1,igrp2
+
+            jg=jg+1
+
+c     update centre of mass position by full time step
+            
+            gcmx(ig)=gxo(jg)+tstep*gvxx(ig)
+            gcmy(ig)=gyo(jg)+tstep*gvyy(ig)
+            gcmz(ig)=gzo(jg)+tstep*gvzz(ig)
+            
+c     calculate rotation of rigid groups: nosquish algorithm
+            
+            q0(ig)=b0(jg)
+            q1(ig)=b1(jg)
+            q2(ig)=b2(jg)
+            q3(ig)=b3(jg)
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+            
+          enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x          rot(3)*gzz(id,j)+gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x          rot(6)*gzz(id,j)+gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x          rot(9)*gzz(id,j)+gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles to full time step
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=xxo(i)+tstep*vxx(i)
+            yyy(i)=yyo(i)+tstep*vyy(i)
+            zzz(i)=zzo(i)+tstep*vzz(i)
+            
+          enddo
+
+c     merge free atom positions
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            call qrattle_r
+     x        (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x        nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x        dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+          endif
+          
+c     end of first stage 
+
+        endif
+
+        if(isw.eq.2)then
+          
+c     second stage of velocity verlet algorithm
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+            id=lstgtp(ig)
+
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities and forces from all nodes
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)then
+
+              call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              call merge1
+     x          (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+              
+            endif
+
+c     correct constraint bond velocities using rattle
+
+            call qrattle_v
+     x        (newstep,safe,lshmov,idnode,mxnode,natms,
+     x        nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x        xxt,yyt,zzt)
+
+          endif
+          
+c     end of second stage
+          
+        endif
+        
+        newstep=.false.
+        
+      enddo
+
+c     check shake convergence
+
+      if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+      if(mxnode.gt.1.and.isw.eq.1)then
+        
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(strcns,9,buffer)
+        
+      endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+
+        engke=engke+engtrn
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     restore forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+
+        enddo
+      
+      endif
+
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nveqvv_2
+
+      subroutine nvtqvv_b2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x  vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nvt ensemble - Berendsen thermostat (n.b. not symplectic)
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engtke
+      real(8) engtrn
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3,taut,sigma,chit
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+
+      save newstep,newjob,p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data newjob/.true./
+      
+c     set array alocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+
+c     free atom block indices
+      
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+c     allocate working arrays
+
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(2))
+      allocate(vxo(msatms),vyo(msatms),vzo(mxatms),stat=fail(3))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(4))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(5))
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(6))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(7))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(8))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(9))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(10))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(11))
+
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(12))
+      if(isw.eq.2)then
+        allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(13))
+      endif
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2130)
+      enddo
+
+c     initialise constraint virial
+
+      if(isw.eq.1)then
+
+        vircon=0.d0
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     store key config data at start of time step
+
+      if(isw.eq.1)then
+
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom atom velocities
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxo(i)=fxx(i)
+          fyo(i)=fyy(i)
+          fzo(i)=fzz(i)
+
+        enddo
+      
+      endif
+
+c     -------------- start of shake iteration cycle -------------------
+      
+      icyc=0
+      mxshk=1
+      safe=.false.
+      newstep=.true.
+      if(ntcons.gt.0)mxshk=mxshak
+      do while(.not.safe.and.icyc.lt.mxshk)
+        
+        icyc=icyc+1
+        
+c     update velocities of free atoms 1/2 timestep
+
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+          vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+          vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+          
+        enddo
+
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     fmx,fmy,fmz represent force on c.o.m.
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+
+c     current rotational matrix
+          
+          jg=jg+1
+          call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+          tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+          tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+          tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+          p0(ig)=c0(jg)+tq0*pt5*tstep
+          p1(ig)=c1(jg)+tq1*pt5*tstep
+          p2(ig)=c2(jg)+tq2*pt5*tstep
+          p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+          gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+          gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+          gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+          
+        enddo
+
+c     first stage of velocity verlet algorithm
+
+        if(isw.eq.1)then
+
+          jg=0
+          do ig=igrp1,igrp2
+
+            jg=jg+1
+
+c     update centre of mass position by full time step
+            
+            gcmx(ig)=gxo(jg)+tstep*gvxx(ig)
+            gcmy(ig)=gyo(jg)+tstep*gvyy(ig)
+            gcmz(ig)=gzo(jg)+tstep*gvzz(ig)
+            
+c     calculate rotation of rigid groups: nosquish algorithm
+            
+            q0(ig)=b0(jg)
+            q1(ig)=b1(jg)
+            q2(ig)=b2(jg)
+            q3(ig)=b3(jg)
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+            
+          enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x          rot(3)*gzz(id,j)+gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x          rot(6)*gzz(id,j)+gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x          rot(9)*gzz(id,j)+gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles to full time step
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=xxo(i)+tstep*vxx(i)
+            yyy(i)=yyo(i)+tstep*vyy(i)
+            zzz(i)=zzo(i)+tstep*vzz(i)
+            
+          enddo
+          
+c     merge atom positions
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            call qrattle_r
+     x        (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x        nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x        dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+          endif
+          
+c     end of first stage 
+
+        else
+          
+c     second stage of velocity verlet algorithm
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+            id=lstgtp(ig)
+
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities and forces from all nodes
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)then
+
+              call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              call merge1
+     x          (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+              
+            endif
+
+c     correct constraint bond velocities using rattle
+
+            call qrattle_v
+     x        (newstep,safe,lshmov,idnode,mxnode,natms,
+     x        nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x        xxt,yyt,zzt)
+
+          endif
+          
+c     end of second stage
+          
+        endif
+        
+        newstep=.false.
+        
+      enddo
+
+c     check shake convergence
+
+      if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+      if(mxnode.gt.1.and.isw.eq.1)then
+        
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(strcns,9,buffer)
+        
+      endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engke+engtrn+engrot
+        engke=engke+engtrn
+        
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+
+c     thermostat velocities of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          if(lstfrz(i).ne.0)then
+            
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+
+        enddo
+
+c     thermostat rigid body velocities
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+
+        enddo
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     restore forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+
+        enddo
+      
+      endif
+
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nvtqvv_b2
+
+      subroutine nvtqvv_h2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,engrot,
+     x  taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nvt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn,vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3,engfke
+      real(8) taut,sigma,chit,hstep,qmass,conint,consv
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      save newstep,newjob,p0,p1,p2,p3,hstep,qmass,ifre1,ifre2
+      save igrp1,igrp2
+
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     timestep parameters
+        
+        hstep=pt5*tstep
+        
+c     nose-hoover inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+c     allocate working arrays
+
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(2))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(3))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(4))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(5))
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(6))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(7))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(8))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(9))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(10))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(11))
+
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(12))
+      if(isw.eq.2)then
+        allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(13))
+      endif
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2150)
+      enddo
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+c     initialise constraint virial
+
+      if(isw.eq.1)then
+
+        vircon=0.d0
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     apply thermostat for first stage
+
+      if(isw.eq.1)then
+        
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+        
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     store key config data at start of time step
+
+      if(isw.eq.1)then
+
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom atom velocities
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxo(i)=fxx(i)
+          fyo(i)=fyy(i)
+          fzo(i)=fzz(i)
+
+        enddo
+      
+      endif
+
+c     -------------- start of shake iteration cycle -------------------
+      
+      icyc=0
+      mxshk=1
+      safe=.false.
+      newstep=.true.
+      if(ntcons.gt.0)mxshk=mxshak
+
+      do while(.not.safe.and.icyc.lt.mxshk)
+        
+        icyc=icyc+1
+        
+c     update velocities of free atoms 1/2 timestep
+
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+          vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+          vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+          
+        enddo
+
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     fmx,fmy,fmz represent force on c.o.m.
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+
+c     current rotational matrix
+          
+          jg=jg+1
+          call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+          tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+          tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+          tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+          p0(ig)=c0(jg)+tq0*pt5*tstep
+          p1(ig)=c1(jg)+tq1*pt5*tstep
+          p2(ig)=c2(jg)+tq2*pt5*tstep
+          p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+          gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+          gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+          gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+          
+        enddo
+
+c     first stage of velocity verlet algorithm
+
+        if(isw.eq.1)then
+
+          jg=0
+          do ig=igrp1,igrp2
+
+            jg=jg+1
+
+c     update centre of mass position by full time step
+            
+            gcmx(ig)=gxo(jg)+tstep*gvxx(ig)
+            gcmy(ig)=gyo(jg)+tstep*gvyy(ig)
+            gcmz(ig)=gzo(jg)+tstep*gvzz(ig)
+            
+c     calculate rotation of rigid groups: nosquish algorithm
+            
+            q0(ig)=b0(jg)
+            q1(ig)=b1(jg)
+            q2(ig)=b2(jg)
+            q3(ig)=b3(jg)
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+            
+          enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x          rot(3)*gzz(id,j)+gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x          rot(6)*gzz(id,j)+gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x          rot(9)*gzz(id,j)+gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles to full time step
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=xxo(i)+tstep*vxx(i)
+            yyy(i)=yyo(i)+tstep*vyy(i)
+            zzz(i)=zzo(i)+tstep*vzz(i)
+            
+          enddo
+
+c     merge atom positions
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            call qrattle_r
+     x        (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x        nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x        dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+          endif
+          
+c     end of first stage 
+
+        else
+          
+c     second stage of velocity verlet algorithm
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+            id=lstgtp(ig)
+
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities and forces from all nodes
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)then
+
+              call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              call merge1
+     x          (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+              
+            endif
+
+c     correct constraint bond velocities using rattle
+
+            call qrattle_v
+     x        (newstep,safe,lshmov,idnode,mxnode,natms,
+     x        nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x        xxt,yyt,zzt)
+
+          endif
+          
+c     end of second stage
+          
+        endif
+        
+        newstep=.false.
+        
+      enddo
+
+c     check shake convergence
+      
+      if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+      if(mxnode.gt.1.and.isw.eq.1)then
+        
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(strcns,9,buffer)
+        
+      endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     apply thermostat for second stage and calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+c     rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     apply thermostat for second stage and calculate kinetic energy
+      
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+        engke=engfke+engtrn
+
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2
+        
+c     metadynamics shell thermostat
+        
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     restore forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+
+        enddo
+      
+      endif
+
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nvtqvv_h2
+
+      subroutine nptqvv_b2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   sep 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig,ntpatm
+      integer iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engtke,engtrn
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz,volm0
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3,taut,sigma,chit
+      real(8) volm,elrc0,elrc,virlrc0,virlrc,scale,psyst,virtot,chip
+      real(8) beta,press,taup,engfke,vzero
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),cell0(9),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+
+      save newstep,newjob,volm0,elrc0,virlrc0,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+c     set array alocation error flags
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+c     assign initial parameters
+
+      if(newjob)then
+
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2180)
+        
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+      
+c     allocate working arrays
+      
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+
+      endif
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(8))
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(9))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(11))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(12))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(13))
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2190)
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+      
+c     store key config data at start of time step
+      
+      if(isw.eq.1)then
+        
+c     cell parameters
+        
+        vzero=volm
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+        
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+        
+      endif
+
+c     store free atom velocities
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+
+      if(isw.eq.1)then
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+        
+      endif
+      
+c     -------------- start of barostat iteration cycle -----------------
+      
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+        
+        if(isw.eq.1)then
+          
+c     restore cell parameters
+          
+          volm=vzero
+          do i=1,9
+            cell(i)=cell0(i)
+          enddo
+          
+c     calculate system pressure
+          
+          vircon=-(strcns(1)+strcns(5)+strcns(9))
+          psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+          
+c     apply Berendsen barostat
+          
+          chip=1.d0+beta*tstep*(psyst-press)/taup
+          chip=1.d0
+          scale=chip**(1.d0/3.d0)
+          volm=chip*volm
+          
+c     reset cell parameters for new volume
+          
+          do i=1,9
+            cell(i)=scale*cell(i)
+          enddo
+          
+c     reset constraint virial
+          
+          vircon=0.d0
+          do i=1,9
+            strcns(i)=0.d0
+          enddo
+          
+        endif
+
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          j=0
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+            vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+            vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+            
+          enddo
+
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+          jg=0
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     fmx,fmy,fmz represent force on c.o.m.
+            
+            jrs=jr
+            fmx=0.d0
+            fmy=0.d0
+            fmz=0.d0
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              fmx=fmx+fxx(i)
+              fmy=fmy+fyy(i)
+              fmz=fmz+fzz(i)
+              
+            enddo
+
+c     current rotational matrix
+            
+            jg=jg+1
+            call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+            jr=jrs
+            ftx=0.d0
+            fty=0.d0
+            ftz=0.d0
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+              fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+              ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+              
+            enddo
+            tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+            tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+            tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+            
+c     calculate quaternion torques
+
+            tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+            tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+            tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+            tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+            p0(ig)=c0(jg)+tq0*pt5*tstep
+            p1(ig)=c1(jg)+tq1*pt5*tstep
+            p2(ig)=c2(jg)+tq2*pt5*tstep
+            p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+            gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+            gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+            gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+            
+          enddo
+          
+c     first stage of velocity verlet algorithm
+
+          if(isw.eq.1)then
+
+            jg=0
+            do ig=igrp1,igrp2
+
+              jg=jg+1
+
+c     update centre of mass position by full time step
+              
+              gcmx(ig)=scale*gxo(jg)+tstep*gvxx(ig)
+              gcmy(ig)=scale*gyo(jg)+tstep*gvyy(ig)
+              gcmz(ig)=scale*gzo(jg)+tstep*gvzz(ig)
+              
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              q0(ig)=b0(jg)
+              q1(ig)=b1(jg)
+              q2(ig)=b2(jg)
+              q3(ig)=b3(jg)
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+            
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+                
+              enddo
+              
+            enddo
+
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              xxx(i)=scale*xxo(i)+tstep*vxx(i)
+              yyy(i)=scale*yyo(i)+tstep*vyy(i)
+              zzz(i)=scale*zzo(i)+tstep*vzz(i)
+              
+            enddo
+
+c     merge atom positions
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+            
+c     end of first stage 
+            
+          endif
+
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+              id=lstgtp(ig)
+
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)then
+                
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+
+c     correct constraint bond velocities using rattle
+
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+        
+c     sum constraint virial and stress across processors
+      
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+
+c     -------------- end of shake iteration cycle -------------------
+
+c     rigid body contribution to stress tensor
+
+        if(isw.eq.2)call bodystress
+     x    (idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     restore  forces
+          
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+
+c     -------------- end of barostat iteration cycle ----------------
+        
+      enddo
+      
+      if(isw.eq.1)then
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do k=1,ntpatm
+          dens(k)=dens0(k)*(volm0/volm)
+        enddo
+        
+c     construct scaling tensor for tethered bonds
+        
+        do i=1,9
+          eta(i)=uni(i)*scale
+        enddo
+        
+      endif
+      
+      if(isw.eq.2)then
+        
+c     calculate kinetic energy
+      
+        engfke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engfke+engtrn+engrot
+        engke=engfke+engtrn
+        
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+        
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+
+c     thermostat velocities of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          if(lstfrz(i).ne.0)then
+            
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+          
+        enddo
+        
+c     thermostat rigid body velocities
+        
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+          
+        enddo
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,fxo,fyo,fzo,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      
+      return
+      end subroutine nptqvv_b2
+
+      subroutine nptqvv_h2
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x  temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircom,vircon,virtot,virlrc,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     npt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,icyc,mxshk,idum,ig,ntpatm
+      integer jcyc,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn,vaa,vbb,vcc,opx,opy,opz,engfke
+      real(8) taut,taup,sigma,chit,hstep,qmass,conint,consv
+      real(8) cxx,cyy,czz,scale,virtot,press,chip,temp
+      real(8) volm,pmass,totmas,qstep,fstep,volm0,elrc
+      real(8) virlrc,elrc0,virlrc0,chit0,chip0,vzero,cons0
+
+      integer, parameter :: nnn=16
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),cell0(9),com(3),vom(3),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: vx1(:),vy1(:),vz1(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gvx1(:),gvy1(:),gvz1(:)
+
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      save newstep,newjob,p0,p1,p2,p3,hstep,fstep,qmass,ifre1,ifre2
+      save igrp1,igrp2,volm0,elrc0,virlrc0,qstep,dens0,totmas
+      save pmass
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2220)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+        
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+        
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(8))
+      allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(9))
+      allocate(vx1(mxatms),vy1(mxatms),vz1(mxatms),stat=fail(10))
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(11))
+      allocate(oxo(mxatms),oyo(mxatms),ozo(mxatms),stat=fail(12))
+      allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),
+     x  stat=fail(13))
+      allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),
+     x  stat=fail(14))
+      allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(15))
+      allocate(gvx1(mxgrp),gvy1(mxgrp),gvz1(mxgrp),stat=fail(16))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2230)
+      enddo
+      
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     store key config data at start of timestep
+
+      vzero=volm
+      chit0=chit
+      chip0=chip
+      cons0=conint
+      do i=1,9
+        cell0(i)=cell(i)
+      enddo
+
+      if(isw.eq.1)then
+        
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store atom positions
+        
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+        
+c     store rigid body positions
+        
+        do ig=1,ngrp
+          
+          gxo(ig)=gcmx(ig)
+          gyo(ig)=gcmy(ig)
+          gzo(ig)=gcmz(ig)
+          
+        enddo
+        
+      endif
+      
+c     store free atom velocities
+
+      do i=1,natms
+        
+        vxo(i)=vxx(i)
+        vyo(i)=vyy(i)
+        vzo(i)=vzz(i)
+        
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+      
+c     store rigid body quaternions, angular and cartesian velocities
+
+      do ig=1,ngrp
+        
+        b0(ig)=q0(ig)
+        b1(ig)=q1(ig)
+        b2(ig)=q2(ig)
+        b3(ig)=q3(ig)
+        oxo(ig)=omx(ig)
+        oyo(ig)=omy(ig)
+        ozo(ig)=omz(ig)
+        gvxo(ig)=gvxx(ig)
+        gvyo(ig)=gvyy(ig)
+        gvzo(ig)=gvzz(ig)
+
+      enddo
+      
+c     iteration necessary if ntcons > 0 and isw=1
+
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+
+c     integration of barostat and thermostat (part 1)
+        
+        if(isw.eq.1)then
+          
+c     restore cell parameters
+
+          volm=vzero
+          chit=chit0
+          chip=chip0
+          conint=cons0
+          do i=1,9
+            cell(i)=cell0(i)
+          enddo
+
+c     restore free atom velocities
+          
+          do i=1,natms
+            
+            vxx(i)=vxo(i)
+            vyy(i)=vyo(i)
+            vzz(i)=vzo(i)
+            
+          enddo
+
+c     restore rigid body quaternions angular and cartesian velocities
+
+          do ig=1,ngrp
+            
+            omx(ig)=oxo(ig)
+            omy(ig)=oyo(ig)
+            omz(ig)=ozo(ig)
+            gvxx(ig)=gvxo(ig)
+            gvyy(ig)=gvyo(ig)
+            gvzz(ig)=gvzo(ig)
+            
+          enddo
+          
+c     current constraint virial
+
+          vircon=-(strcns(1)+strcns(5)+strcns(9))
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+
+          engke=engfke+engtrn
+          
+c     scale cell vectors - isotropic
+          
+          scale=(volm/vzero)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     reset constraint virial and stress
+          
+          vircon=0.d0
+          do i=1,9
+            strcns(i)=0.d0
+          enddo
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-b1(ig)*opx-b2(ig)*opy-b3(ig)*opz)
+            p1(ig)=2.0d0*( b0(ig)*opx-b3(ig)*opy+b2(ig)*opz)
+            p2(ig)=2.0d0*( b3(ig)*opx+b0(ig)*opy-b1(ig)*opz)
+            p3(ig)=2.0d0*(-b2(ig)*opx+b1(ig)*opy+b0(ig)*opz)
+            
+          enddo
+          
+        endif
+        
+c     store intermediate velocities
+
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vx1(i)=vxx(i)
+          vy1(i)=vyy(i)
+          vz1(i)=vzz(i)
+          
+        enddo
+        do ig=igrp1,igrp2
+          
+          c0(ig)=p0(ig)
+          c1(ig)=p1(ig)
+          c2(ig)=p2(ig)
+          c3(ig)=p3(ig)
+          gvx1(ig)=gvxx(ig)
+          gvy1(ig)=gvyy(ig)
+          gvz1(ig)=gvzz(ig)
+          
+        enddo
+
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=vx1(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vy1(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vz1(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+          
+c     *************  rigid body motion ****************************
+          
+c     restore rigid body quaternions, angular momenta and velocities
+
+          do ig=igrp1,igrp2
+            
+            q0(ig)=b0(ig)
+            q1(ig)=b1(ig)
+            q2(ig)=b2(ig)
+            q3(ig)=b3(ig)
+            p0(ig)=c0(ig)
+            p1(ig)=c1(ig)
+            p2(ig)=c2(ig)
+            p3(ig)=c3(ig)
+            gvxx(ig)=gvx1(ig)
+            gvyy(ig)=gvy1(ig)
+            gvzz(ig)=gvz1(ig)
+            
+          enddo
+
+c     calculate new rigid body velocities
+
+          call rotate_omega
+     x      (idnode,mxnode,ngrp,hstep,p0,p1,p2,p3,dtx,dty,dtz)
+
+c     first stage of velocity verlet algorithm
+
+          if(isw.eq.1)then
+            
+c     calculate system centre of mass
+            
+            call getcom(natms,idnode,mxnode,totmas,com)
+            
+c     update centre of mass position by full time step
+      
+            do ig=igrp1,igrp2
+              
+              cxx=gxo(ig)-com(1)
+              cyy=gyo(ig)-com(2)
+              czz=gzo(ig)-com(3)
+              gcmx(ig)=gxo(ig)+tstep*(gvxx(ig)+chip*cxx)
+              gcmy(ig)=gyo(ig)+tstep*(gvyy(ig)+chip*cyy)
+              gcmz(ig)=gzo(ig)+tstep*(gvzz(ig)+chip*czz)
+              
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+            
+c     merge group coms from all nodes
+            
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+            
+c     new atomic positions for atoms in rigid bodies - relative to com
+            
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              cxx=xxo(i)-com(1)
+              cyy=yyo(i)-com(2)
+              czz=zzo(i)-com(3)
+              xxx(i)=xxo(i)+tstep*(vxx(i)+chip*cxx)
+              yyy(i)=yyo(i)+tstep*(vyy(i)+chip*cyy)
+              zzz(i)=zzo(i)+tstep*(vzz(i)+chip*czz)
+              
+            enddo
+
+c     merge atom positions
+
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+
+c     end of first stage 
+            
+          endif
+          
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+            
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+              id=lstgtp(ig)
+
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+              
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)then
+
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+
+c     correct constraint bond velocities using rattle
+
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+
+c     -------------- end of shake iteration cycle -------------------
+        
+c     rigid body contribution to stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     integration of barostat and thermostat (part 2)
+        
+        if(isw.eq.2)then
+
+c     current constraint virial
+
+          vircon=-(strcns(1)+strcns(5)+strcns(9))
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+
+          engke=engfke+engtrn
+
+c     scale cell vectors - isotropic
+          
+          scale=(volm/vzero)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+        endif
+
+c     restore  forces
+        
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+
+c     -------------- end of barostat iteration cycle ----------------
+
+      enddo
+
+      if(isw.eq.2)then
+
+c     calculate conserved variable
+
+        consv=conint+0.5d0*qmass*chit**2+press*volm
+     x    +0.5d0*pmass*chip**2
+        
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+        
+c     merge velocity arrays
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+          
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+c     construct scaling tensor (for tethered atoms)
+      
+      do i=1,9
+        eta(i)=chip*uni(i)
+      enddo
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     exchange position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(oxo,oyo,ozo,dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      deallocate(fxo,fyo,fzo,stat=fail(7))
+      
+      return
+      end subroutine nptqvv_h2
+
+      subroutine nstqvv_b2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nst ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   sep 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,icyc,mxshk,idum,ig,ntpatm,mode
+      integer iter,mxiter,jrs
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engtke
+      real(8) engtrn,taut,sigma,chit
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz,volm0
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3
+      real(8) volm,elrc0,elrc,virlrc0,virlrc
+      real(8) beta,press,taup,engfke,hstep,vzero
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),uni(9),celp(10)
+      real(8) cell0(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+
+      save newstep,newjob,volm0,elrc0,virlrc0,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2,hstep
+
+      data newjob/.true./,beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     set array alocation error flags
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+c     assign initial parameters
+
+      if(newjob)then
+
+c     timestep parameters
+        
+        hstep=pt5*tstep
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2260)
+        
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+
+        newjob=.false.
+
+      endif
+      
+c     allocate working arrays
+      
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+
+      endif
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(8))
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(9))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(11))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(12))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(13))
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2270)
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+      
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+      
+c     store key config data at start of time step
+      
+      if(isw.eq.1)then
+
+c     cell parameters
+        
+        vzero=volm
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+        
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom velocities
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+      
+c     extract previous constraint terms from stress tensor
+
+      if(isw.eq.1)then
+        
+        do i=1,9
+          stress(i)=stress(i)-strcns(i)
+        enddo
+
+      endif
+
+c     -------------- start of barostat iteration cycle -----------------
+      
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+        
+        do i=1,9
+          eta(i)=uni(i)
+        enddo
+        
+        if(isw.eq.1)then
+          
+c     restore cell parameters
+          
+          volm=vzero
+          do i=1,9
+            cell(i)=cell0(i)
+          enddo
+          
+c     calculate Berendsen barostat
+          
+          do i=1,9
+            eta(i)=tstep*beta*((stress(i)+strcns(i))/volm-
+     x        press*uni(i))/taup+uni(i)
+          enddo
+          if(mode.gt.0)then
+            eta(3)=0.d0
+            eta(6)=0.d0
+            eta(7)=0.d0
+            eta(8)=0.d0
+            if(mode.lt.3)then
+              eta(2)=0.d0
+              eta(4)=0.d0
+              if(mode.eq.2)then
+                eta(1)=0.5d0*(eta(1)+eta(5))
+                eta(5)=eta(1)
+              endif
+            endif
+          endif
+          
+c     reset cell parameters for new volume
+          
+          call mat_mul(eta,cell,cell)
+          
+c     calculate new volume
+          
+          call dcell(cell,celp)
+          volm=celp(10)
+
+c     reset constraint virial
+        
+          vircon=0.d0
+          
+          do i=1,9
+            strcns(i)=0.d0
+          enddo
+          
+        endif
+        
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          j=0
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            vxx(i)=vxo(j)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vyo(j)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vzo(j)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+          
+c     *************  rigid body motion ****************************
+          
+c     operations common to first and second stages
+          
+          jg=0
+          jr=0
+          do ig=igrp1,igrp2
+              
+c     fmx,fmy,fmz represent force on c.o.m.
+            
+            jrs=jr
+            fmx=0.d0
+            fmy=0.d0
+            fmz=0.d0
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              fmx=fmx+fxx(i)
+              fmy=fmy+fyy(i)
+              fmz=fmz+fzz(i)
+              
+            enddo
+            
+c     current rotational matrix
+            
+            jg=jg+1
+            call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+            
+c     calculate torque in principal frame
+            
+            jr=jrs
+            ftx=0.d0
+            fty=0.d0
+            ftz=0.d0
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+              fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+              ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+
+            enddo
+
+            tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+            tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+            tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+            
+c     calculate quaternion torques
+            
+            tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+            tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+            tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+            tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+            
+c     update quaternion momentum by half timestep
+            
+            p0(ig)=c0(jg)+tq0*hstep
+            p1(ig)=c1(jg)+tq1*hstep
+            p2(ig)=c2(jg)+tq2*hstep
+            p3(ig)=c3(jg)+tq3*hstep
+            
+c     update centre of mass velocity by half timestep
+            
+            gvxx(ig)=gvxo(jg)+fmx*hstep/gmass(id)
+            gvyy(ig)=gvyo(jg)+fmy*hstep/gmass(id)
+            gvzz(ig)=gvzo(jg)+fmz*hstep/gmass(id)
+            
+          enddo
+          
+c     first stage of velocity verlet algorithm
+          
+          if(isw.eq.1)then
+            
+            jg=0
+            do ig=igrp1,igrp2
+              
+              jg=jg+1
+              
+c     update centre of mass position by full time step
+              
+              gcmx(ig)=tstep*gvxx(ig)+
+     x          eta(1)*gxo(jg)+eta(4)*gyo(jg)+eta(7)*gzo(jg)
+              gcmy(ig)=tstep*gvyy(ig)+
+     x          eta(2)*gxo(jg)+eta(5)*gyo(jg)+eta(8)*gzo(jg)
+              gcmz(ig)=tstep*gvzz(ig)+
+     x          eta(3)*gxo(jg)+eta(6)*gyo(jg)+eta(9)*gzo(jg)
+              
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              q0(ig)=b0(jg)
+              q1(ig)=b1(jg)
+              q2(ig)=b2(jg)
+              q3(ig)=b3(jg)
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+
+              enddo
+              
+            enddo
+            
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              xxx(i)=tstep*vxx(i)+
+     x          eta(1)*xxo(i)+eta(4)*yyo(i)+eta(7)*zzo(i)
+              yyy(i)=tstep*vyy(i)+
+     x          eta(2)*xxo(i)+eta(5)*yyo(i)+eta(8)*zzo(i)
+              zzz(i)=tstep*vzz(i)+
+     x          eta(3)*xxo(i)+eta(6)*yyo(i)+eta(9)*zzo(i)
+              
+            enddo
+            
+c     merge atom positions
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+            
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+            
+c     end of first stage 
+            
+          endif
+
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+            
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+              
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+              
+              id=lstgtp(ig)
+              
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+              
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+                
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+            
+              if(mxnode.gt.1)then
+                
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+              
+c     correct constraint bond velocities using rattle
+              
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+              
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+        
+c     sum constraint virial and stress across processors
+        
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     rigid body contribution to stress tensor
+
+        if(isw.eq.2)call bodystress
+     x    (idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     restore  forces
+        
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+
+c     -------------- end of barostat iteration cycle ----------------
+        
+      enddo
+      
+      if(isw.eq.1)then
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do k=1,ntpatm
+          dens(k)=dens0(k)*(volm0/volm)
+        enddo
+        
+      endif
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+        
+        engfke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engfke+engtrn+engrot
+        engke=engfke+engtrn
+        
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+        
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+
+c     thermostat velocities of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          if(lstfrz(i).ne.0)then
+            
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+          
+        enddo
+        
+c     thermostat rigid body velocities
+        
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+          
+        enddo
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,fxo,fyo,fzo,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      
+      return
+      end subroutine nstqvv_b2
+
+      subroutine nstqvv_h2
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x  sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircom,vircon,virlrc,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nst ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith sept 2005
+c     adapted     d. quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,icyc,mxshk,idum,ig,ntpatm,mode
+      integer jcyc,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn,engfke
+      real(8) vaa,vbb,vcc,opx,opy,opz
+      real(8) taut,taup,sigma,chit,hstep,qmass,conint,consv
+      real(8) cxx,cyy,czz,press,chip2,temp
+      real(8) volm,pmass,totmas,qstep,fstep,volm0,elrc
+      real(8) virlrc,elrc0,virlrc0,chit0,vzero,cons0
+
+      integer, parameter :: nnn=16
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),com(3),vom(3)
+      real(8) cell0(9),eta0(9),stres0(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: vx1(:),vy1(:),vz1(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gvx1(:),gvy1(:),gvz1(:)
+      
+c     metadynamics shell thermostat variables
+      
+      integer ntshl,keyshl
+      real(8) sigma_shl
+      
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+      
+c     end metadynamics shell thermostat variables
+      
+      save newstep,newjob,p0,p1,p2,p3,hstep,fstep,qmass,ifre1,ifre2
+      save igrp1,igrp2,volm0,elrc0,virlrc0,qstep,dens0,totmas
+      save pmass
+
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2220)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+        
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+        
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(8))
+      allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(9))
+      allocate(vx1(mxatms),vy1(mxatms),vz1(mxatms),stat=fail(10))
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(11))
+      allocate(oxo(mxatms),oyo(mxatms),ozo(mxatms),stat=fail(12))
+      allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),
+     x  stat=fail(13))
+      allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),
+     x  stat=fail(14))
+      allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(15))
+      allocate(gvx1(mxgrp),gvy1(mxgrp),gvz1(mxgrp),stat=fail(16))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2230)
+      enddo
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     store key config data at start of timestep
+
+      vzero=volm
+      chit0=chit
+      cons0=conint
+      do i=1,9
+
+        cell0(i)=cell(i)
+        eta0(i)=eta(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+      if(isw.eq.1)then
+        
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store atom positions
+        
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+        
+c     store rigid body positions
+        
+        do ig=1,ngrp
+          
+          gxo(ig)=gcmx(ig)
+          gyo(ig)=gcmy(ig)
+          gzo(ig)=gcmz(ig)
+          
+        enddo
+        
+      endif
+      
+c     store free atom velocities
+
+      do i=1,natms
+        
+        vxo(i)=vxx(i)
+        vyo(i)=vyy(i)
+        vzo(i)=vzz(i)
+        
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+      
+c     store rigid body quaternions, angular and cartesian velocities
+
+      do ig=1,ngrp
+        
+        b0(ig)=q0(ig)
+        b1(ig)=q1(ig)
+        b2(ig)=q2(ig)
+        b3(ig)=q3(ig)
+        oxo(ig)=omx(ig)
+        oyo(ig)=omy(ig)
+        ozo(ig)=omz(ig)
+        gvxo(ig)=gvxx(ig)
+        gvyo(ig)=gvyy(ig)
+        gvzo(ig)=gvzz(ig)
+
+      enddo
+      
+c     iteration necessary if ntcons > 0 and isw=1
+      
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+
+c     integration of barostat and thermostat (part 1)
+
+        if(isw.eq.1)then
+
+c     restore cell parameters
+
+          volm=vzero
+          chit=chit0
+          conint=cons0
+          do i=1,9
+
+            cell(i)=cell0(i)
+            eta(i)=eta0(i)
+            
+          enddo
+
+c     restore free atom velocities
+          
+          do i=1,natms
+            
+            vxx(i)=vxo(i)
+            vyy(i)=vyo(i)
+            vzz(i)=vzo(i)
+            
+          enddo
+
+c     restore rigid body quaternions angular and cartesian velocities
+
+          do ig=1,ngrp
+            
+            omx(ig)=oxo(ig)
+            omy(ig)=oyo(ig)
+            omz(ig)=ozo(ig)
+            gvxx(ig)=gvxo(ig)
+            gvyy(ig)=gvyo(ig)
+            gvzz(ig)=gvzo(ig)
+            
+          enddo
+          
+c     kinetic contributions to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p2
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,press,
+     x        volm,strkin,strgrp)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+
+          engke=engfke+engtrn
+          
+c     reset constraint virial and stress
+
+          vircon=0.d0
+          do i=1,9
+
+            stress(i)=stress(i)-strcns(i)-strbod(i)
+            strcns(i)=0.d0
+
+          enddo
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-b1(ig)*opx-b2(ig)*opy-b3(ig)*opz)
+            p1(ig)=2.0d0*( b0(ig)*opx-b3(ig)*opy+b2(ig)*opz)
+            p2(ig)=2.0d0*( b3(ig)*opx+b0(ig)*opy-b1(ig)*opz)
+            p3(ig)=2.0d0*(-b2(ig)*opx+b1(ig)*opy+b0(ig)*opz)
+            
+          enddo
+          
+        endif
+        
+c     store intermediate velocities
+
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vx1(i)=vxx(i)
+          vy1(i)=vyy(i)
+          vz1(i)=vzz(i)
+          
+        enddo
+        do ig=igrp1,igrp2
+          
+          c0(ig)=p0(ig)
+          c1(ig)=p1(ig)
+          c2(ig)=p2(ig)
+          c3(ig)=p3(ig)
+          gvx1(ig)=gvxx(ig)
+          gvy1(ig)=gvyy(ig)
+          gvz1(ig)=gvzz(ig)
+          
+        enddo
+
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=vx1(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vy1(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vz1(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+          
+c     *************  rigid body motion ****************************
+          
+c     restore rigid body quaternions, angular momenta and velocities
+
+          do ig=igrp1,igrp2
+            
+            q0(ig)=b0(ig)
+            q1(ig)=b1(ig)
+            q2(ig)=b2(ig)
+            q3(ig)=b3(ig)
+            p0(ig)=c0(ig)
+            p1(ig)=c1(ig)
+            p2(ig)=c2(ig)
+            p3(ig)=c3(ig)
+            gvxx(ig)=gvx1(ig)
+            gvyy(ig)=gvy1(ig)
+            gvzz(ig)=gvz1(ig)
+            
+          enddo
+          
+c     calculate new rigid body velocities
+
+          call rotate_omega
+     x      (idnode,mxnode,ngrp,hstep,p0,p1,p2,p3,dtx,dty,dtz)
+
+c     first stage of velocity verlet algorithm
+
+          if(isw.eq.1)then
+            
+c     calculate system centre of mass
+            
+            call getcom(natms,idnode,mxnode,totmas,com)
+
+c     update centre of mass position by full time step
+            
+            do ig=igrp1,igrp2
+
+              cxx=gxo(ig)-com(1)
+              cyy=gyo(ig)-com(2)
+              czz=gzo(ig)-com(3)
+              gcmx(ig)=gxo(ig)+
+     x          tstep*(gvxx(ig)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+              gcmy(ig)=gyo(ig)+
+     x          tstep*(gvyy(ig)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+              gcmz(ig)=gzo(ig)+
+     x          tstep*(gvzz(ig)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+            
+c     merge group coms from all nodes
+
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+            
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              cxx=xxo(i)-com(1)
+              cyy=yyo(i)-com(2)
+              czz=zzo(i)-com(3)
+              xxx(i)=xxo(i)+
+     x          tstep*(vxx(i)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+              yyy(i)=yyo(i)+
+     x          tstep*(vyy(i)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+              zzz(i)=zzo(i)+
+     x          tstep*(vzz(i)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+              
+            enddo
+
+c     merge atom positions
+
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+
+c     end of first stage 
+
+          endif
+
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+            
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+              id=lstgtp(ig)
+
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+              
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)then
+
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+
+c     correct constraint bond velocities using rattle
+
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+        
+c     sum constraint virial and stress across processors
+        
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+        
+c     -------------- end of shake iteration cycle -------------------
+
+c     calculate rigid body contribution to stress tensor
+          
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+          
+c     add new constraint terms to stress tensor
+          
+        if(isw.eq.1)then
+
+          do i=1,9
+            stress(i)=stress(i)+strcns(i)+strbod(i)
+          enddo
+        
+        endif
+
+c     integration of barostat and thermostat (part 2)
+        
+        if(isw.eq.2)then
+          
+c     kinetic contributions to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     add kinetic and body contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+          enddo
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p2
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,press,
+     x        volm,strkin,strgrp)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+          
+          engke=engfke+engtrn
+
+c     sum up all contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+          enddo
+          
+        endif
+
+c     restore forces
+
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+        
+c     -------------- end of barostat iteration cycle ----------------
+
+      enddo
+
+      if(isw.eq.2)then
+
+c     calculate conserved variable
+
+        chip2=sdot0(9,eta,eta)
+        if(mode.eq.2)chip2=chip2-eta(1)**2
+        consv=conint+0.5d0*qmass*chit**2+0.5d0*pmass*chip2+press*volm
+        
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     merge velocity arrays
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nstqvv_h2
+      
+      end module vv_rotation2_module
