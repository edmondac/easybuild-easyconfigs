fix Intel compilation errors, partially based on https://github.com/dtschump/CImg/commit/d66a4e7f1b13594a572c22160c20e2bd3f231f6c
author: Kenneth Hoste (HPC-UGent)
--- imager/inst/include/CImg.h.orig	2016-08-31 16:30:10.000000000 +0200
+++ imager/inst/include/CImg.h	2017-04-01 22:43:25.292695440 +0200
@@ -17988,7 +17988,7 @@
         unsigned int ind = (unsigned int)mp.opcode[2];
         if (ind!=~0U) ind = (unsigned int)cimg::mod((int)_mp_arg(2),mp.listin.width());
         CImg<T> &img = ind==~0U?mp.imgout:mp.listout[ind];
-        if (img) {
+        if ((bool)img) {
           if (mp.opcode[12]!=(ulongT)-1) {
             const CImg<double> M(&_mp_arg(12) + 1,dx,dy,dz,(unsigned int)mp.opcode[13],true);
             img.draw_image(x,y,z,c,S,M,opacity,(float)_mp_arg(14));
@@ -18107,10 +18107,10 @@
         if (off<0 || off>=whds)
           switch (boundary_conditions) {
           case 2 : // Periodic boundary
-            if (img) return (double)img[cimg::mod(off,whds)];
+            if ((bool)img) return (double)img[cimg::mod(off,whds)];
             return 0;
           case 1 : // Neumann boundary
-            if (img) return (double)(off<0?*img:img.back());
+            if ((bool)img) return (double)(off<0?*img:img.back());
             return 0;
           default : // Dirichet boundary
             return 0;
@@ -18184,10 +18184,10 @@
         if (off<0 || off>=whds)
           switch (boundary_conditions) {
           case 2 : // Periodic boundary
-            if (img) return (double)img[cimg::mod(off,whds)];
+            if ((bool)img) return (double)img[cimg::mod(off,whds)];
             return 0;
           case 1 : // Neumann boundary
-            if (img) return (double)(off<0?*img:img.back());
+            if ((bool)img) return (double)(off<0?*img:img.back());
             return 0;
           default : // Dirichet boundary
             return 0;
@@ -18257,10 +18257,10 @@
         if (off<0 || off>=whds)
           switch (boundary_conditions) {
           case 2 : // Periodic boundary
-            if (img) return (double)img[cimg::mod(off,whds)];
+            if ((bool)img) return (double)img[cimg::mod(off,whds)];
             return 0;
           case 1 : // Neumann boundary
-            if (img) return (double)(off<0?*img:img.back());
+            if ((bool)img) return (double)(off<0?*img:img.back());
             return 0;
           default : // Dirichet boundary
             return 0;
@@ -18317,10 +18317,10 @@
         if (off<0 || off>=whds)
           switch (boundary_conditions) {
           case 2 : // Periodic boundary
-            if (img) return (double)img(ind,cimg::mod(off,whds));
+            if ((bool)img) return (double)img(ind,cimg::mod(off,whds));
             return 0;
           case 1 : // Neumann boundary
-            if (img) return (double)(off<0?*img:img.back());
+            if ((bool)img) return (double)(off<0?*img:img.back());
             return 0;
           default : // Dirichet boundary
             return 0;
@@ -18590,7 +18590,7 @@
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
             return cimg::type<double>::nan();
           case 1 : // Neumann boundary
-            if (img) {
+            if ((bool)img) {
               ptrs = off<0?img._data:&img.back();
               cimg_forC(img,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
@@ -18662,7 +18662,7 @@
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
             return cimg::type<double>::nan();
           case 1 : // Neumann boundary
-            if (img) {
+            if ((bool)img) {
               ptrs = off<0?img._data:&img.back();
               cimg_forC(img,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
@@ -19579,7 +19579,7 @@
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
             return cimg::type<double>::nan();
           case 1 : // Neumann boundary
-            if (img) {
+            if ((bool)img) {
               ptrs = off<0?img._data:&img.back();
               cimg_forC(img,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
@@ -19648,7 +19648,7 @@
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
             return cimg::type<double>::nan();
           case 1 : // Neumann boundary
-            if (img) {
+            if ((bool)img) {
               ptrs = off<0?img._data:&img.back();
               cimg_forC(img,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
             } else std::memset(ptrd,0,img._spectrum*sizeof(double));
@@ -25664,14 +25664,15 @@
             x0 = ((int)xc%width()) - width(),
             y0 = ((int)yc%height()) - height(),
             z0 = ((int)zc%depth()) - depth(),
-            c0 = ((int)cc%spectrum()) - spectrum();
+            c0 = ((int)cc%spectrum()) - spectrum(),
+            dx = width(), dy = height(), dz = depth(), dc = spectrum();
 #ifdef cimg_use_openmp
 #pragma omp parallel for collapse(3) if (res.size()>=65536)
 #endif
-          for (int c = c0; c<(int)sc; c+=spectrum())
-            for (int z = z0; z<(int)sz; z+=depth())
-              for (int y = y0; y<(int)sy; y+=height())
-                for (int x = x0; x<(int)sx; x+=width())
+          for (int c = c0; c<(int)sc; c+=dc)
+            for (int z = z0; z<(int)sz; z+=dz)
+              for (int y = y0; y<(int)sy; y+=dy)
+                for (int x = x0; x<(int)sx; x+=dx)
                   res.draw_image(x,y,z,c,*this);
         } break;
         case 1 : { // Neumann boundary.
@@ -47059,7 +47060,7 @@
       const IplImage *img = 0;
       for (unsigned int i = 0; i<skip_frames; ++i) img = cvQueryFrame(capture[camera_index]);
       img = cvQueryFrame(capture[camera_index]);
-      if (img) {
+      if ((bool)img) {
         const int step = (int)(img->widthStep - 3*img->width);
         assign(img->width,img->height,1,3);
         const unsigned char* ptrs = (unsigned char*)img->imageData;
@@ -52636,7 +52637,7 @@
       case 'x' : { // Along the X-axis.
         cimglist_for(*this,l) {
           const CImg<T>& img = (*this)[l];
-          if (img) {
+          if ((bool)img) {
             dx+=img._width;
             dy = cimg::max(dy,img._height);
             dz = cimg::max(dz,img._depth);
@@ -52646,7 +52647,7 @@
         res.assign(dx,dy,dz,dc,0);
         if (res) cimglist_for(*this,l) {
             const CImg<T>& img = (*this)[l];
-            if (img) res.draw_image(pos,
+            if ((bool)img) res.draw_image(pos,
                                     (int)(align*(dy - img._height)),
                                     (int)(align*(dz - img._depth)),
                                     (int)(align*(dc - img._spectrum)),
@@ -52657,7 +52658,7 @@
       case 'y' : { // Along the Y-axis.
         cimglist_for(*this,l) {
           const CImg<T>& img = (*this)[l];
-          if (img) {
+          if ((bool)img) {
             dx = cimg::max(dx,img._width);
             dy+=img._height;
             dz = cimg::max(dz,img._depth);
@@ -52667,7 +52668,7 @@
         res.assign(dx,dy,dz,dc,0);
         if (res) cimglist_for(*this,l) {
             const CImg<T>& img = (*this)[l];
-            if (img) res.draw_image((int)(align*(dx - img._width)),
+            if ((bool)img) res.draw_image((int)(align*(dx - img._width)),
                                     pos,
                                     (int)(align*(dz - img._depth)),
                                     (int)(align*(dc - img._spectrum)),
@@ -52678,7 +52679,7 @@
       case 'z' : { // Along the Z-axis.
         cimglist_for(*this,l) {
           const CImg<T>& img = (*this)[l];
-          if (img) {
+          if ((bool)img) {
             dx = cimg::max(dx,img._width);
             dy = cimg::max(dy,img._height);
             dz+=img._depth;
@@ -52688,7 +52689,7 @@
         res.assign(dx,dy,dz,dc,0);
         if (res) cimglist_for(*this,l) {
             const CImg<T>& img = (*this)[l];
-            if (img) res.draw_image((int)(align*(dx - img._width)),
+            if ((bool)img) res.draw_image((int)(align*(dx - img._width)),
                                     (int)(align*(dy - img._height)),
                                     pos,
                                     (int)(align*(dc - img._spectrum)),
@@ -52699,7 +52700,7 @@
       default : { // Along the C-axis.
         cimglist_for(*this,l) {
           const CImg<T>& img = (*this)[l];
-          if (img) {
+          if ((bool)img) {
             dx = cimg::max(dx,img._width);
             dy = cimg::max(dy,img._height);
             dz = cimg::max(dz,img._depth);
@@ -52709,7 +52710,7 @@
         res.assign(dx,dy,dz,dc,0);
         if (res) cimglist_for(*this,l) {
             const CImg<T>& img = (*this)[l];
-            if (img) res.draw_image((int)(align*(dx - img._width)),
+            if ((bool)img) res.draw_image((int)(align*(dx - img._width)),
                                     (int)(align*(dy - img._height)),
                                     (int)(align*(dz - img._depth)),
                                     pos,
@@ -53957,7 +53958,7 @@
         CImg<T> img;
         try { img.load_pnm(filename_tmp2); }
         catch (CImgException&) { stop_flag = true; }
-        if (img) { img.move_to(*this); std::remove(filename_tmp2); }
+        if ((bool)img) { img.move_to(*this); std::remove(filename_tmp2); }
       }
       cimg::exception_mode(omode);
       if (is_empty())
@@ -54033,7 +54034,7 @@
       CImg<T> img;
       try { img.load_png(filename_tmp2); }
       catch (CImgException&) { }
-      if (img) { img.move_to(*this); std::remove(filename_tmp2); }
+      if ((bool)img) { img.move_to(*this); std::remove(filename_tmp2); }
       else { // Try to read animated gif.
         unsigned int i = 0;
         for (bool stop_flag = false; !stop_flag; ++i) {
@@ -54042,7 +54043,7 @@
           CImg<T> img;
           try { img.load_png(filename_tmp2); }
           catch (CImgException&) { stop_flag = true; }
-          if (img) { img.move_to(*this); std::remove(filename_tmp2); }
+          if ((bool)img) { img.move_to(*this); std::remove(filename_tmp2); }
         }
       }
       cimg::exception_mode(omode);
--- imager/src/Makevars.in.orig	2017-04-01 22:32:32.628591934 +0200
+++ imager/src/Makevars.in	2017-04-01 22:32:40.968645087 +0200
@@ -1,4 +1,5 @@
 
 PKG_CPPFLAGS = @HAVE_OPENMP@ @OPENMP_CFLAGS@ @CPPFLAGS@ @HAVE_FFTW@ @FFTW_CFLAGS@ -I../inst/include -DCIMG_COMPILING -Dcimg_use_rng -Dcimg_r_mode -Dcimg_use_fftw3_singlethread -Dcimg_verbosity=1 
 PKG_LIBS =  @OPENMP_CFLAGS@ @LIBS@  @HAVE_FFTW@ @FFTW_LIBS@ $(RCPP_LDFLAGS)
-
+# disable Intel C++ compiler (icpc) warning/error #308, to avoid 'member "std::complex<double>::_M_value" is inaccessible'
+PKG_CXXFLAGS = -wd308
--- imager/MD5.orig	2016-09-12 15:08:55.000000000 +0200
+++ imager/MD5	2017-04-01 22:44:16.943021224 +0200
@@ -31,7 +31,7 @@
 05e04a3bc5a858c40e001cc65b853dfc *inst/extdata/Leonardo_Birds.jpg
 e1328ba2c55d5a72eb77e283c9630b90 *inst/extdata/parrots.png
 daa5b7e30235689ad0444df37c88b7ff *inst/extdata/tennis_sif.mpeg
-00de9e6b4c2066d28d7f8d9e251915cd *inst/include/CImg.h
+ea9acc61a3dd73452639c570af543d29 *inst/include/CImg.h
 034a9e8aab9e05094fd31ce9ea3bbae2 *inst/include/imager.h
 0c8aae8db902f96a8f8e323043eb1418 *inst/include/wrappers.h
 be39be77874a0181ecd47b1a7a9af5dd *man/FFT.Rd
@@ -140,7 +140,7 @@
 a680472a2ef1eda48c1a9b90488543b5 *man/vanvliet.Rd
 08193940e20b440f614e4c7a2dbf82fb *man/warp.Rd
 429b25a38f282c30d5d178ad9efc3b1f *man/watershed.Rd
-ab8f97aa6f15c67d1029e3eb5091853d *src/Makevars.in
+802ecbe76012c51adf729063804c793a *src/Makevars.in
 5ecf9e8577f31e535dee1c371e75a35f *src/Makevars.win
 78aff3a88c55983a329723eb1174a4ca *src/RcppExports.cpp
 8193f4fecd751c7d310d23b0faacd303 *src/colourspace.cpp
