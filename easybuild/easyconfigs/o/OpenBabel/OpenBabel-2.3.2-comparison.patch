# From: https://sourceforge.net/p/openbabel/bugs/945/
# Rotor tests fail on ppc architecture, because the checks for the expected value don't take into account the modulus. This patch should fix the issue.
# Author: Susi Lehtola
diff -up openbabel-2.3.2/include/openbabel/obutil.h.orig openbabel-2.3.2/include/openbabel/obutil.h
--- openbabel-2.3.2/include/openbabel/obutil.h.orig	2010-10-09 19:05:12.000000000 -0700
+++ openbabel-2.3.2/include/openbabel/obutil.h	2014-10-16 16:35:49.050074389 -0700
@@ -190,6 +190,8 @@ namespace OpenBabel
    * \deprecated Use IsApprox() instead
    */
   OBAPI bool IsNear(const double &, const double &, const double epsilon=2e-6);
+  //! Same but with comparison with a modulus
+  OBAPI bool IsNear_mod(const double &, const double &, const double & mod, const double epsilon=2e-6);
   /*! "Safe" comparison for floats/doubles: true if a is less than epsilon
    * This function really doesn't make any sense w.r.t. floating-point
    * representation, so you should never use it. It is provided only for
diff -up openbabel-2.3.2/src/obutil.cpp.orig openbabel-2.3.2/src/obutil.cpp
--- openbabel-2.3.2/src/obutil.cpp.orig	2012-10-03 12:08:15.000000000 -0700
+++ openbabel-2.3.2/src/obutil.cpp	2014-10-16 16:54:18.309740019 -0700
@@ -77,6 +77,18 @@ namespace OpenBabel
     return (fabs(a - b) < epsilon);
   }
 
+  //! Comparison for doubles with a modulus: returns mod(a - b,m) < epsilon
+  bool IsNear_mod(const double &a, const double &b, const double &m, const double epsilon)
+  {
+    double arg=a-b;
+    while(arg<-m/2)
+      arg+=m;
+    while(arg>=m/2)
+      arg-=m;
+
+    return (fabs(arg) < epsilon);
+  }
+
   //! Comparison for doubles: returns fabs(a) < epsilon
   bool IsNearZero(const double &a, const double epsilon)
   {
diff -up openbabel-2.3.2/test/rotortest.cpp.orig openbabel-2.3.2/test/rotortest.cpp
--- openbabel-2.3.2/test/rotortest.cpp.orig	2011-10-12 13:24:02.000000000 -0700
+++ openbabel-2.3.2/test/rotortest.cpp	2014-10-16 16:54:32.869985348 -0700
@@ -74,7 +74,7 @@ void testOBRotorSetToAngle()
     atoms[i] = (atoms[i] - 1) * 3;
   rotor.SetRotAtoms(atoms);
 
-  OB_ASSERT(IsNear(fabs(RAD_TO_DEG * rotor.CalcTorsion(mol->GetCoordinates())), 180.0, 1.0));
+  OB_ASSERT(IsNear_mod(fabs(RAD_TO_DEG * rotor.CalcTorsion(mol->GetCoordinates())), 180.0, 360.0, 1.0));
 
   // rotate
   rotor.SetToAngle(mol->GetCoordinates(), 60.0 * DEG_TO_RAD);
@@ -106,7 +106,7 @@ void testOBRotorSetRotor()
     atoms[i] = (atoms[i] - 1) * 3;
   rotor.SetRotAtoms(atoms);
 
-  OB_ASSERT(IsNear(fabs(RAD_TO_DEG * rotor.CalcTorsion(mol->GetCoordinates())), 180.0, 1.0));
+  OB_ASSERT(IsNear_mod(fabs(RAD_TO_DEG * rotor.CalcTorsion(mol->GetCoordinates())), 180.0, 360.0, 1.0));
   rotor.SetToAngle(mol->GetCoordinates(), 60.0 * DEG_TO_RAD);
 
   // set torsion values
